var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Simulation-Information-Type-and-Methods","page":"API","title":"Simulation Information Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SimulationInfo\ninitialize_datafolder\nmodel_summary","category":"page"},{"location":"api/","page":"API","title":"API","text":"SimulationInfo\nSimulationInfo(;)\ninitialize_datafolder\nmodel_summary","category":"page"},{"location":"api/#SmoQyDQMC.SimulationInfo","page":"API","title":"SmoQyDQMC.SimulationInfo","text":"SimulationInfo\n\nContains identification information about simulation, including the location data is written to, the simulation ID, and MPI process ID, and whether this simulation started a new simulation or resumed a previous simulation.\n\nFields\n\nfilepath::String: File path to where data folder lives.\ndatafolder_prefix: Prefix for the data folder name.\ndatafolder_name::String: The data folder name, given by $(datafolder_prefix)_$(sID).\ndatafolder::String: The data folder, including filepath, given by joinpath(filepath, datafolder_name).\npID::Int: MPI process ID, defaults to 0 if MPI not being used.\nsID::Int: Simulation ID.\nresuming::Bool: Whether current simulation is resuming a previous simulation (true) or starting a new one (false).\nsmoqy_version::VersionNumber: Version of SmoQyDQMC used in simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SimulationInfo-Tuple{}","page":"API","title":"SmoQyDQMC.SimulationInfo","text":"SimulationInfo(; datafolder_prefix::String, filepath::String = \".\", sID::Int=0, pID::Int=0)\n\nInitialize and return in instance of the type SimulationInfo.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize_datafolder","page":"API","title":"SmoQyDQMC.initialize_datafolder","text":"initialize_datafolder(sim_info::SimulationInfo)\n\nInitalize sim_info.datafolder directory if it does not already exist.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.model_summary","page":"API","title":"SmoQyDQMC.model_summary","text":"model_summary(; simulation_info::SimulationInfo,\n              β::T, Δτ::T, model_geometry::ModelGeometry,\n              tight_binding_model::TightBindingModel,\n              interactions::Tuple) where {T<:AbstractFloat}\n\nWrite model to summary to file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Model-Geometry-Type-and-Methods","page":"API","title":"Model Geometry Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ModelGeometry\nadd_bond!\nget_bond_id","category":"page"},{"location":"api/","page":"API","title":"API","text":"ModelGeometry\nModelGeometry(::UnitCell{D}, ::Lattice{D}) where {D}\nadd_bond!\nget_bond_id","category":"page"},{"location":"api/#SmoQyDQMC.ModelGeometry","page":"API","title":"SmoQyDQMC.ModelGeometry","text":"ModelGeometry{D, T<:AbstractFloat, N}\n\nContains all the information defining the lattice geometry for the model in D spatial dimensions.\n\nComment\n\nThe bond ID associated with a bond::Bond{D} corresponds to the index associated with it into the bonds vector field.\n\nFields\n\nunit_cell::UnitCell{D,T,N}: Defines unit cell.\nlattice::Lattice{D}: Defines finite lattice extent.\nbonds::Vector{Bond{D}}: All available bond definitions in simulation, with vector indices giving the bond ID.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ModelGeometry-Union{Tuple{D}, Tuple{UnitCell{D}, Lattice{D}}} where D","page":"API","title":"SmoQyDQMC.ModelGeometry","text":"ModelGeometry(unit_cell::UnitCell, lattice::Lattice)\n\nInitialize and return a ModelGeometry instance. Defines a \"trivial\" bond defintion for each orbital in the unit cell that connects an orbital to itself.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.add_bond!","page":"API","title":"SmoQyDQMC.add_bond!","text":"addbond!(modelgeometry::ModelGeometry{D,T}, bond::Bond{D}) where {D, T}   \n\nAdd bond definition to model_geometry, returning the bond ID i.e. the index to bond in the vector model_geometry.bonds. This method first checks that bond is not already defined. If it is this method simply returns the corresponding bond ID. If bond is not already defined, then it is appended to the vector model_geometry.bonds.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.get_bond_id","page":"API","title":"SmoQyDQMC.get_bond_id","text":"get_bond_id(model_geometry::ModelGeometry{D,T}, bond::Bond{D}) where {D, T}\n\nReturn the bond ID associated with the bond defintion bond, returning bond_id=0 if the it is not a recorded bond.\n\n\n\n\n\n","category":"function"},{"location":"api/#Fermion-Path-Integral-Type-and-Methods","page":"API","title":"Fermion Path Integral Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FermionPathIntegral\ninitialize_propagators\ncalculate_propagators!\ncalculate_propagator!","category":"page"},{"location":"api/","page":"API","title":"API","text":"FermionPathIntegral\nFermionPathIntegral(;)\ninitialize_propagators\ncalculate_propagators!\ncalculate_propagator!","category":"page"},{"location":"api/#SmoQyDQMC.FermionPathIntegral","page":"API","title":"SmoQyDQMC.FermionPathIntegral","text":"FermionPathIntegral{T<:Number, E<:AbstractFloat}\n\nRepresents a fermion path integral. In particular, contains the information to represent each diagonal on-site energy matrix V_l and hopping matrix K_l for each imaginary time slicel in 1 L_tau such that tau = Deltatau cdot l and beta = Deltatau cdot L_tau\n\nFields\n\nβ::E: Inverse temperature.\nΔτ::E: Discretization in imaginary time.\nLτ::Int: Length of the imaginary time axis.\nN::Int: Number of orbitals in the lattice.\nneighbor_table::Matrix{Int}: Neighbor table for each pair of orbitals in the lattice connected by a hopping.\nt::Matrix{T}: Hopping amplitudes for imaginary time slice l is stored in t[:,l].\nV::Matrix{T}: Diagonal on-site energy matrix V_l for imaginary time slice l is stored in V[:,l].\nK::Matrix{T}: Used to construct hopping matrix to cacluate exponentiated hopping matrix if checkerboard approximation is not being used.\neigen_ws::HermitianEigenWs{T,Matrix{T},E}: For calculating eigenvalues and eigenvectors of K while avoiding dynamic memory allocations.\nu::Vector{T}: Temporary vector to avoid dynamic allocation when performing local updates.\nv::Vector{T}: Temporary vector to avoid dynamic allocation when performing local updates.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.FermionPathIntegral-Tuple{}","page":"API","title":"SmoQyDQMC.FermionPathIntegral","text":"FermionPathIntegral(; tight_binding_parameters::TightBindingParameters{T,E},\n                    β::E, Δτ::E) where {T,E}\n\nInitialize an instance of FermionPathIntegral an instance of TightBindingParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize_propagators","page":"API","title":"SmoQyDQMC.initialize_propagators","text":"initialize_propagators(fpi::FermionPathIntegral{T,E}; symmetric::Bool, checkerboard::Bool) where {T,E}\n\nInitialize a propagator for each imaginary time slice, returning a vector of type Vector{<:AbstractPropagators{T,E}}.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.calculate_propagators!","page":"API","title":"SmoQyDQMC.calculate_propagators!","text":"calculate_propagators!(B::Vector{P}, fpi::FermionPathIntegral{T,E};\n                       calculate_exp_V::Bool, calculate_exp_K::Bool) where {T, E, P<:AbstractPropagator{T,E}}\n\nCalculate the propagator matrices B_l, given by B[l], for all imaginary time slice tau = Deltatau cdot l If calculate_exp_V = true, then calculate the diagonal exponentiated on-site energy matrices. If calculate_exp_K = true, then calculate the exponentiated hopping matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.calculate_propagator!","page":"API","title":"SmoQyDQMC.calculate_propagator!","text":"calculate_propagator!(B::AbstractPropagator{T,E}, fpi::FermionPathIntegral{T,E}, l::Int;\n                      calculate_exp_V::Bool, calculate_exp_K::Bool) where {T,E}\n\nCalculate the propagator matrix B_l for imaginary time slice tau = Deltatau cdot l If calculate_exp_V = true, then calculate the diagonal exponentiated on-site energy matrix. If calculate_exp_K = true, then calculate the exponentiated hopping matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#Update-Numerical-Stabilization-Frequency","page":"API","title":"Update Numerical Stabilization Frequency","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"update_stabalization_frequency!","category":"page"},{"location":"api/","page":"API","title":"API","text":"update_stabalization_frequency!","category":"page"},{"location":"api/#SmoQyDQMC.update_stabalization_frequency!","page":"API","title":"SmoQyDQMC.update_stabalization_frequency!","text":"update_stabalization_frequency!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n                                Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T;\n                                fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                                fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                                Bup::Vector{P}, Bdn::Vector{P}, δG::E, δθ::T, n_stab::Int,\n                                δG_max::E) where {E<:AbstractFloat, T<:Number, P<:AbstractPropagator{T,E}}\n\nIf the corrected error in the Green's funciton matrix is too large, δG > δG_max, then increase the frequency of numerical stablization by decrementing n_stab such that it is updated to n_stab = max(n_stab - 1, 1), and update the equal-time Green's function matrices and all related variables and types. If the frequency of stabilization is udpated, then δG and δθ are reset to zero. This method returns a tuple of the following variables:\n\n(logdetGup, sgndetGdn, logdetGup, sgndetGdn, δG, δθ),\n\nwhere updated = true if n_stab was decremented.\n\n\n\n\n\nupdate_stabalization_frequency!(G::Matrix{T}, logdetG::E, sgndetG::T;\n                                fermion_greens_calculator::FermionGreensCalculator{T,E},\n                                B::Vector{P}, δG::E, δθ::T, n_stab::Int,\n                                δG_max::E) where {E<:AbstractFloat, T<:Number, P<:AbstractPropagator{T,E}}\n\nIf the corrected error in the Green's funciton matrix is too large, δG > δG_max, then increase the frequency of numerical stablization by decrementing n_stab such that it is updated to n_stab = max(n_stab - 1, 1), and update the equal-time Green's function matrices and all related variables and types. If the frequency of stabilization is udpated, then δG and δθ are reset to zero. This method returns a tuple of the following variables:\n\n(updated, logdetG, sgndetG, δG, δθ),\n\nwhere updated = true if n_stab was decremented.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tight-Binding-Model","page":"API","title":"Tight-Binding Model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TightBindingModel\nTightBindingParameters\nmeasure_onsite_energy\nmeasure_hopping_energy","category":"page"},{"location":"api/","page":"API","title":"API","text":"TightBindingModel\nTightBindingModel(;)\nTightBindingParameters\nTightBindingParameters(;)\nmeasure_onsite_energy\nmeasure_hopping_energy","category":"page"},{"location":"api/#SmoQyDQMC.TightBindingModel","page":"API","title":"SmoQyDQMC.TightBindingModel","text":"TightBindingModel{T<:Number, E<:AbstractFloat, D}\n\nDefines a tight binding model in D dimensions.\n\nFields\n\nμ::E: Chemical potential.\nϵ_mean::Vector{E}: Mean on-site energy for each orbital in the unit cell. \nϵ_std::Vector{E}: Standard deviation of on-site energy for each orbital in the unit cell.\nt_bond_ids::Vector{Int}: The bond ID for each bond/hopping definition.\nt_bonds::Vector{Bond{D}}: Bond definition for each type of hopping in the tight binding model.\nt_mean::Vector{T}: Mean hopping energy for each type of hopping.\nt_std::Vector{E}: Standard deviation of hopping energy for each type of hopping.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.TightBindingModel-Tuple{}","page":"API","title":"SmoQyDQMC.TightBindingModel","text":"TightBindingModel(; model_geometry::ModelGeometry{D,E,N},\n                  μ::E,\n                  ϵ_mean::Vector{E},\n                  ϵ_std::Vector{E} = zeros(eltype(ϵ_mean), length(ϵ_mean)),\n                  t_bonds::Vector{Bond{D}} = Bond{ndims(model_geometry.unit_cell)}[],\n                  t_mean::Vector{T} = eltype(ϵ_mean)[],\n                  t_std::Vector{E} = zeros(eltype(ϵ_mean), length(t_mean))) where {T<:Number, E<:AbstractFloat, D, N}\n\nInitialize and return an instance of TightBindingModel, also adding/recording the bond defintions t_bonds to the ModelGeometry instance model_geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.TightBindingParameters","page":"API","title":"SmoQyDQMC.TightBindingParameters","text":"TightBindingParameters{T<:Number, E<:AbstractFloat}\n\nA mutable struct containing all the parameters needed to characterize a finite tight-binding Hamiltonian for a single spin species sigma on a finite lattice with periodic boundary conditions of the form\n\nhatH_0sigma=-sum_langle ijrangle(t_ij hatc_sigmai^daggerhatc_sigmaj+textrmhc)+sum_i(epsilon_i-mu)hatn_sigmai\n\nwhere hatc_sigmai^dagger is the fermion creation operator for an electron with spin sigma on orbital i t_ij are the hopping energies, epsilon_i are the on-site energies for each orbital in the lattice, and mu is the chemical potential.\n\nFields\n\nμ::E: The chemical potential mu\nconst ϵ::Vector{E}: A vector containing the on-site energy epsilon_i for each orbital in the lattice.\nconst t::Vector{T}: The hopping energy t_ij associated with each pair of neighboring orbitals connected by a bond in the lattice.\nconst neighbor_table::Matrix{Int}: Neighbor table containing all pairs of orbitals in the lattices connected by a bond, with a non-zero hopping energy between them.\nconst bond_ids::Vector{Int}: The bond ID definitions that define the types of hopping in the lattice.\nconst bond_slices::Vector{UnitRange{Int}}: Slices of neighbor_table corresponding to given bond ID i.e. the neighbors neighbor_table[:,bond_slices[1]] corresponds the bond_ids[1] bond defintion.\nconst norbital::Int: Number of orbitals per unit cell.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.TightBindingParameters-Tuple{}","page":"API","title":"SmoQyDQMC.TightBindingParameters","text":"TightBindingParameters(; tight_binding_model::TightBindingModel{T,E,D},\n                       model_geometry::ModelGeometry{D,E},\n                       rng::AbstractRNG) where {T,E,D}\n\nInitialize and return an instance of TightBindingParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.measure_onsite_energy","page":"API","title":"SmoQyDQMC.measure_onsite_energy","text":"measure_onsite_energy(tight_binding_parameters::TightBindingParameters{T,E},\n                      Gup::Matrix{T}, Gdn::Matrix{T},\n                      orbital_id::Int) where {T<:Number, E<:AbstractFloat, D, N}\n\nMeasure and return the on-site energy epsilon_textrmon-site = (epsilon - mu)langle hatn_uparrow + hatn_downarrow rangle for the orbital_id in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_hopping_energy","page":"API","title":"SmoQyDQMC.measure_hopping_energy","text":"measure_hopping_energy(tight_binding_parameters::TightBindingParameters{T,E},\n                       Gup::Matrix{T}, Gdn::Matrix{T},\n                       bond_id::Int) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average hopping energy epsilon_rm hopping = -sum_sigma langle t_ij hatc^dagger_sigmai hatc_sigmaj + rm hc rangle for the hopping defined by the bond corresponding to bond_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#Hubbard-Model","page":"API","title":"Hubbard Model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HubbardModel\nHubbardParameters\ninitialize","category":"page"},{"location":"api/","page":"API","title":"API","text":"Hubbard Model Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"measure_hubbard_energy","category":"page"},{"location":"api/","page":"API","title":"API","text":"Hubbard Ising Hubbard-Stratonovich Transformation Types and Methods","category":"page"},{"location":"api/","page":"API","title":"API","text":"HubbardIsingHSParameters\ninitialize!\nlocal_updates!\nreflection_update!\nswap_update!","category":"page"},{"location":"api/","page":"API","title":"API","text":"HubbardModel\nHubbardModel(;)\nHubbardParameters\nHubbardParameters(;)\ninitialize!(::FermionPathIntegral{T,E}, ::FermionPathIntegral{T,E}, ::HubbardParameters{E}) where {T,E}","category":"page"},{"location":"api/#SmoQyDQMC.HubbardModel","page":"API","title":"SmoQyDQMC.HubbardModel","text":"HubbardModel{T<:AbstractFloat}\n\nIf shifted = true, then a Hubbard interaction of the form\n\nhatH_U=sum_mathbfinuU_numathbfihatn_uparrownumathbfihatn_downarrownumathbfi\n\nis assumed, where mathbfi specifies the unit cell, and nu denotes the orbital in the unit cell. For a bipartite lattice with only nearest neighbor hopping, the on-site energy corresponding to half-filling and particle-hole symmetry is epsilon_numathbfi = -U_numathbfi2\n\nIf shifted = false, then a Hubbard interaction of the form\n\nhatH_U=sum_mathbfinuU_numathbfi(hatn_uparrownumathbfi-tfrac12)(hatn_downarrownumathbfi-tfrac12)\n\nis assumed. In this case, for a bipartite lattice with only nearest neighbor hopping, the on-site energy corresponding to half-filling and particle-hole symmetry is epsilon_numathbfi = 0\n\nFields\n\nshifted::Bool: Determines which form for Hubbard interaction is used, and whether the on-site energies need to be shifted.\nU_orbital::Vector{Int}: Orbital species in unit cell with finite Hubbard interaction.\nU_mean::Vector{T}: Average Hubbard U_nu for a given orbital species in the lattice.\nU_std::Vector{T}: Standard deviation of Hubbard U_nu for a given orbital species in the lattice.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardModel-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardModel","text":"HubbardModel(; shifted::Bool, U_orbital::AbstractVector{Int}, U_mean::AbstractVector{T},\n             U_std::AbstractVector{T} = zeros(eltype(U_mean), length(U_mean))) where {T<:AbstractFloat}\n\nInitialize and return an instance of the type HubbardModel.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.HubbardParameters","page":"API","title":"SmoQyDQMC.HubbardParameters","text":"HubbardParameters{T<:AbstractFloat}\n\nHubbard parameters for finite lattice.\n\nFields\n\nU::Vector{T}: On-site Hubbard interaction for each site with finite Hubbard interaction.\nsites::Vector{Int}: Site index associated with each finite Hubbard U interaction.\norbitals::Vector{Int}: Orbital species in unit cell with finite Hubbard interaction.\nshifted::Bool: Convention used for Hubbard interaction, refer to HubbardModel for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardParameters-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardParameters","text":"HubbardParameters(; hubbard_model::HubbardModel{T},\n                  model_geometry::ModelGeometry{D,T},\n                  rng::AbstractRNG) where {D,T<:AbstractFloat}\n\nInitialize an instance of HubbardParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, HubbardParameters{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(fermion_path_integral_up::FermionPathIntegral{T,E},\n            fermion_path_integral_dn::FermionPathIntegral{T,E},\n            hubbard_parameters::HubbardParameters{E}) where {T,E}\n\ninitialize!(fermion_path_integral::FermionPathIntegral{T,E},\n            hubbard_parameters::HubbardParameters{E}) where {T,E}\n\nInitialize the contribution from the Hubbard interaction to a FermionPathIntegral instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hubbard-Model-Measurements","page":"API","title":"Hubbard Model Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"measure_hubbard_energy","category":"page"},{"location":"api/#SmoQyDQMC.measure_hubbard_energy","page":"API","title":"SmoQyDQMC.measure_hubbard_energy","text":"measure_hubbard_energy(hubbard_parameters::HubbardParameters{E},\n                       Gup::Matrix{T}, Gdn::Matrix{T},\n                       orbital_id::Int) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average Hubbard energy U langle hatn_uparrow hatn_downarrow rangle for the orbital corresponding orbital_id in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#Hubbard-Ising-Hubbard-Stratonovich-Transformation-Types-and-Methods","page":"API","title":"Hubbard Ising Hubbard-Stratonovich Transformation Types and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HubbardIsingHSParameters\nHubbardIsingHSParameters(;)\ninitialize!(::FermionPathIntegral{T,E}, ::FermionPathIntegral{T,E}, ::HubbardIsingHSParameters{E}) where {T,E}\ninitialize!(::FermionPathIntegral{T,E}, ::HubbardIsingHSParameters{E}) where {T,E}\nlocal_updates!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E})  where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nlocal_updates!(::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E})  where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nreflection_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nreflection_update!(::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nswap_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nswap_update!(::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}","category":"page"},{"location":"api/#SmoQyDQMC.HubbardIsingHSParameters","page":"API","title":"SmoQyDQMC.HubbardIsingHSParameters","text":"HubbardIsingHSParameters{T<:AbstractFloat}\n\nParameters associated with decoupling the Hubbard interaction using the standard Ising Hubbard-Stratonovich (HS) transformation.\n\nFields\n\nβ::T: Inverse temperature.\nΔτ::T: Discretization in imaginary time.\nLτ::Int: Length of imaginary time axis.\nN::Int: Number of orbitals in the lattice.\nU::Vector{T}: Each hubbard interaction.\nα::Vector{T}: The constant given by cosh(alpha_i) = e^Deltatau vert U_i vert2\nsites::Vector{Int}: Site index associated with each finite Hubbard U interaction.\ns::Matrix{Int}: Ising Hubbard-Stratonovich fields.\nupdate_perm::Vector{Int}: Order in which to iterate over HS fields in time slice when performing local updates.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardIsingHSParameters-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardIsingHSParameters","text":"HubbardIsingHSParameters(; β::E, Δτ::E,\n                         hubbard_parameters::HubbardParameters{E},\n                         rng::AbstractRNG) where {E<:AbstractFloat}\n\nInitialize and return an instance of the HubbardIsingHSParameters type. Note that on-site energies fpi.V are shifted by -U_i2 if hmshifted = true.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, HubbardIsingHSParameters{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(fermion_path_integral_up::FermionPathIntegral{T,E},\n            fermion_path_integral_dn::FermionPathIntegral{T,E},\n            hubbard_ising_parameters::HubbardIsingHSParameters{E}) where {T,E}\n\nInitialize the contribution from the Hubbard interaction to the FermionPathIntegral instance fermion_path_integral_up for spin up and fermion_path_integral_dn spin down.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, HubbardIsingHSParameters{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(fermion_path_integral::FermionPathIntegral{T,E},\n            hubbard_ising_parameters::HubbardIsingHSParameters{E}) where {T,E}\n\nInitialize the contribution from an attractive Hubbard interaction to the FermionPathIntegral instance fermion_path_integral.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.local_updates!","text":"local_updates!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n               Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n               hubbard_ising_parameters::HubbardIsingHSParameters{E};\n               fermion_path_integral_up::FermionPathIntegral{T,E},\n               fermion_path_integral_dn::FermionPathIntegral{T,E},\n               fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n               fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n               Bup::Vector{P}, Bdn::Vector{P},\n               δG_max::E, δG::E, δθ::E, rng::AbstractRNG) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nSweep through every imaginary time slice and orbital in the lattice, peforming local updates to every Ising Hubbard-Stratonovich (HS) field.\n\nThis method returns the a tuple containing (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ).\n\nArguments\n\nGup::Matrix{T}: Spin-up equal-time Green's function matrix.\nlogdetGup::E: The log of the absolute value of the determinant of the spin-up equal-time Green's function matrix, log vert det G_uparrow(tautau) vert\nsgndetGup::T: The sign/phase of the determinant of the spin-up equal-time Green's function matrix, det G_uparrow(tautau)  vert det G_uparrow(tautau) vert\nGdn::Matrix{T}: Spin-down equal-time Green's function matrix.\nlogdetGdn::E: The log of the absolute value of the determinant of the spin-down equal-time Green's function matrix, log vert det G_downarrow(tautau) vert\nsgndetGdn::T: The sign/phase of the determinant of the spin-down equal-time Green's function matrix, det G_downarrow(tautau)  vert det G_downarrow(tautau) vert\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of the FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of the FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: An instance of the FermionGreensCalculator type for the spin-up electrons.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: An instance of the FermionGreensCalculator type for the spin-down electrons.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-dn propagators for each imaginary time slice.\nδG_max::E: Maximum allowed error corrected by numerical stabilization.\nδG::E: Previously recorded maximum error in the Green's function corrected by numerical stabilization.\nδθ::T: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green's function matrix corrected by numerical stabilization.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.local_updates!","text":"local_updates!(G::Matrix{T}, logdetG::E, sgndetG::T,\n               hubbard_ising_parameters::HubbardIsingHSParameters{E};\n               fermion_path_integral::FermionPathIntegral{T,E},\n               fermion_greens_calculator::FermionGreensCalculator{T,E},\n               B::Vector{P}, δG_max::E, δG::E, δθ::E,\n               rng::AbstractRNG) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nSweep through every imaginary time slice and orbital in the lattice, performing local updates to every Ising Hubbard-Stratonovich (HS) field, assuming strictly attractive Hubbard interactions and perfect spin symmetry.\n\nThis method returns the a tuple containing (acceptance_rate, logdetG, sgndetG, δG, δθ).\n\nArguments\n\nG::Matrix{T}: Equal-time Green's function matrix.\nlogdetG::E: The log of the absolute value of the determinant of theequal-time Green's function matrix, log vert det G_uparrow(tautau) vert\nsgndetG::T: The sign/phase of the determinant of the equal-time Green's function matrix, det G_uparrow(tautau)  vert det G_uparrow(tautau) vert\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of the FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: An instance of the FermionGreensCalculator type.\nB::Vector{P}: Propagators for each imaginary time slice.\nδG_max::E: Maximum allowed error corrected by numerical stabilization.\nδG::E: Previously recorded maximum error in the Green's function corrected by numerical stabilization.\nδθ::T: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green's function matrix corrected by numerical stabilization.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n                   Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n                   hubbard_ising_parameters::HubbardIsingHSParameters{E};\n                   fermion_path_integral_up::FermionPathIntegral{T,E},\n                   fermion_path_integral_dn::FermionPathIntegral{T,E},\n                   fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n                   Bup::Vector{P}, Bdn::Vector{P},\n                   rng::AbstractRNG) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform a reflection update where the sign of every Ising Hubbard-Stratonovich field on a randomly chosen orbital in the lattice is changed. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n                   hubbard_ising_parameters::HubbardIsingHSParameters{E};\n                   fermion_path_integral::FermionPathIntegral{T,E},\n                   fermion_greens_calculator::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n                   B::Vector{P},\n                   rng::AbstractRNG) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform a reflection update where the sign of every Ising Hubbard-Stratonovich field on a randomly chosen orbital in the lattice is changed. This function returns (accepted, logdetG, sgndetG). This method assumes strictly attractive Hubbard interactions.\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n             Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n             hubbard_ising_parameters::HubbardIsingHSParameters{E};\n             fermion_path_integral_up::FermionPathIntegral{T,E},\n             fermion_path_integral_dn::FermionPathIntegral{T,E},\n             fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n             Bup::Vector{P}, Bdn::Vector{P},\n             rng::AbstractRNG) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform a swap update where the HS fields associated with two randomly chosen sites in the lattice are exchanged. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n             hubbard_ising_parameters::HubbardIsingHSParameters{E};\n             fermion_path_integral::FermionPathIntegral{T,E},\n             fermion_greens_calculator::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n             B::Vector{P}, rng::AbstractRNG) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nFor strictly attractive Hubbard interactions, perform a swap update where the HS fields associated with two randomly chosen sites in the lattice are exchanged. This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#Electron-Phonon-Model","page":"API","title":"Electron-Phonon Model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Model Types and Method","category":"page"},{"location":"api/","page":"API","title":"API","text":"ElectronPhononModel\nPhononMode\nHolsteinCoupling\nSSHCoupling\nPhononDispersion\nadd_phonon_mode!\nadd_holstein_coupling!\nadd_ssh_coupling!\nadd_phonon_dispersion!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Parameter Types and Methods","category":"page"},{"location":"api/","page":"API","title":"API","text":"ElectronPhononParameters\nPhononParameters\nHolsteinParameters\nSSHParameters\nDispersionParameters\ninitialize!\nupdate!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"measure_phonon_kinetic_energy\nmeasure_phonon_potential_energy\nmeasure_phonon_position_moment\nmeasure_holstein_energy\nmeasure_ssh_energy\nmeasure_dispersion_energy","category":"page"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Updates","category":"page"},{"location":"api/","page":"API","title":"API","text":"HMCUpdater\nhmc_update!\nLMCUpdater\nlmc_update!\nSmoQyDQMC.FourierMassMatrix\nreflection_update!\nswap_update!","category":"page"},{"location":"api/#Electron-Phonon-Model-Types-and-Method","page":"API","title":"Electron-Phonon Model Types and Method","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ElectronPhononModel\nElectronPhononModel(;)\nPhononMode\nPhononMode(;)\nHolsteinCoupling\nHolsteinCoupling(;)\nSSHCoupling\nSSHCoupling(;)\nPhononDispersion\nPhononDispersion(;)\nadd_phonon_mode!\nadd_holstein_coupling!\nadd_ssh_coupling!\nadd_phonon_dispersion!","category":"page"},{"location":"api/#SmoQyDQMC.ElectronPhononModel","page":"API","title":"SmoQyDQMC.ElectronPhononModel","text":"ElectronPhononModel{T<:Number, E<:AbstractFloat, D}\n\nDefines an electron-phonon model.\n\nFields\n\nphonon_modes::Vector{PhononModes{E}}: A vector of PhononMode definitions.\nholstein_couplings::Vector{HolsteinCoupling{E,D}}: A vector of HolsteinCoupling definitions.\nssh_couplings::Vector{SSHCoupling{T,E,D}}: A vector of SSHCoupling defintions.\nphonon_dispersions::Vector{PhononDispersion{E,D}}: A vector of PhononDispersion defintions.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ElectronPhononModel-Tuple{}","page":"API","title":"SmoQyDQMC.ElectronPhononModel","text":"ElectronPhononModel(; model_geometry::ModelGeometry{D,E},\n                    tight_binding_model::TightBindingModel{T,E,D}) where {T<:Number, E<:AbstractFloat, D}\n\nInitialize and return a null (empty) instance of ElectronPhononModel given model_geometry and tight_binding_model.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononMode","page":"API","title":"SmoQyDQMC.PhononMode","text":"PhononMode{E<:AbstractFloat}\n\nDefines a phonon mode on the orbital species orbital in the unit cell. Specifically, it defines the phonon Hamiltonian terms\n\nhatH_rm ph = sum_mathbfi\n  left\n      frac12 M_mathbfinuOmega_mathbfinu^2hatX_mathbfinu^2\n    + frac112M_mathbfinuOmega_4mathbfinu^2hatX_mathbfinu^4\n    + frac12M_mathbfinuhatP_mathbfinu^2\n  right\n\nwhere the sum runs over unit cell mathbfi, nu denotes the orbital species orbital in the unit cell, M_mathbfinu is the phonon mass M, Omega_mathbfinu is the phonon frequency that is distributed according to a normal distribution with mean Ω_mean and standard deviation Ω_std. Lastly, Omega_4mathbfinu is the anhmaronic coefficient, and is distributed according to a normal distribution with mean Ω4_mean and standard deviation Ω4_std.\n\nFields\n\norbital::Int: Orbital species nu in the unit cell.\nM::E:: The phonon mass M_mathbfinu\nΩ_mean::E: Mean of normal distribution the phonon frequency Omega_mathbfinu is sampled from.\nΩ_std::E: Standard deviation of normal distribution the phonon frequency Omega_mathbfinu is sampled from.\nΩ4_mean::E: Mean of normal distribution the anharmonic coefficient Omega_4mathbfinu is sampled from.\nΩ4_std::E: Standard deviation of normal distribution the anharmonic coefficient Omega_4mathbfinu is sampled from.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.PhononMode-Tuple{}","page":"API","title":"SmoQyDQMC.PhononMode","text":"PhononMode(; orbital::Int, Ω_mean::E, Ω_std::E=0., M::E=1., Ω4_mean::E=0., Ω4_std::E=0.) where {E<:AbstractFloat}\n\nInitialize and return a instance of PhononMode.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.HolsteinCoupling","page":"API","title":"SmoQyDQMC.HolsteinCoupling","text":"HolsteinCoupling{E<:AbstractFloat, D}\n\nDefines a Holstein coupling between a specified phonon mode and orbital density. Specifically, it defines the (extended) Holstein Hamiltonian interaction term\n\nhatH_rm hol = sum_sigmamathbfi\n    left sum_n=1^4alpha_nmathbfi(mathbfrkappanu)hatX_mathbfinu^n right\n    left( hatn_sigmamathbfi+mathbfrkappa-tfrac12 right)\n\nwhere sigma specifies the sum, and the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa specify orbital species in the unit cell, and mathbfr is a static displacement in unit cells.\n\nFields\n\nphonon_mode::Int: The phonon mode getting coupled to.\nbond::Bond{D}: Static displacement from hatX_mathbfinu to hatn_sigmamathbfi+mathbfrkappa\nbond_id::Int: Bond ID associtated with bond field.\nα_mean::E: Mean of the linear Holstein coupling coefficient alpha_1mathbfi(mathbfrkappanu)\nα_std::E: Standard deviation of the linear Holstein coupling coefficient alpha_1mathbfi(mathbfrkappanu)\nα2_mean::E: Mean of the squared Holstein coupling coefficient alpha_2mathbfi(mathbfrkappanu)\nα2_std::E: Standard deviation of the squared Holstein coupling coefficient alpha_2mathbfi(mathbfrkappanu)\nα3_mean::E: Mean of the cubic Holstein coupling coefficient alpha_3mathbfi(mathbfrkappanu)\nα3_std::E: Standard deviation of the cubic Holstein coupling coefficient alpha_3mathbfi(mathbfrkappanu)\nα4_mean::E: Mean of the quartic Holstein coupling coefficient alpha_4mathbfi(mathbfrkappanu)\nα4_std::E: Standard deviation of the quartic Holstein coupling coefficient alpha_4mathbfi(mathbfrkappanu)\n\nComment\n\nNote that the initial orbital bond.orbital[1] must match the orbital species associated with phonon mode PhononMode getting coupled to.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HolsteinCoupling-Tuple{}","page":"API","title":"SmoQyDQMC.HolsteinCoupling","text":"HolsteinCoupling(; model_geometry::ModelGeometry{D,E}, phonon_mode::Int,\n                 bond::Bond{D}, α_mean::E, α_std::E=0.,\n                 α2_mean::E=0., α2_std::E=0., α3_mean::E=0., α3_std::E=0.,\n                 α4_mean::E=0., α4_std::E=0.) where {E,D}\n\nInitialize and return a instance of HolsteinCoupling.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.SSHCoupling","page":"API","title":"SmoQyDQMC.SSHCoupling","text":"SSHCoupling{T<:Number, E<:AbstractFloat, D}\n\nDefines a Su-Schrieffer-Heeger (SSH) coupling between a pair of phonon modes. Specifically, it defines the SSH interaction term\n\nhatH_rm ssh = -sum_sigmamathbfi\n    left t_mathbfi(mathbfrkappanu) - left( sum_n=1^4alpha_nmathbfi(mathbfrkappanu)\n    left( hatX_mathbfi+mathbfrkappa - hatX_mathbfinuright)^nright) right\n    left( hatc_sigmamathbfi+mathbfrkappa^daggerhatc_sigmamathbfinu+rm hc right)\n\nwhere sigma specifies the sum, and the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa specify orbital species in the unit cell, and mathbfr is a static displacement in unit cells. In that above expression t_mathbfi(mathbfrkappanu) is the bare hopping amplitude, which is not specified here.\n\nFields\n\nphonon_modes::NTuple{2,Int}: Pair of phonon modes getting coupled together.\nbond::Bond{D}: Static displacement seperating the two phonon modes getting coupled.\nbond_id::Int: Bond ID associated with the bond field.\nα_mean::T: Mean of the linear SSH coupling constant alpha_1mathbfi(mathbfrkappanu)\nα_std::T: Standard deviation of the linear SSH coupling constant alpha_1mathbfi(mathbfrkappanu)\nα2_mean::T: Mean of the quadratic SSH coupling constant alpha_2mathbfi(mathbfrkappanu)\nα2_std::T: Standard deviation of the quadratic SSH coupling constant alpha_2mathbfi(mathbfrkappanu)\nα3_mean::T: Mean of the cubic SSH coupling constant alpha_3mathbfi(mathbfrkappanu)\nα3_std::T: Standard deviation of the cubic SSH coupling constant alpha_3mathbfi(mathbfrkappanu)\nα4_mean::T: Mean of the quartic SSH coupling constant alpha_4mathbfi(mathbfrkappanu)\nα4_std::T: Standard deviation of the quartic SSH coupling constant alpha_4mathbfi(mathbfrkappanu)\n\nComment\n\nThe pair of orbitals appearing in bond.orbitals must correspond to the orbital species associated with the two coupling phonon modes specified by phonon_modes.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SSHCoupling-Tuple{}","page":"API","title":"SmoQyDQMC.SSHCoupling","text":"SSHCoupling(; model_geometry::ModelGeometry{D,E}, tight_binding_model::TightBindingModel{T,E,D},\n            phonon_modes::NTuple{2,Int}, bond::Bond{D},\n            α_mean::T, α_std::E=0., α2_mean::T=0., α2_std::E=0., α3_mean::T=0., α3_std::E=0.,\n            α4_mean::T=0., α4_std::E=0.) where {D, T<:Number, E<:AbstractFloat}\n\nInitialize and return a instance of SSHCoupling.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononDispersion","page":"API","title":"SmoQyDQMC.PhononDispersion","text":"PhononDispersion{E<:AbstractFloat, D}\n\nDefines a dispersive phonon coupling between phonon modes. Specifically, it defines the dispersive phonon term\n\nhatH_rm disp = sum_mathbfi\n    left(\n        fracM_mathbfi+mathbfrkappaM_mathbfinuM_mathbfi+mathbfrkappa+M_mathbfinu\n    right)\n    bigg\n                    Omega_mathbfi(mathbfrkappanu)^2Big(hatX_mathbfi+mathbfrkappa-hatX_mathbfinuBig)^2\n       +frac112Omega_4mathbfi(mathbfrkappanu)^2Big(hatX_mathbfi+mathbfrkappa-hatX_mathbfinuBig)^4\n    bigg\n\nwhere the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa specify orbital species in the unit cell, and mathbfr is a static displacement in unit cells.\n\nFields\n\nphonon_modes::NTuple{2,Int}: Pair of phonon modes getting coupled together.\nbond::Bond{D}: Static displacement seperating the two phonon modes getting coupled.\nbond_id::Int: Bond ID associated with the bond field.\nΩ_mean::E: Mean dispersive phonon frequency Omega_mathbfi(mathbfrkappanu)\nΩ_std::E: Standard deviation of dispersive phonon frequency Omega_mathbfi(mathbfrkappanu)\nΩ4_mean::E: Mean quartic dispersive phonon coefficient Omega_4mathbfi(mathbfrkappanu)\nΩ4_std::E: Standard deviation of quartic dispersive phonon coefficient Omega_4mathbfi(mathbfrkappanu)\n\nComment\n\nThe pair of orbitals appearing in bond.orbitals must correspond to the orbital species associated with the two coupling phonon modes specified by phonon_modes.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.PhononDispersion-Tuple{}","page":"API","title":"SmoQyDQMC.PhononDispersion","text":"PhononDispersion(; model_geometry::ModelGeometry{D,E}, phonon_modes::NTuple{2,Int}, bond::Bond{D},\n                 Ω_mean::E, Ω_std::E=0., Ω4_mean::E=0., Ω4_std::E=0.) where {E<:AbstractFloat, D}\n\nInitialize and return a instance of PhononDispersion.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.add_phonon_mode!","page":"API","title":"SmoQyDQMC.add_phonon_mode!","text":"add_phonon_mode!(; electron_phonon_model::ElectronPhononModel{T,E,D},\n                 phonon_mode::PhononMode{E}) where {T<:Number, E<:AbstractFloat, D}\n\nAdd a PhononMode to an ElectronPhononModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_holstein_coupling!","page":"API","title":"SmoQyDQMC.add_holstein_coupling!","text":"add_holstein_coupling!(; electron_phonon_model::ElectronPhononModel{T,E,D},\n                       holstein_coupling::HolsteinCoupling{E,D},\n                       model_geometry::ModelGeometry{D,E}) where {T,E,D}\n\nAdd the HolsteinCoupling to an ElectronPhononModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_ssh_coupling!","page":"API","title":"SmoQyDQMC.add_ssh_coupling!","text":"add_ssh_coupling!(; electron_phonon_model::ElectronPhononModel{T,E,D},\n                  ssh_coupling::SSHCoupling{T,E,D},\n                  tight_binding_model::TightBindingModel{T,E,D}) where {T,E,D}\n\nAdd a SSHCoupling to an ElectronPhononModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_phonon_dispersion!","page":"API","title":"SmoQyDQMC.add_phonon_dispersion!","text":"add_phonon_dispersion!(elphm::ElectronPhononModel{T,E,D}, pd::PhononDispersion{E,D}, mg::ModelGeometry{D,E}) where {T,E,D}\n\nAdd a PhononDispersion to an ElectronPhononModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#Electron-Phonon-Parameter-Types-and-Methods","page":"API","title":"Electron-Phonon Parameter Types and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ElectronPhononParameters\nElectronPhononParameters(;)\nSmoQyDQMC.PhononParameters\nSmoQyDQMC.HolsteinParameters\nSmoQyDQMC.SSHParameters\nSmoQyDQMC.DispersionParameters\ninitialize!(::FermionPathIntegral{T,E}, ::FermionPathIntegral{T,E}, ::ElectronPhononParameters{T,E}) where {T,E}\nupdate!(::FermionPathIntegral{T,E}, ::FermionPathIntegral{T,E}, ::ElectronPhononParameters{T,E}, ::Matrix{E}, ::Matrix{E}) where {T,E}","category":"page"},{"location":"api/#SmoQyDQMC.ElectronPhononParameters","page":"API","title":"SmoQyDQMC.ElectronPhononParameters","text":"ElectronPhononParameters{T<:Number, E<:AbstractFloat}\n\nDescribes all parameters in the electron-phonon model.\n\nFields\n\nβ::E: Inverse temperature.\nΔτ::E: Discretization in imaginary time.\nLτ::Int: Length of imaginary time axis.\nx::Matrix{E}: Phonon fields, where each column represents the phonon fields for a given imaginary time slice.\nphonon_parameters::PhononParameters{E}: Refer to PhononParameters.\nholstein_parameters::HolsteinParameters{E}: Refer to HolsteinParameters.\nssh_parameters::SSHParameters{T}: Refer to SSHParameters.\ndispersion_parameters::DispersionParameters{E}: Refer to DispersionParameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ElectronPhononParameters-Tuple{}","page":"API","title":"SmoQyDQMC.ElectronPhononParameters","text":"ElectronPhononParameters(; β::E, Δτ::E,\n                         model_geometry::ModelGeometry{D,E},\n                         tight_binding_parameters::TightBindingParameters{T,E},\n                         electron_phonon_model::ElectronPhononModel{T,E,D},\n                         rng::AbstractRNG) where {T,E,D}\n\nInitialize and return an instance of ElectronPhononParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononParameters","page":"API","title":"SmoQyDQMC.PhononParameters","text":"PhononParameters{E<:AbstractFloat}\n\nDefines the parameters for each phonon in the lattice, includes the phonon field configuration.\n\nFields\n\nnphonon::Int: Number of type of phonon modes.\nNphonon::Int: Total number of phonon modes in finite lattice.\nM::Int: Mass of each phonon mode.\nΩ::Int: Frequency of each phonon mode.\nΩ4::Int: Quartic phonon coefficient for each phonon mode.\nphonon_to_site::Vector{Int}: Map each phonon to the site it lives on in the lattice.\nsite_to_phonons::Vector{Vector{Int}}: Maps the site to the phonon modes on it, allowing for multiple modes to reside on a single site.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HolsteinParameters","page":"API","title":"SmoQyDQMC.HolsteinParameters","text":"HolsteinParameters{E<:AbstractFloat}\n\nDefines the Holstein coupling parameters in lattice.\n\nFields\n\nnholstein::Int: The number of type of holstein couplings.\nNholstein::Int: Total number of Holstein couplings in lattice.\nα::Vector{T}: Linear Holstein coupling.\nα2::Vector{T}: Quadratic Holstein coupling.\nα3::Vector{T}: Cubic Holstein coupling.\nα4::Vector{T}: Quartic Holstein coupling.\nneighbor_table::Matrix{Int}: Neighbor table where the first row specifies the site where the phonon mode is located, and the second row specifies the site corresponds to the density getting coupled to.\ncoupling_to_phonon::Vector{Int}: Maps each Holstein coupling in the lattice to the corresponding phonon mode.\nphonon_to_coupling::Vector{Vector{Int}}: Maps each phonon model to correspond Holstein couplings.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SSHParameters","page":"API","title":"SmoQyDQMC.SSHParameters","text":"SSHParameters{T<:Number}\n\nDefines the SSH coupling parameters in lattice.\n\nFields\n\nnssh::Int: Number of types of SSH couplings.\nNssh::Int: Number of SSH couplings in lattice.\nα::Vector{T}: Linear SSH coupling.\nα2::Vector{T}: Quadratic SSH coupling.\nα3::Vector{T}: Cubic SSH coupling.\nα4::Vector{T}: Quartic SSH coupling.`\nneighbor_table::Matrix{Int}: Neighbor table to SSH coupling.\ncoupling_to_phonon::Matrix{Int}: Maps each SSH coupling onto that pair of coupled phonons.\ninit_phonon_to_coupling::Vector{Vector{Int}}: Maps initial phonon mode to corresponding SSH coupling(s).\nfinal_phonon_to_coupling::Vector{Vector{Int}}: Maps final phonon mode to corresponding SSH coupling(s).\nhopping_to_coupling::Vector{Int}: Maps hopping in the tight-binding model onto SSH couplings. If zero, this means there is no SSH coupling for that hopping.\ncoupling_to_hopping::Vector{Int}: Maps each SSH coupling onto the corresponding hopping in the tight-binding model.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.DispersionParameters","page":"API","title":"SmoQyDQMC.DispersionParameters","text":"DispersionParameters{E<:AbstractFloat}\n\nDefines the dispersive phonon coupling parameters in the lattice.\n\nFields\n\nndispersion::Int: Number of types of dispersive couplings.\nNdispersion::Int: Number of dispersive couplings in the lattice.\nΩ::Vector{E}: Frequency of dispersive phonon coupling.\nΩ4::Vector{E}: Quartic coefficient for the phonon dispersion.\ndispersion_to_phonon::Matrix{Int}: Pair of phonon modes in lattice coupled by dispersive coupling.\ninit_phonon_to_coupling::Vector{Vector{Int}}: Maps initial phonon mode to corresponding dispersive phonon coupling.\nfinal_phonon_to_coupling::Vector{Vector{Int}}: Maps final phonon mode to corresponding dispersive phonon coupling.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, ElectronPhononParameters{T, E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(fermion_path_integral_up::FermionPathIntegral{T,E},\n            fermion_path_integral_dn::FermionPathIntegral{T,E},\n            electron_phonon_parameters::ElectronPhononParameters{T,E}) where {T,E}\n\ninitialize!(fermion_path_integral::FermionPathIntegral{T,E},\n            electron_phonon_parameters::ElectronPhononParameters{T,E}) where {T,E}\n\nInitialize the contribution of an ElectronPhononParameters to a FermionPathIntegral.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.update!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, ElectronPhononParameters{T, E}, Matrix{E}, Matrix{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.update!","text":"update!(fermion_path_integral_up::FermionPathIntegral{T,E},\n        fermion_path_integral_dn::FermionPathIntegral{T,E},\n        electron_phonon_parameters::ElectronPhononParameters{T,E},\n        x′::Matrix{E}, x::Matrix{E} = electron_phonon_parameters.x) where {T,E}\n\nupdate!(fermion_path_integral::FermionPathIntegral{T,E},\n        electron_phonon_parameters::ElectronPhononParameters{T,E},\n        x′::Matrix{E}, x::Matrix{E} = electron_phonon_parameters.x) where {T,E}\n\nUpdate a FermionPathIntegral to reflect a change in the phonon configuration from x to x′.\n\n\n\n\n\n","category":"method"},{"location":"api/#Electron-Phonon-Measurements","page":"API","title":"Electron-Phonon Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"measure_phonon_kinetic_energy\nmeasure_phonon_potential_energy\nmeasure_phonon_position_moment\nmeasure_holstein_energy\nmeasure_ssh_energy\nmeasure_dispersion_energy","category":"page"},{"location":"api/#SmoQyDQMC.measure_phonon_kinetic_energy","page":"API","title":"SmoQyDQMC.measure_phonon_kinetic_energy","text":"measure_phonon_kinetic_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                              n::Int) where {T<:Number, E<:AbstractFloat}\n\nEvaluate the average phonon kinetic energy for phonon mode n. The measurement is made using the expression\n\nlangle K rangle = frac12Deltatau - fracM2bigglanglefrac(x_l+1-x_l)^2Deltatau^2biggrangle \n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_phonon_potential_energy","page":"API","title":"SmoQyDQMC.measure_phonon_potential_energy","text":"measure_phonon_potential_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                                n::Int) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average phonon potential energy, given by\n\nU = frac12 M Omega^2 langle hatX^2 rangle + frac124 M Omega_4^2 langle hatX^4 rangle\n\nfor phonon mode n in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_phonon_position_moment","page":"API","title":"SmoQyDQMC.measure_phonon_position_moment","text":"measure_phonon_position_moment(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                               n::Int, m::Int) where {T<:Number, E<:AbstractFloat}\n\nMeasure langle X^m rangle for phonon mode n in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_holstein_energy","page":"API","title":"SmoQyDQMC.measure_holstein_energy","text":"measure_holstein_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                     Gup::Matrix{T}, Gdn::Matrix{T},\n                     holstein_id::Int) where {T<:Number, E<:AbstractFloat}\n\nCalculate and return the Holstein interaction energy\n\nepsilon_rm hol = leftlangle  alpha hatX     + alpha_2 hatX^2\n                                  + alpha_3 hatX^3 + alpha_4 hatX^4\n                                (hatn_uparrow + hatn_downarrow - 1) rightrangle\n\nfor the Holstein coupling definition corresponding to holstein_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_ssh_energy","page":"API","title":"SmoQyDQMC.measure_ssh_energy","text":"measure_ssh_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                Gup::Matrix{T}, Gdn::Matrix{T},\n                ssh_id::Int) where {T<:Number, E<:AbstractFloat}\n\nCalculate the return the SSH interaction energy\n\nepsilon_rm ssh = sum_sigma leftlangle alpha hatX     + alpha_2 hatX^2\n                                               alpha_3 hatX^3 + alpha_4 hatX^4\n                                              (hatc^dagger_sigmai hatc_sigmaj + rm hc) rightrangle\n\nfor coupling definition specified by ssh_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_dispersion_energy","page":"API","title":"SmoQyDQMC.measure_dispersion_energy","text":"measure_dispersion_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                       dispersion_id::Int) where {T<:Number, E<:AbstractFloat}\n\nEvaluate the average dispersion energy\n\nepsilon_rm disp = frac12 M_rm red Omega^2 langle(hatX_i - hatX_j)^2rangle\n                    + frac124 Mrm red Omega_4^2 langle(hatX_i - hatX_j)^4rangle\n\nwhere M_rm red = fracM_i M_jM_i + M_j is the reduced mass, for the dispersive coupling definition specified by dispersion_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#Electron-Phonon-Updates","page":"API","title":"Electron-Phonon Updates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HMCUpdater\nHMCUpdater(;)\nhmc_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}, ::HMCUpdater{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nhmc_update!(::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}, ::HMCUpdater{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nLMCUpdater\nLMCUpdater(;)\nlmc_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}, ::LMCUpdater{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nlmc_update!(::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}, ::LMCUpdater{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nSmoQyDQMC.FourierMassMatrix\nSmoQyDQMC.FourierMassMatrix(::ElectronPhononParameters{T,E}, ::E) where {T,E}\nreflection_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nreflection_update!(::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nswap_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nswap_update!(::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}","category":"page"},{"location":"api/#SmoQyDQMC.HMCUpdater","page":"API","title":"SmoQyDQMC.HMCUpdater","text":"HMCUpdater{T<:Number, E<:AbstractFloat, PFFT, PIFFT}\n\nDefines a hybrid/hamiltonian monte carlo (HMC) update for the phonon degrees of freedom. Each HMC update uses a number of timesteps sampled from a geometric distribution with a mean given by Nt.\n\nFields\n\nNt::Int: Mean trajectory length in terms of the number of fermionic time-steps.\nΔt::E: Fermionic time-step size.\nnt::Int: Number of bosonic time-steps per fermionic time-step. The effective bosonic time-step size is Δt′ = Δt/nt.\nM::FourierMassMatrix{E, PFFT, PIFFT}: Fourier mass matrix, refer to FourierMassMatrix for more information.\ndSdx::Matrix{E}: Array to contain derivative of fermionic and bosonic action during HMC trajectory.\ndSfdx0::Matrix{E}: Array to contain the initial derivative of fermionic action associated with the initial phonon configuration.\nGup′::Matrix{T}: Matrix to contain itermediate spin-up Green's function matrices.\nGdn′::Matrix{T}: Matrix to contain itermediate spin-down Green's function matrices.\nx′::Matrix{E}: Array to record intermediate phonon configurations.\nx0::Matrix{E}: Array to record initial phonon configuration.\nv::Matrix{E}: Conjugate momentum to phonon fields in HMC trajectory.\nfirst_update::Bool: A flag indicating whether the next update will be the first update\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HMCUpdater-Tuple{}","page":"API","title":"SmoQyDQMC.HMCUpdater","text":"HMCUpdater(; electron_phonon_parameters::ElectronPhononParameters{T,E},\n           G::Matrix{T}, Nt::Int, Δt::E, nt::Int, reg::E) where {T,E}\n\nInitialize and return an instance of HMCUpdater.\n\nArguments\n\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Defines electron phonon model.\nG::Matrix{T}: Template Green's function matrix.\nNt::Int: Mean of geometric distribution an HMC trajectory length in the number of fermionic timesteps is sampled from.\nΔt::E: Fermionic time-step.\nnt::Int: Bosonic time-steps per fermionic time-step, with the effective bosonic time-step given by Δt′ = Δt/nt.\nreg::E: Regularization parameter for defining an instance of FourierMassMatrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}, HMCUpdater{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n            Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n            electron_phonon_parameters::ElectronPhononParameters{T,E},\n            hmc_updater::HMCUpdater{T,E};\n            fermion_path_integral_up::FermionPathIntegral{T,E},\n            fermion_path_integral_dn::FermionPathIntegral{T,E},\n            fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n            Bup::Vector{P}, Bdn::Vector{P},\n            δG_max::E, δG::E, δθ::E, rng::AbstractRNG,\n            initialize_force::Bool = true,\n            δG_reject::E = 1e-2) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform HMC update to the phonon degrees of freedom. This method returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ), where accepted is a boolean field indicating whether the proposed HMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}, HMCUpdater{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n            electron_phonon_parameters::ElectronPhononParameters{T,E},\n            hmc_updater::HMCUpdater{T,E};\n            fermion_path_integral::FermionPathIntegral{T,E},\n            fermion_greens_calculator::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n            B::Vector{P}, δG_max::E, δG::E, δθ::E, rng::AbstractRNG,\n            initialize_force::Bool = true,\n            δG_reject::E = 1e-2) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform HMC update to the phonon degrees of freedom assuming the spin-up and spin-down sectors are equivalent. This method returns (accepted, logdetG, sgndetG, δG, δθ), where accepted is a boolean field indicating whether the proposed HMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.LMCUpdater","page":"API","title":"SmoQyDQMC.LMCUpdater","text":"LMCUpdater{T<:Number, E<:AbstractFloat, PFFT, PIFFT}\n\nDefines a langevin monte carlo (HMC) update for the phonon degrees of freedom.\n\nFields\n\nΔt::E: Mean fermionic time-step size, which for a given LMC update is sampled from an exponential distribution.\nnt::Int: Number of bosonic time-steps per fermionic time-step. The effective bosonic time-step size is Δt′ = Δt/nt.\nM::FourierMassMatrix{E, PFFT, PIFFT}: Fourier mass matrix, refer to FourierMassMatrix for more information.\ndSdx::Matrix{E}: Array to contain derivative of fermionic and bosonic action during HMC trajectory.\ndSfdx0::Matrix{E}: Array to contain the initial derivative of fermionic action associated with the initial phonon configuration.\nGup′::Matrix{T}: Matrix to contain itermediate spin-up Green's function matrices.\nGdn′::Matrix{T}: Matrix to contain itermediate spin-down Green's function matrices.\nx′::Matrix{E}: Array to record intermediate phonon configurations.\nx0::Matrix{E}: Array to record initial phonon configuration.\nv::Matrix{E}: Conjugate momentum to phonon fields in HMC trajectory.\nfirst_update::Bool: A flag indicating whether the next update will be the first update\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.LMCUpdater-Tuple{}","page":"API","title":"SmoQyDQMC.LMCUpdater","text":"LMCUpdater(; electron_phonon_parameters::ElectronPhononParameters{T,E},\n           G::Matrix{T}, Δt::E, nt::Int, reg::E) where {T,E}\n\nInitialize and return an instance of LMCUpdater.\n\nArguments\n\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Defines electron phonon model.\nG::Matrix{T}: Template Green's function matrix.\nΔt::E: Mean of exponential distribution the fermionic time-step is sampled from.\nnt::Int: Number of bosonic time-steps, with the effective bosonic time-step given by Δt′ = Δt/nt.\nreg::E: Regularization parameter for defining an instance of FourierMassMatrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.lmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}, LMCUpdater{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.lmc_update!","text":"lmc_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n            Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n            electron_phonon_parameters::ElectronPhononParameters{T,E},\n            lmc_updater::LMCUpdater{T,E};\n            fermion_path_integral_up::FermionPathIntegral{T,E},\n            fermion_path_integral_dn::FermionPathIntegral{T,E},\n            fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n            Bup::Vector{P}, Bdn::Vector{P},\n            δG_max::E, δG::E, δθ::E, rng::AbstractRNG,\n            initialize_force::Bool = true,\n            δG_reject::E = sqrt(δG_max)) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform LMC update to the phonon degrees of freedom. This method returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ), where accepted is a boolean field indicating whether the proposed LMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.lmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}, LMCUpdater{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.lmc_update!","text":"lmc_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n            electron_phonon_parameters::ElectronPhononParameters{T,E},\n            lmc_updater::LMCUpdater{T,E};\n            fermion_path_integral::FermionPathIntegral{T,E},\n            fermion_greens_calculator::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n            B::Vector{P}, δG_max::E, δG::E, δθ::E, rng::AbstractRNG,\n            initialize_force::Bool = true,\n            δG_reject::E = sqrt(δG_max)) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform LMC update to the phonon degrees of freedom assuming the spin-up and spin-down sectors are equivalent. This method returns (accepted, logdetG, sgndetG, δG, δθ), where accepted is a boolean field indicating whether the proposed LMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.FourierMassMatrix","page":"API","title":"SmoQyDQMC.FourierMassMatrix","text":"FourierMassMatrix{E<:AbstractFloat, PFFT, PIFFT}\n\nDefines the mass matrix that implements fourier acceleration when performing either hybrid/hamiltonian monte carlo or langevin monte carlo updates to the phonon fields.\n\nFields\n\nM̃::Matrix{E}: Matrix elements of fourier mass matrix in frequency space.\nv′::Matrix{Complex{E}}: Temporary storage array to contain velocities as complex numbers to avoid dynamic memory allocations.\nṽ::Matrix{Complex{E}}: Temporary storage to avoid some dynamic memory allocations when performing fourier transforms.\npfft::PFFT: Forward FFT plan to perform transformation from imaginary time to frequency space without allocations.\npifft::PIFFT: Inverse FFT plan to perform transformation from frequency to imaginary time space without allocations.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.FourierMassMatrix-Union{Tuple{E}, Tuple{T}, Tuple{ElectronPhononParameters{T, E}, E}} where {T, E}","page":"API","title":"SmoQyDQMC.FourierMassMatrix","text":"FourierMassMatrix(electron_phonon_parameters::ElectronPhononParameters{T,E}, reg::E=1.0) where {T,E}\n\nInitialize and return an instance of FouerierMassMatrix. Given a regularization value of reg, represented by the symbol m_rm reg, the matrix elements of the fouerier mass matrix in frequency space, where it is diagonal, are given by\n\ntildeM_omegaomega = \n    Deltataufrac(1+m_rm reg)MOmega^2+frac4MDeltatau^2sin^2big(frac2piomegaL_taubig)(1+m_rm reg)MOmega^2\n\nwhere omega in 0 L_tau) corresponds to the frequency after fourier transforming from imaginary time to frequency space, and L_tau is the length of the imaginary time axis. Also, Omega and M are the phonon frequency and mass respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n                   Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n                   electron_phonon_parameters::ElectronPhononParameters{T,E};\n                   fermion_path_integral_up::FermionPathIntegral{T,E},\n                   fermion_path_integral_dn::FermionPathIntegral{T,E},\n                   fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n                   Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,\n                   phonon_types = nothing) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a phonon mode in the lattice, and propose an update that reflects all the phonon fields associated with that phonon mode x rightarrow -x This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_types = nothing: Collection of phonon types in the unit cell to randomly sample a phonon mode from. If nothing then all phonon modes in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n                   electron_phonon_parameters::ElectronPhononParameters{T,E};\n                   fermion_path_integral::FermionPathIntegral{T,E},\n                   fermion_greens_calculator::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n                   B::Vector{P}, rng::AbstractRNG,\n                   phonon_types = nothing) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a phonon mode in the lattice, and propose an update that reflects all the phonon fields associated with that phonon mode x rightarrow -x This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_types = nothing: Collection of phonon types in the unit cell to randomly sample a phonon mode from. If nothing then all phonon modes in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n             Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n             electron_phonon_parameters::ElectronPhononParameters{T,E};\n             fermion_path_integral_up::FermionPathIntegral{T,E},\n             fermion_path_integral_dn::FermionPathIntegral{T,E},\n             fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n             Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,\n             phonon_type_pairs = nothing) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a pairs of phonon modes and exchange the phonon fields associated with the pair of phonon modes. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_type_pairs = nothing: Collection of phonon type pairs in the unit cell to randomly sample a phonon modes from. If nothing then all phonon mode pairs in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n             electron_phonon_parameters::ElectronPhononParameters{T,E};\n             fermion_path_integral::FermionPathIntegral{T,E},\n             fermion_greens_calculator::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n             B::Vector{P}, rng::AbstractRNG,\n             phonon_type_pairs = nothing) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a pairs of phonon modes and exchange the phonon fields associated with the pair of phonon modes. This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_type_pairs = nothing: Collection of phonon type pairs in the unit cell to randomly sample a phonon modes from. If nothing then all phonon mode pairs in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#Density-and-Chemical-Potential-Tuning","page":"API","title":"Density and Chemical Potential Tuning","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"update_chemical_potential!\nsave_density_tuning_profile","category":"page"},{"location":"api/","page":"API","title":"API","text":"update_chemical_potential!\nsave_density_tuning_profile","category":"page"},{"location":"api/#SmoQyDQMC.update_chemical_potential!","page":"API","title":"SmoQyDQMC.update_chemical_potential!","text":"update_chemical_potential!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n                           Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T;\n                           chemical_potential_tuner::MuTunerLogger{E,T},\n                           tight_binding_parameters::TightBindingParameters{T,E},\n                           fermion_path_integral_up::FermionPathIntegral{T,E},\n                           fermion_path_integral_dn::FermionPathIntegral{T,E},\n                           fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                           fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                           Bup::Vector{P}, Bdn::Vector{P}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nUpdate the chemical potential mu in the simulation to approach the target density/filling. This method returns the new values for (logdetGup, sgndetGup, logdetGup, sgndetGup).\n\n\n\n\n\nupdate_chemical_potential!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n                           Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T;\n                           chemical_potential_tuner::MuTunerLogger{E,T},\n                           tight_binding_parameters::TightBindingParameters{T,E},\n                           fermion_path_integral_up::FermionPathIntegral{T,E},\n                           fermion_path_integral_dn::FermionPathIntegral{T,E},\n                           fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                           fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                           Bup::Vector{P}, Bdn::Vector{P}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nupdate_chemical_potential!(G::Matrix{T}, logdetG::E, sgndetG::T;\n                           chemical_potential_tuner::MuTunerLogger{E,T},\n                           tight_binding_parameters::TightBindingParameters{T,E},\n                           fermion_path_integral::FermionPathIntegral{T,E},\n                           fermion_greens_calculator::FermionGreensCalculator{T,E},\n                           B::Vector{P}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nUpdate the chemical potential mu in the simulation to approach the target density/filling. This method returns the new values for (logdetG, sgndetG).\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.save_density_tuning_profile","page":"API","title":"SmoQyDQMC.save_density_tuning_profile","text":"save_density_tuning_profile(simulation_info::SimulationInfo,\n                            chemical_potential_tuner::MuTunerLogger{E,T}) where {E,T}\n\nWrite the full density tuning history to a CSV file, typically done at the end of a simulation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Measurement-Methods","page":"API","title":"Measurement Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CORRELATION_FUNCTIONS","category":"page"},{"location":"api/","page":"API","title":"API","text":"Initialize Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"initialize_measurement_container\ninitialize_measurements!\ninitialize_correlation_measurements!\ninitialize_measurement_directories","category":"page"},{"location":"api/","page":"API","title":"API","text":"Make Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"make_measurements!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Write Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"write_measurements!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Process Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"process_measurements\nprocess_correlation_measurement\ncomposite_correlation_stats\nglobal_measurement_bins_to_csv\nlocal_measurement_bins_to_csv\ncorrelation_bins_to_csv","category":"page"},{"location":"api/","page":"API","title":"API","text":"CORRELATION_FUNCTIONS","category":"page"},{"location":"api/#SmoQyDQMC.CORRELATION_FUNCTIONS","page":"API","title":"SmoQyDQMC.CORRELATION_FUNCTIONS","text":"const CORRELATION_FUNCTIONS = (\n    \"greens_up\",\n    \"greens_dn\",\n    \"phonon_greens\",\n    \"density\",\n    \"pair\",\n    \"spin_x\",\n    \"spin_z\",\n    \"bond\",\n    \"current\"\n)\n\nList of all the correlation functions that can be measured. Correlation functions are well defined in both position and momentum space.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Initialize-Measurements","page":"API","title":"Initialize Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"initialize_measurement_container\ninitialize_measurements!\ninitialize_correlation_measurements!\ninitialize_measurement_directories","category":"page"},{"location":"api/#SmoQyDQMC.initialize_measurement_container","page":"API","title":"SmoQyDQMC.initialize_measurement_container","text":"initialize_measurement_container(model_geometry::ModelGeometry{D,T,N}, β::T, Δτ::T) where {T<:AbstractFloat, D, N}\n\nInitialize and return a measurement container of type NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_measurements!","page":"API","title":"SmoQyDQMC.initialize_measurements!","text":"initialize_measurements!(measurement_container::NamedTuple,\n                         tight_binding_model::TightBindingModel{T,E}) where {T<:Number, E<:AbstractFloat}\n\nInitialize tight-binding model related measurements.\n\nInitialized Measurements\n\nonsite_energy: Refer to measure_onsite_energy.\nhopping_energy: Refer to measure_hopping_energy.\n\n\n\n\n\ninitialize_measurements!(measurement_container::NamedTuple,\n                         hubbard_model::HubbardModel{T}) where {T<:AbstractFloat}\n\nInitialize Hubbard model related measurements.\n\nInitialized Measurements:\n\nhubbard_energy: Refer to measure_hopping_energy.\n\n\n\n\n\ninitialize_measurements!(measurement_container::NamedTuple,\n                         electron_phonon_model::ElectronPhononModel{T, E, D}) where {T<:Number, E<:AbstractFloat, D}\n\nInitialize electron-phonon model related measurements.\n\nInitialized Measurements:\n\nphonon_kinetic_energy: Refer to measure_phonon_kinetic_energy.\nphonon_potential_energy: Refer to measure_phonon_potential_energy.\nX: Measure langle hatX rangle, refer to measure_phonon_position_moment.\nX2: Measure langle hatX^2 rangle, refer to measure_phonon_position_moment.\nX3: Measure langle hatX^3 rangle, refer to measure_phonon_position_moment.\nX4: Measure langle hatX^4 rangle, refer to measure_phonon_position_moment.\nholstein_energy: Refer to measure_holstein_energy.\nssh_energy: Refer to measure_ssh_energy.\nssh_sgn_switch: Refer to measure_ssh_sgn_switch.\ndispersion_energy: Refer to measure_dispersion_energy.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_correlation_measurements!","page":"API","title":"SmoQyDQMC.initialize_correlation_measurements!","text":"initialize_correlation_measurements!(; measurement_container::NamedTuple,\n                                     model_geometry::ModelGeometry{D,T,N},\n                                     correlation::String, pairs::AbstractVector{NTuple{2,Int}},\n                                     time_displaced::Bool)  where {T<:AbstractFloat, D, N}\n\nInitialize measurements of correlation for all pairs of bond ID's in pairs. The name correlation must appear in CORRELATION_FUNCTIONS.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_measurement_directories","page":"API","title":"SmoQyDQMC.initialize_measurement_directories","text":"initialize_measurement_directories(; simulation_info::SimulationInfo,\n                                   measurement_container::NamedTuple)\n\nInitialize the measurement directories for simulation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Make-Measreuments","page":"API","title":"Make Measreuments","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"make_measurements!","category":"page"},{"location":"api/#SmoQyDQMC.make_measurements!","page":"API","title":"SmoQyDQMC.make_measurements!","text":"make_measurements!(measurement_container::NamedTuple,\n                   logdetGup::E, sgndetGup::T, Gup::AbstractMatrix{T}, Gup_ττ::AbstractMatrix{T}, Gup_τ0::AbstractMatrix{T}, Gup_0τ::AbstractMatrix{T},\n                   logdetGdn::E, sgndetGdn::T, Gdn::AbstractMatrix{T}, Gdn_ττ::AbstractMatrix{T}, Gdn_τ0::AbstractMatrix{T}, Gdn_0τ::AbstractMatrix{T};\n                   fermion_path_integral_up::FermionPathIntegral{T,E},\n                   fermion_path_integral_dn::FermionPathIntegral{T,E},\n                   fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                   Bup::Vector{P}, Bdn::Vector{P}, δG_max::E, δG::E, δθ::E,\n                   model_geometry::ModelGeometry{D,E,N},\n                   tight_binding_parameters::TightBindingParameters{T,E},\n                   coupling_parameters::Tuple) where {T<:Number, E<:AbstractFloat, D, N, P<:AbstractPropagator{T,E}}\n\nMake measurements, including time-displaced correlation and zero Matsubara frequency measurements. This method also returns (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ).\n\n\n\n\n\nmake_measurements!(measurement_container::NamedTuple,\n                   logdetG::E, sgndetG::T, G::AbstractMatrix{T},\n                   G_ττ::AbstractMatrix{T}, G_τ0::AbstractMatrix{T}, G_0τ::AbstractMatrix{T};\n                   fermion_path_integral::FermionPathIntegral{T,E},\n                   fermion_greens_calculator::FermionGreensCalculator{T,E},\n                   B::Vector{P}, δG_max::E, δG::E, δθ::E,\n                   model_geometry::ModelGeometry{D,E,N},\n                   tight_binding_parameters::TightBindingParameters{T,E},\n                   coupling_parameters::Tuple) where {T<:Number, E<:AbstractFloat, D, N, P<:AbstractPropagator{T,E}}\n\nMake measurements, including time-displaced correlation and zero Matsubara frequency measurements. This method also returns (logdetG, sgndetG, δG, δθ).\n\n\n\n\n\n","category":"function"},{"location":"api/#Write-Measreuments","page":"API","title":"Write Measreuments","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"write_measurements!","category":"page"},{"location":"api/#SmoQyDQMC.write_measurements!","page":"API","title":"SmoQyDQMC.write_measurements!","text":"write_measurements!(; measurement_container::NamedTuple,\n                    simulation_info::SimulationInfo,\n                    model_geometry::ModelGeometry{D, E, N},\n                    bin::Int, bin_size::Int) where {E<:AbstractFloat, D, N}\n\nWrite the measurements contained in measurement_container to file. Measurements are written to file in a binary format using the JLD2.jl package.\n\nThis funciton also does a few other things:\n\nNormalizes all the measurements by the bin_size i.e. the number of measurements that were accumlated into the measurement container.\nTake position space correlation function measurements and fourier transform them to momentum space.\nIntegrate relevant time-displaced correlation function measurements over imaginary time to get the corresponding zero matsubara frequency correlation function.\nReset all the measurements in measurement_container to zero after the measurements are written to file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Process-Measurements","page":"API","title":"Process Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"process_measurements\nprocess_correlation_measurement\ncomposite_correlation_stats\nglobal_measurement_bins_to_csv\nlocal_measurement_bins_to_csv\ncorrelation_bins_to_csv","category":"page"},{"location":"api/#SmoQyDQMC.process_measurements","page":"API","title":"SmoQyDQMC.process_measurements","text":"process_measurements(folder::String, N_bin::Int; time_displaced::Bool = false)\n\nProcess the measurements recorded in the simulation directory folder, where N_bin is the number of bins the data is grouped into for calculating error bars. Note that this method will over-write an existing correlation stats file if there already is one. The boolean flag time_displaced determines whether or not to calculate error bars for time-displaced correlation measurements, as this can take a non-negligible amount of time for large system, especially when many simulations were run in parallel.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.process_correlation_measurement","page":"API","title":"SmoQyDQMC.process_correlation_measurement","text":"process_correlation_measurement(; folder::String, correlation::String, type::String, space::String, N_bin::Int)\n\nProcess a single correlation measurement using N_bin number of bins to calculate the error bars. The argument type must be set to either \"equal-time\", \"time-displaced\" or \"integrated\", and the argument space must be set to either \"position\" or \"momentum\".\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.composite_correlation_stats","page":"API","title":"SmoQyDQMC.composite_correlation_stats","text":"composite_correlation_stats(;\n    folder::String,\n    correlation::String,\n    space::String,\n    type::String,\n    ids::Vector{NTuple{2,Int}},\n    locs::Vector{NTuple{D,Int}},\n    num_bins::Int,\n    l::Int = 0,\n    f::Function = identity\n) where {D}\n\nCalaculate the mean and error for a composite correlation measurement based on the function Note that D indicates the spatial dimension of the system.\n\nKeyword Arguments\n\nfolder::String: The directory all simulations results were written to.\ncorrelation::String: Name of the correlation in question that will be processed.\nspace::String: The space of the measurement, either \"position\" or \"momentum\".\ntype::String: The type of correlation measurement \"eqaul-time\", \"time-displaced\" or \"integrated\".\nids::Vector{NTuple{2,Int}}: A vector or ID pairs to read.\nlocs::Vector{NTuple{D,Int}}: A vector specifying either a displacement if type = \"position\", or k-point if type = \"momentum\".\nnum_bins::Int: The number of bins that should be used to calculate the mean and standard deviation with using the jackknife method.\nl::Int = 0: Specifies the imaginary time slice, only used if type = \"time-displaced\".\nf::Function = identity: The function used to construct the composite correlation function based on each correlation specified by ids and locs.\n\nComments\n\nFor the locs argument, for a given location, i.e. loc = locs[1], the loc[d] value corresponds to either a displacement in the direction of the d lattice vector, or corresponds to a k-point index relative to the d reciprocal lattice vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.global_measurement_bins_to_csv","page":"API","title":"SmoQyDQMC.global_measurement_bins_to_csv","text":"global_measurement_bins_to_csv(folder::String)\n\nWrite the binned global measurements to file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.local_measurement_bins_to_csv","page":"API","title":"SmoQyDQMC.local_measurement_bins_to_csv","text":"local_measurement_bins_to_csv(folder::String, measurement::String)\n\nWrite the binned values for the local measurement measurement to a CSV file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.correlation_bins_to_csv","page":"API","title":"SmoQyDQMC.correlation_bins_to_csv","text":"correlation_bins_to_csv(; folder::String, correlation::String, type::String, space::String, write_index_key::Bool = true)\n\nWrite binned correlation data for correlation to a CSV file. The field type must be set equal to \"equal-time\", \"time-displaced\" or \"integrated\", and the field space but bet set to either \"position\" or \"momentum\".\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this section we link to and discuss some example scripts for running DQMC simulations of various systems.","category":"page"},{"location":"examples/#Optical-SSH-Chain","page":"Examples","title":"Optical SSH Chain","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the script examples/ossh_chain.jl we set up a simulation of an optical SSH model on a one-dimensional chain, where the Hamiltonian is given by","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\nhatH_textrmo-ssh =  -sum_isigmat-alpha(hatX_i+1-hatX_i)(hatc_i+1sigma^daggerhatc_isigma+textrmhc)-musum_isigmahatn_isigma\n                            +sum_ibiggfrac12MhatP_i^2+frac12MOmega^2hatX_i^2bigg\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The simulation is run with the command","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"> julia -O3 ossh_chain.jl","category":"page"},{"location":"examples/#Bond-SSH-Chain","page":"Examples","title":"Bond SSH Chain","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the script examples/bssh_chain.jl we set up a simulation of an bond SSH model on a one-dimensional chain, where the Hamiltonian is given by","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\nhatH_textrmb-ssh =  -sum_isigmat-alpha(hatX_langle i+1irangle)(hatc_i+1sigma^daggerhatc_isigma+textrmhc)-musum_isigmahatn_isigma\n                            +sum_ibiggfrac12MhatP_langle i+1irangle^2+frac12MOmega^2hatX_langle i+1irangle^2bigg\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"such that the phonon modes effectively live on the bonds between orbitals rather than on the orbitals themselves. In practice in the code this is achieved by defining two phonon modes per orbital and setting the mass of one of the two phonon modes to infinity. In this way, the phonon modes with finite mass effectively lives on the bond. The simulation is run with the command","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"> julia -O3 bssh_chain.jl","category":"page"},{"location":"examples/#Bond-SSH-Chain-with-MPI","page":"Examples","title":"Bond SSH Chain with MPI","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the script examples/bssh_chain_mpi.jl run simulations identical to the previous section, except we use MPI.jl to run identical simulations in parallel. The simulation may be run with either the command","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"> mpiexec -n n julia -O3 bssh_chain_mpi.jl","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"or","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"> mpiexecjl -n n julia -O3 bssh_chain_mpi.jl","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"depending on how your system is configured, where n specifies the number of simulations/processes that are run in parallel using. For more information on how to set-up and use MPI on your system refer to the (very good) documentation for MPI.jl.","category":"page"},{"location":"examples/#Kagome-Holstein-Model-with-Density-Tuning","page":"Examples","title":"Kagome Holstein Model with Density Tuning","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the script examples/holstein_kagome.jl we simulate the kagome lattice Holstein model","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign\nhatH_textrmkag-hol =  -tsum_langle ijranglesigma(hatc_isigma^daggerhatc_jsigma+textrmhc)-musum_isigmahatn_isigma\n                              +sum_ibiggfrac12MhatP_i^2+frac12MOmega^2hatX_i^2bigg+alphasum_isigmahatX_i(hatn_isigma-tfrac12)\nendalign","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where the sum over langle ij rangle runs over all pairs of nearest-neighbor orbitals in the kagome lattice. Additionally, in the simulation the chemical potential mu is tuned to achieve a target density of langle n rangle = 23 The simulation is run with the command","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"> julia -O3 holstein_kagome.jl","category":"page"},{"location":"examples/#Square-Lattice-Hubbard-Model","page":"Examples","title":"Square Lattice Hubbard Model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the script examples/hubbard_square.jl we simulate the half-filled, particle-hole symmetric repulsive Hubbard model on a square lattice, given by","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginalign*\nhatH_textrmsq-hub =  -tsum_langle ijranglesigma(hatc_isigma^daggerhatc_jsigma+textrmhc)-musum_isigmahatn_isigma\n                             +Usum_i(hatn_iuparrow-tfrac12)(hatn_idownarrow-tfrac12)\nendalign*","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where mu = 0. The simulation is run with the command","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"> julia -O3 hubbard_sqaure.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SmoQyDQMC","category":"page"},{"location":"#SmoQyDQMC","page":"Home","title":"SmoQyDQMC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SmoQyDQMC.jl. This package implements the determinant quantum Monte Carlo (DQMC) method for Hubbard, and electron-phonon interactions, including both Holstein and Su-Schrieffer-Heeger (SSH) style electron-phonon coupling.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This code is currently in the experimental phase of development.","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The development of this code was supported by the U.S. Department of Energy, Office of Science, Basic Energy Sciences, under Award Number DE-SC0022311.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NOTE: This package is in the experimental phase of development and is not yet published to the Julia General registry. The instruction for installation below will be updated once that package is registered.","category":"page"},{"location":"#Method-1","page":"Home","title":"Method 1","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First clone the SmoQyDQMC.jl repository onto your machine:","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone https://github.com/SmoQySuite/SmoQyDQMC.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then navigate into the SmoQyDQMC.jl repository directory and open a Julia REPL environment and run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] dev .","category":"page"},{"location":"#Method-2","page":"Home","title":"Method 2","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Open a Julia REPL environment and run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] dev https://github.com/SmoQySuite/SmoQyDQMC.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"This command clones the SmoQyDQMC.jl repository to the hidden direcotry .julia/dev that exists in the same directory where Julia is installed.","category":"page"},{"location":"#Supported-Hamiltonians","page":"Home","title":"Supported Hamiltonians","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SmoQyDQMC.jl currently support Hamitonians of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH = hatH_0+hatH_textrmhub+hatH_etextrm-ph","category":"page"},{"location":"","page":"Home","title":"Home","text":"for arbitrary lattice geometries. The term hatH_0 corresponds to the non-interacting tight-binding model given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH_0 = sum_langle(mathbfinu)(mathbfjkappa)ranglesigmabig(-t_(mathbfinu)(mathbfjkappa)hatc_sigmamathbfinu^daggerhatc_sigmamathbfjkappa+textrmhcbig)+sum_mathbfinusigmabig(epsilon_mathbfinu-mubig)hatn_sigmamathbfinu","category":"page"},{"location":"","page":"Home","title":"Home","text":"where sigma is the electron spin, mathbfi and mathbfj specify the unit cell, and kappa and nu specify the orbital species in the unit cell.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The hatH_textrmhub term corresponds to the Hubbard interaction, which may be represented in either the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH_textrmhub = sum_mathbfinuU_mathbfinuhatn_uparrowmathbfinuhatn_downarrowmathbfinu","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH_textrmhub = sum_mathbfinuU_mathbfinubig(hatn_uparrowmathbfinu-tfrac12big)big(hatn_downarrowmathbfinu-tfrac12big)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The code supports both repulsive (U0) and attractive (U0) Hubbard interaction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The term","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH_etextrm-ph = hatH_textrmph+hatH_textrmhol+hatH_textrmssh+hatH_textrmdisp","category":"page"},{"location":"","page":"Home","title":"Home","text":"represents the electron-phonon interaction component of the Hamiltonian. Here hatH_textrmph defines a population of non-interacting local phonon modes given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH_textrmph = sum_mathbfinubigg(frac12M_mathbfinuhatP_mathbfinu^2+frac12M_mathbfinuOmega_mathbfinu^2hatX_mathbfinu^2+frac124M_mathbfinuOmega_4mathbfinu^2hatX_mathbfinu^4bigg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where the index nu runs over all phonon modes in each unit-cell. Note that any number independent of phonon modes can be placed on each orbital in the unit cell.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next, the hatH_textrmhol term describes the Holstein e-ph couplings in the model, that may be either local or long-ranged, given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH_textrmhol = sum_mathbfisigmaleftsum_n=1^4alpha_nmathbfi(kappanumathbfr)hatX_mathbfikappa^nrightbig(hatn_sigmamathbfi+mathbfrnu-tfrac12big)","category":"page"},{"location":"","page":"Home","title":"Home","text":"with non-linear coupling out to fourth order supported. Similarly, the hatH_textrmssh term describes the Su–Schrieffer–Heeger (SSH) e-ph couplings in the model, and is given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH_textrmssh = sum_mathbfisigmaleftsum_n=1^4alpha_nmathbfi(kappanumathbfr)Big(hatX_mathbfi+mathbfrnu-hatX_mathbfkkappaBig)^nrightbig(hatc_sigmamathbfi+mathbfrnu^daggerhatc_sigmamathbfikappa+textrmhcbig)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where again non-linear coupling out to fourth order are supported. Lastly, the hatH_textrmdisp term describes dispersive coupling between phonon modes, and is given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH_textrmdisp = sum_mathbfibigg(fracM_mathbfikappaM_mathbfi+mathbfrnuM_mathbfikappa+M_mathbfi+mathbfrnubigg)leftOmega_mathbfi(kappanumathbfr)^2Big(hatX_mathbfi+mathbfrnu-hatX_mathbfkkappaBig)^2+frac112Omega_4mathbfi(kappanumathbfr)^2Big(hatX_mathbfi+mathbfrnu-hatX_mathbfkkappaBig)^4right","category":"page"},{"location":"#Notable-Package-Dependencies","page":"Home","title":"Notable Package Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This section reviews some notable package dependencies.","category":"page"},{"location":"#Re-exported-Packages","page":"Home","title":"Re-exported Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SmoQyDQMC.jl re-exports certain packages using the Reexport.jl package in order to simplify the installation process.","category":"page"},{"location":"","page":"Home","title":"Home","text":"LatticeUtilties.jl: Used to represent arbitrary lattice geometries.\nJDQMCFramework.jl: Implements and exports the basic framework for running a DQMC simulation.\nJDQMCMeasurements.jl: Implements various global, local and correlation measurements for a DQMC simulation.\nMuTuner.jl: Impelments and exports an algorithm for tuning the chemical potential to achieve a target density in grand canonical Monte Carlo simulations.","category":"page"},{"location":"#External-Dependencies","page":"Home","title":"External Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StableLinearAlgebra.jl: Implements optimized numerical stabilizaiton methods required by DQMC simulations.\nCheckerboard.jl: Implements and exports the checkerboard method for approximating exponentiated hopping matrices by a sparse matrix.\nJLD2.jl: Package used to write data to binary files in an HDF5 compatible format. It is also recommended this package be used at the scripting level to implement checkpointing in a simulation.\nBinningAnalysis.jl: Export method impelementing the jackknife algorithm for calculating error bars.","category":"page"},{"location":"#Contact-Us","page":"Home","title":"Contact Us","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For question and comments regarding this package, please email either Dr. Benjamin Cohen-Stead at bcohenst@utk.edu or Professor Steven Johnston at sjohn145@utk.edu.","category":"page"}]
}
