<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SmoQyDQMC.jl</title><meta name="title" content="API · SmoQyDQMC.jl"/><meta property="og:title" content="API · SmoQyDQMC.jl"/><meta property="twitter:title" content="API · SmoQyDQMC.jl"/><meta name="description" content="Documentation for SmoQyDQMC.jl."/><meta property="og:description" content="Documentation for SmoQyDQMC.jl."/><meta property="twitter:description" content="Documentation for SmoQyDQMC.jl."/><meta property="og:url" content="https://smoqysuite.github.io/SmoQyDQMC.jl/stable/api/"/><meta property="twitter:url" content="https://smoqysuite.github.io/SmoQyDQMC.jl/stable/api/"/><link rel="canonical" href="https://smoqysuite.github.io/SmoQyDQMC.jl/stable/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SmoQyDQMC.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../hamiltonian/">Supported Hamiltonians</a></li><li><a class="tocitem" href="../simulation_output/">Simulation Output Overview</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Simulation-Information-Type-and-Methods"><span>Simulation Information Type and Methods</span></a></li><li><a class="tocitem" href="#Model-Geometry-Type-and-Methods"><span>Model Geometry Type and Methods</span></a></li><li><a class="tocitem" href="#Fermion-Path-Integral-Type-and-Methods"><span>Fermion Path Integral Type and Methods</span></a></li><li><a class="tocitem" href="#Update-Numerical-Stabilization-Frequency"><span>Update Numerical Stabilization Frequency</span></a></li><li><a class="tocitem" href="#Tight-Binding-Model"><span>Tight-Binding Model</span></a></li><li><a class="tocitem" href="#Hubbard-Model"><span>Hubbard Model</span></a></li><li><a class="tocitem" href="#Extended-Hubbard-Model"><span>Extended Hubbard Model</span></a></li><li><a class="tocitem" href="#Hubbard-Stratonovich-Transformations"><span>Hubbard-Stratonovich Transformations</span></a></li><li><a class="tocitem" href="#Electron-Phonon-Model"><span>Electron-Phonon Model</span></a></li><li><a class="tocitem" href="#Density-and-Chemical-Potential-Tuning"><span>Density and Chemical Potential Tuning</span></a></li><li><a class="tocitem" href="#Measurement-Methods"><span>Measurement Methods</span></a></li><li><a class="tocitem" href="#Checkpointing-Utilities"><span>Checkpointing Utilities</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/hubbard_square/">1a) Square Hubbard Model</a></li><li><a class="tocitem" href="../tutorials/hubbard_square_mpi/">1b) Square Hubbard Model with MPI Parallelization</a></li><li><a class="tocitem" href="../tutorials/hubbard_square_checkpoint/">1c) Square Hubbard Model with Checkpointing</a></li><li><a class="tocitem" href="../tutorials/hubbard_square_density_tuning/">1d) Square Hubbard Model with Density Tuning</a></li><li><a class="tocitem" href="../tutorials/holstein_honeycomb/">2a) Honeycomb Holstein Model</a></li><li><a class="tocitem" href="../tutorials/holstein_honeycomb_mpi/">2b) Honeycomb Holstein Model with MPI Parallelization</a></li><li><a class="tocitem" href="../tutorials/holstein_honeycomb_checkpoint/">2c) Honeycomb Holstein Model with Checkpointing</a></li><li><a class="tocitem" href="../tutorials/holstein_honeycomb_density_tuning/">2d) Honeycomb Holstein Model with Density Tuning</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/ossh_chain/">Optical Su-Schrieffer-Heeger Chain</a></li><li><a class="tocitem" href="../examples/ossh_square/">Square Optical Su-Schrieffer-Heeger Model</a></li><li><a class="tocitem" href="../examples/bssh_chain/">Bond Su-Schrieffer-Heeger Chain</a></li><li><a class="tocitem" href="../examples/bssh_square/">Bond Su-Schrieffer-Heeger Square</a></li><li><a class="tocitem" href="../examples/hubbard_ossh_square/">Square Optical Su-Schrieffer-Heeger-Hubbard Model</a></li><li><a class="tocitem" href="../examples/hubbard_holstein_square/">Square Holstein-Hubbard Model</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/main/docs/src/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Simulation-Information-Type-and-Methods"><a class="docs-heading-anchor" href="#Simulation-Information-Type-and-Methods">Simulation Information Type and Methods</a><a id="Simulation-Information-Type-and-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-Information-Type-and-Methods" title="Permalink"></a></h2><article><details class="docstring"><summary id="SmoQyDQMC.SimulationInfo"><a class="docstring-binding" href="#SmoQyDQMC.SimulationInfo"><code>SmoQyDQMC.SimulationInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SimulationInfo</code></pre><p>Contains identification information about simulation, including the location data is written to, the simulation ID, and MPI process ID, and whether this simulation started a new simulation or resumed a previous simulation.</p><p><strong>Fields</strong></p><ul><li><code>filepath::String</code>: File path to where data folder lives.</li><li><code>datafolder_prefix</code>: Prefix for the data folder name.</li><li><code>datafolder_name::String</code>: The data folder name, given by <code>$(datafolder_prefix)_$(sID)</code>.</li><li><code>datafolder::String</code>: The data folder, including filepath, given by <code>joinpath(filepath, datafolder_name)</code>.</li><li><code>pID::Int</code>: MPI process ID, defaults to 0 if MPI not being used.</li><li><code>sID::Int</code>: Simulation ID.</li><li><code>write_bins_concurrent::Bool</code>: Whether binned data will be written to HDF5 during the simulation or held in memory until the end of the simulation.</li><li><code>bin_files::Vector{Vector{UInt8}}</code>: Represents the HDF5 files containing the binned data.</li><li><code>resuming::Bool</code>: Whether current simulation is resuming a previous simulation (<code>true</code>) or starting a new one (<code>false</code>).</li><li><code>smoqy_version::VersionNumber</code>: Version of <a href="https://github.com/SmoQySuite/SmoQyDQMC.jl">SmoQyDQMC.jl</a> used in simulation.</li></ul><p><strong>Notes</strong></p><p>If <code>write_bins_concurrent = true</code>, then the elements of <code>bin_files</code> correspond to the HDF5 bin filenames, assuming the vector elements are converted to strings. If <code>write_bins_concurrent = false</code>, then the elements of the <code>bin_files</code> correspond to a byte vector representation of a HDF5 file containing the binned data. For small simulations that run very fast setting <code>write_bins_concurrent = false</code> can make sense, as it significantly reduces the frequency of file IO during the simulation. This can cause issues on some clusters with respect to overtaxing the cluster network if data is being written to file too frequently during the simulation. However, for most larger simulations it is advisable to set <code>write_bins_concurrent = true</code> as this significantly reduces the memory footprint of the simulation, particularly when making time-displaced correlation measurements. Also, setting <code>write_bins_concurrent = false</code> dramatically increases the size of the checkpoint files if checkpointing is occurring during the simulation, as the checkpoint files now need to contain all the binned data collected during the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/SimulationInfo.jl#L1-L30">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.SimulationInfo-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.SimulationInfo-Tuple{}"><code>SmoQyDQMC.SimulationInfo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SimulationInfo(;
    # KEYWORD ARGUMENTS
    datafolder_prefix::String,
    filepath::String = &quot;.&quot;,
    write_bins_concurrent::Bool = true,
    sID::Int=0,
    pID::Int=0
)</code></pre><p>Initialize and return in instance of the type <a href="#SmoQyDQMC.SimulationInfo"><code>SimulationInfo</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/SimulationInfo.jl#L64-L75">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.initialize_datafolder"><a class="docstring-binding" href="#SmoQyDQMC.initialize_datafolder"><code>SmoQyDQMC.initialize_datafolder</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize_datafolder(comm::MPI.Comm, sim_info::SimulationInfo)

initialize_datafolder(sim_info::SimulationInfo)</code></pre><p>Initialize <code>sim_info.datafolder</code> directory if it does not already exist. If <code>comm::MPI.Comm</code> is passed as the first argument, this this function will synchronize all the MPI processes, ensuring that none proceed beyond this function call until the data folder that results will be written to is successfully initialized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/SimulationInfo.jl#L161-L170">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.model_summary"><a class="docstring-binding" href="#SmoQyDQMC.model_summary"><code>SmoQyDQMC.model_summary</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">model_summary(;
    simulation_info::SimulationInfo,
    β::T, Δτ::T, model_geometry::ModelGeometry,
    tight_binding_model::Union{TightBindingModel,Nothing} = nothing,
    tight_binding_model_up::Union{TightBindingModel,Nothing} = nothing,
    tight_binding_model_dn::Union{TightBindingModel,Nothing} = nothing,
    interactions::Union{Tuple,Nothing} = nothing
) where {T&lt;:AbstractFloat}</code></pre><p>Write model to summary to file. Note that either <code>tight_binding_model</code> or <code>tight_binding_model_up</code> and <code>tight_binding_model_dn</code> need to be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/model_summary.jl#L1-L13">source</a></section></details></article><h2 id="Model-Geometry-Type-and-Methods"><a class="docs-heading-anchor" href="#Model-Geometry-Type-and-Methods">Model Geometry Type and Methods</a><a id="Model-Geometry-Type-and-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Geometry-Type-and-Methods" title="Permalink"></a></h2><article><details class="docstring"><summary id="SmoQyDQMC.ModelGeometry"><a class="docstring-binding" href="#SmoQyDQMC.ModelGeometry"><code>SmoQyDQMC.ModelGeometry</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ModelGeometry{D, T&lt;:AbstractFloat, N}</code></pre><p>Contains all the information defining the lattice geometry for the model in <code>D</code> spatial dimensions.</p><p><strong>Comment</strong></p><p>The bond ID associated with a <code>bond::Bond{D}</code> corresponds to the index associated with it into the <code>bonds</code> vector field.</p><p><strong>Fields</strong></p><ul><li><code>unit_cell::UnitCell{D,T,N}</code>: Defines unit cell.</li><li><code>lattice::Lattice{D}</code>: Defines finite lattice extent.</li><li><code>bonds::Vector{Bond{D}}</code>: All available bond definitions in simulation, with vector indices giving the bond ID.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ModelGeometry.jl#L1-L15">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.ModelGeometry-Union{Tuple{D}, Tuple{UnitCell{D}, Lattice{D}}} where D"><a class="docstring-binding" href="#SmoQyDQMC.ModelGeometry-Union{Tuple{D}, Tuple{UnitCell{D}, Lattice{D}}} where D"><code>SmoQyDQMC.ModelGeometry</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ModelGeometry(unit_cell::UnitCell, lattice::Lattice)</code></pre><p>Initialize and return a <a href="#SmoQyDQMC.ModelGeometry"><code>ModelGeometry</code></a> instance. Defines a &quot;trivial&quot; bond definition for each orbital in the unit cell that connects an orbital to itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ModelGeometry.jl#L23-L28">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.add_bond!"><a class="docstring-binding" href="#SmoQyDQMC.add_bond!"><code>SmoQyDQMC.add_bond!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>add<em>bond!(model</em>geometry::ModelGeometry{D,T}, bond::Bond{D}) where {D, T}   </p><p>Add <code>bond</code> definition to <code>model_geometry</code>, returning the bond ID i.e. the index to <code>bond</code> in the vector <code>model_geometry.bonds</code>. This method first checks that <code>bond</code> is not already defined. If it is this method simply returns the corresponding bond ID. If <code>bond</code> is not already defined, then it is appended to the vector <code>model_geometry.bonds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ModelGeometry.jl#L87-L95">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.get_bond_id"><a class="docstring-binding" href="#SmoQyDQMC.get_bond_id"><code>SmoQyDQMC.get_bond_id</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_bond_id(model_geometry::ModelGeometry{D,T}, bond::Bond{D}) where {D, T}</code></pre><p>Return the bond ID associated with the bond defintion <code>bond</code>, returning <code>bond_id=0</code> if the it is not a recorded bond.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ModelGeometry.jl#L115-L120">source</a></section></details></article><h2 id="Fermion-Path-Integral-Type-and-Methods"><a class="docs-heading-anchor" href="#Fermion-Path-Integral-Type-and-Methods">Fermion Path Integral Type and Methods</a><a id="Fermion-Path-Integral-Type-and-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Fermion-Path-Integral-Type-and-Methods" title="Permalink"></a></h2><article><details class="docstring"><summary id="SmoQyDQMC.FermionPathIntegral"><a class="docstring-binding" href="#SmoQyDQMC.FermionPathIntegral"><code>SmoQyDQMC.FermionPathIntegral</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FermionPathIntegral{H&lt;:Number, T&lt;:Number, U&lt;:Number, R&lt;:AbstractFloat}</code></pre><p>A type (mutable struct) to represent a fermion path integral. In particular, this type contains the information required to reconstruct the diagonal on-site energy matrices <span>$V_l$</span> and hopping matrices <span>$K_l$</span> for each imaginary time slice <span>$l \in [1, L_\tau],$</span> where <span>$\tau = \Delta\tau \cdot l$</span> and <span>$\beta = \Delta\tau \cdot L_\tau.$</span></p><p><strong>Types</strong></p><ul><li><code>H&lt;:Number</code>: <span>$H_l = (K_l + V_l)$</span> Hamiltonian matrix element type.</li><li><code>T&lt;:Number</code>: <span>$K_l$</span> kinetic energy matrix element type.</li><li><code>U&lt;:Number</code>: <span>$V_l$</span> potential energy matrix element type.</li><li><code>R&lt;:AbstractFloat</code>: Real number type.</li></ul><p><strong>Fields</strong></p><ul><li><code>β::R</code>: Inverse temperature.</li><li><code>Δτ::R</code>: Discretization in imaginary time.</li><li><code>Lτ::Int</code>: Length of the imaginary time axis.</li><li><code>N::Int</code>: Number of orbitals in the lattice.</li><li><code>neighbor_table::Matrix{Int}</code>: Neighbor table for each pair of orbitals in the lattice connected by a hopping.</li><li><code>t::Matrix{T}</code>: Hopping amplitudes for imaginary-time slice <span>$l$</span> are stored in <code>t[:,l]</code>.</li><li><code>V::Matrix{U}</code>: The diagonal on-site energy matrices <span>$V_l$</span> for imaginary-time slice <span>$l$</span> are stored in <code>V[:,l]</code>.</li><li><code>K::Matrix{T}</code>: Used to construct hopping matrix to calculate exponentiated hopping matrix if checkerboard approximation is not being used.</li><li><code>Sb::H</code>: Keeps track of total bosonic action associated with fermionic path integral.</li><li><code>eigen_ws::HermitianEigenWs{T,Matrix{T},R}</code>: For calculating eigenvalues and eigenvectors of <code>K</code> while avoiding dynamic memory allocations.</li><li><code>u::Matrix{H}</code>: Temporary matrix to avoid dynamic allocation when performing local updates.</li><li><code>v::Matrix{H}</code>: Temporary matrix to avoid dynamic allocation when performing local updates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/FermionPathIntegral.jl#L1-L29">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.FermionPathIntegral-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.FermionPathIntegral-Tuple{}"><code>SmoQyDQMC.FermionPathIntegral</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FermionPathIntegral(;
    # KEYWORD ARGUMENTS
    tight_binding_parameters::TightBindingParameters{T,R},
    β::R, Δτ::R,
    forced_complex_kinetic::Bool = false,
    forced_complex_potential::Bool = false
) where {T&lt;:Number, R&lt;:AbstractFloat}</code></pre><p>Initialize an instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> an instance of <a href="#SmoQyDQMC.TightBindingParameters"><code>TightBindingParameters</code></a>.</p><p>If <code>forced_complex_kinetic = true</code>, then the off-diagonal kinetic energy matrices <span>$K_l$</span> are assumed to be complex, otherwise the matrix element type is inferred.</p><p>If <code>forced_complex_potential = true</code>, then the diagonal potential energy matrices <span>$V_l$</span> are assumed to be complex, otherwise the matrix element type is inferred.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/FermionPathIntegral.jl#L58-L74">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.initialize_propagators"><a class="docstring-binding" href="#SmoQyDQMC.initialize_propagators"><code>SmoQyDQMC.initialize_propagators</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize_propagators(
    # ARGUMENTS
    fermion_path_integral::FermionPathIntegral;
    # KEYWORD ARGUMENTS
    symmetric::Bool,
    checkerboard::Bool
)</code></pre><p>Initialize a propagator for each imaginary time slice, returning a vector of type <code>Vector{&lt;:AbstractPropagators{T,E}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/FermionPathIntegral.jl#L141-L151">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.calculate_propagators!"><a class="docstring-binding" href="#SmoQyDQMC.calculate_propagators!"><code>SmoQyDQMC.calculate_propagators!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">calculate_propagators!(
    # ARGUMENTS
    B::Vector{P},
    fpi::FermionPathIntegral;
    # KEYWORD ARGUMENTS
    calculate_exp_V::Bool,
    calculate_exp_K::Bool
) where {P&lt;:AbstractPropagator}</code></pre><p>Calculate the propagator matrices <span>$B_l$</span>, given by <code>B[l]</code>, for all imaginary time slice <span>$\tau = \Delta\tau \cdot l.$</span> If <code>calculate_exp_V = true</code>, then calculate the diagonal exponentiated on-site energy matrices. If <code>calculate_exp_K = true</code>, then calculate the exponentiated hopping matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/FermionPathIntegral.jl#L302-L315">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.calculate_propagator!"><a class="docstring-binding" href="#SmoQyDQMC.calculate_propagator!"><code>SmoQyDQMC.calculate_propagator!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">calculate_propagator!(
    # ARGUMENTS
    B::P,
    fpi::FermionPathIntegral{H,T,U},
    l::Int;
    # KEYWORD ARGUMENTS
    calculate_exp_V::Bool,
    calculate_exp_K::Bool
) where {H&lt;:Number, T&lt;:Number, U&lt;:Number, P&lt;:AbstractPropagator{T,U}}</code></pre><p>Calculate the propagator matrix <span>$B_l$</span> for imaginary time slice <span>$\tau = \Delta\tau \cdot l.$</span> If <code>calculate_exp_V = true</code>, then calculate the diagonal exponentiated on-site energy matrix. If <code>calculate_exp_K = true</code>, then calculate the exponentiated hopping matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/FermionPathIntegral.jl#L335-L349">source</a></section></details></article><h2 id="Update-Numerical-Stabilization-Frequency"><a class="docs-heading-anchor" href="#Update-Numerical-Stabilization-Frequency">Update Numerical Stabilization Frequency</a><a id="Update-Numerical-Stabilization-Frequency-1"></a><a class="docs-heading-anchor-permalink" href="#Update-Numerical-Stabilization-Frequency" title="Permalink"></a></h2><article><details class="docstring"><summary id="SmoQyDQMC.update_stabilization_frequency!"><a class="docstring-binding" href="#SmoQyDQMC.update_stabilization_frequency!"><code>SmoQyDQMC.update_stabilization_frequency!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">update_stabilization_frequency!(
    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,
    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H;
    fermion_greens_calculator_up::FermionGreensCalculator{H,R},
    fermion_greens_calculator_dn::FermionGreensCalculator{H,R},
    Bup::Vector{P}, Bdn::Vector{P}, δG::R, δθ::R, δG_max::R
) where {H&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}</code></pre><p>If the corrected error in the Green&#39;s function matrix is too large, <code>δG &gt; δG_max</code>, then increase the frequency of numerical stabilization by decrementing <code>n_stab</code> such that it is updated to <code>n_stab = max(n_stab - 1, 1)</code>, and update the equal-time Green&#39;s function matrices and all related variables and types. If the frequency of stabilization is udpated, then <code>δG</code> and <code>δθ</code> are reset to zero. This method returns a tuple of the following variables:</p><pre><code class="language-julia hljs">(logdetGup, sgndetGdn, logdetGup, sgndetGdn, δG, δθ),</code></pre><p>where <code>updated = true</code> if <code>n_stab</code> was decremented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/update_stabilization_frequency.jl#L1-L19">source</a></section><section><div><pre><code class="language-julia hljs">update_stabilization_frequency!(
    G::Matrix{H}, logdetG::R, sgndetG::H;
    fermion_greens_calculator::FermionGreensCalculator{H,R},
    B::Vector{P}, δG::R, δθ::R, δG_max::R
) where {H&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}</code></pre><p>If the corrected error in the Green&#39;s function matrix is too large, <code>δG &gt; δG_max</code>, then increase the frequency of numerical stabilization by decrementing <code>n_stab</code> such that it is updated to <code>n_stab = max(n_stab - 1, 1)</code>, and update the equal-time Green&#39;s function matrices and all related variables and types. If the frequency of stabilization is udpated, then <code>δG</code> and <code>δθ</code> are reset to zero. This method returns a tuple of the following variables:</p><pre><code class="language-julia hljs">(updated, logdetG, sgndetG, δG, δθ),</code></pre><p>where <code>updated = true</code> if <code>n_stab</code> was decremented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/update_stabilization_frequency.jl#L70-L86">source</a></section></details></article><h2 id="Tight-Binding-Model"><a class="docs-heading-anchor" href="#Tight-Binding-Model">Tight-Binding Model</a><a id="Tight-Binding-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Tight-Binding-Model" title="Permalink"></a></h2><article><details class="docstring"><summary id="SmoQyDQMC.TightBindingModel"><a class="docstring-binding" href="#SmoQyDQMC.TightBindingModel"><code>SmoQyDQMC.TightBindingModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TightBindingModel{T&lt;:Number, E&lt;:AbstractFloat, D}</code></pre><p>Defines a tight binding model in <code>D</code> dimensions. Note that <code>spin = 1 (spin = 2)</code> corresponds to spin-up (spin-down), and <code>spin = 0</code> corresponds to both spin-up and spin-down.</p><p><strong>Types</strong></p><ul><li><code>T&lt;:Number</code>: The type of the hopping energy, which can be a real or complex number.</li><li><code>E&lt;:AbstractFloat</code>: The type of the chemical potential and on-site energy, which must be real.</li><li><code>D</code>: The number of spatial dimensions the model lives in.</li></ul><p><strong>Fields</strong></p><ul><li><code>μ::E</code>: Chemical potential.</li><li><code>ϵ_mean::Vector{E}</code>: Mean on-site energy for each orbital in the unit cell. </li><li><code>ϵ_std::Vector{E}</code>: Standard deviation of on-site energy for each orbital in the unit cell.</li><li><code>t_bond_ids::Vector{Int}</code>: The bond ID for each bond/hopping definition.</li><li><code>t_bonds::Vector{Bond{D}}</code>: Bond definition for each type of hopping in the tight binding model.</li><li><code>t_mean::Vector{T}</code>: Mean hopping energy for each type of hopping.</li><li><code>t_std::Vector{E}</code>: Standard deviation of hopping energy for each type of hopping.</li><li><code>η::Vector{E}</code>: Relative twist angle for each lattice vector direction <span>$d \in [1, D]$</span> such that <span>$\eta_d \in [0, 1).$</span></li><li><code>expniϕ::Vector{T}</code>: Twist angle phase <span>$\exp(i n_d \phi_d)$</span> for each hopping.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/TightBinding.jl#L1-L24">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.TightBindingModel-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.TightBindingModel-Tuple{}"><code>SmoQyDQMC.TightBindingModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TightBindingModel(;
    # KEYWORD ARGUMENTS
    model_geometry::ModelGeometry{D,E,N},
    μ::E,
    ϵ_mean::Vector{E},
    ϵ_std::Vector{E} = zeros(eltype(ϵ_mean), length(ϵ_mean)),
    t_bonds::Vector{Bond{D}} = Bond{ndims(model_geometry.unit_cell)}[],
    t_mean::Vector{T} = eltype(ϵ_mean)[],
    t_std::Vector{E} = zeros(eltype(ϵ_mean), length(t_mean)),
    η::Union{Vector{E},Nothing} = nothing
) where {T&lt;:Number, E&lt;:AbstractFloat, D, N}</code></pre><p>Initialize and return an instance of <a href="#SmoQyDQMC.TightBindingModel"><code>TightBindingModel</code></a>, also adding/recording the bond defintions <code>t_bonds</code> to the <a href="#SmoQyDQMC.ModelGeometry"><code>ModelGeometry</code></a> instance <code>model_geometry</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/TightBinding.jl#L55-L70">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.TightBindingParameters"><a class="docstring-binding" href="#SmoQyDQMC.TightBindingParameters"><code>SmoQyDQMC.TightBindingParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TightBindingParameters{T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>A mutable struct containing all the parameters needed to characterize a finite tight-binding Hamiltonian for a single spin species <span>$\sigma$</span> on a finite lattice with periodic boundary conditions of the form</p><p class="math-container">\[\hat{H}_{0,\sigma}=-\sum_{\langle i,j\rangle}(t_{ij} \hat{c}_{\sigma,i}^{\dagger}\hat{c}_{\sigma,j}+\textrm{h.c.})+\sum_{i}(\epsilon_{i}-\mu)\hat{n}_{\sigma,i},\]</p><p>where <span>$\hat{c}_{\sigma,i}^\dagger$</span> is the fermion creation operator for an electron with spin <span>$\sigma$</span> on orbital <span>$i,$</span> <span>$t_{i,j}$</span> are the hopping energies, <span>$\epsilon_i$</span> are the on-site energies for each orbital in the lattice, and <span>$\mu$</span> is the chemical potential.</p><p><strong>Fields</strong></p><ul><li><code>μ::E</code>: The chemical potential <span>$\mu.$</span></li><li><code>const ϵ::Vector{E}</code>: A vector containing the on-site energy <span>$\epsilon_i$</span> for each orbital in the lattice.</li><li><code>const t::Vector{T}</code>: The hopping energy <span>$t_{i,j}$</span> associated with each pair of neighboring orbitals connected by a bond in the lattice.</li><li><code>const neighbor_table::Matrix{Int}</code>: Neighbor table containing all pairs of orbitals in the lattices connected by a bond, with a non-zero hopping energy between them.</li><li><code>const bond_ids::Vector{Int}</code>: The bond ID definitions that define the types of hopping in the lattice.</li><li><code>const bond_slices::Vector{UnitRange{Int}}</code>: Slices of <code>neighbor_table</code> corresponding to given bond ID i.e. the neighbors <code>neighbor_table[:,bond_slices[i]]</code> corresponds the <code>bond_ids[i]</code> bond defintion.</li><li><code>const norbital::Int</code>: Number of orbitals per unit cell.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/TightBinding.jl#L208-L229">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.TightBindingParameters-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.TightBindingParameters-Tuple{}"><code>SmoQyDQMC.TightBindingParameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">TightBindingParameters(;
    tight_binding_model::TightBindingModel{T,E,D},
    model_geometry::ModelGeometry{D,E},
    rng::AbstractRNG
) where {T,E,D}</code></pre><p>Initialize and return an instance of <a href="#SmoQyDQMC.TightBindingParameters"><code>TightBindingParameters</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/TightBinding.jl#L255-L263">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.measure_onsite_energy"><a class="docstring-binding" href="#SmoQyDQMC.measure_onsite_energy"><code>SmoQyDQMC.measure_onsite_energy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure_onsite_energy(
    tight_binding_parameters::TightBindingParameters{T,E},
    G::Matrix{H}, orbital_id::Int
) where {H&lt;:Number, T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Measure and return the on-site energy <span>$\epsilon_\textrm{on-site} = (\epsilon - \mu)\langle \hat{n}_\sigma \rangle$</span> for the <code>orbital_id</code> in the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/tight_binding_measurements.jl#L1-L9">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.measure_hopping_energy"><a class="docstring-binding" href="#SmoQyDQMC.measure_hopping_energy"><code>SmoQyDQMC.measure_hopping_energy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure_hopping_energy(
    tight_binding_parameters::TightBindingParameters{T,E},
    fermion_path_integral::FermionPathIntegral{H},
    G::Matrix{H}, hopping_id::Int
) where {H&lt;:Number, T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Calculate the average hopping energy <span>$\epsilon_{\rm hopping} = -\langle t_{l,\langle i,j \rangle} \hat{c}^\dagger_{\sigma,i} \hat{c}_{\sigma,j} + {\rm h.c.} \rangle$</span> for the hopping defined by the the <code>hopping_id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/tight_binding_measurements.jl#L85-L95">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.measure_bare_hopping_energy"><a class="docstring-binding" href="#SmoQyDQMC.measure_bare_hopping_energy"><code>SmoQyDQMC.measure_bare_hopping_energy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure_bare_hopping_energy(
    tight_binding_parameters::TightBindingParameters{T,E},
    G::Matrix{H}, hopping_id::Int
) where {H&lt;:Number, T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Calculate the average bare hopping energy <span>$\epsilon_{\rm hopping} = -\langle t_{\langle i,j \rangle} \hat{c}^\dagger_{\sigma,i} \hat{c}_{\sigma,j} + {\rm h.c.} \rangle$</span> for the hopping defined by the <code>hopping_id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/tight_binding_measurements.jl#L40-L49">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.measure_hopping_amplitude"><a class="docstring-binding" href="#SmoQyDQMC.measure_hopping_amplitude"><code>SmoQyDQMC.measure_hopping_amplitude</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure_hopping_amplitude(
    tight_binding_parameters::TightBindingParameters{T,E},
    fermion_path_integral::FermionPathIntegral{H},
    hopping_id::Int
) where {H&lt;:Number, T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Calculate the average hopping amplitude for the hopping defined by the <code>hopping_id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/tight_binding_measurements.jl#L133-L141">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.measure_hopping_inversion"><a class="docstring-binding" href="#SmoQyDQMC.measure_hopping_inversion"><code>SmoQyDQMC.measure_hopping_inversion</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure_hopping_inversion(
    tight_binding_parameters::TightBindingParameters{T,E},
    fermion_path_integral::FermionPathIntegral{H},
    hopping_id::Int
) where {H&lt;:Number, T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Measure the fraction of time the sign of the instantaneous modulated hopping amplitude <span>$t_{l,(\mathbf{i},\nu),(\mathbf{j},\gamma)}$</span> is inverted relative to the bare hopping amplitude <span>$t_{(\mathbf{i},\nu),(\mathbf{j},\gamma)}$</span>, where <span>$l$</span> is the imaginary time-slice index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/tight_binding_measurements.jl#L163-L173">source</a></section></details></article><h2 id="Hubbard-Model"><a class="docs-heading-anchor" href="#Hubbard-Model">Hubbard Model</a><a id="Hubbard-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Hubbard-Model" title="Permalink"></a></h2><article><details class="docstring"><summary id="SmoQyDQMC.HubbardModel"><a class="docstring-binding" href="#SmoQyDQMC.HubbardModel"><code>SmoQyDQMC.HubbardModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HubbardModel{T&lt;:AbstractFloat}</code></pre><p>A type to represent a, in general, multi-orbital Hubbard model.</p><p>If the type field <code>ph_sym_form = false</code>, then the particle-hole asymmetric form for the Hubbard interaction</p><p class="math-container">\[\hat{H}_{U}=\sum_{\mathbf{i},\nu}U_{\nu,\mathbf{i}}\hat{n}_{\uparrow,\nu,\mathbf{i}}\hat{n}_{\downarrow,\nu,\mathbf{i}}\]</p><p>is used, where <span>$\mathbf{i}$</span> specifies the unit cell, and <span>$\nu$</span> denotes the orbital in the unit cell. In the case of a bipartite lattice with only nearest neighbor hopping, this convention results in an on-site energy corresponding to half-filling and particle-hole symmetry given by <span>$\epsilon_{\nu,\mathbf{i}} = -U_{\nu,\mathbf{i}}/2.$</span></p><p>If <code>ph_sym_form = true</code>, then the particle-hole symmetric form for the Hubbard interaction</p><p class="math-container">\[\hat{H}_{U}=\sum_{\mathbf{i},\nu}U_{\nu,\mathbf{i}}(\hat{n}_{\uparrow,\nu,\mathbf{i}}-\tfrac{1}{2})(\hat{n}_{\downarrow,\nu,\mathbf{i}}-\tfrac{1}{2})\]</p><p>is used instead. In this case, for a bipartite lattice with only nearest neighbor hopping, the on-site energy corresponding to half-filling and particle-hole symmetry is <span>$\epsilon_{\nu,\mathbf{i}} = 0.$</span></p><p><strong>Fields</strong></p><ul><li><code>ph_sym_form::Bool</code>: Determines whether the particle-hole symmetric form of the Hubbard interaction is used.</li><li><code>U_orbital_ids::Vector{Int}</code>: Orbital species/IDs in unit cell with finite Hubbard interaction.</li><li><code>U_mean::Vector{T}</code>: Average Hubbard interaction strength <span>$U_\nu$</span> for a given orbital species in the lattice.</li><li><code>U_std::Vector{T}</code>: Standard deviation of Hubbard interaction strength <span>$U_\nu$</span> for a given orbital species in the lattice.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Hubbard/HubbardModel.jl#L1-L28">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.HubbardModel-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.HubbardModel-Tuple{}"><code>SmoQyDQMC.HubbardModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">HubbardModel(;
    # KEYWORD ARGUMENTS
    ph_sym_form::Bool,
    U_orbital::AbstractVector{Int},
    U_mean::AbstractVector{T},
    U_std::AbstractVector{T} = zero(U_mean)
) where {T&lt;:AbstractFloat}</code></pre><p>Initialize and return an instance of the type <a href="#SmoQyDQMC.HubbardModel"><code>HubbardModel</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>ph_sym_form::Bool</code>: Determines whether the particle-hole symmetric form of the Hubbard interaction is used.</li><li><code>U_orbital::Vector{Int}</code>: Orbital species/IDs in unit cell with finite Hubbard interaction.</li><li><code>U_mean::Vector{T}</code>: Average Hubbard interaction strength <span>$U_\nu$</span> for a given orbital species in the lattice.</li><li><code>U_std::Vector{T}</code>: Standard deviation of Hubbard interaction strength <span>$U_\nu$</span> for a given orbital species in the lattice.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Hubbard/HubbardModel.jl#L44-L61">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.HubbardParameters"><a class="docstring-binding" href="#SmoQyDQMC.HubbardParameters"><code>SmoQyDQMC.HubbardParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HubbardParameters{T&lt;:AbstractFloat}</code></pre><p>Hubbard parameters for finite lattice.</p><p><strong>Fields</strong></p><ul><li><code>U::Vector{T}</code>: On-site Hubbard interaction for each site with finite Hubbard interaction.</li><li><code>sites::Vector{Int}</code>: Site index associated with each finite Hubbard <code>U</code> interaction.</li><li><code>orbital_ids::Vector{Int}</code>: Orbital ID/species in unit cell with finite Hubbard interaction.</li><li><code>ph_sym_form::Bool</code>: Convention used for Hubbard interaction, refer to <a href="#SmoQyDQMC.HubbardModel"><code>HubbardModel</code></a> for more information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Hubbard/HubbardModel.jl#L90-L101">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.HubbardParameters-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.HubbardParameters-Tuple{}"><code>SmoQyDQMC.HubbardParameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">HubbardParameters(;
    hubbard_model::HubbardModel{T},
    model_geometry::ModelGeometry{D,T},
    rng::AbstractRNG
) where {D, T&lt;:AbstractFloat}</code></pre><p>Initialize an instance of <a href="#SmoQyDQMC.HubbardParameters"><code>HubbardParameters</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Hubbard/HubbardModel.jl#L117-L125">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.initialize!-Tuple{FermionPathIntegral, FermionPathIntegral, HubbardParameters}"><a class="docstring-binding" href="#SmoQyDQMC.initialize!-Tuple{FermionPathIntegral, FermionPathIntegral, HubbardParameters}"><code>SmoQyDQMC.initialize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize!(
    fermion_path_integral_up::FermionPathIntegral,
    fermion_path_integral_dn::FermionPathIntegral,
    hubbard_parameters::HubbardParameters
)

initialize!(
    fermion_path_integral::FermionPathIntegral,
    hubbard_parameters::HubbardParameters
)</code></pre><p>Initialize the contribution from the Hubbard interaction to a <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Hubbard/HubbardModel.jl#L170-L183">source</a></section></details></article><h3 id="Hubbard-Model-Measurements"><a class="docs-heading-anchor" href="#Hubbard-Model-Measurements">Hubbard Model Measurements</a><a id="Hubbard-Model-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Hubbard-Model-Measurements" title="Permalink"></a></h3><article><details class="docstring"><summary id="SmoQyDQMC.measure_hubbard_energy"><a class="docstring-binding" href="#SmoQyDQMC.measure_hubbard_energy"><code>SmoQyDQMC.measure_hubbard_energy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure_hubbard_energy(
    hubbard_parameters::HubbardParameters{E},
    Gup::Matrix{T}, Gdn::Matrix{T},
    hubbard_id::Int
) where {T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Calculate the average Hubbard energy <span>$U \langle \hat{n}_\uparrow \hat{n}_\downarrow \rangle$</span> if <code>ph_sym_form = false</code> and <span>$U \langle (\hat{n}_\uparrow - \tfrac{1}{2})(\hat{n}_\downarrow - \tfrac{1}{2})\rangle$</span> if <code>ph_sym_form = true</code> for the orbital corresponding <code>orbital_id</code> in the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Hubbard/hubbard_model_measurements.jl#L1-L11">source</a></section></details></article><h2 id="Extended-Hubbard-Model"><a class="docs-heading-anchor" href="#Extended-Hubbard-Model">Extended Hubbard Model</a><a id="Extended-Hubbard-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Extended-Hubbard-Model" title="Permalink"></a></h2><article><details class="docstring"><summary id="SmoQyDQMC.ExtendedHubbardModel"><a class="docstring-binding" href="#SmoQyDQMC.ExtendedHubbardModel"><code>SmoQyDQMC.ExtendedHubbardModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ExtendedHubbardModel{T&lt;:AbstractFloat}</code></pre><p>A type to represent extended Hubbard interactions.</p><p>If the type field <code>ph_sym_form = false</code> then the particle-hole asymmetric form of the extended Hubbard interaction</p><p class="math-container">\[\begin{align*}
\hat{H}_{V} = \sum_{\mathbf{j},\mathbf{r},\nu,\eta}V_{(\mathbf{j}+\mathbf{r},\nu),(\mathbf{j},\eta)} &amp; \hat{n}_{\mathbf{j}+\mathbf{r},\nu}\hat{n}_{\mathbf{j},\eta} \\
    = \sum_{\mathbf{j},\mathbf{r},\nu,\eta}V_{(\mathbf{j}+\mathbf{r},\nu),(\mathbf{j},\eta)} &amp; \bigg[\tfrac{1}{2}(\hat{n}_{\mathbf{j}+\mathbf{r},\nu}+\hat{n}_{\mathbf{j},\eta}-2)^{2}-1 \\
    &amp; -\hat{n}_{\mathbf{j}+\mathbf{r},\nu,\uparrow}\hat{n}_{\mathbf{j}+\mathbf{r},\nu\downarrow}-\hat{n}_{\mathbf{j},\eta,\uparrow}\hat{n}_{\mathbf{j},\eta\downarrow}+\tfrac{3}{2}\hat{n}_{\mathbf{j}+\mathbf{r},\nu}+\tfrac{3}{2}\hat{n}_{\mathbf{j},\eta}\bigg]
\end{align*}\]</p><p>is used, where <span>$\mathbf{j}$</span> specifies a unit cell in the lattice, <span>$\mathbf{r}$</span> is a displacement in units, and <span>$\nu$</span> and <span>$\eta$</span> specify the orbital in a given unit cell. Here, <span>$\hat{n}_{\mathbf{j},\eta} = (\hat{n}_{\uparrow,\mathbf{j},\eta} + \hat{n}_{\downarrow,\mathbf{j},\eta})$</span> is the electron number operator for orbital <span>$\eta$</span> in unit cell <span>$\mathbf{j}$</span> in the lattice. Therefore, <span>$V_{(\mathbf{j}+\mathbf{r},\nu),(\mathbf{j},\eta)}$</span> controls the strength of the extended Hubbard interaction between orbital <span>$\eta$</span> in unit cell <span>$\mathbf{j}$</span> and orbital <span>$\nu$</span> in unit cell <span>$\mathbf{j}+\mathbf{r}$</span>.</p><p>If the type field <code>ph_sym_form = true</code>, then the particle-hole symmetric for the extended Hubbard interaction</p><p class="math-container">\[\begin{align*}
\hat{H}_{V}=\sum_{\mathbf{j},\mathbf{r},\nu,\eta}V_{(\mathbf{j}+\mathbf{r},\nu),(\mathbf{j},\eta)}&amp;(\hat{n}_{\mathbf{j}+\mathbf{r},\nu}-1)(\hat{n}_{\mathbf{j},\eta}-1) \\
    = \sum_{\mathbf{j},\mathbf{r},\nu,\eta}V_{(\mathbf{j}+\mathbf{r},\nu),(\mathbf{j},\eta)}&amp;\bigg[\tfrac{1}{2}(\hat{n}_{\mathbf{j}+\mathbf{r},\nu}+\hat{n}_{\mathbf{j},\eta}-2)^{2}+\tfrac{1}{2} \\
    &amp; -(\hat{n}_{\mathbf{j}+\mathbf{r},\nu,\uparrow}-\tfrac{1}{2})(\hat{n}_{\mathbf{j}+\mathbf{r},\nu\downarrow}-\tfrac{1}{2})-(\hat{n}_{\mathbf{j},\eta,\uparrow}-\tfrac{1}{2})(\hat{n}_{\mathbf{j},\eta\downarrow}-\tfrac{1}{2})\bigg]
\end{align*}\]</p><p>is used instead.</p><p><strong>Fields</strong></p><ul><li><code>ph_sym_form::Bool</code>: Whether the particle-hole symmetric form of the extended Hubbard interaction is used.</li><li><code>V_bond_ids::Vector{Int}</code>: Bond IDs specifying bond definition that separates a pair of orbitals with an extended Hubbard interaction between them.</li><li><code>V_mean::Vector{T}</code>: Average extended Hubbard interaction strength <span>$V_{(\mathbf{j}+\mathbf{r},\nu),(\mathbf{j},\eta)}$</span> associated with bond definition.</li><li><code>V_mean::Vector{T}</code>: Standard deviation of extended Hubbard interaction strength <span>$V_{(\mathbf{j}+\mathbf{r},\nu),(\mathbf{j},\eta)}$</span> associated with bond definition.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ExtendedHubbard/ExtendedHubbardModel.jl#L1-L35">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.ExtendedHubbardModel-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.ExtendedHubbardModel-Tuple{}"><code>SmoQyDQMC.ExtendedHubbardModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ExtendedHubbardModel(;
    # KEYWORD ARGUMENTS
    model_geometry::ModelGeometry{D,T},
    ph_sym_form::Bool,
    V_bond::Vector{Bond{D}},
    V_mean::Vector{T},
    V_std::Vector{T} = zero(V_mean)
) where {T&lt;:AbstractFloat, D}</code></pre><p>Initialize and return an instance of the type <a href="#SmoQyDQMC.ExtendedHubbardModel"><code>ExtendedHubbardModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ExtendedHubbard/ExtendedHubbardModel.jl#L51-L62">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.ExtendedHubbardParameters"><a class="docstring-binding" href="#SmoQyDQMC.ExtendedHubbardParameters"><code>SmoQyDQMC.ExtendedHubbardParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ExtendedHubbardParameters{T&lt;:AbstractFloat}</code></pre><p>Extended Hubbard interaction parameters for finite lattice.</p><p><strong>Fields</strong></p><ul><li><code>V::Vector{T}</code>: Extended Hubbard interaction strength for each pair neighbors in the lattice.</li><li><code>neighbor_table::Matrix{Int}</code>: Neighbor table for extended Hubbard interactions on lattice.</li><li><code>bond_ids::Vector{Int}</code>: Bond IDs used to define extended Hubbard interactions.</li><li><code>ph_sym_form::Bool</code>: Whether particle-hole symmetric form of extended Hubbard interaction was used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ExtendedHubbard/ExtendedHubbardParameters.jl#L1-L12">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.ExtendedHubbardParameters-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.ExtendedHubbardParameters-Tuple{}"><code>SmoQyDQMC.ExtendedHubbardParameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ExtendedHubbardParameters(;
    # KEYWORD ARGUMENTS
    extended_hubbard_model::ExtendedHubbardModel{T},
    model_geometry::ModelGeometry{D,T},
    rng::AbstractRNG
) where {D, T&lt;:AbstractFloat}</code></pre><p>Initialize an instance of the <a href="#SmoQyDQMC.ExtendedHubbardParameters"><code>ExtendedHubbardParameters</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ExtendedHubbard/ExtendedHubbardParameters.jl#L28-L37">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.initialize!-Tuple{FermionPathIntegral, FermionPathIntegral, ExtendedHubbardParameters}"><a class="docstring-binding" href="#SmoQyDQMC.initialize!-Tuple{FermionPathIntegral, FermionPathIntegral, ExtendedHubbardParameters}"><code>SmoQyDQMC.initialize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize!(
    fermion_path_integral_up::FermionPathIntegral,
    fermion_path_integral_dn::FermionPathIntegral,
    extended_hubbard_parameters::ExtendedHubbardParameters
)

initialize!(
    fermion_path_integral::FermionPathIntegral,
    extended_hubbard_parameters::ExtendedHubbardParameters
)</code></pre><p>Initialize the contribution from the Hubbard interaction to a <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ExtendedHubbard/ExtendedHubbardParameters.jl#L74-L87">source</a></section></details></article><h3 id="Extended-Hubbard-Model-Measurements"><a class="docs-heading-anchor" href="#Extended-Hubbard-Model-Measurements">Extended Hubbard Model Measurements</a><a id="Extended-Hubbard-Model-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Extended-Hubbard-Model-Measurements" title="Permalink"></a></h3><article><details class="docstring"><summary id="SmoQyDQMC.measure_ext_hub_energy"><a class="docstring-binding" href="#SmoQyDQMC.measure_ext_hub_energy"><code>SmoQyDQMC.measure_ext_hub_energy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure_ext_hub_energy(
    ext_hub_params::ExtendedHubbardParameters{E},
    Gup::Matrix{T}, Gdn::Matrix{T},
    ext_hub_id::Int
) where {T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Measure the extended Hubbard interaction energy</p><p class="math-container">\[V (\hat{n}_i-1)(\hat{n}_j-1)\]</p><p>if <code>ph_sym_form = true</code> and</p><p class="math-container">\[V \hat{n}_i \hat{n}_j\]</p><p>if <code>ph_sym_form = false</code> for the specified <code>EXT_HUB_ID</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ExtendedHubbard/ext_hub_model_measurements.jl#L1-L17">source</a></section></details></article><h2 id="Hubbard-Stratonovich-Transformations"><a class="docs-heading-anchor" href="#Hubbard-Stratonovich-Transformations">Hubbard-Stratonovich Transformations</a><a id="Hubbard-Stratonovich-Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Hubbard-Stratonovich-Transformations" title="Permalink"></a></h2><p>Below are the abstract types used to represent generic Hubbard-Stratonovich transformations.</p><article><details class="docstring"><summary id="SmoQyDQMC.AbstractHST"><a class="docstring-binding" href="#SmoQyDQMC.AbstractHST"><code>SmoQyDQMC.AbstractHST</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractHST{T&lt;:Number, R&lt;:AbstractFloat} end</code></pre><p>Abstract type to represent a Hubbard-Stratonovich transformation. Here <code>T</code> is the effective Hubbard-Stratonovich field type, specifying whether the Hubbard-Stratonovich transformation is real or complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/AbstractHST.jl#L1-L7">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.AbstractSymHST"><a class="docstring-binding" href="#SmoQyDQMC.AbstractSymHST"><code>SmoQyDQMC.AbstractSymHST</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractSymHST{T, R} &lt;: AbstractHST{T, R} end</code></pre><p>Abstract type to represent a Hubbard-Stratonovich transformation that couples to each spin species symmetrically. Here <code>T</code> is the effective Hubbard-Stratonovich field type, specifying whether the Hubbard-Stratonovich transformation is real or complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/AbstractHST.jl#L10-L16">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.AbstractAsymHST"><a class="docstring-binding" href="#SmoQyDQMC.AbstractAsymHST"><code>SmoQyDQMC.AbstractAsymHST</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractAsymHST{T, R} &lt;: AbstractHST{T, R} end</code></pre><p>Abstract type to represent a Hubbard-Stratonovich transformation that couples to each spin species asymmetrically. Here <code>T</code> is the effective Hubbard-Stratonovich field type, specifying whether the Hubbard-Stratonovich transformation is real or complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/AbstractHST.jl#L19-L25">source</a></section></details></article><p>Below is the shared API for the <a href="#SmoQyDQMC.AbstractHST"><code>AbstractHST</code></a> type.</p><article><details class="docstring"><summary id="SmoQyDQMC.initialize!-Union{Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H}, FermionPathIntegral{H}, AbstractHST{T}}} where {H&lt;:Number, T&lt;:Number}"><a class="docstring-binding" href="#SmoQyDQMC.initialize!-Union{Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H}, FermionPathIntegral{H}, AbstractHST{T}}} where {H&lt;:Number, T&lt;:Number}"><code>SmoQyDQMC.initialize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize!(
    fermion_path_integral_up::FermionPathIntegral{H},
    fermion_path_integral_dn::FermionPathIntegral{H},
    hst_parameters::AbstractHST{T}
) where {H&lt;:Number, T&lt;:Number}

initialize!(
    fermion_path_integral_up::FermionPathIntegral{H},
    fermion_path_integral_dn::FermionPathIntegral{H},
    hst_parameters::Tuple
) where {H&lt;:Number}

initialize!(
    fermion_path_integral::FermionPathIntegral{H},
    hst_parameters::AbstractSymHST{T}
) where {H&lt;:Number, T&lt;:Number}

initialize!(
    fermion_path_integral::FermionPathIntegral{H},
    hst_parameters::Tuple
) where {H&lt;:Number}</code></pre><p>Initialize a <code>FermionPathIntegral</code> integral type to reflect the the current Hubbard-Stratonovich transformation type represented by <code>hst_parameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/AbstractHST.jl#L31-L57">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, AbstractHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><a class="docstring-binding" href="#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, AbstractHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><code>SmoQyDQMC.local_updates!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">local_updates!(
    # ARGUMENTS
    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,
    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,
    hst_parameters::AbstractHST{T,R};
    # KEYWORD ARGUMENTS
    fermion_path_integral_up::FermionPathIntegral{H},
    fermion_path_integral_dn::FermionPathIntegral{H},
    fermion_greens_calculator_up::FermionGreensCalculator{H},
    fermion_greens_calculator_dn::FermionGreensCalculator{H},
    Bup::Vector{P}, Bdn::Vector{P},
    δG::R, δθ::R,  rng::AbstractRNG,
    δG_max::R = 1e-6,
    update_stabilization_frequency::Bool = true
) where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}</code></pre><p>Perform local updates to Hubbard-Stratonovich fields stored in <code>hst_parameters</code>. This method returns a tuple containing <code>(acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Gup::Matrix{H}</code>: Spin-up equal-time Green&#39;s function matrix.</li><li><code>logdetGup::R</code>: The log of the absolute value of the determinant of the spin-up equal-time Green&#39;s function matrix, <span>$\log \vert \det G_\uparrow(\tau,\tau) \vert.$</span></li><li><code>sgndetGup::H</code>: The sign/phase of the determinant of the spin-up equal-time Green&#39;s function matrix, <span>$\det G_\uparrow(\tau,\tau) / \vert \det G_\uparrow(\tau,\tau) \vert.$</span></li><li><code>Gdn::Matrix{H}</code>: Spin-down equal-time Green&#39;s function matrix.</li><li><code>logdetGdn::R</code>: The log of the absolute value of the determinant of the spin-down equal-time Green&#39;s function matrix, <span>$\log \vert \det G_\downarrow(\tau,\tau) \vert.$</span></li><li><code>sgndetGdn::H</code>: The sign/phase of the determinant of the spin-down equal-time Green&#39;s function matrix, <span>$\det G_\downarrow(\tau,\tau) / \vert \det G_\downarrow(\tau,\tau) \vert.$</span></li><li><code>hst_parameters::AbstractHST{T,R}</code>: Type representing Hubbard-Stratonovich transformation.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral_up::FermionPathIntegral{H}</code>: An instance of the <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type for spin-up electrons.</li><li><code>fermion_path_integral_dn::FermionPathIntegral{H}</code>: An instance of the <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type for spin-down electrons.</li><li><code>fermion_greens_calculator_up::FermionGreensCalculator{H}</code>: An instance of the <a href="https://smoqysuite.github.io/JDQMCFramework.jl/stable/api/#JDQMCFramework.FermionGreensCalculator"><code>FermionGreensCalculator</code></a> type for the spin-up electrons.</li><li><code>fermion_greens_calculator_dn::FermionGreensCalculator{H}</code>: An instance of the <a href="https://smoqysuite.github.io/JDQMCFramework.jl/stable/api/#JDQMCFramework.FermionGreensCalculator"><code>FermionGreensCalculator</code></a> type for the spin-down electrons.</li><li><code>Bup::Vector{P}</code>: Spin-up propagators for each imaginary time slice.</li><li><code>Bdn::Vector{P}</code>: Spin-dn propagators for each imaginary time slice.</li><li><code>δG_max::R</code>: Maximum allowed error corrected by numerical stabilization.</li><li><code>δG::R</code>: Previously recorded maximum error in the Green&#39;s function corrected by numerical stabilization.</li><li><code>δθ::R</code>: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green&#39;s function matrix corrected by numerical stabilization.</li><li><code>rng::AbstractRNG</code>: Random number generator used in method instead of global random number generator, important for reproducibility.</li><li><code>update_stabilization_frequency::Bool = true</code>: If true, allows the stabilization frequency <code>n_stab</code> to be dynamically adjusted.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/AbstractHST.jl#L116-L159">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{R}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, Tuple}} where {H&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><a class="docstring-binding" href="#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{R}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, Tuple}} where {H&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><code>SmoQyDQMC.local_updates!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">local_updates!(
    # ARGUMENTS
    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,
    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,
    hst_parameters::Tuple;
    # KEYWORD ARGUMENTS
    fermion_path_integral_up::FermionPathIntegral{H},
    fermion_path_integral_dn::FermionPathIntegral{H},
    fermion_greens_calculator_up::FermionGreensCalculator{H},
    fermion_greens_calculator_dn::FermionGreensCalculator{H},
    Bup::Vector{P}, Bdn::Vector{P},
    δG::R, δθ::R,  rng::AbstractRNG,
    δG_max::R = 1e-6,
    update_stabilization_frequency::Bool = true
) where {H&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}</code></pre><p>Perform local updates to Hubbard-Stratonovich fields for <code>N</code> different types of Hubbard-Stratonovich transformations. This method returns a tuple containing <code>(acceptance_rates, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ)</code>. Note that <code>acceptance_rates</code> is a tuple returning the acceptance rate for local updates of each type of Hubbard-Stratonovich field that was sampled.</p><p><strong>Arguments</strong></p><ul><li><code>Gup::Matrix{H}</code>: Spin-up equal-time Green&#39;s function matrix.</li><li><code>logdetGup::R</code>: The log of the absolute value of the determinant of the spin-up equal-time Green&#39;s function matrix, <span>$\log \vert \det G_\uparrow(\tau,\tau) \vert.$</span></li><li><code>sgndetGup::H</code>: The sign/phase of the determinant of the spin-up equal-time Green&#39;s function matrix, <span>$\det G_\uparrow(\tau,\tau) / \vert \det G_\uparrow(\tau,\tau) \vert.$</span></li><li><code>Gdn::Matrix{H}</code>: Spin-down equal-time Green&#39;s function matrix.</li><li><code>logdetGdn::R</code>: The log of the absolute value of the determinant of the spin-down equal-time Green&#39;s function matrix, <span>$\log \vert \det G_\downarrow(\tau,\tau) \vert.$</span></li><li><code>sgndetGdn::H</code>: The sign/phase of the determinant of the spin-down equal-time Green&#39;s function matrix, <span>$\det G_\downarrow(\tau,\tau) / \vert \det G_\downarrow(\tau,\tau) \vert.$</span></li><li><code>hst_parameters::Tuple</code>: Tuple of parameters for multiple different Hubbard-Stratonovich transformation fields that will be sampled.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral_up::FermionPathIntegral{H}</code>: An instance of the <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type for spin-up electrons.</li><li><code>fermion_path_integral_dn::FermionPathIntegral{H}</code>: An instance of the <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type for spin-down electrons.</li><li><code>fermion_greens_calculator_up::FermionGreensCalculator{H}</code>: An instance of the <a href="https://smoqysuite.github.io/JDQMCFramework.jl/stable/api/#JDQMCFramework.FermionGreensCalculator"><code>FermionGreensCalculator</code></a> type for the spin-up electrons.</li><li><code>fermion_greens_calculator_dn::FermionGreensCalculator{H}</code>: An instance of the <a href="https://smoqysuite.github.io/JDQMCFramework.jl/stable/api/#JDQMCFramework.FermionGreensCalculator"><code>FermionGreensCalculator</code></a> type for the spin-down electrons.</li><li><code>Bup::Vector{P}</code>: Spin-up propagators for each imaginary time slice.</li><li><code>Bdn::Vector{P}</code>: Spin-dn propagators for each imaginary time slice.</li><li><code>δG_max::R</code>: Maximum allowed error corrected by numerical stabilization.</li><li><code>δG::R</code>: Previously recorded maximum error in the Green&#39;s function corrected by numerical stabilization.</li><li><code>δθ::R</code>: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green&#39;s function matrix corrected by numerical stabilization.</li><li><code>rng::AbstractRNG</code>: Random number generator used in method instead of global random number generator, important for reproducibility.</li><li><code>update_stabilization_frequency::Bool = true</code>: If true, allows the stabilization frequency <code>n_stab</code> to be dynamically adjusted.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/AbstractHST.jl#L245-L289">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, AbstractSymHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><a class="docstring-binding" href="#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, AbstractSymHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><code>SmoQyDQMC.local_updates!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">local_updates!(
    # ARGUMENTS
    G::Matrix{H}, logdetG::R, sgndetG::H,
    hst_parameters::AbstractSymHST{T,R};
    # KEYWORD ARGUMENTS
    fermion_path_integral::FermionPathIntegral{H},
    fermion_greens_calculator::FermionGreensCalculator{H},
    B::Vector{P},
    δG::R, δθ::R,  rng::AbstractRNG,
    δG_max::R = 1e-6,
    update_stabilization_frequency::Bool = true
) where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}</code></pre><p>Perform local updates to Hubbard-Stratonovich fields for a spin-symmetric (density channel) Hubbard-Stratonovich transformation. This method returns a tuple containing <code>(acceptance_rate, logdetG, sgndetG, δG, δθ)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>G::Matrix{H}</code>: Equal-time Green&#39;s function matrix.</li><li><code>logdetG::R</code>: The log of the absolute value of the determinant of the equal-time Green&#39;s function matrix, <span>$\log \vert \det G(\tau,\tau) \vert.$</span></li><li><code>sgndetG::H</code>: The sign/phase of the determinant of the equal-time Green&#39;s function matrix, <span>$\det G(\tau,\tau) / \vert \det G(\tau,\tau) \vert.$</span></li><li><code>hst_parameters::AbstractSymHST{T,R}</code>: Type representing spin-symmetric Hubbard-Stratonovich transformation.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral::FermionPathIntegral{H}</code>: An instance of the <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a>.</li><li><code>fermion_greens_calculator::FermionGreensCalculator{H}</code>: An instance of the <a href="https://smoqysuite.github.io/JDQMCFramework.jl/stable/api/#JDQMCFramework.FermionGreensCalculator"><code>FermionGreensCalculator</code></a> type.</li><li><code>B::Vector{P}</code>: Propagators for each imaginary time slice.</li><li><code>δG_max::R</code>: Maximum allowed error corrected by numerical stabilization.</li><li><code>δG::R</code>: Previously recorded maximum error in the Green&#39;s function corrected by numerical stabilization.</li><li><code>δθ::R</code>: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green&#39;s function matrix corrected by numerical stabilization.</li><li><code>rng::AbstractRNG</code>: Random number generator used in method instead of global random number generator, important for reproducibility.</li><li><code>update_stabilization_frequency::Bool = true</code>: If true, allows the stabilization frequency <code>n_stab</code> to be dynamically adjusted.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/AbstractHST.jl#L383-L417">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{R}, Tuple{H}, Tuple{Matrix{H}, R, H, Tuple}} where {H&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><a class="docstring-binding" href="#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{R}, Tuple{H}, Tuple{Matrix{H}, R, H, Tuple}} where {H&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><code>SmoQyDQMC.local_updates!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">local_updates!(
    # ARGUMENTS
    G::Matrix{H}, logdetG::R, sgndetG::H,
    hst_parameters::Tuple;
    # KEYWORD ARGUMENTS
    fermion_path_integral::FermionPathIntegral{H},
    fermion_greens_calculator::FermionGreensCalculator{H},
    B::Vector{P},
    δG::R, δθ::R,  rng::AbstractRNG,
    δG_max::R = 1e-6,
    update_stabilization_frequency::Bool = true
) where {H&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}</code></pre><p>Perform local updates to multiple types Hubbard-Stratonovich fields for a spin-symmetric (density channel) Hubbard-Stratonovich transformation. This method returns a tuple containing <code>(acceptance_rate, logdetG, sgndetG, δG, δθ)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>G::Matrix{H}</code>: Equal-time Green&#39;s function matrix.</li><li><code>logdetG::R</code>: The log of the absolute value of the determinant of the equal-time Green&#39;s function matrix, <span>$\log \vert \det G(\tau,\tau) \vert.$</span></li><li><code>sgndetG::H</code>: The sign/phase of the determinant of the equal-time Green&#39;s function matrix, <span>$\det G(\tau,\tau) / \vert \det G(\tau,\tau) \vert.$</span></li><li><code>hst_parameters::Tuple</code>: Tuple of parameters for multiple different spin-symmetric Hubbard-Stratonovich transformation fields that will be sampled.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral::FermionPathIntegral{H}</code>: An instance of the <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a>.</li><li><code>fermion_greens_calculator::FermionGreensCalculator{H}</code>: An instance of the <a href="https://smoqysuite.github.io/JDQMCFramework.jl/stable/api/#JDQMCFramework.FermionGreensCalculator"><code>FermionGreensCalculator</code></a> type.</li><li><code>B::Vector{P}</code>: Propagators for each imaginary time slice.</li><li><code>δG_max::R</code>: Maximum allowed error corrected by numerical stabilization.</li><li><code>δG::R</code>: Previously recorded maximum error in the Green&#39;s function corrected by numerical stabilization.</li><li><code>δθ::R</code>: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green&#39;s function matrix corrected by numerical stabilization.</li><li><code>rng::AbstractRNG</code>: Random number generator used in method instead of global random number generator, important for reproducibility.</li><li><code>update_stabilization_frequency::Bool = true</code>: If true, allows the stabilization frequency <code>n_stab</code> to be dynamically adjusted.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/AbstractHST.jl#L486-L520">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, AbstractHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><a class="docstring-binding" href="#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, AbstractHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><code>SmoQyDQMC.reflection_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reflection_update!(
    # ARGUMENTS
    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,
    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,
    hst_parameters::AbstractHST{T,R};
    # KEYWORD ARGUMENTS
    fermion_path_integral_up::FermionPathIntegral{H},
    fermion_path_integral_dn::FermionPathIntegral{H},
    fermion_greens_calculator_up::FermionGreensCalculator{H,R},
    fermion_greens_calculator_dn::FermionGreensCalculator{H,R},
    fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R},
    fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R},
    Bup::Vector{P}, Bdn::Vector{P},
    rng::AbstractRNG
) where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}</code></pre><p>Perform a reflection update for a Hubbard-Stratonovich field on a randomly chosen location in the lattice for all imaginary-time slices. This function returns <code>(accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Gup::Matrix{H}</code>: Spin-up equal-time Greens function matrix.</li><li><code>logdetGup::R</code>: Log of the determinant of the spin-up equal-time Greens function matrix.</li><li><code>sgndetGup::H</code>: Sign/phase of the determinant of the spin-up equal-time Greens function matrix.</li><li><code>Gdn::Matrix{H}</code>: Spin-down equal-time Greens function matrix.</li><li><code>logdetGdn::R</code>: Log of the determinant of the spin-down equal-time Greens function matrix.</li><li><code>sgndetGdn::H</code>: Sign/phase of the determinant of the spin-down equal-time Greens function matrix.</li><li><code>hst_parameters::AbstractHST{T,R}</code>: Hubbard-Stratonovich fields and associated parameters to update.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral_up::FermionPathIntegral{H}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type for spin-up electrons.</li><li><code>fermion_path_integral_dn::FermionPathIntegral{H}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type for spin-down electrons.</li><li><code>fermion_greens_calculator_up::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current spin-up sector state.</li><li><code>fermion_greens_calculator_dn::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current spin-down sector state.</li><li><code>fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed spin-up sector state.</li><li><code>fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed spin-down sector state.</li><li><code>Bup::Vector{P}</code>: Spin-up propagators for each imaginary time slice.</li><li><code>Bdn::Vector{P}</code>: Spin-down propagators for each imaginary time slice.</li><li><code>rng::AbstractRNG</code>: Random number generator used in method instead of global random number generator, important for reproducibility.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/AbstractHST.jl#L597-L638">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, AbstractSymHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><a class="docstring-binding" href="#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, AbstractSymHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><code>SmoQyDQMC.reflection_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reflection_update!(
    # ARGUMENTS
    G::Matrix{H}, logdetG::R, sgndetG::H,
    hst_parameters::AbstractSymHST{T,R};
    # KEYWORD ARGUMENTS
    fermion_path_integral::FermionPathIntegral{H},
    fermion_greens_calculator::FermionGreensCalculator{H,R},
    fermion_greens_calculator_alt::FermionGreensCalculator{H,R},
    B::Vector{P},
    rng::AbstractRNG
) where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}</code></pre><p>Perform a reflection update for a spin-symmetric (density channel) Hubbard-Stratonovich field on a randomly chosen location in the lattice for all imaginary-time slices. This function returns <code>(accepted, logdetG, sgndetG)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>G::Matrix{H}</code>: The current Hubbard-Stratonovich field matrix.</li><li><code>logdetG::R</code>: Log of the determinant of the Hubbard-Stratonovich field matrix.</li><li><code>sgndetG::H</code>: Sign/phase of the determinant of the Hubbard-Stratonovich field matrix.</li><li><code>hst_parameters::AbstractSymHST{T,R}</code>: Hubbard-Stratonovich fields and associated parameters to update.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral::FermionPathIntegral{H}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a>.</li><li><code>fermion_greens_calculator::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current state.</li><li><code>fermion_greens_calculator_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed state.</li><li><code>B::Vector{P}</code>: Propagators for each imaginary time slice.</li><li><code>rng::AbstractRNG</code>: Random number generator used in method instead of global random number</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/AbstractHST.jl#L670-L700">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, AbstractHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><a class="docstring-binding" href="#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, AbstractHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><code>SmoQyDQMC.swap_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">swap_update!(
    # ARGUMENTS
    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,
    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,
    hst_parameters::AbstractHST{T,R};
    # KEYWORD ARGUMENTS
    fermion_path_integral_up::FermionPathIntegral{H},
    fermion_path_integral_dn::FermionPathIntegral{H},
    fermion_greens_calculator_up::FermionGreensCalculator{H,R},
    fermion_greens_calculator_dn::FermionGreensCalculator{H,R},
    fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R},
    fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R},
    Bup::Vector{P}, Bdn::Vector{P},
    rng::AbstractRNG
) where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}</code></pre><p>Perform a swap update for a Hubbard-Stratonovich field between a pair of randomly chosen locations in the lattice for all imaginary-time slices. This function returns <code>(accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Gup::Matrix{H}</code>: Spin-up equal-time Greens function matrix.</li><li><code>logdetGup::R</code>: Log of the determinant of the spin-up equal-time Greens function matrix.</li><li><code>sgndetGup::H</code>: Sign/phase of the determinant of the spin-up equal-time Greens function matrix.</li><li><code>Gdn::Matrix{H}</code>: Spin-down equal-time Greens function matrix.</li><li><code>logdetGdn::R</code>: Log of the determinant of the spin-down equal-time Greens function matrix.</li><li><code>sgndetGdn::H</code>: Sign/phase of the determinant of the spin-down equal-time Greens function matrix.</li><li><code>hst_parameters::AbstractHST{T,R}</code>: Hubbard-Stratonovich fields and associated parameters to update.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral_up::FermionPathIntegral{H}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type for spin-up electrons.</li><li><code>fermion_path_integral_dn::FermionPathIntegral{H}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type for spin-down electrons.</li><li><code>fermion_greens_calculator_up::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current spin-up sector state.</li><li><code>fermion_greens_calculator_dn::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current spin-down sector state.</li><li><code>fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed spin-up sector state.</li><li><code>fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed spin-down sector state.</li><li><code>Bup::Vector{P}</code>: Spin-up propagators for each imaginary time slice.</li><li><code>Bdn::Vector{P}</code>: Spin-down propagators for each imaginary time slice</li><li><code>rng::AbstractRNG</code>: Random number generator used in method instead of global random number generator, important for reproducibility.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/AbstractHST.jl#L762-L803">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, AbstractSymHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><a class="docstring-binding" href="#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, AbstractSymHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><code>SmoQyDQMC.swap_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">swap_update!(
    # ARGUMENTS
    G::Matrix{H}, logdetG::R, sgndetG::H,
    hst_parameters::AbstractSymHST{T,R};
    # KEYWORD ARGUMENTS
    fermion_path_integral::FermionPathIntegral{H},
    fermion_greens_calculator::FermionGreensCalculator{H,R},
    fermion_greens_calculator_alt::FermionGreensCalculator{H,R},
    B::Vector{P},
    rng::AbstractRNG
) where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}</code></pre><p>Perform a swap update for a spin-symmetric (density channel) Hubbard-Stratonovich field between a pair of randomly chosen locations in the lattice for all imaginary-time slices. This function returns <code>(accepted, logdetG, sgndetG)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>G::Matrix{H}</code>: The current Hubbard-Stratonovich field matrix.</li><li><code>logdetG::R</code>: Log of the determinant of the Hubbard-Stratonovich field</li><li><code>sgndetG::H</code>: Sign of the determinant of the Hubbard-Stratonovich field matrix.</li><li><code>hst_parameters::AbstractSymHST{T,R}</code>: Hubbard-Stratonovich fields and associated parameters to update.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral::FermionPathIntegral{H}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a>.</li><li><code>fermion_greens_calculator::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current state.</li><li><code>fermion_greens_calculator_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed state.</li><li><code>B::Vector{P}</code>: Propagators for each imaginary time slice.</li><li><code>rng::AbstractRNG</code>: Random number generator used in method instead of global random number generator, important for reproducibility.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/AbstractHST.jl#L841-L871">source</a></section></details></article><h3 id="Hubbard-Model-Hubbard-Stratonovich-Transformations"><a class="docs-heading-anchor" href="#Hubbard-Model-Hubbard-Stratonovich-Transformations">Hubbard Model Hubbard-Stratonovich Transformations</a><a id="Hubbard-Model-Hubbard-Stratonovich-Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Hubbard-Model-Hubbard-Stratonovich-Transformations" title="Permalink"></a></h3><article><details class="docstring"><summary id="SmoQyDQMC.HubbardSpinHirschHST"><a class="docstring-binding" href="#SmoQyDQMC.HubbardSpinHirschHST"><code>SmoQyDQMC.HubbardSpinHirschHST</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HubbardSpinHirschHST{T,R} &lt;: AbstractAsymHST{T,R}</code></pre><p>This type represents a Hubbard-Stratonovich (HS) transformation for decoupling the local Hubbard interaction in the spin channel, where the introduced HS fields take on the two discrete values <span>$s = \pm 1$</span>. Specifically, the Hubbard interaction is decoupled as</p><p class="math-container">\[e^{-\Delta\tau U\left(n_{\uparrow}-\tfrac{1}{2}\right)\left(n_{\downarrow}-\tfrac{1}{2}\right)}
 = \gamma\sum_{s=\pm1}e^{-\Delta\tau\alpha(n_{\uparrow}-n_{\downarrow})s},\]</p><p>where</p><p class="math-container">\[\gamma=\frac{1}{2}e^{-\Delta\tau U/4}\]</p><p>and</p><p class="math-container">\[\alpha = \frac{1}{\Delta\tau}\cosh^{-1}\left(e^{\Delta\tau U/2}\right).\]</p><p>Note that when <span>$U \ge 0$</span> then <span>$\alpha$</span> is real, whereas if <span>$U&lt;0$</span> then <span>$\alpha$</span> is purely imaginary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Hubbard/HubbardSpinHirschHST.jl#L1-L20">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.HubbardSpinHirschHST-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.HubbardSpinHirschHST-Tuple{}"><code>SmoQyDQMC.HubbardSpinHirschHST</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">HubbardSpinHirschHST(;
    # KEYWORD ARGUMENTS
    hubbard_parameters::HubbardParameters{R},
    β::R, Δτ::R, rng::AbstractRNG
) where {R&lt;:AbstractFloat}</code></pre><p>Initialize an instance of the <a href="#SmoQyDQMC.HubbardSpinHirschHST"><code>HubbardSpinHirschHST</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Hubbard/HubbardSpinHirschHST.jl#L51-L59">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.HubbardSpinGaussHermiteHST"><a class="docstring-binding" href="#SmoQyDQMC.HubbardSpinGaussHermiteHST"><code>SmoQyDQMC.HubbardSpinGaussHermiteHST</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HubbardSpinGaussHermiteHST{T,R} &lt;: AbstractAsymHST{T,R}</code></pre><p>This type represents a Hubbard-Stratonovich (HS) transformation for decoupling the local Hubbard interaction in the spin channel, where the introduced HS fields take on the four discrete values <span>$s \in \{ -2, -1, +1, +2 \}.$</span> Note that the Hubbard interaction can be written in the spin channel as</p><p class="math-container">\[U(\hat{n}_{\uparrow}-\tfrac{1}{2})(\hat{n}_{\downarrow}-\tfrac{1}{2})=-\tfrac{U}{2}(\hat{n}_{\uparrow}-\hat{n}_{\downarrow})^{2}+\tfrac{U}{4},\]</p><p>different only by a constant energy offset <span>$U/4$</span> which does not matter. Therefore, we can perform a Gauss-Hermite Hubbard-Statonovich transformation in the spin channel as</p><p class="math-container">\[e^{-\Delta\tau\left[-\frac{U}{2}\right](\hat{n}_{\uparrow}-\hat{n}_{\downarrow})^{2}}
    = \frac{1}{4}\sum_{s=\pm1,\pm2}e^{-S_{\text{GH}}(s)-\Delta\tau\hat{V}(s)}+\mathcal{O}\left((\Delta\tau U)^{4}\right),\]</p><p>where <span>$\hat{V}(s)=\alpha\eta(s)(\hat{n}_{\uparrow}-\hat{n}_{\downarrow})$</span> and <span>$\alpha = \sqrt{U/(2\Delta\tau)}$</span>. In the above expression,</p><p class="math-container">\[S_{\text{GH}}(s)=-\log\left(1+\sqrt{6}\left(1-\tfrac{2}{3}|s|\right)\right)\]</p><p>and</p><p class="math-container">\[\eta(s)=\frac{s}{|s|}\sqrt{6(1-\sqrt{6})+4\sqrt{6}|s|}.\]</p><p>Note that <span>$\alpha$</span> is strictly real when <span>$U \ge 0$</span> and strictly imaginary when <span>$U &lt; 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Hubbard/HubbardSpinGaussHermiteHST.jl#L1-L26">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.HubbardSpinGaussHermiteHST-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.HubbardSpinGaussHermiteHST-Tuple{}"><code>SmoQyDQMC.HubbardSpinGaussHermiteHST</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">HubbardSpinGaussHermiteHST(;
    # KEYWORD ARGUMENTS
    hubbard_parameters::HubbardParameters{E},
    β::E, Δτ::E, rng::AbstractRNG
) where {E&lt;:AbstractFloat}</code></pre><p>Initialize an instance of the <a href="#SmoQyDQMC.HubbardSpinGaussHermiteHST"><code>HubbardSpinGaussHermiteHST</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Hubbard/HubbardSpinGaussHermiteHST.jl#L57-L65">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.HubbardDensityHirschHST"><a class="docstring-binding" href="#SmoQyDQMC.HubbardDensityHirschHST"><code>SmoQyDQMC.HubbardDensityHirschHST</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HubbardDensityHirschHST{T,R} &lt;: AbstractSymHST{T,R}</code></pre><p>This type represents a Hubbard-Stratonovich (HS) transformation for decoupling the local Hubbard interaction in the density channel, where the introduced HS fields take on the two discrete values <span>$s = \pm 1$</span>. Specifically, the Hubbard interaction is decoupled as</p><p class="math-container">\[e^{-\Delta\tau U\left(n_{\uparrow}-\tfrac{1}{2}\right)\left(n_{\downarrow}-\tfrac{1}{2}\right)} =
\gamma\sum_{s=\pm1}e^{-\Delta\tau\alpha(n_{\uparrow}+n_{\downarrow}-1)s},\]</p><p>where</p><p class="math-container">\[\gamma = \frac{1}{2}e^{\Delta\tau U/4}\]</p><p>and</p><p class="math-container">\[\alpha = \frac{1}{\Delta\tau}\cosh\left(e^{-\Delta\tau U/2}\right).\]</p><p>Note that when <span>$U \le 0$</span> then <span>$\alpha$</span> is real, whereas if <span>$U &gt; 0$</span> then <span>$\alpha$</span> is purely imaginary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Hubbard/HubbardDensityHirschHST.jl#L1-L20">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.HubbardDensityHirschHST-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.HubbardDensityHirschHST-Tuple{}"><code>SmoQyDQMC.HubbardDensityHirschHST</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">HubbardDensityHirschHST(;
    # KEYWORD ARGUMENTS
    hubbard_parameters::HubbardParameters{E},
    β::E, Δτ::E, rng::AbstractRNG
) where {E&lt;:AbstractFloat}</code></pre><p>Initialize an instance of the <a href="#SmoQyDQMC.HubbardDensityHirschHST"><code>HubbardDensityHirschHST</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Hubbard/HubbardDensityHirschHST.jl#L52-L60">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.HubbardDensityGaussHermiteHST"><a class="docstring-binding" href="#SmoQyDQMC.HubbardDensityGaussHermiteHST"><code>SmoQyDQMC.HubbardDensityGaussHermiteHST</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HubbardDensityGaussHermiteHST{T,R} &lt;: AbstractSymHST{T,R}</code></pre><p>This type represents a Hubbard-Stratonovich (HS) transformation for decoupling the local Hubbard interaction in the density channel, where the introduced HS fields take on the four discrete values <span>$s \in \{ -2, -1, +1, +2 \}.$</span> Note that the Hubbard interaction can be written in the density channel as</p><p class="math-container">\[U(\hat{n}_{\uparrow}-\tfrac{1}{2})(\hat{n}_{\downarrow}-\tfrac{1}{2})=-\tfrac{U}{2}(\hat{n}_{\uparrow}+\hat{n}_{\downarrow}-1)^{2}-\tfrac{U}{4},\]</p><p>different only by a constant energy offset <span>$-U/4$</span> which does not matter. Therefore, we can perform a Gauss-Hermite Hubbard-Statonovich transformation in the density channel as</p><p class="math-container">\[e^{-\Delta\tau\left[\frac{U}{2}\right](\hat{n}_{\uparrow}+\hat{n}_{\downarrow}-1)^{2}}
 = \frac{1}{4}\sum_{s=\pm1,\pm2}e^{-S_{\text{GF}}(s)-\Delta\tau\hat{V}(s)}+\mathcal{O}\left((\Delta\tau U)^{4}\right)\]</p><p>where <span>$\hat{V}(s)=\alpha\eta(s)(\hat{n}_{\uparrow}+\hat{n}_{\downarrow}-1)$</span> and <span>$\alpha = \sqrt{-U/(2\Delta\tau)}$</span>. In the above expression,</p><p class="math-container">\[S_{\text{GH}}(s)=-\log\left(1+\sqrt{6}\left(1-\tfrac{2}{3}|s|\right)\right)\]</p><p>and</p><p class="math-container">\[\eta(s)=\frac{s}{|s|}\sqrt{6(1-\sqrt{6})+4\sqrt{6}|s|}.\]</p><p>Note that <span>$\alpha$</span> is strictly real when <span>$U \le 0$</span> and strictly imaginary when <span>$U &gt; 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Hubbard/HubbardDensityGaussHermiteHST.jl#L2-L27">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.HubbardDensityGaussHermiteHST-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.HubbardDensityGaussHermiteHST-Tuple{}"><code>SmoQyDQMC.HubbardDensityGaussHermiteHST</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">HubbardDensityGaussHermiteHST(;
    # KEYWORD ARGUMENTS
    hubbard_parameters::HubbardParameters{E},
    β::E, Δτ::E, rng::AbstractRNG
) where {E&lt;:AbstractFloat}</code></pre><p>Initialize an instance of the <a href="#SmoQyDQMC.HubbardDensityGaussHermiteHST"><code>HubbardDensityGaussHermiteHST</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Hubbard/HubbardDensityGaussHermiteHST.jl#L58-L66">source</a></section></details></article><h3 id="Extended-Hubbard-Model-Hubbard-Stratonovich-Transformations"><a class="docs-heading-anchor" href="#Extended-Hubbard-Model-Hubbard-Stratonovich-Transformations">Extended Hubbard Model Hubbard-Stratonovich Transformations</a><a id="Extended-Hubbard-Model-Hubbard-Stratonovich-Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Extended-Hubbard-Model-Hubbard-Stratonovich-Transformations" title="Permalink"></a></h3><article><details class="docstring"><summary id="SmoQyDQMC.ExtHubSpinHirschHST"><a class="docstring-binding" href="#SmoQyDQMC.ExtHubSpinHirschHST"><code>SmoQyDQMC.ExtHubSpinHirschHST</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ExtHubSpinHirschHST{T,R} &lt;: AbstractAsymHST{T,R}</code></pre><p>This type represent a Hirsch style Hubbard-Stratonovich (HS) transformation used to decouple an extended Hubbard interaction, where the introduced HS fields can take on the values <span>$s = \pm 1$</span>. The decomposition is done using the spin-channel. Here the extended Hubbard interaction is expressed as</p><p class="math-container">\[V(\hat{n}_i-1)(\hat{n}_j) = V\sum_{\sigma,\sigma&#39;} (\hat{n}_{\sigma,i}-\frac{1}{2})\hat{n}_{\sigma&#39;,j}-\frac{1}{2}).\]</p><p>Then each of the four terms on the right is decouple using a HS transformation of the form</p><p class="math-container">\[e^{-\Delta\tau V\left(n_{\sigma}-\tfrac{1}{2}\right)\left(n_{\sigma&#39;}-\tfrac{1}{2}\right)}
 = \gamma\sum_{s=\pm1}e^{-\Delta\tau\alpha(n_{\sigma}-n_{\sigma&#39;})s},\]</p><p>where</p><p class="math-container">\[\gamma=\frac{1}{2}e^{-\Delta\tau V/4}\]</p><p>and</p><p class="math-container">\[\alpha = \frac{1}{\Delta\tau}\cosh^{-1}\left(e^{\Delta\tau V/2}\right).\]</p><p>Note that when <span>$V \ge 0$</span> then <span>$\alpha$</span> is real, whereas if <span>$V&lt;0$</span> then <span>$\alpha$</span> is purely imaginary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ExtendedHubbard/ExtHubSpinHirschHST.jl#L1-L25">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.ExtHubSpinHirschHST-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.ExtHubSpinHirschHST-Tuple{}"><code>SmoQyDQMC.ExtHubSpinHirschHST</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ExtHubSpinHirschHST(;
    # KEYWORD ARGUMENTS
    extended_hubbard_parameters::ExtendedHubbardParameters{R},
    β::R, Δτ::R, rng::AbstractRNG
) where {R&lt;:AbstractFloat}</code></pre><p>Initialize an instance of the <a href="#SmoQyDQMC.ExtHubSpinHirschHST"><code>ExtHubSpinHirschHST</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ExtendedHubbard/ExtHubSpinHirschHST.jl#L62-L70">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.ExtHubDensityGaussHermiteHST"><a class="docstring-binding" href="#SmoQyDQMC.ExtHubDensityGaussHermiteHST"><code>SmoQyDQMC.ExtHubDensityGaussHermiteHST</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ExtHubDensityGaussHermiteHST{T,R} &lt;: AbstractSymHST{T,R}</code></pre><p>This type represents a Hubbard-Stratonovich (HS) transformation for decoupling the extended Hubbard interaction, where the introduced HS fields take on the four discrete values <span>$s \in \{ -2, -1, +1, +2 \}.$</span></p><p>Specifically, we perform the Gauss-Hermite Hubbard-Stratonovich transformation</p><p class="math-container">\[e^{-\Delta\tau\left[\tfrac{V}{2}\right](\hat{n}_{\mathbf{i}}+\hat{n}_{\mathbf{j}}-2)^{2}} =
= \frac{1}{4}\sum_{s=\pm1,\pm2}e^{-S_{\text{GH}}(s)-\Delta\tau\hat{V}(s)}+\mathcal{O}\left(\left[\tfrac{\Delta\tau V}{2}\right]^{4}\right)\]</p><p>where <span>$\hat{V}(s) = \alpha\eta(s)(\hat{n}_{\mathbf{i}}+\hat{n}_{\mathbf{j}}-2)$</span> and <span>$\alpha=\sqrt{\frac{-V}{2\Delta\tau}}$</span>. In the above expression,</p><p class="math-container">\[S_{\text{GH}}(s)=-\log\left(1+\sqrt{6}\left(1-\tfrac{2}{3}|s|\right)\right)\]</p><p>and</p><p class="math-container">\[\eta(s)=\frac{s}{|s|}\sqrt{6(1-\sqrt{6})+4\sqrt{6}|s|}.\]</p><p>Note that <span>$\alpha$</span> is strictly real when <span>$V \le 0$</span> and strictly imaginary when <span>$V &gt; 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ExtendedHubbard/ExtHubDensityGaussHermiteHST.jl#L1-L22">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.ExtHubDensityGaussHermiteHST-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.ExtHubDensityGaussHermiteHST-Tuple{}"><code>SmoQyDQMC.ExtHubDensityGaussHermiteHST</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ExtHubDensityGaussHermiteHST(;
    # KEYWORD ARGUMENTS
    extended_hubbard_parameters::ExtendedHubbardParameters{R},
    β::R, Δτ::R, rng::AbstractRNG
) where {R&lt;:AbstractFloat}</code></pre><p>Initialize an instance of the <a href="#SmoQyDQMC.ExtHubDensityGaussHermiteHST"><code>ExtHubDensityGaussHermiteHST</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ExtendedHubbard/ExtHubDensityGaussHermiteHST.jl#L60-L68">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.init_renormalized_hubbard_parameters-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.init_renormalized_hubbard_parameters-Tuple{}"><code>SmoQyDQMC.init_renormalized_hubbard_parameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">init_renormalized_hubbard_parameters(;
    # KEYWORD ARGUMENTS
    hubbard_parameters::HubbardParameters{E},
    hst_parameters::ExtHubDensityGaussHermiteHST{T,E},
    model_geometry::ModelGeometry{D,E}
) where {D, T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Returns a new instance of the <a href="#SmoQyDQMC.HubbardParameters"><code>HubbardParameters</code></a> type with the Hubbard interactions renormalized based on the <a href="#SmoQyDQMC.ExtHubDensityGaussHermiteHST"><code>ExtHubDensityGaussHermiteHST</code></a> definition. Refer to the definition of the <a href="#SmoQyDQMC.ExtendedHubbardModel"><code>ExtendedHubbardModel</code></a> to see where this renormalization of the local Hubbard interaction comes from.</p><p>Note that either both the local and extended Hubbard interactions need to be initialized using the particle-hole symmetric or asymmetric form for the interaction (as specified by <code>ph_sym_form</code> keyword argument), and cannot use opposite conventions. Additionally, the <a href="#SmoQyDQMC.HubbardModel"><code>HubbardModel</code></a> definition used to create the <code>hubbard_parameters</code> instance of the <a href="#SmoQyDQMC.HubbardParameters"><code>HubbardParameters</code></a> passed to this function must initialize a Hubbard interaction on each type of orbital species/ID appearing in an extended Hubbard interaction, even if this means initializing the local Hubbard interaction to <span>$U = 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ExtendedHubbard/ExtHubDensityGaussHermiteHST.jl#L100-L117">source</a></section></details></article><h2 id="Electron-Phonon-Model"><a class="docs-heading-anchor" href="#Electron-Phonon-Model">Electron-Phonon Model</a><a id="Electron-Phonon-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Electron-Phonon-Model" title="Permalink"></a></h2><ul><li><a href="#Electron-Phonon-Model-Types-and-Method">Electron-Phonon Model Types and Method</a></li><li><a href="#Electron-Phonon-Parameter-Types-and-Methods">Electron-Phonon Parameter Types and Methods</a></li><li><a href="#Electron-Phonon-Measurements">Electron-Phonon Measurements</a></li><li><a href="#Electron-Phonon-Updates">Electron-Phonon Updates</a></li></ul><h3 id="Electron-Phonon-Model-Types-and-Method"><a class="docs-heading-anchor" href="#Electron-Phonon-Model-Types-and-Method">Electron-Phonon Model Types and Method</a><a id="Electron-Phonon-Model-Types-and-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Electron-Phonon-Model-Types-and-Method" title="Permalink"></a></h3><article><details class="docstring"><summary id="SmoQyDQMC.ElectronPhononModel"><a class="docstring-binding" href="#SmoQyDQMC.ElectronPhononModel"><code>SmoQyDQMC.ElectronPhononModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ElectronPhononModel{T&lt;:Number, E&lt;:AbstractFloat, D}</code></pre><p>Defines an electron-phonon model.</p><p><strong>Fields</strong></p><ul><li><code>phonon_modes::Vector{PhononModes{E,D}}</code>: A vector of <a href="#SmoQyDQMC.PhononMode"><code>PhononMode</code></a> definitions.</li><li><code>phonon_dispersions::Vector{PhononDispersion{E,D}}</code>: A vector of <a href="#SmoQyDQMC.PhononDispersion"><code>PhononDispersion</code></a> definitions.</li><li><code>holstein_couplings_up::Vector{HolsteinCoupling{E,D}}</code>: A vector of <a href="#SmoQyDQMC.HolsteinCoupling"><code>HolsteinCoupling</code></a> definitions for spin-up.</li><li><code>holstein_couplings_dn::Vector{HolsteinCoupling{E,D}}</code>: A vector of <a href="#SmoQyDQMC.HolsteinCoupling"><code>HolsteinCoupling</code></a> definitions for spin-down.</li><li><code>ssh_couplings_up::Vector{SSHCoupling{T,E,D}}</code>: A vector of <a href="#SmoQyDQMC.SSHCoupling"><code>SSHCoupling</code></a> definitions for spin-up.</li><li><code>ssh_couplings_dn::Vector{SSHCoupling{T,E,D}}</code>: A vector of <a href="#SmoQyDQMC.SSHCoupling"><code>SSHCoupling</code></a> definitions for spin-down.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononModel.jl#L416-L429">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.ElectronPhononModel-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.ElectronPhononModel-Tuple{}"><code>SmoQyDQMC.ElectronPhononModel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ElectronPhononModel(;
    # KEYWORD ARGUMENTS
    model_geometry::ModelGeometry{D,E},
    tight_binding_model::Union{TightBindingModel{T,E,D}, Nothing} = nothing,
    tight_binding_model_up::Union{TightBindingModel{T,E,D}, Nothing} = nothing,
    tight_binding_model_dn::Union{TightBindingModel{T,E,D}, Nothing} = nothing
) where {T&lt;:Number, E&lt;:AbstractFloat, D}</code></pre><p>Initialize and return a null (empty) instance of <a href="#SmoQyDQMC.ElectronPhononModel"><code>ElectronPhononModel</code></a>. Note that either <code>tight_binding_model</code> or <code>tight_binding_model_up</code> and <code>tight_binding_model_dn</code> needs to be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononModel.jl#L451-L463">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.PhononMode"><a class="docstring-binding" href="#SmoQyDQMC.PhononMode"><code>SmoQyDQMC.PhononMode</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PhononMode{E&lt;:AbstractFloat}</code></pre><p>Defines a phonon mode <span>$\nu$</span> at location <code>\mathbf{r}_\nu</code> in the unit cell. Specifically, it defines the phonon Hamiltonian terms</p><p class="math-container">\[\hat{H}_{{\rm ph}} = \sum_{\mathbf{i}}
  \left[
      \frac{1}{2} M_{\mathbf{i},\nu}\Omega_{\mathbf{i},\nu}^{2}\hat{X}_{\mathbf{i},\nu}^{2}
    + \frac{1}{12}M_{\mathbf{i},\nu}\Omega_{4,\mathbf{i},\nu}^{2}\hat{X}_{\mathbf{i},\nu}^{4}
    + \frac{1}{2M_{\mathbf{i},\nu}}\hat{P}_{\mathbf{i},\nu}^{2}
  \right],\]</p><p>where the sum runs over unit cell <span>$\mathbf{i}$</span>, <span>$\mathbf{r}_\nu$</span> denotes the location of the phonon mode in the unit cell, <span>$M_{\mathbf{i},\nu}$</span> is the phonon mass <code>M</code>, <span>$\Omega_{\mathbf{i},\nu}$</span> is the phonon frequency that is distributed according to a normal distribution with mean <code>Ω_mean</code> and standard deviation <code>Ω_std</code>. Lastly, <span>$\Omega_{4,\mathbf{i},\nu}$</span> is the anharmonic coefficient, and is distributed according to a normal distribution with mean <code>Ω4_mean</code> and standard deviation <code>Ω4_std</code>.</p><p><strong>Fields</strong></p><ul><li><code>basis_vec::SVector{D,E}</code>: Location <span>$\mathbf{r}_\nu$</span> of phonon mode in unit cell.</li><li><code>M::E</code>:: The phonon mass <span>$M_{\mathbf{i},\nu}.$</span></li><li><code>Ω_mean::E</code>: Mean of normal distribution the phonon frequency <span>$\Omega_{\mathbf{i},\nu}$</span> is sampled from.</li><li><code>Ω_std::E</code>: Standard deviation of normal distribution the phonon frequency <span>$\Omega_{\mathbf{i},\nu}$</span> is sampled from.</li><li><code>Ω4_mean::E</code>: Mean of normal distribution the anharmonic coefficient <span>$\Omega_{4,\mathbf{i},\nu}$</span> is sampled from.</li><li><code>Ω4_std::E</code>: Standard deviation of normal distribution the anharmonic coefficient <span>$\Omega_{4,\mathbf{i},\nu}$</span> is sampled from.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononModel.jl#L1-L26">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.PhononMode-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.PhononMode-Tuple{}"><code>SmoQyDQMC.PhononMode</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PhononMode(;
    # KEYWORD ARGUMENTS
    basis_vec::AbstractVector{E},
    Ω_mean::E,
    Ω_std::E = 0.,
    M::E = 1.,
    Ω4_mean::E = 0.0,
    Ω4_std::E = 0.0,
) where {E&lt;:AbstractFloat}</code></pre><p>Initialize and return a instance of <a href="#SmoQyDQMC.PhononMode"><code>PhononMode</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononModel.jl#L48-L60">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.HolsteinCoupling"><a class="docstring-binding" href="#SmoQyDQMC.HolsteinCoupling"><code>SmoQyDQMC.HolsteinCoupling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HolsteinCoupling{E&lt;:AbstractFloat, D}</code></pre><p>Defines a Holstein coupling between a specified phonon mode and orbital density. Specifically, if <code>ph_sym_form = true</code> then a the particle-hole symmetric form of the Holstein coupling given by</p><p class="math-container">\[\begin{align*}
H = \sum_{\mathbf{i}} \Big[ 
        &amp; (\alpha_{\mathbf{i},(\mathbf{r},\kappa,\nu)} \hat{X}_{\mathbf{i},\nu}
        + \alpha_{3,\mathbf{i},(\mathbf{r},\kappa,\nu)} \hat{X}^3_{\mathbf{i},\nu}) \ (\hat{n}_{\sigma,\mathbf{i}+\mathbf{r},\kappa}-\tfrac{1}{2})\\
        &amp; + (\alpha_{2,\mathbf{i},(\mathbf{r},\kappa,\nu)} \hat{X}^2_{\mathbf{i},\nu}
        + \alpha_{4,\mathbf{i},(\mathbf{r},\kappa,\nu)} \hat{X}^4_{\mathbf{i},\nu}) \ \hat{n}_{\sigma,\mathbf{i}+\mathbf{r},\kappa} 
\Big]
\end{align*},\]</p><p>is used, whereas if <code>ph_sym_form = false</code> Holstein coupling is given by</p><p class="math-container">\[\begin{align*}
H = \sum_{\mathbf{i}} \Big[ 
        &amp; (\alpha_{\mathbf{i},(\mathbf{r},\kappa,\nu)} \hat{X}_{\mathbf{i},\nu}
        + \alpha_{3,\mathbf{i},(\mathbf{r},\kappa,\nu)} \hat{X}^3_{\mathbf{i},\nu}) \ \hat{n}_{\sigma,\mathbf{i}+\mathbf{r},\kappa}\\
        &amp; + (\alpha_{2,\mathbf{i},(\mathbf{r},\kappa,\nu)} \hat{X}^2_{\mathbf{i},\nu}
        + \alpha_{4,\mathbf{i},(\mathbf{r},\kappa,\nu)} \hat{X}^4_{\mathbf{i},\nu}) \ \hat{n}_{\sigma,\mathbf{i}+\mathbf{r},\kappa} 
\Big]
\end{align*}.\]</p><p>In the above, <span>$\sigma$</span> specifies the sum, and the sum over <span>$\mathbf{i}$</span> runs over unit cells in the lattice. In the above <span>$\nu$</span> and <span>$\kappa$</span> specify the phonon mode orbital species IDs respectively, and <span>$\mathbf{r}$</span> is a static displacement in unit cells.</p><p><strong>Fields</strong></p><ul><li><code>ph_sym_form::Bool</code>: If particle-hole symmetric form is used for Holstein coupling.</li><li><code>phonon_id::Int</code>: The ID <span>$\nu$</span> specifying phonon mode getting coupled to.</li><li><code>orbital_id::Int</code>: The ID <span>$\kappa$</span> specifying orbital species the phonon mode getting coupled to.</li><li><code>displacement::SVector{D,Int}</code>: Static displacement <span>$r$</span> in unit cells in the direction of each lattice vector.</li><li><code>α_mean::E</code>: Mean of the linear Holstein coupling coefficient <span>$\alpha_{1,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>α_std::E</code>: Standard deviation of the linear Holstein coupling coefficient <span>$\alpha_{1,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>α2_mean::E</code>: Mean of the squared Holstein coupling coefficient <span>$\alpha_{2,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>α2_std::E</code>: Standard deviation of the squared Holstein coupling coefficient <span>$\alpha_{2,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>α3_mean::E</code>: Mean of the cubic Holstein coupling coefficient <span>$\alpha_{3,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>α3_std::E</code>: Standard deviation of the cubic Holstein coupling coefficient <span>$\alpha_{3,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>α4_mean::E</code>: Mean of the quartic Holstein coupling coefficient <span>$\alpha_{4,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>α4_std::E</code>: Standard deviation of the quartic Holstein coupling coefficient <span>$\alpha_{4,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li></ul><p><strong>Comment</strong></p><p>Note that the initial orbital <code>bond.orbital[1]</code> must match the orbital species associated with phonon mode <a href="#SmoQyDQMC.PhononMode"><code>PhononMode</code></a> getting coupled to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononModel.jl#L77-L125">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.HolsteinCoupling-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.HolsteinCoupling-Tuple{}"><code>SmoQyDQMC.HolsteinCoupling</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">HolsteinCoupling(;
    # KEYWORD ARGUMENTS
    model_geometry::ModelGeometry{D,E},
    phonon_id::Int,
    orbital_id::Int,
    displacement::AbstractVector{Int},
    α_mean::E,
    α_std::E  = 0.0,
    α2_mean::E = 0.0,
    α2_std::E = 0.0,
    α3_mean::E = 0.0,
    α3_std::E = 0.0,
    α4_mean::E = 0.0,
    α4_std::E = 0.0,
    ph_sym_form::Bool = true
) where {D, E&lt;:AbstractFloat}</code></pre><p>Initialize and return a instance of <a href="#SmoQyDQMC.HolsteinCoupling"><code>HolsteinCoupling</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononModel.jl#L165-L184">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.SSHCoupling"><a class="docstring-binding" href="#SmoQyDQMC.SSHCoupling"><code>SmoQyDQMC.SSHCoupling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SSHCoupling{T&lt;:Number, E&lt;:AbstractFloat, D}</code></pre><p>Defines a Su-Schrieffer-Heeger (SSH) coupling between a pair of phonon modes. Specifically, it defines the SSH interaction term</p><p class="math-container">\[\hat{H}_{{\rm ssh}} = -\sum_{\sigma,\mathbf{i}}
    \left[ t_{\mathbf{i},(\mathbf{r},\kappa,\nu)} - \left( \sum_{n=1}^{4}\alpha_{n,\mathbf{i},(\mathbf{r},\kappa&#39;,\nu&#39;)}
    \left( \hat{X}_{\mathbf{i}+\mathbf{r},\kappa&#39;} - \hat{X}_{\mathbf{i},\nu&#39;}\right)^{n}\right) \right]
    \left( \hat{c}_{\sigma,\mathbf{i}+\mathbf{r},\kappa}^{\dagger}\hat{c}_{\sigma,\mathbf{i},\nu}+{\rm h.c.} \right),\]</p><p>where <span>$\sigma$</span> specifies the sum, and the sum over <span>$\mathbf{i}$</span> runs over unit cells in the lattice. In the above <span>$\nu$</span> and <span>$\kappa$</span> IDs specify orbital species in the unit cell, and <span>$\kappa&#39;$</span> and <span>$\nu&#39;$</span> IDs specify the phonon modes getting coupled to. Finally, <span>$\mathbf{r}$</span> is a static displacement in unit cells in the direction of each lattice vector. In that above expression <span>$t_{\mathbf{i},(\mathbf{r},\kappa,\nu)}$</span> is the bare hopping amplitude, which is not specified here.</p><p><strong>Fields</strong></p><ul><li><code>phonon_ids::NTuple{2,Int}</code>: Pair of phonon modes getting coupled together.</li><li><code>bond::Bond{D}</code>: Bond separating the two orbitals getting coupled to, which are separated by <span>$\mathbf{r} + (\mathbf{r}_\kappa - \mathbf{r}_\nu)$</span>.</li><li><code>bond_id::Int</code>: Bond ID associated with the <code>bond</code> field.</li><li><code>α_mean::T</code>: Mean of the linear SSH coupling constant <span>$\alpha_{1,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>α_std::T</code>: Standard deviation of the linear SSH coupling constant <span>$\alpha_{1,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>α2_mean::T</code>: Mean of the quadratic SSH coupling constant <span>$\alpha_{2,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>α2_std::T</code>: Standard deviation of the quadratic SSH coupling constant <span>$\alpha_{2,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>α3_mean::T</code>: Mean of the cubic SSH coupling constant <span>$\alpha_{3,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>α3_std::T</code>: Standard deviation of the cubic SSH coupling constant <span>$\alpha_{3,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>α4_mean::T</code>: Mean of the quartic SSH coupling constant <span>$\alpha_{4,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>α4_std::T</code>: Standard deviation of the quartic SSH coupling constant <span>$\alpha_{4,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>expniϕ::T</code>: Twisted boundary conditions phase factor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononModel.jl#L207-L238">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.SSHCoupling-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.SSHCoupling-Tuple{}"><code>SmoQyDQMC.SSHCoupling</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SSHCoupling(;
    # KEYWORD ARGUMENTS
    model_geometry::ModelGeometry{D,E},
    tight_binding_model::TightBindingModel{T,E,D},
    phonon_ids::NTuple{2,Int},
    bond::Bond{D},
    α_mean::Union{T,E},
    α_std::E  = 0.0,
    α2_mean::Union{T,E} = 0.0,
    α2_std::E = 0.0,
    α3_mean::Union{T,E} = 0.0,
    α3_std::E = 0.0,
    α4_mean::Union{T,E} = 0.0,
    α4_std::E = 0.0
) where {D, T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Initialize and return a instance of <a href="#SmoQyDQMC.SSHCoupling"><code>SSHCoupling</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononModel.jl#L278-L296">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.PhononDispersion"><a class="docstring-binding" href="#SmoQyDQMC.PhononDispersion"><code>SmoQyDQMC.PhononDispersion</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PhononDispersion{E&lt;:AbstractFloat, D}</code></pre><p>Defines a dispersive phonon coupling between phonon modes. Specifically, it defines the dispersive phonon term</p><p class="math-container">\[\hat{H}_{{\rm disp}} = \sum_{\mathbf{i}}
    \left(
        \frac{M_{\mathbf{i}+\mathbf{r},\kappa}M_{\mathbf{i},\nu}}{M_{\mathbf{i}+\mathbf{r},\kappa}+M_{\mathbf{i},\nu}}
    \right)
    \bigg[
                    \Omega_{\mathbf{i},(\mathbf{r},\kappa,\nu)}^{2}\Big(\hat{X}_{\mathbf{i}+\mathbf{r},\kappa}-\hat{X}_{\mathbf{i},\nu}\Big)^{2}
       +\frac{1}{12}\Omega_{4,\mathbf{i},(\mathbf{r},\kappa,\nu)}^{2}\Big(\hat{X}_{\mathbf{i}+\mathbf{r},\kappa}-\hat{X}_{\mathbf{i},\nu}\Big)^{4}
    \bigg]\]</p><p>where the sum over <span>$\mathbf{i}$</span> runs over unit cells in the lattice. In the above <span>$\nu$</span> and <span>$\kappa$</span> IDs specify the phonon modes in the unit cell, and <span>$\mathbf{r}$</span> is a static displacement in unit cells.</p><p><strong>Fields</strong></p><ul><li><code>phonon_ids::NTuple{2,Int}</code>: ID&#39;s for pair of phonon modes getting coupled together.</li><li><code>displacement::SVector{D,Int}</code>: Static displacement <span>$\mathbf{r}$</span> in unit cells separating the two phonon modes getting coupled.</li><li><code>Ω_mean::E</code>: Mean dispersive phonon frequency <span>$\Omega_{\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>Ω_std::E</code>: Standard deviation of dispersive phonon frequency <span>$\Omega_{\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>Ω4_mean::E</code>: Mean quartic dispersive phonon coefficient <span>$\Omega_{4,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li><li><code>Ω4_std::E</code>: Standard deviation of quartic dispersive phonon coefficient <span>$\Omega_{4,\mathbf{i},(\mathbf{r},\kappa,\nu)}.$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononModel.jl#L339-L364">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.PhononDispersion-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.PhononDispersion-Tuple{}"><code>SmoQyDQMC.PhononDispersion</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PhononDispersion(;
    # KEYWORD ARGUMENTS
    model_geometry::ModelGeometry{D,E},
    phonon_ids::NTuple{2,Int},
    displacement::AbstractVector{Int},
    Ω_mean::E,
    Ω_std::E=0.0,
    Ω4_mean::E=0.0,
    Ω4_std::E=0.0
) where {E&lt;:AbstractFloat, D}</code></pre><p>Initialize and return a instance of <a href="#SmoQyDQMC.PhononDispersion"><code>PhononDispersion</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononModel.jl#L386-L399">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.add_phonon_mode!"><a class="docstring-binding" href="#SmoQyDQMC.add_phonon_mode!"><code>SmoQyDQMC.add_phonon_mode!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_phonon_mode!(;
    # KEYWORD ARGUMENTS
    electron_phonon_model::ElectronPhononModel{T,E,D},
    phonon_mode::PhononMode{E,D}
) where {T&lt;:Number, E&lt;:AbstractFloat, D}</code></pre><p>Add a <a href="#SmoQyDQMC.PhononMode"><code>PhononMode</code></a> to an <a href="#SmoQyDQMC.ElectronPhononModel"><code>ElectronPhononModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononModel.jl#L701-L709">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.add_holstein_coupling!"><a class="docstring-binding" href="#SmoQyDQMC.add_holstein_coupling!"><code>SmoQyDQMC.add_holstein_coupling!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_holstein_coupling!(;
    # KEYWORD ARGUMENTS
    model_geometry::ModelGeometry{D,E},
    electron_phonon_model::ElectronPhononModel{T,E,D},
    holstein_coupling::Union{HolsteinCoupling{E,D}, Nothing} = nothing,
    holstein_coupling_up::Union{HolsteinCoupling{E,D}, Nothing} = nothing,
    holstein_coupling_dn::Union{HolsteinCoupling{E,D}, Nothing} = nothing
) where {T,E,D}</code></pre><p>Add the <a href="#SmoQyDQMC.HolsteinCoupling"><code>HolsteinCoupling</code></a> to an <a href="#SmoQyDQMC.ElectronPhononModel"><code>ElectronPhononModel</code></a>. Note that either <code>holstein_coupling</code> or <code>holstein_coupling_up</code> and <code>holstein_coupling_dn</code> must be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononModel.jl#L754-L766">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.add_ssh_coupling!"><a class="docstring-binding" href="#SmoQyDQMC.add_ssh_coupling!"><code>SmoQyDQMC.add_ssh_coupling!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_ssh_coupling!(;
    # KEYWORD ARGUMENTS
    electron_phonon_model::ElectronPhononModel{T,E,D},
    tight_binding_model::Union{TightBindingModel{T,E,D}, Nothing} = nothing,
    ssh_coupling::Union{SSHCoupling{T,E,D}, Nothing} = nothing,
    tight_binding_model_up::Union{TightBindingModel{T,E,D}, Nothing} = nothing,
    tight_binding_model_dn::Union{TightBindingModel{T,E,D}, Nothing} = nothing,
    ssh_coupling_up::Union{SSHCoupling{T,E,D}, Nothing} = nothing,
    ssh_coupling_dn::Union{SSHCoupling{T,E,D}, Nothing} = nothing
) where {T,E,D}</code></pre><p>Add a <a href="#SmoQyDQMC.SSHCoupling"><code>SSHCoupling</code></a> to an <a href="#SmoQyDQMC.ElectronPhononModel"><code>ElectronPhononModel</code></a>. Note that either <code>ssh_coupling</code> and <code>tight_binding_model</code> or <code>ssh_coupling_up</code>, <code>ssh_coupling_dn</code>, <code>tight_binding_model_up</code> and <code>tight_binding_model_dn</code> need to be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononModel.jl#L809-L825">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.add_phonon_dispersion!"><a class="docstring-binding" href="#SmoQyDQMC.add_phonon_dispersion!"><code>SmoQyDQMC.add_phonon_dispersion!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_phonon_dispersion!(;
    # KEYWORD ARGUMENTS
    electron_phonon_model::ElectronPhononModel{T,E,D},
    phonon_dispersion::PhononDispersion{E,D},
    model_geometry::ModelGeometry{D,E}
) where {T,E,D}</code></pre><p>Add a <a href="#SmoQyDQMC.PhononDispersion"><code>PhononDispersion</code></a> to an <a href="#SmoQyDQMC.ElectronPhononModel"><code>ElectronPhononModel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononModel.jl#L723-L732">source</a></section></details></article><h3 id="Electron-Phonon-Parameter-Types-and-Methods"><a class="docs-heading-anchor" href="#Electron-Phonon-Parameter-Types-and-Methods">Electron-Phonon Parameter Types and Methods</a><a id="Electron-Phonon-Parameter-Types-and-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Electron-Phonon-Parameter-Types-and-Methods" title="Permalink"></a></h3><article><details class="docstring"><summary id="SmoQyDQMC.ElectronPhononParameters"><a class="docstring-binding" href="#SmoQyDQMC.ElectronPhononParameters"><code>SmoQyDQMC.ElectronPhononParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ElectronPhononParameters{T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Describes all parameters in the electron-phonon model.</p><p><strong>Fields</strong></p><ul><li><code>β::E</code>: Inverse temperature.</li><li><code>Δτ::E</code>: Discretization in imaginary time.</li><li><code>Lτ::Int</code>: Length of imaginary time axis.</li><li><code>x::Matrix{E}</code>: Phonon fields, where each column represents the phonon fields for a given imaginary time slice.</li><li><code>phonon_parameters::PhononParameters{E,D}</code>: Refer to <a href="#SmoQyDQMC.PhononParameters"><code>PhononParameters</code></a>.</li><li><code>holstein_parameters_up::HolsteinParameters{E}</code>: Spin up <a href="#SmoQyDQMC.HolsteinParameters"><code>HolsteinParameters</code></a>.</li><li><code>holstein_parameters_dn::HolsteinParameters{E}</code>: Spin down <a href="#SmoQyDQMC.HolsteinParameters"><code>HolsteinParameters</code></a>.</li><li><code>ssh_parameters_up::SSHParameters{T}</code>: Spin up <a href="#SmoQyDQMC.SSHParameters"><code>SSHParameters</code></a>.</li><li><code>ssh_parameters_dn::SSHParameters{T}</code>: Spin down <a href="#SmoQyDQMC.SSHParameters"><code>SSHParameters</code></a>.</li><li><code>dispersion_parameters::DispersionParameters{E}</code>: Refer to <a href="#SmoQyDQMC.DispersionParameters"><code>DispersionParameters</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononParameters.jl#L1-L18">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.ElectronPhononParameters-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.ElectronPhononParameters-Tuple{}"><code>SmoQyDQMC.ElectronPhononParameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ElectronPhononParameters(;
    β::E, Δτ::E,
    model_geometry::ModelGeometry{D,E},
    tight_binding_parameters::Union{TightBindingParameters{T,E}, Nothing} = nothing,
    tight_binding_parameters_up::Union{TightBindingParameters{T,E}, Nothing} = nothing,
    tight_binding_parameters_dn::Union{TightBindingParameters{T,E}, Nothing} = nothing,
    electron_phonon_model::ElectronPhononModel{T,E,D},
    rng::AbstractRNG
) where {T,E,D}</code></pre><p>Initialize and return an instance of <a href="#SmoQyDQMC.ElectronPhononParameters"><code>ElectronPhononParameters</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononParameters.jl#L52-L64">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.PhononParameters"><a class="docstring-binding" href="#SmoQyDQMC.PhononParameters"><code>SmoQyDQMC.PhononParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PhononParameters{E&lt;:AbstractFloat}</code></pre><p>Defines the parameters for each phonon in the lattice, includes the phonon field configuration.</p><p><strong>Fields</strong></p><ul><li><code>nphonon::Int</code>: Number of type of phonon modes.</li><li><code>Nphonon::Int</code>: Total number of phonon modes in finite lattice.</li><li><code>M::Int</code>: Mass of each phonon mode.</li><li><code>Ω::Int</code>: Frequency of each phonon mode.</li><li><code>Ω4::Int</code>: Quartic phonon coefficient for each phonon mode.</li><li><code>basis_vecs::Vector{Vector{E}}</code>: Basis vector for each of the <code>nphonon</code> types of phonon mode.`</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/PhononParameters.jl#L1-L14">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.HolsteinParameters"><a class="docstring-binding" href="#SmoQyDQMC.HolsteinParameters"><code>SmoQyDQMC.HolsteinParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HolsteinParameters{E&lt;:AbstractFloat}</code></pre><p>Defines the Holstein coupling parameters in lattice.</p><p><strong>Fields</strong></p><ul><li><code>nholstein::Int</code>: The number of type of holstein couplings.</li><li><code>Nholstein::Int</code>: Total number of Holstein couplings in lattice.</li><li><code>α::Vector{T}</code>: Linear Holstein coupling.</li><li><code>α2::Vector{T}</code>: Quadratic Holstein coupling.</li><li><code>α3::Vector{T}</code>: Cubic Holstein coupling.</li><li><code>α4::Vector{T}</code>: Quartic Holstein coupling.</li><li><code>ph_sym_form::Vector{Bool}</code>: If particle-hole symmetric form is used for Holstein coupling.</li><li><code>coupling_to_site::Vector{Int}</code>: Maps each Holstein coupling in the lattice to the corresponding site in the lattice.</li><li><code>coupling_to_phonon::Vector{Int}</code>: Maps each Holstein coupling in the lattice to the corresponding phonon mode.</li><li><code>phonon_to_coupling::Vector{Vector{Int}}</code>: Maps each phonon model to correspond Holstein couplings.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/HolsteinParameters.jl#L1-L18">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.SSHParameters"><a class="docstring-binding" href="#SmoQyDQMC.SSHParameters"><code>SmoQyDQMC.SSHParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SSHParameters{T&lt;:Number}</code></pre><p>Defines the SSH coupling parameters in lattice.</p><p><strong>Fields</strong></p><ul><li><code>nssh::Int</code>: Number of types of SSH couplings.</li><li><code>Nssh::Int</code>: Number of SSH couplings in lattice.</li><li><code>α::Vector{T}</code>: Linear SSH coupling.</li><li><code>α2::Vector{T}</code>: Quadratic SSH coupling.</li><li><code>α3::Vector{T}</code>: Cubic SSH coupling.</li><li><code>α4::Vector{T}</code>: Quartic SSH coupling.`</li><li><code>neighbor_table::Matrix{Int}</code>: Neighbor table to SSH coupling.</li><li><code>coupling_to_phonon::Matrix{Int}</code>: Maps each SSH coupling onto that pair of coupled phonons.</li><li><code>init_phonon_to_coupling::Vector{Vector{Int}}</code>: Maps initial phonon mode to corresponding SSH coupling(s).</li><li><code>final_phonon_to_coupling::Vector{Vector{Int}}</code>: Maps final phonon mode to corresponding SSH coupling(s).</li><li><code>hopping_to_couplings::Vector{Vector{Int}}</code>: Maps hopping in the tight-binding model onto SSH couplings.</li><li><code>coupling_to_hopping::Vector{Int}</code>: Maps each SSH coupling onto the corresponding hopping in the tight-binding model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/SSHParameters.jl#L1-L20">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.DispersionParameters"><a class="docstring-binding" href="#SmoQyDQMC.DispersionParameters"><code>SmoQyDQMC.DispersionParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DispersionParameters{E&lt;:AbstractFloat}</code></pre><p>Defines the dispersive phonon coupling parameters in the lattice.</p><p><strong>Fields</strong></p><ul><li><code>ndispersion::Int</code>: Number of types of dispersive couplings.</li><li><code>Ndispersion::Int</code>: Number of dispersive couplings in the lattice.</li><li><code>Ω::Vector{E}</code>: Frequency of dispersive phonon coupling.</li><li><code>Ω4::Vector{E}</code>: Quartic coefficient for the phonon dispersion.</li><li><code>dispersion_to_phonon::Matrix{Int}</code>: Pair of phonon modes in lattice coupled by dispersive coupling.</li><li><code>init_phonon_to_coupling::Vector{Vector{Int}}</code>: Maps initial phonon mode to corresponding dispersive phonon coupling.</li><li><code>final_phonon_to_coupling::Vector{Vector{Int}}</code>: Maps final phonon mode to corresponding dispersive phonon coupling.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/DispersionParameters.jl#L1-L15">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.initialize!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}"><a class="docstring-binding" href="#SmoQyDQMC.initialize!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}"><code>SmoQyDQMC.initialize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize!(
    fermion_path_integral_up::FermionPathIntegral{H,T},
    fermion_path_integral_dn::FermionPathIntegral{H,T},
    electron_phonon_parameters::ElectronPhononParameters{T,R}
) where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}</code></pre><p>Initialize the contribution of an <a href="#SmoQyDQMC.ElectronPhononParameters"><code>ElectronPhononParameters</code></a> to a <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononParameters.jl#L156-L164">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.initialize!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}"><a class="docstring-binding" href="#SmoQyDQMC.initialize!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}"><code>SmoQyDQMC.initialize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">initialize!(
    # ARGUMENTS
    fermion_path_integral::FermionPathIntegral{H,T},
    electron_phonon_parameters::ElectronPhononParameters{T,R};
    # KEYWORD ARGUMENTS
    spin::Int = +1
) where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}</code></pre><p>Initialize the contribution of an <a href="#SmoQyDQMC.ElectronPhononParameters"><code>ElectronPhononParameters</code></a> to a <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononParameters.jl#L180-L190">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.update!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}, Matrix{R}, Matrix{R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}"><a class="docstring-binding" href="#SmoQyDQMC.update!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}, Matrix{R}, Matrix{R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}"><code>SmoQyDQMC.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(
    fermion_path_integral_up::FermionPathIntegral{H,T},
    fermion_path_integral_dn::FermionPathIntegral{H,T},
    electron_phonon_parameters::ElectronPhononParameters{T,R},
    x′::Matrix{R},
    x::Matrix{R}
) where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}</code></pre><p>Update a <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> to reflect a change in the phonon configuration from <code>x</code> to <code>x′</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononParameters.jl#L221-L231">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.update!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}, Matrix{R}, Matrix{R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}"><a class="docstring-binding" href="#SmoQyDQMC.update!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}, Matrix{R}, Matrix{R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}"><code>SmoQyDQMC.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(
    # ARGUMENTS
    fermion_path_integral::FermionPathIntegral{H,T},
    electron_phonon_parameters::ElectronPhononParameters{T,R},
    x′::Matrix{R},
    x::Matrix{R};
    # KEYWORD ARGUMENTS
    spin::Int = +1
) where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}</code></pre><p>Update a <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> to reflect a change in the phonon configuration from <code>x</code> to <code>x′</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononParameters.jl#L249-L261">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.update!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}, Matrix{R}, Int64}} where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}"><a class="docstring-binding" href="#SmoQyDQMC.update!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}, Matrix{R}, Int64}} where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}"><code>SmoQyDQMC.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(
    # ARGUMENTS
    fermion_path_integral::FermionPathIntegral{H,T},
    electron_phonon_parameters::ElectronPhononParameters{T,R},
    x::Matrix{R},
    sgn::Int;
    # KEYWORD ARGUMENTS
    spin::Int = +1
) where {H&lt;:Number, T&lt;:Number, R&lt;:AbstractFloat}</code></pre><p>Update a <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> according to <code>sgn * x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ElectronPhononParameters.jl#L291-L303">source</a></section></details></article><h3 id="Electron-Phonon-Measurements"><a class="docs-heading-anchor" href="#Electron-Phonon-Measurements">Electron-Phonon Measurements</a><a id="Electron-Phonon-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Electron-Phonon-Measurements" title="Permalink"></a></h3><article><details class="docstring"><summary id="SmoQyDQMC.measure_phonon_kinetic_energy"><a class="docstring-binding" href="#SmoQyDQMC.measure_phonon_kinetic_energy"><code>SmoQyDQMC.measure_phonon_kinetic_energy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure_phonon_kinetic_energy(
    electron_phonon_parameters::ElectronPhononParameters{T,E},
    n::Int
) where {T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Evaluate the average phonon kinetic energy for phonon mode <code>n</code>. The measurement is made using the expression</p><p class="math-container">\[\langle K \rangle = \frac{1}{2\Delta\tau} - \frac{M}{2}\bigg\langle\frac{(x_{l+1}-x_{l})^{2}}{\Delta\tau^{2}}\bigg\rangle. \]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/phonon_measurements.jl#L5-L16">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.measure_phonon_potential_energy"><a class="docstring-binding" href="#SmoQyDQMC.measure_phonon_potential_energy"><code>SmoQyDQMC.measure_phonon_potential_energy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure_phonon_potential_energy(
    electron_phonon_parameters::ElectronPhononParameters{T,E},
    n::Int
) where {T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Calculate the average phonon potential energy, given by</p><p class="math-container">\[U = \frac{1}{2} M \Omega^2 \langle \hat{X}^2 \rangle + \frac{1}{24} M \Omega_4^2 \langle \hat{X}^4 \rangle,\]</p><p>for phonon mode <code>n</code> in the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/phonon_measurements.jl#L72-L83">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.measure_phonon_position_moment"><a class="docstring-binding" href="#SmoQyDQMC.measure_phonon_position_moment"><code>SmoQyDQMC.measure_phonon_position_moment</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure_phonon_position_moment(
    electron_phonon_parameters::ElectronPhononParameters{T,E},
    n::Int, m::Int
) where {T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Measure <span>$\langle X^m \rangle$</span> for phonon mode <code>n</code> in the unit cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/phonon_measurements.jl#L146-L153">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.measure_holstein_energy"><a class="docstring-binding" href="#SmoQyDQMC.measure_holstein_energy"><code>SmoQyDQMC.measure_holstein_energy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure_holstein_energy(
    holstein_parameters::HolsteinParameters{E},
    G::Matrix{T},
    x::Matrix{E},
    holstein_id::Int
) where {T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Calculate and return both the spin-resolved Holstein interaction energy</p><p class="math-container">\[\epsilon_{{\rm hol},\sigma} = 
                            \left\langle
                                [
                                    \alpha   \hat{X}   + \alpha_2 \hat{X}^2
                                  + \alpha_3 \hat{X}^3 + \alpha_4 \hat{X}^4
                                ]
                                \left(
                                    \hat{n}_\sigma - \frac{1}{2}
                                \right)
                            \right\rangle,\]</p><p>corresponding to <code>holstein_id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/holstein_measurements.jl#L5-L27">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.measure_ssh_energy"><a class="docstring-binding" href="#SmoQyDQMC.measure_ssh_energy"><code>SmoQyDQMC.measure_ssh_energy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure_ssh_energy(
    ssh_parameters::SSHParameters{T},
    G::Matrix{T}, x::Matrix{E}, ssh_id::Int
) where {T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Calculate the return the SSH interaction energy</p><p class="math-container">\[\epsilon_{\rm ssh} = \left\langle [\alpha \hat{X}     + \alpha_2 \hat{X}^2
                                   \alpha_3 \hat{X}^3 + \alpha_4 \hat{X}^4]
                        (\hat{c}^\dagger_{\sigma,i} \hat{c}_{\sigma,j} + {\rm h.c.}) \right\rangle\]</p><p>for coupling definition specified by <code>ssh_id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/ssh_measurements.jl#L5-L18">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.measure_dispersion_energy"><a class="docstring-binding" href="#SmoQyDQMC.measure_dispersion_energy"><code>SmoQyDQMC.measure_dispersion_energy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">measure_dispersion_energy(
    electron_phonon_parameters::ElectronPhononParameters{T,E},
    dispersion_id::Int
) where {T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Evaluate the average dispersion energy</p><p class="math-container">\[\epsilon_{\rm disp} = \frac{1}{2} M_{\rm red} \Omega^2 \langle(\hat{X}_i - \hat{X}_j)^2\rangle
                    + \frac{1}{24} M{\rm red} \Omega_4^2 \langle(\hat{X}_i - \hat{X}_j)^4\rangle,\]</p><p>where <span>$M_{\rm red} = \frac{M_i M_j}{M_i + M_j}$</span> is the reduced mass, for the dispersive coupling definition specified by <code>dispersion_id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/dispersion_measurements.jl#L1-L14">source</a></section></details></article><h3 id="Electron-Phonon-Updates"><a class="docs-heading-anchor" href="#Electron-Phonon-Updates">Electron-Phonon Updates</a><a id="Electron-Phonon-Updates-1"></a><a class="docs-heading-anchor-permalink" href="#Electron-Phonon-Updates" title="Permalink"></a></h3><article><details class="docstring"><summary id="SmoQyDQMC.EFAHMCUpdater"><a class="docstring-binding" href="#SmoQyDQMC.EFAHMCUpdater"><code>SmoQyDQMC.EFAHMCUpdater</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EFAHMCUpdater{T&lt;:Number, E&lt;:AbstractFloat, PFFT, PIFFT}</code></pre><p>Defines an Exact Fourier Acceleration Hamiltonian/Hybrid Monte Carlo (EFA-HMC) update for the phonon degrees of freedom.</p><p><strong>Fields</strong></p><ul><li><code>Nt::Int</code>: Number of time-steps in HMC trajectory.</li><li><code>Δt::E</code>: Average time-step size used in HMC update.</li><li><code>δ::E</code>: Time-step used in EFA-HMC update is jittered by an amount <code>Δt = Δt * (1 + δ*(2*rand(rng)-1))</code>.</li><li><code>x::Matrix{E}</code>: Records initial phonon configuration in position space.</li><li><code>p::Matrix{E}</code>: Conjugate momentum in HMC dynamics.</li><li><code>dSdx::Matrix{E}</code>: Stores the derivative of the action.</li><li><code>Gup′::Matrix{T}</code>: Intermediate spin-up Green&#39;s function matrix during HMC trajectory.</li><li><code>Gdn′::Matrix{T}</code>: Intermediate spin-down Green&#39;s function matrix during HMC trajectory.</li><li><code>efa::ExactFourierAccelerator{E,PFFT,PIFFT}</code>: Type to perform exact integration of equations of motion of quantum harmonic oscillator. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/EFAHMCUpdater.jl#L1-L18">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.EFAHMCUpdater-Tuple{}"><a class="docstring-binding" href="#SmoQyDQMC.EFAHMCUpdater-Tuple{}"><code>SmoQyDQMC.EFAHMCUpdater</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">EFAHMCUpdater(;
    # KEYWORD ARGUMENTS
    electron_phonon_parameters::ElectronPhononParameters{T,E},
    G::Matrix{T},
    Nt::Int,
    Δt::E = π/(2*Nt),
    reg::E = 0.0,
    δ::E = 0.05
) where {T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p><strong>Keyword Arguments</strong></p><ul><li><code>electron_phonon_parameters::ElectronPhononParameters{T,E}</code>: Defines electron-phonon model.</li><li><code>G::Matrix{T}</code>: Sample Green&#39;s function matrix.</li><li><code>Nt::Int</code>: Number of time-steps used in EFA-HMC update.</li><li><code>Δt::E = π/(2*Nt)</code>: Average step size used for HMC update.</li><li><code>reg::E = 0.0</code>: Regularization used for mass in equations of motion.</li><li><code>δ::E = 0.05</code>: Amount of jitter added to time-step used in EFA-HMC update.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/EFAHMCUpdater.jl#L49-L68">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, ElectronPhononParameters{T, R}, EFAHMCUpdater{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><a class="docstring-binding" href="#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, ElectronPhononParameters{T, R}, EFAHMCUpdater{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><code>SmoQyDQMC.hmc_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hmc_update!(
    # ARGUMENTS
    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,
    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,
    electron_phonon_parameters::ElectronPhononParameters{T,R},
    hmc_updater::EFAHMCUpdater{T,R};
    # KEYWORD ARGUMENTS
    fermion_path_integral_up::FermionPathIntegral{H,T},
    fermion_path_integral_dn::FermionPathIntegral{H,T},
    fermion_greens_calculator_up::FermionGreensCalculator{H,R},
    fermion_greens_calculator_dn::FermionGreensCalculator{H,R},
    fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R},
    fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R},
    Bup::Vector{P}, Bdn::Vector{P},
    δG::R, δθ::R, rng::AbstractRNG, 
    update_stabilization_frequency::Bool = false,
    δG_max::R = 1e-5,
    δG_reject::R = 1e-2,
    recenter!::Function = identity,
    Nt::Int = hmc_updater.Nt,
    Δt::R = hmc_updater.Δt,
    δ::R = hmc_updater.δ
) where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator{T}}</code></pre><p>Perform EFA-HMC update to the phonon degrees of freedom. This method returns <code>(accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ)</code>, where <code>accepted</code> is a boolean field indicating whether the proposed HMC update was accepted or rejected.</p><p><strong>Arguments</strong></p><ul><li><code>Gup::Matrix{H}</code>: Green&#39;s function matrix for spin up.</li><li><code>logdetGup::R</code>: Log determinant of Green&#39;s function matrix for spin up.</li><li><code>sgndetGup::H</code>: Sign of determinant of Green&#39;s function matrix for spin up.</li><li><code>Gdn::Matrix{H}</code>: Green&#39;s function matrix for spin down.</li><li><code>logdetGdn::R</code>: Log determinant of Green&#39;s function matrix for spin down.</li><li><code>electron_phonon_parameters::ElectronPhononParameters{T,R}</code>: Electron-phonon model parameters.</li><li><code>hmc_updater::EFAHMCUpdater{T,R}</code>: EFA-HMC updater.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral_up::FermionPathIntegral{H}</code>: Fermion path integral for spin up.</li><li><code>fermion_path_integral_dn::FermionPathIntegral{H}</code>: Fermion path integral for spin down.</li><li><code>fermion_greens_calculator_up::FermionGreensCalculator{H,R}</code>: Fermion greens calculator for spin up.</li><li><code>fermion_greens_calculator_dn::FermionGreensCalculator{H,R}</code>: Fermion greens calculator for spin down.</li><li><code>fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R}</code>: Alternative fermion greens calculator for spin up.</li><li><code>fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R}</code>: Alternative fermion greens calculator for spin down.</li><li><code>Bup::Vector{P}</code>: Spin up propagators.</li><li><code>Bdn::Vector{P}</code>: Spin down propagators.</li><li><code>δG::R</code>: Numerical error in Green&#39;s function corrected by numerical stabilization.</li><li><code>δθ::R</code>: Numerical error in the phase of the determinant of the Green&#39;s function matrix corrected by numerical stabilization.</li><li><code>rng::AbstractRNG</code>: Random number generator.</li><li><code>update_stabilization_frequency::Bool = false</code>: Whether to update the stabilization frequency.</li><li><code>δG_max::R = 1e-5</code>: Maximum numerical error in Green&#39;s function corrected by numerical stabilization.</li><li><code>δG_reject::R = 1e-2</code>: Reject the update if the numerical error in Green&#39;s function corrected by numerical stabilization is greater than this value.</li><li><code>Nt::Int = hmc_updater.Nt</code>: Number of time-steps used in EFA-HMC update.</li><li><code>Δt::R = hmc_updater.Δt</code>: Average step size used for HMC update.</li><li><code>δ::R = hmc_updater.δ</code>: Amount of jitter added to time-step used in EFA-HMC update.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/EFAHMCUpdater.jl#L93-L151">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, ElectronPhononParameters{T, R}, EFAHMCUpdater{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><a class="docstring-binding" href="#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, ElectronPhononParameters{T, R}, EFAHMCUpdater{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><code>SmoQyDQMC.hmc_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hmc_update!(
    # ARGUMENTS
    G::Matrix{H}, logdetG::R, sgndetG::H,
    electron_phonon_parameters::ElectronPhononParameters{T,R},
    hmc_updater::EFAHMCUpdater{T,R};
    # KEYWORD ARGUMENTS
    fermion_path_integral::FermionPathIntegral{H,T},
    fermion_greens_calculator::FermionGreensCalculator{H,R},
    fermion_greens_calculator_alt::FermionGreensCalculator{H,R},
    B::Vector{P},
    δG::R, δθ::R, rng::AbstractRNG,
    update_stabilization_frequency::Bool = false,
    δG_max::R = 1e-5,
    δG_reject::R = 1e-2,
    recenter!::Function = identity,
    Nt::Int = hmc_updater.Nt,
    Δt::R = hmc_updater.Δt,
    δ::R = hmc_updater.δ
) where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator{T}}</code></pre><p>Perform EFA-HMC update to the phonon degrees of freedom. This method returns <code>(accepted, logdetG, sgndetG, δG, δθ)</code>, where <code>accepted</code> is a boolean field indicating whether the proposed HMC update was accepted or rejected.</p><p><strong>Arguments</strong></p><ul><li><code>G::Matrix{H}</code>: Green&#39;s function matrix for spin up.</li><li><code>logdetG::R</code>: Log determinant of Green&#39;s function matrix for spin up.</li><li><code>sgndetG::H</code>: Sign of determinant of Green&#39;s function matrix for spin up.</li><li><code>electron_phonon_parameters::ElectronPhononParameters{T,R}</code>: Electron-phonon model parameters.</li><li><code>hmc_updater::EFAHMCUpdater{T,R}</code>: EFA-HMC updater.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral::FermionPathIntegral{H}</code>: Fermion path integral.</li><li><code>fermion_greens_calculator::FermionGreensCalculator{H,R}</code>: Fermion greens calculator.</li><li><code>fermion_greens_calculator_alt::FermionGreensCalculator{H,R}</code>: Alternative fermion greens calculator.</li><li><code>B::Vector{P}</code>: Spin up propagators.</li><li><code>δG::R</code>: Numerical error in Green&#39;s function corrected by numerical stabilization.</li><li><code>δθ::R</code>: Numerical error in the phase of the determinant of the Green&#39;s function matrix corrected by numerical stabilization.</li><li><code>rng::AbstractRNG</code>: Random number generator.</li><li><code>update_stabilization_frequency::Bool = false</code>: Whether to update the stabilization frequency.</li><li><code>δG_max::R = 1e-5</code>: Maximum numerical error in Green&#39;s function corrected by numerical stabilization.</li><li><code>δG_reject::R = 1e-2</code>: Reject the update if the numerical error in Green&#39;s function corrected by numerical stabilization is greater than this value.</li><li><code>Nt::Int = hmc_updater.Nt</code>: Number of time-steps used in EFA-HMC update.</li><li><code>Δt::R = hmc_updater.Δt</code>: Average step size used for HMC update.</li><li><code>δ::R = hmc_updater.δ</code>: Amount of jitter added to time-step used in EFA-HMC update.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/EFAHMCUpdater.jl#L450-L498">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><a class="docstring-binding" href="#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><code>SmoQyDQMC.reflection_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reflection_update!(
    # ARGUMENTS
    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,
    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,
    electron_phonon_parameters::ElectronPhononParameters{T,R};
    # KEYWORD ARGUMENTS
    fermion_path_integral_up::FermionPathIntegral{T,U},
    fermion_path_integral_dn::FermionPathIntegral{T,U},
    fermion_greens_calculator_up::FermionGreensCalculator{H,R},
    fermion_greens_calculator_dn::FermionGreensCalculator{H,R},
    fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R},
    fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R},
    Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,
    phonon_types = nothing
) where {H&lt;:Number, T&lt;:Number, U&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator{T,U}}</code></pre><p>Randomly sample a phonon mode in the lattice, and propose an update that reflects all the phonon fields associated with that phonon mode <span>$x \rightarrow -x.$</span> This function returns <code>(accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Gup::Matrix{H}</code>: Spin-up equal-time Greens function matrix.</li><li><code>logdetGup::R</code>: Log of the determinant of the spin-up equal-time Greens function matrix.</li><li><code>sgndetGup::H</code>: Sign/phase of the determinant of the spin-up equal-time Greens function matrix.</li><li><code>Gdn::Matrix{H}</code>: Spin-down equal-time Greens function matrix.</li><li><code>logdetGdn::R</code>: Log of the determinant of the spin-down equal-time Greens function matrix.</li><li><code>sgndetGdn::H</code>: Sign/phase of the determinant of the spin-down equal-time Greens function matrix.</li><li><code>electron_phonon_parameters::ElectronPhononParameters{T,R}</code>: Electron-phonon parameters, including the current phonon configuration.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral_up::FermionPathIntegral{T,U}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type for spin-up electrons.</li><li><code>fermion_path_integral_dn::FermionPathIntegral{T,U}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type for spin-down electrons.</li><li><code>fermion_greens_calculator_up::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current spin-up sector state.</li><li><code>fermion_greens_calculator_dn::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current spin-down sector state.</li><li><code>fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed spin-up sector state.</li><li><code>fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed spin-up sector state.</li><li><code>Bup::Vector{P}</code>: Spin-up propagators for each imaginary time slice.</li><li><code>Bdn::Vector{P}</code>: Spin-down propagators for each imaginary time slice.</li><li><code>rng::AbstractRNG</code>: Random number generator used in method instead of global random number generator, important for reproducibility.</li><li><code>phonon_types = nothing</code>: Collection of phonon types in the unit cell to randomly sample a phonon mode from. If <code>nothing</code> then all phonon modes in the unit cell are considered.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/reflection_update.jl#L1-L43">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><a class="docstring-binding" href="#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><code>SmoQyDQMC.reflection_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reflection_update!(
    # ARGUMENTS
    G::Matrix{H}, logdetG::R, sgndetG::H,
    electron_phonon_parameters::ElectronPhononParameters{T,R};
    # KEYWORD ARGUMENTS
    fermion_path_integral::FermionPathIntegral{H,T},
    fermion_greens_calculator::FermionGreensCalculator{H,R},
    fermion_greens_calculator_alt::FermionGreensCalculator{H,R},
    B::Vector{P}, rng::AbstractRNG,
    phonon_types = nothing
) where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator{T}}</code></pre><p>Randomly sample a phonon mode in the lattice, and propose an update that reflects all the phonon fields associated with that phonon mode <span>$x \rightarrow -x.$</span> This function returns <code>(accepted, logdetG, sgndetG)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>G::Matrix{H}</code>: equal-time Greens function matrix.</li><li><code>logdetG::R</code>: Log of the determinant of the equal-time Greens function matrix.</li><li><code>sgndetG::H</code>: Sign/phase of the determinant of the equal-time Greens function matrix.</li><li><code>electron_phonon_parameters::ElectronPhonParameters{T,R}</code>: Electron-phonon parameters, including the current phonon configuration.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral::FermionPathIntegral{H,T}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type.</li><li><code>fermion_greens_calculator::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current state.</li><li><code>fermion_greens_calculator_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed state.</li><li><code>B::Vector{P}</code>: Propagators for each imaginary time slice.</li><li><code>rng::AbstractRNG</code>: Random number generator used in method instead of global random number generator, important for reproducibility.</li><li><code>phonon_types = nothing</code>: Collection of phonon types (specified my <code>PHONON_ID</code>) in the unit cell to randomly sample a phonon mode from. If <code>nothing</code> then all phonon modes in the unit cell are considered.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/reflection_update.jl#L222-L253">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><a class="docstring-binding" href="#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><code>SmoQyDQMC.swap_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">swap_update!(
    # ARGUMENTS
    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,
    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,
    electron_phonon_parameters::ElectronPhononParameters{T,R};
    # KEYWORD ARGUMENTS
    fermion_path_integral_up::FermionPathIntegral{H,T},
    fermion_path_integral_dn::FermionPathIntegral{H,T},
    fermion_greens_calculator_up::FermionGreensCalculator{H,R},
    fermion_greens_calculator_dn::FermionGreensCalculator{H,R},
    fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R},
    fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R},
    Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,
    phonon_id_pairs = nothing
) where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator{T}}</code></pre><p>Randomly sample a pairs of phonon modes and exchange the phonon fields associated with the pair of phonon modes. This function returns <code>(accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Gup::Matrix{H}</code>: Spin-up equal-time Greens function matrix.</li><li><code>logdetGup::R</code>: Log of the determinant of the spin-up equal-time Greens function matrix.</li><li><code>sgndetGup::H</code>: Sign/phase of the determinant of the spin-up equal-time Greens function matrix.</li><li><code>Gdn::Matrix{H}</code>: Spin-down equal-time Greens function matrix.</li><li><code>logdetGdn::R</code>: Log of the determinant of the spin-down equal-time Greens function matrix.</li><li><code>sgndetGdn::H</code>: Sign/phase of the determinant of the spin-down equal-time Greens function matrix.</li><li><code>electron_phonon_parameters::ElectronPhononParameters{T,R}</code>: Electron-phonon parameters, including the current phonon configuration.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral_up::FermionPathIntegral{H,T}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type for spin-up electrons.</li><li><code>fermion_path_integral_dn::FermionPathIntegral{H,T}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type for spin-down electrons.</li><li><code>fermion_greens_calculator_up::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current spin-up sector state.</li><li><code>fermion_greens_calculator_dn::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current spin-down sector state.</li><li><code>fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed spin-up sector state.</li><li><code>fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed spin-up sector state.</li><li><code>Bup::Vector{P}</code>: Spin-up propagators for each imaginary time slice.</li><li><code>Bdn::Vector{P}</code>: Spin-down propagators for each imaginary time slice.</li><li><code>rng::AbstractRNG</code>: Random number generator used in method instead of global random number generator, important for reproducibility.</li><li><code>phonon_id_pairs = nothing</code>: Collection of phonon type pairs (specified by pairs of <code>PHONON_ID</code> values) in the unit cell to randomly sample a phonon modes from. If <code>nothing</code> then all phonon mode pairs in the unit cell are considered.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/swap_update.jl#L1-L43">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><a class="docstring-binding" href="#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><code>SmoQyDQMC.swap_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">swap_update!(
    # ARGUMENTS
    G::Matrix{H}, logdetG::R, sgndetG::H,
    electron_phonon_parameters::ElectronPhononParameters{T,R};
    # KEYWORD ARGUMENTS
    fermion_path_integral::FermionPathIntegral{H,T},
    fermion_greens_calculator::FermionGreensCalculator{H,R},
    fermion_greens_calculator_alt::FermionGreensCalculator{H,R},
    B::Vector{P}, rng::AbstractRNG,
    phonon_id_pairs = nothing
) where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator{T}}</code></pre><p>Randomly sample a pairs of phonon modes and exchange the phonon fields associated with the pair of phonon modes. This function returns <code>(accepted, logdetG, sgndetG)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>G::Matrix{H}</code>: equal-time Greens function matrix.</li><li><code>logdetG::R</code>: Log of the determinant of the equal-time Greens function matrix.</li><li><code>sgndetG::H</code>: Sign/phase of the determinant of the equal-time Greens function matrix.</li><li><code>electron_phonon_parameters::ElectronPhononParameters{T,R}</code>: Electron-phonon parameters, including the current phonon configuration.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral::FermionPathIntegral{H,T}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type.</li><li><code>fermion_greens_calculator::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current state.</li><li><code>fermion_greens_calculator_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed state.</li><li><code>B::Vector{P}</code>: Propagators for each imaginary time slice.</li><li><code>rng::AbstractRNG</code>: Random number generator used in method instead of global random number generator, important for reproducibility.</li><li><code>phonon_id_pairs = nothing</code>: Collection of phonon type pairs in the unit cell to randomly sample a phonon modes from. If <code>nothing</code> then all phonon mode pairs in the unit cell are considered.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/swap_update.jl#L229-L260">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.radial_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><a class="docstring-binding" href="#SmoQyDQMC.radial_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><code>SmoQyDQMC.radial_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">radial_update!(
    # ARGUMENTS
    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,
    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,
    electron_phonon_parameters::ElectronPhononParameters{T,R};
    # KEYWORD ARGUMENTS
    fermion_path_integral_up::FermionPathIntegral{H,T},
    fermion_path_integral_dn::FermionPathIntegral{H,T},
    fermion_greens_calculator_up::FermionGreensCalculator{H,R},
    fermion_greens_calculator_dn::FermionGreensCalculator{H,R},
    fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R},
    fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R},
    Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,
    phonon_id::Union{Int, Nothing} = nothing,
    σ::R = 1.0
) where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator{T}}</code></pre><p>Perform a radial update to the phonon fields, as described by Algorithm 1 in the paper <a href="https://arxiv.org/abs/2411.18218">arXiv:2411.18218</a>. Specifically, the proposed update to the phonon fields <span>$x$</span> is a rescaling such that <span>$x \rightarrow e^{\gamma} x$</span> where <span>$\gamma \sim N(0, \sigma/\sqrt{d})$</span> and <span>$d$</span> is the number of phonon fields being updated.</p><p><strong>Arguments</strong></p><ul><li><code>Gup::Matrix{H}</code>: Spin-up equal-time Greens function matrix.</li><li><code>logdetGup::R</code>: Log of the determinant of the spin-up equal-time Greens function matrix.</li><li><code>sgndetGup::H</code>: Sign/phase of the determinant of the spin-up equal-time Greens function matrix.</li><li><code>Gdn::Matrix{H}</code>: Spin-down equal-time Greens function matrix.</li><li><code>logdetGdn::R</code>: Log of the determinant of the spin-down equal-time Greens function matrix.</li><li><code>sgndetGdn::H</code>: Sign/phase of the determinant of the spin-down equal-time Greens function matrix.</li><li><code>electron_phonon_parameters::ElectronPhononParameters{T,R}</code>: Electron-phonon parameters, including the current phonon configuration.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral_up::FermionPathIntegral{H,T}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type for spin-up electrons.</li><li><code>fermion_path_integral_dn::FermionPathIntegral{H,T}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type for spin-down electrons.</li><li><code>fermion_greens_calculator_up::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current spin-up sector state.</li><li><code>fermion_greens_calculator_dn::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current spin-down sector state.</li><li><code>fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed spin-up sector state.</li><li><code>fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed spin-up sector state.</li><li><code>Bup::Vector{P}</code>: Spin-up propagators for each imaginary time slice.</li><li><code>Bdn::Vector{P}</code>: Spin-down propagators for each imaginary time slice.</li><li><code>rng::AbstractRNG</code>: Random number generator used in method instead of global random number generator, important for reproducibility.</li><li><code>phonon_id::Union{Int, Nothing} = nothing</code>: Apply radial update to phonon fields corresponding tp specified <code>PHONON_ID</code>. If <code>phonon_id = nothing</code>, then radial update is applied to all phonon fields.</li><li><code>σ::R = 1.0</code>: Relative size of the radial update.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/radial_update.jl#L1-L48">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.radial_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><a class="docstring-binding" href="#SmoQyDQMC.radial_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:(AbstractPropagator{T})}"><code>SmoQyDQMC.radial_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">radial_update!(
    # ARGUMENTS
    G::Matrix{H}, logdetG::R, sgndetG::H,
    electron_phonon_parameters::ElectronPhononParameters{T,R};
    # KEYWORD ARGUMENTS
    fermion_path_integral::FermionPathIntegral{H,T},
    fermion_greens_calculator::FermionGreensCalculator{H,R},
    fermion_greens_calculator_alt::FermionGreensCalculator{H,R},
    B::Vector{P}, rng::AbstractRNG,
    phonon_id::Union{Int, Nothing} = nothing,
    σ::R = 1.0
) where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator{T}}</code></pre><p>Perform a radial update to the phonon fields, as described by Algorithm 1 in the paper <a href="https://arxiv.org/abs/2411.18218">arXiv:2411.18218</a>. Specifically, the proposed update to the phonon fields <span>$x$</span> is a rescaling such that <span>$x \rightarrow e^{\gamma} x$</span> where <span>$\gamma \sim N(0, \sigma/\sqrt{d})$</span> and <span>$d$</span> is the number of phonon fields being updated.</p><p><strong>Arguments</strong></p><ul><li><code>G::Matrix{H}</code>: equal-time Greens function matrix.</li><li><code>logdetG::R</code>: Log of the determinant of the equal-time Greens function matrix.</li><li><code>sgndetG::H</code>: Sign/phase of the determinant of the equal-time Greens function matrix.</li><li><code>electron_phonon_parameters::ElectronPhononParameters{T,R}</code>: Electron-phonon parameters, including the current phonon configuration.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fermion_path_integral::FermionPathIntegral{H,T}</code>: An instance of <a href="#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type.</li><li><code>fermion_greens_calculator::FermionGreensCalculator{H,R}</code>: Contains matrix factorization information for current state.</li><li><code>fermion_greens_calculator_alt::FermionGreensCalculator{H,R}</code>: Used to calculate matrix factorizations for proposed state.</li><li><code>B::Vector{P}</code>: Propagators for each imaginary time slice.</li><li><code>rng::AbstractRNG</code>: Random number generator used in method instead of global random number generator, important for reproducibility.</li><li><code>phonon_id::Union{Int, Nothing} = nothing</code>: Apply radial update to phonon fields corresponding tp specified <code>PHONON_ID</code>. If <code>phonon_id = nothing</code>, then radial update is applied to all phonon fields.</li><li><code>σ::R = 1.0</code>: Relative size of the radial update.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/ElectronPhonon/radial_update.jl#L241-L277">source</a></section></details></article><h2 id="Density-and-Chemical-Potential-Tuning"><a class="docs-heading-anchor" href="#Density-and-Chemical-Potential-Tuning">Density and Chemical Potential Tuning</a><a id="Density-and-Chemical-Potential-Tuning-1"></a><a class="docs-heading-anchor-permalink" href="#Density-and-Chemical-Potential-Tuning" title="Permalink"></a></h2><article><details class="docstring"><summary id="SmoQyDQMC.update_chemical_potential!"><a class="docstring-binding" href="#SmoQyDQMC.update_chemical_potential!"><code>SmoQyDQMC.update_chemical_potential!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">update_chemical_potential!(
    # ARGUMENTS
    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,
    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H;
    # KEYWORD ARGUMENTS
    chemical_potential_tuner::MuTunerLogger{R,H},
    tight_binding_parameters::Union{TightBindingParameters, Nothing} = nothing,
    tight_binding_parameters_up::Union{TightBindingParameters, Nothing} = nothing,
    tight_binding_parameters_dn::Union{TightBindingParameters, Nothing} = nothing,
    fermion_path_integral_up::FermionPathIntegral{H},
    fermion_path_integral_dn::FermionPathIntegral{H},
    fermion_greens_calculator_up::FermionGreensCalculator{H},
    fermion_greens_calculator_dn::FermionGreensCalculator{H},
    Bup::Vector{P}, Bdn::Vector{P}
) where {H&lt;:Number, R&lt;:AbstractFloat, P&lt;:AbstractPropagator}</code></pre><p>Update the chemical potential <span>$\mu$</span> in the simulation to approach the target density/filling. This method returns the new values for <code>(logdetGup, sgndetGup, logdetGup, sgndetGup)</code>. Note that either the keyword <code>tight_binding_parameters</code> needs to be specified, or <code>tight_binding_parameters_up</code> and <code>tight_binding_parameters_dn</code> both need to be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/update_chemical_potential.jl#L1-L22">source</a></section><section><div><pre><code class="language-julia hljs">update_chemical_potential!(
    # ARGUMENTS
    G::Matrix{H}, logdetG::R, sgndetG::H;
    # KEYWORD ARGUMENTS
    chemical_potential_tuner::MuTunerLogger{R,H},
    tight_binding_parameters::TightBindingParameters,
    fermion_path_integral::FermionPathIntegral{H},
    fermion_greens_calculator::FermionGreensCalculator{H},
    B::Vector{P}
) where {H&lt;:Number, R&lt;:AbstractFloat, P&lt;:AbstractPropagator}</code></pre><p>Update the chemical potential <span>$\mu$</span> in the simulation to approach the target density/filling. This method returns the new values for <code>(logdetG, sgndetG)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/update_chemical_potential.jl#L86-L100">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.save_density_tuning_profile"><a class="docstring-binding" href="#SmoQyDQMC.save_density_tuning_profile"><code>SmoQyDQMC.save_density_tuning_profile</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">save_density_tuning_profile(
    # ARGUMENTS
    simulation_info::SimulationInfo,
    chemical_potential_tuner::MuTunerLogger{R, H};
    # KEYWORD ARGUMENTS
    export_to_h5::Bool = true,
    export_to_csv::Bool = false,
    scientific_notation::Bool = false,
    decimals::Int = 9,
    delimiter::String = &quot; &quot;,
) where {R&lt;:AbstractFloat, H&lt;:Number}</code></pre><p>Record the history of chemical potential and density tuning that occurred during the simulation, writing the information to an HDF5 and/or CSV file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/update_chemical_potential.jl#L145-L160">source</a></section></details></article><h2 id="Measurement-Methods"><a class="docs-heading-anchor" href="#Measurement-Methods">Measurement Methods</a><a id="Measurement-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement-Methods" title="Permalink"></a></h2><ul><li><a href="#Measurement-Names">Measurement Names</a></li><li><a href="#Initialize-Measurements">Initialize Measurements</a></li><li><a href="#Make-Measurements">Make Measurements</a></li><li><a href="#Write-Measurements">Write Measurements</a></li><li><a href="#Checkpointing-Utilities">Checkpointing Utilities</a></li><li><a href="#Process-Measurements">Process Measurements</a></li><li><a href="#Export-Measurements">Export Measurements</a></li></ul><h3 id="Measurement-Names"><a class="docs-heading-anchor" href="#Measurement-Names">Measurement Names</a><a id="Measurement-Names-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement-Names" title="Permalink"></a></h3><article><details class="docstring"><summary id="SmoQyDQMC.GLOBAL_MEASUREMENTS"><a class="docstring-binding" href="#SmoQyDQMC.GLOBAL_MEASUREMENTS"><code>SmoQyDQMC.GLOBAL_MEASUREMENTS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const GLOBAL_MEASUREMENTS = (
    &quot;logdetGup&quot;,
    &quot;logdetGdn&quot;,
    &quot;sgndetGup&quot;,
    &quot;sgndetGdn&quot;,
    &quot;sgn&quot;,
    &quot;action_total&quot;,
    &quot;action_bosonic&quot;,
    &quot;action_fermionic&quot;,
    &quot;density&quot;,
    &quot;density_up&quot;,
    &quot;density_dn&quot;,
    &quot;double_occ&quot;,
    &quot;Nsqrd&quot;
)</code></pre><p>List of all the global measurements that are made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/measurement_names.jl#L145-L163">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.LOCAL_MEASUREMENTS"><a class="docstring-binding" href="#SmoQyDQMC.LOCAL_MEASUREMENTS"><code>SmoQyDQMC.LOCAL_MEASUREMENTS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">const LOCAL_MEASUREMENTS = Base.ImmutableDict(
    &quot;density&quot;                  =&gt; &quot;ORBITAL_ID&quot;,
    &quot;density_up&quot;               =&gt; &quot;ORBITAL_ID&quot;,
    &quot;density_dn&quot;               =&gt; &quot;ORBITAL_ID&quot;,
    &quot;double_occ&quot;               =&gt; &quot;ORBITAL_ID&quot;,
    &quot;onsite_energy&quot;            =&gt; &quot;ORBITAL_ID&quot;,
    &quot;onsite_energy_up&quot;         =&gt; &quot;ORBITAL_ID&quot;,
    &quot;onsite_energy_dn&quot;         =&gt; &quot;ORBITAL_ID&quot;,
    &quot;bare_hopping_energy&quot;      =&gt; &quot;HOPPING_ID&quot;,
    &quot;bare_hopping_energy_up&quot;   =&gt; &quot;HOPPING_ID&quot;,
    &quot;bare_hopping_energy_dn&quot;   =&gt; &quot;HOPPING_ID&quot;,
    &quot;hopping_energy&quot;           =&gt; &quot;HOPPING_ID&quot;,
    &quot;hopping_energy_up&quot;        =&gt; &quot;HOPPING_ID&quot;,
    &quot;hopping_energy_dn&quot;        =&gt; &quot;HOPPING_ID&quot;,
    &quot;hopping_amplitude_up&quot;     =&gt; &quot;HOPPING_ID&quot;,
    &quot;hopping_amplitude_dn&quot;     =&gt; &quot;HOPPING_ID&quot;,
    &quot;hopping_amplitude&quot;        =&gt; &quot;HOPPING_ID&quot;,
    &quot;hopping_inversion_up&quot;     =&gt; &quot;HOPPING_ID&quot;,
    &quot;hopping_inversion_dn&quot;     =&gt; &quot;HOPPING_ID&quot;,
    &quot;hopping_inversion&quot;        =&gt; &quot;HOPPING_ID&quot;,
    &quot;hubbard_energy&quot;           =&gt; &quot;HUBBARD_ID&quot;,
    &quot;ext_hub_energy&quot;           =&gt; &quot;EXT_HUB_ID&quot;,
    &quot;phonon_kin_energy&quot;        =&gt; &quot;PHONON_ID&quot;,
    &quot;phonon_pot_energy&quot;        =&gt; &quot;PHONON_ID&quot;,
    &quot;X&quot;                        =&gt; &quot;PHONON_ID&quot;,
    &quot;X2&quot;                       =&gt; &quot;PHONON_ID&quot;,
    &quot;X3&quot;                       =&gt; &quot;PHONON_ID&quot;,
    &quot;X4&quot;                       =&gt; &quot;PHONON_ID&quot;,
    &quot;holstein_energy&quot;          =&gt; &quot;HOLSTEIN_ID&quot;,
    &quot;holstein_energy_up&quot;       =&gt; &quot;HOLSTEIN_ID&quot;,
    &quot;holstein_energy_dn&quot;       =&gt; &quot;HOLSTEIN_ID&quot;,
    &quot;ssh_energy&quot;               =&gt; &quot;SSH_ID&quot;,
    &quot;ssh_energy_up&quot;            =&gt; &quot;SSH_ID&quot;,
    &quot;ssh_energy_dn&quot;            =&gt; &quot;SSH_ID&quot;,
    &quot;dispersion_energy&quot;        =&gt; &quot;DISPERSION_ID&quot;
)</code></pre><p>List of all the local measurements than can be made, with a mapping to the corresponding type of ID each measurement is reported in terms of.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/measurement_names.jl#L67-L107">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.CORRELATION_FUNCTIONS"><a class="docstring-binding" href="#SmoQyDQMC.CORRELATION_FUNCTIONS"><code>SmoQyDQMC.CORRELATION_FUNCTIONS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">CORRELATION_FUNCTIONS = Base.ImmutableDict(
    &quot;greens&quot;           =&gt; &quot;ORBITAL_ID&quot;,
    &quot;greens_up&quot;        =&gt; &quot;ORBITAL_ID&quot;,
    &quot;greens_dn&quot;        =&gt; &quot;ORBITAL_ID&quot;,
    &quot;greens_tautau&quot;    =&gt; &quot;ORBITAL_ID&quot;,
    &quot;greens_tautau_up&quot; =&gt; &quot;ORBITAL_ID&quot;,
    &quot;greens_tautau_dn&quot; =&gt; &quot;ORBITAL_ID&quot;,
    &quot;density&quot;          =&gt; &quot;ORBITAL_ID&quot;,
    &quot;density_upup&quot;     =&gt; &quot;ORBITAL_ID&quot;,
    &quot;density_dndn&quot;     =&gt; &quot;ORBITAL_ID&quot;,
    &quot;density_updn&quot;     =&gt; &quot;ORBITAL_ID&quot;,
    &quot;density_dnup&quot;     =&gt; &quot;ORBITAL_ID&quot;,
    &quot;spin_x&quot;           =&gt; &quot;ORBITAL_ID&quot;,
    &quot;spin_z&quot;           =&gt; &quot;ORBITAL_ID&quot;,
    &quot;pair&quot;             =&gt; &quot;BOND_ID&quot;,
    &quot;bond&quot;             =&gt; &quot;BOND_ID&quot;,
    &quot;bond_upup&quot;        =&gt; &quot;BOND_ID&quot;,
    &quot;bond_dndn&quot;        =&gt; &quot;BOND_ID&quot;,
    &quot;bond_updn&quot;        =&gt; &quot;BOND_ID&quot;,
    &quot;bond_dnup&quot;        =&gt; &quot;BOND_ID&quot;,
    &quot;current&quot;          =&gt; &quot;HOPPING_ID&quot;,
    &quot;current_upup&quot;     =&gt; &quot;HOPPING_ID&quot;,
    &quot;current_dndn&quot;     =&gt; &quot;HOPPING_ID&quot;,
    &quot;current_updn&quot;     =&gt; &quot;HOPPING_ID&quot;,
    &quot;current_dnup&quot;     =&gt; &quot;HOPPING_ID&quot;,
    &quot;phonon_greens&quot;    =&gt; &quot;PHONON_ID&quot;
)</code></pre><p>List of all the correlation functions that can be measured, along with the corresponding type of ID the correlation measurement is reported in terms of. Correlation functions are well defined in both position and momentum space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/measurement_names.jl#L5-L37">source</a></section></details></article><h3 id="Initialize-Measurements"><a class="docs-heading-anchor" href="#Initialize-Measurements">Initialize Measurements</a><a id="Initialize-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-Measurements" title="Permalink"></a></h3><article><details class="docstring"><summary id="SmoQyDQMC.initialize_measurement_container"><a class="docstring-binding" href="#SmoQyDQMC.initialize_measurement_container"><code>SmoQyDQMC.initialize_measurement_container</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize_measurement_container(
    model_geometry::ModelGeometry{D,T,N},
    β::T, Δτ::T
) where {T&lt;:AbstractFloat, D, N}</code></pre><p>Initialize and return a measurement container of type <code>NamedTuple</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/initialize_measurements.jl#L5-L12">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.initialize_measurements!"><a class="docstring-binding" href="#SmoQyDQMC.initialize_measurements!"><code>SmoQyDQMC.initialize_measurements!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize_measurements!(
    measurement_container::NamedTuple,
    tight_binding_model_up::TightBindingModel{T,E},
    tight_binding_model_dn::TightBindingModel{T,E},
) where {T&lt;:Number, E&lt;:AbstractFloat}

initialize_measurements!(
    measurement_container::NamedTuple,
    tight_binding_model::TightBindingModel{T,E}
) where {T&lt;:Number, E&lt;:AbstractFloat}</code></pre><p>Initialize tight-binding model related measurements.</p><p><strong>Initialized Measurements</strong></p><ul><li><code>onsite_energy</code>: Refer to <a href="#SmoQyDQMC.measure_onsite_energy"><code>measure_onsite_energy</code></a>.</li><li><code>onsite_energy_up</code>: Refer to <a href="#SmoQyDQMC.measure_onsite_energy"><code>measure_onsite_energy</code></a>.</li><li><code>onsite_energy_dn</code>: Refer to <a href="#SmoQyDQMC.measure_onsite_energy"><code>measure_onsite_energy</code></a>.</li><li><code>hopping_energy</code>: Refer to <a href="#SmoQyDQMC.measure_hopping_energy"><code>measure_hopping_energy</code></a>.</li><li><code>hopping_energy_up</code>: Refer to <a href="#SmoQyDQMC.measure_hopping_energy"><code>measure_hopping_energy</code></a>.</li><li><code>hopping_energy_dn</code>: Refer to <a href="#SmoQyDQMC.measure_hopping_energy"><code>measure_hopping_energy</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/initialize_measurements.jl#L91-L113">source</a></section><section><div><pre><code class="language-julia hljs">initialize_measurements!(
    measurement_container::NamedTuple,
    hubbard_model::HubbardModel{T}
) where {T&lt;:AbstractFloat}</code></pre><p>Initialize Hubbard model related measurements.</p><p><strong>Initialized Measurements:</strong></p><ul><li><code>hubbard_energy</code>: Refer to <a href="#SmoQyDQMC.measure_hopping_energy"><code>measure_hopping_energy</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/initialize_measurements.jl#L175-L186">source</a></section><section><div><pre><code class="language-julia hljs">initialize_measurements!(
    measurement_container::NamedTuple,
    extended_hubbard_model::ExtendedHubbardModel{T}
) where {T&lt;:AbstractFloat}</code></pre><p>Initialize Extended Hubbard model related measurements.</p><p><strong>Initialized Measurements:</strong></p><ul><li><code>ext_hubbard_energy</code>: Refer to <a href="#SmoQyDQMC.measure_ext_hub_energy"><code>measure_ext_hub_energy</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/initialize_measurements.jl#L205-L216">source</a></section><section><div><pre><code class="language-julia hljs">initialize_measurements!(
    measurement_container::NamedTuple,
    electron_phonon_model::ElectronPhononModel{T, E, D}
) where {T&lt;:Number, E&lt;:AbstractFloat, D}</code></pre><p>Initialize electron-phonon model related measurements.</p><p><strong>Initialized Measurements:</strong></p><ul><li><code>phonon_kinetic_energy</code>: Refer to <a href="#SmoQyDQMC.measure_phonon_kinetic_energy"><code>measure_phonon_kinetic_energy</code></a>.</li><li><code>phonon_potential_energy</code>: Refer to <a href="#SmoQyDQMC.measure_phonon_potential_energy"><code>measure_phonon_potential_energy</code></a>.</li><li><code>X</code>: Measure <span>$\langle \hat{X} \rangle$</span>, refer to <a href="#SmoQyDQMC.measure_phonon_position_moment"><code>measure_phonon_position_moment</code></a>.</li><li><code>X2</code>: Measure <span>$\langle \hat{X}^2 \rangle$</span>, refer to <a href="#SmoQyDQMC.measure_phonon_position_moment"><code>measure_phonon_position_moment</code></a>.</li><li><code>X3</code>: Measure <span>$\langle \hat{X}^3 \rangle$</span>, refer to <a href="#SmoQyDQMC.measure_phonon_position_moment"><code>measure_phonon_position_moment</code></a>.</li><li><code>X4</code>: Measure <span>$\langle \hat{X}^4 \rangle$</span>, refer to <a href="#SmoQyDQMC.measure_phonon_position_moment"><code>measure_phonon_position_moment</code></a>.</li><li><code>holstein_energy</code>: Refer to <a href="#SmoQyDQMC.measure_holstein_energy"><code>measure_holstein_energy</code></a>.</li><li><code>holstein_energy_up</code>: Refer to <a href="#SmoQyDQMC.measure_holstein_energy"><code>measure_holstein_energy</code></a>.</li><li><code>holstein_energy_dn</code>: Refer to <a href="#SmoQyDQMC.measure_holstein_energy"><code>measure_holstein_energy</code></a>.</li><li><code>ssh_energy</code>: Refer to <a href="#SmoQyDQMC.measure_ssh_energy"><code>measure_ssh_energy</code></a>.</li><li><code>ssh_energy_up</code>: Refer to <a href="#SmoQyDQMC.measure_ssh_energy"><code>measure_ssh_energy</code></a>.</li><li><code>ssh_energy_dn</code>: Refer to <a href="#SmoQyDQMC.measure_ssh_energy"><code>measure_ssh_energy</code></a>.</li><li><code>dispersion_energy</code>: Refer to <a href="#SmoQyDQMC.measure_dispersion_energy"><code>measure_dispersion_energy</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/initialize_measurements.jl#L235-L258">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.initialize_correlation_measurements!"><a class="docstring-binding" href="#SmoQyDQMC.initialize_correlation_measurements!"><code>SmoQyDQMC.initialize_correlation_measurements!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize_correlation_measurements!(;
    measurement_container::NamedTuple,
    model_geometry::ModelGeometry{D,T,N},
    correlation::String,
    pairs::AbstractVector{NTuple{2,Int}},
    time_displaced::Bool,
    integrated::Bool = false
)  where {T&lt;:AbstractFloat, D, N}</code></pre><p>Initialize measurements of <code>correlation</code> for all ID pairs; refer to <a href="#SmoQyDQMC.CORRELATION_FUNCTIONS"><code>CORRELATION_FUNCTIONS</code></a> for ID type associated with each correlation measurement. The name <code>correlation</code> must therefore also appear in [<code>CORRELATION_FUNCTIONS</code>]@ref. If <code>time_displaced = true</code> then time-displaced and integrated correlation measurements are made. If <code>time_displaced = false</code> and <code>integrated = false</code>, then just equal-time correlation measurements are made. If <code>time_displaced = false</code> and <code>integrated = true</code>, then both equal-time and integrated correlation measurements are made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/initialize_measurements.jl#L348-L364">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.initialize_composite_correlation_measurement!"><a class="docstring-binding" href="#SmoQyDQMC.initialize_composite_correlation_measurement!"><code>SmoQyDQMC.initialize_composite_correlation_measurement!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize_composite_correlation_measurement!(;
    measurement_container::NamedTuple,
    model_geometry::ModelGeometry{D,T,N},
    name::String,
    correlation::String,
    ids::Union{Nothing,Vector{Int}} = nothing,
    id_pairs::Union{Nothing,Vector{NTuple{2,Int}}} = nothing,
    coefficients,
    displacement_vecs = nothing,
    time_displaced::Bool,
    integrated::Bool = false
)  where {T&lt;:AbstractFloat, D, N}</code></pre><p>Initialize a composite correlation measurement called <code>name</code> based on a linear combination of local operators used in a standard <code>correlation</code> measurement.</p><p>If the keyword <code>ids</code> is passed and <code>id_pairs = nothing</code>, then the composite correlation function is given by</p><p class="math-container">\[\begin{align*}
    C_{\mathbf{r}}(\tau) &amp; = \frac{1}{N}\sum_{\mathbf{i}}\langle\hat{\Phi}_{\mathbf{i}+\mathbf{r}}^{\dagger}(\tau)\hat{\Phi}_{\mathbf{i}}^{\phantom{\dagger}}(0)\rangle \\
                         &amp; = \frac{1}{N}\sum_{\eta,\nu}\sum_{\mathbf{i}}c_{\eta}^{*}c_{\nu}\langle\hat{O}_{\mathbf{i}+\mathbf{r},\eta}^{\dagger}(\tau)\hat{O}_{\mathbf{i},\nu}^{\phantom{\dagger}}(0)\rangle \\
                         &amp; = \sum_{\eta,\nu}c_{\eta}^{*}c_{\nu}C_{\mathbf{r}}^{\eta,\nu}(\tau)
\end{align*}\]</p><p>where the composite operator is</p><p class="math-container">\[\hat{\Phi}_{\mathbf{\mathbf{r}}}(\tau)=\sum_{\nu}c_{\nu}\hat{O}_{\mathbf{r},\nu}(\tau).\]</p><p>The sum over <span>$\mathbf{i}$</span> runs over all unit cells, <span>$\mathbf{r}$</span> denotes a displacement in unit cells and <span>$N$</span> is the number unit cells. The operator type <span>$\hat{O}^{\nu}$</span> and corresponding correlation function type <span>$C_{\mathbf{r}}^{\eta,\nu}(\tau)$</span> are specified by the <code>correlation</code> keyword, while <span>$\nu$</span> corresponds to labels/IDs specified by the <code>ids</code> keyword argument. Lastly, the <span>$c_\nu$</span> coefficients are specified using the <code>coefficients</code> keyword arguments. The corresponding fourier transform of this composite correlation function measurement is given by</p><p class="math-container">\[S_{\mathbf{q}}(\tau)=\sum_{\eta,\nu}\sum_{\mathbf{r}}e^{-{\rm i}\mathbf{q}\cdot(\mathbf{r}+\mathbf{r}_{\eta}-\mathbf{r}_{\nu})}C_{\mathbf{r}}^{\eta,\nu}(\tau),\]</p><p>where the static vectors <span>$\mathbf{r}_\nu$</span> are specified using the <code>displacement_vecs</code> keyword arguments. If <code>displacement_vecs = nothing</code> then <span>$\mathbf{r}_\nu = 0$</span> for all label/ID values <span>$\nu$</span>.</p><p>On the other hand, if <code>id_pairs</code> is passed and <code>ids = nothing</code>, then the composite correlation function is given by</p><p class="math-container">\[\begin{align*}
    C_{\mathbf{r}}(\tau) &amp; = \sum_{n}c_{n}C_{\mathbf{r}}^{\eta_{n},\nu_{n}}(\tau) \\
                         &amp; = \frac{1}{N}\sum_{n}\sum_{\mathbf{i}}c_{n}\langle\hat{O}_{\mathbf{i}+\mathbf{r},\eta_{n}}^{\dagger}(\tau)\hat{O}_{\mathbf{i},\nu_{n}}^{\phantom{\dagger}}(0)\rangle,
\end{align*}\]</p><p>where the <span>$n$</span> index runs over pairs of labels/IDs <span>$(\nu_n, \eta_n)$</span> specified by the <code>id_pairs</code> keyword argument. Note that the order of the label/ID pair <span>$(\nu_n, \eta_n)$</span> reflects how each tuple in the <code>id_pairs</code> vector will be interpreted. Once again, operator type <span>$\hat{O}^{\nu_n}$</span> and corresponding correlation function type <span>$C_{\mathbf{r}}^{\eta_n,\nu_n}(\tau)$</span> are specified by the <code>correlation</code> keyword. The corresponding fourier transform of this composite correlation function measurement is given by</p><p class="math-container">\[S_{\mathbf{q}}(\tau)=\sum_{n}\sum_{\mathbf{r}}e^{-{\rm i}\mathbf{q}\cdot(\mathbf{r}+\mathbf{r}_{n})}C_{\mathbf{r}}^{\eta_{n},\nu_{n}}(\tau),\]</p><p>where the static displacement vectors <span>$\mathbf{r}_n$</span> are specified by the <code>displacement_vecs</code> keyword argument. As before, if <code>displacement_vecs = nothing</code>, then <span>$\mathbf{r}_n = 0$</span> for all <span>$n$</span>.</p><p>Note that the specified correlation type <code>correlation</code> needs to correspond to one of the keys in the global <a href="#SmoQyDQMC.CORRELATION_FUNCTIONS"><code>CORRELATION_FUNCTIONS</code></a> dictionary, which lists all the predefined types of correlation functions that can be measured.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/initialize_measurements.jl#L457-L516">source</a></section></details></article><h3 id="Make-Measurements"><a class="docs-heading-anchor" href="#Make-Measurements">Make Measurements</a><a id="Make-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Make-Measurements" title="Permalink"></a></h3><article><details class="docstring"><summary id="SmoQyDQMC.make_measurements!"><a class="docstring-binding" href="#SmoQyDQMC.make_measurements!"><code>SmoQyDQMC.make_measurements!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">make_measurements!(
    # ARGUMENTS
    measurement_container::NamedTuple,
    logdetGup::E, sgndetGup::T, Gup::AbstractMatrix{T},
    Gup_ττ::AbstractMatrix{T}, Gup_τ0::AbstractMatrix{T}, Gup_0τ::AbstractMatrix{T},
    logdetGdn::E, sgndetGdn::T, Gdn::AbstractMatrix{T},
    Gdn_ττ::AbstractMatrix{T}, Gdn_τ0::AbstractMatrix{T}, Gdn_0τ::AbstractMatrix{T};
    # KEYWORD ARGUMENTS
    fermion_path_integral_up::FermionPathIntegral{T,E},
    fermion_path_integral_dn::FermionPathIntegral{T,E},
    fermion_greens_calculator_up::FermionGreensCalculator{T,E},
    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},
    Bup::Vector{P}, Bdn::Vector{P},
    model_geometry::ModelGeometry{D,E,N},
    tight_binding_parameters::Union{Nothing, TightBindingParameters} = nothing,
    tight_binding_parameters_up::Union{Nothing, TightBindingParameters} = nothing,
    tight_binding_parameters_dn::Union{Nothing, TightBindingParameters} = nothing,
    coupling_parameters::Tuple,
    δG::E, δθ::E, δG_max::E = 1e-6
) where {T&lt;:Number, E&lt;:AbstractFloat, D, N, P&lt;:AbstractPropagator}</code></pre><p>Make measurements, including time-displaced correlation and zero Matsubara frequency measurements. This method also returns <code>(logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ)</code>. Note that either the keyword <code>tight_binding_parameters</code> needs to be specified, or <code>tight_binding_parameters_up</code> and <code>tight_binding_parameters_dn</code> both need to be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/make_measurements.jl#L5-L31">source</a></section><section><div><pre><code class="language-julia hljs">make_measurements!(
    # ARGUMENTS
    measurement_container::NamedTuple,
    logdetG::E, sgndetG::T, G::AbstractMatrix{T},
    G_ττ::AbstractMatrix{T}, G_τ0::AbstractMatrix{T}, G_0τ::AbstractMatrix{T};
    # KEYWORD ARGUMENTS
    fermion_path_integral::FermionPathIntegral{T},
    fermion_greens_calculator::FermionGreensCalculator{T,E},
    B::Vector{P},
    model_geometry::ModelGeometry{D,E,N},
    tight_binding_parameters::TightBindingParameters,
    coupling_parameters::Tuple,
    δG::E, δθ::E, δG_max::E = 1e-6
) where {T&lt;:Number, E&lt;:AbstractFloat, D, N, P&lt;:AbstractPropagator}</code></pre><p>Make measurements, including time-displaced correlation and zero Matsubara frequency measurements. This method also returns <code>(logdetG, sgndetG, δG, δθ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/make_measurements.jl#L235-L253">source</a></section></details></article><h3 id="Write-Measurements"><a class="docs-heading-anchor" href="#Write-Measurements">Write Measurements</a><a id="Write-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Write-Measurements" title="Permalink"></a></h3><article><details class="docstring"><summary id="SmoQyDQMC.write_measurements!"><a class="docstring-binding" href="#SmoQyDQMC.write_measurements!"><code>SmoQyDQMC.write_measurements!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">write_measurements!(;
    measurement_container::NamedTuple,
    simulation_info::SimulationInfo,
    model_geometry::ModelGeometry{D, E, N},
    Δτ::E,
    bin_size::Int,
    measurement::Int = 0,
    bin::Int = measurement ÷ bin_size
) where {D, E&lt;:AbstractFloat, N}</code></pre><p>Write the measurements contained in <code>measurement_container</code> to file if <code>update % bin_size == 0</code>. Measurements are written to file in a binary format using the <a href="https://github.com/JuliaIO/JLD2.jl.git"><code>JLD2.jl</code></a> package.</p><p>This function also does a few other things:</p><ol><li>Normalizes all the measurements by the <code>bin_size</code> i.e. the number of measurements that were accumulated into the measurement container.</li><li>Take position space correlation function measurements and fourier transform them to momentum space.</li><li>Integrate relevant time-displaced correlation function measurements over imaginary time to get the corresponding zero Matsubara frequency correlation function.</li><li>Reset all the measurements in <code>measurement_container</code> to zero after the measurements are written to file.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/write_measurements.jl#L5-L24">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.merge_bins"><a class="docstring-binding" href="#SmoQyDQMC.merge_bins"><code>SmoQyDQMC.merge_bins</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">merge_bins(
    # ARGUMENTS
    simulation_info::SimulationInfo
)</code></pre><p>Merge the separate HDF5 files containing the binned measurements into a single HDF5 file. This is true even if the HDF5 &quot;files&quot; containing the binned data were <a href="https://juliaio.github.io/HDF5.jl/stable/#In-memory-HDF5-files">held in memory</a> during the simulation (<code>simulation_info.write_bins_concurrent = false</code>) instead of being actively written to file during the simulation (<code>simulation_info.write_bins_concurrent = true</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/merge_bins.jl#L1-L11">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.rm_bins"><a class="docstring-binding" href="#SmoQyDQMC.rm_bins"><code>SmoQyDQMC.rm_bins</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rm_bins(
    comm::MPI.Comm,
    datafolder::String
)

rm_bins(
    datafolder::String
)</code></pre><p>Delete the binned data stored in the <code>datafolder</code> directory. This function essentially deletes the directory <code>datafolder/bins</code> and its contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/merge_bins.jl#L321-L333">source</a></section></details></article><h2 id="Checkpointing-Utilities"><a class="docs-heading-anchor" href="#Checkpointing-Utilities">Checkpointing Utilities</a><a id="Checkpointing-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Checkpointing-Utilities" title="Permalink"></a></h2><article><details class="docstring"><summary id="SmoQyDQMC.write_jld2_checkpoint"><a class="docstring-binding" href="#SmoQyDQMC.write_jld2_checkpoint"><code>SmoQyDQMC.write_jld2_checkpoint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">write_jld2_checkpoint(
    # Arguments
    comm::MPI.Comm,
    simulation_info::SimulationInfo;
    # Required Keyword Arguments
    model_geometry::ModelGeometry,
    measurement_container::NamedTuple,
    # Optional Keyword Arguments
    checkpoint_timestamp::T = 0.0,
    checkpoint_freq::T = 0.0,
    start_timestamp::T = 0.0,
    runtime_limit::T = Inf,
    error_code::Int = 13,
    # Arbitrary Keyword Arguments Written to Checkpoint
    kwargs...
) where {T&lt;:AbstractFloat}

write_jld2_checkpoint(
    # Arguments
    simulation_info::SimulationInfo;
    # Required Keyword Arguments
    model_geometry::ModelGeometry,
    measurement_container::NamedTuple,
    # Optional Keyword Arguments
    checkpoint_timestamp::T = 0.0,
    checkpoint_freq::T = 0.0,
    start_timestamp::T = 0.0,
    runtime_limit::T = Inf,
    error_code::Int = 13,
    # Arbitrary Keyword Arguments Written to Checkpoint
    kwargs...
) where {T&lt;:AbstractFloat}</code></pre><p>Checkpoint a simulation by writing a new checkpoint file if necessary The checkpoint file is a <a href="https://github.com/JuliaIO/JLD2.jl">JLD2</a> binary file.</p><p><strong>Arguments</strong></p><ul><li><code>comm::MPI.Comm</code>: (optional) MPI communicator object used to synchronize processes. Ensures all MPI processes remain synchronized.</li><li><code>simulation_info::SimulationInfo</code>: Contains datafolder and MPI process ID information.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>checkpoint_timestamp::T = 0.0</code>: (optional) Epoch timestamp of previously written checkpoint file.</li><li><code>checkpoint_freq::T = 0.0</code>: (optional) Frequency with with checkpoint files are written; new checkpoint is written only if this many seconds has elapsed since previous checkpoint.</li><li><code>start_timestamp::T = 0.0</code>: (optional) Epoch timestamp of the start time of the simulation.</li><li><code>runtime_limit::T = Inf</code>: (optional) Maximum runtime for simulation in seconds; if after writing a new checkpoint file the next checkpoint file that would be written in the future exceeds the runtime limit then exit the simulation.</li><li><code>error_code::Int = 13</code>: (optional) Error code used to exit simulation if the runtime limit is exceeded.</li><li><code>kwargs...</code>: Additional keyword arguments containing the information that will stored in the checkpoint file; keyword arguments can point to arbitrary Julia objects.</li></ul><p><strong>Notes</strong></p><p>The default values for the <code>checkpoint_timestamp</code>, <code>checkpoint_freq</code>, <code>start_timestamp</code>, and <code>runtime_limit</code> keyword arguments result in there being no runtime limit for the simulation and a new checkpoint file being written every time this function is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/checkpointing_utilities.jl#L92-L147">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.read_jld2_checkpoint"><a class="docstring-binding" href="#SmoQyDQMC.read_jld2_checkpoint"><code>SmoQyDQMC.read_jld2_checkpoint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">read_jld2_checkpoint(
    simulation_info::SimulationInfo
)</code></pre><p>Read in a checkpoint file written using the <a href="#SmoQyDQMC.write_jld2_checkpoint"><code>write_jld2_checkpoint</code></a> function and return its contents as a dictionary. This function returns the tuple <code>(checkpoint, checkpoint_timestamp)</code> where <code>checkpoint</code> is a dictionary containing the contents of the checkpoint file and <code>checkpoint_timestamp</code> is the epoch timestamp corresponding to when the checkpoint file was read in. Behind the scenes, the <a href="https://github.com/JuliaIO/JLD2.jl.git">JLD2.jl</a> package is used to read (and write) the checkpoint files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/checkpointing_utilities.jl#L1-L11">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.rm_jld2_checkpoints"><a class="docstring-binding" href="#SmoQyDQMC.rm_jld2_checkpoints"><code>SmoQyDQMC.rm_jld2_checkpoints</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rm_jld2_checkpoints(
    # ARGUMENTS
    comm::MPI.Comm,
    simulation_info::SimulationInfo
)

rm_jld2_checkpoints(
    # ARGUMENTS
    simulation_info::SimulationInfo
)</code></pre><p>Delete the JLD2 checkpoint files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/checkpointing_utilities.jl#L307-L320">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.rename_complete_simulation"><a class="docstring-binding" href="#SmoQyDQMC.rename_complete_simulation"><code>SmoQyDQMC.rename_complete_simulation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rename_complete_simulation(
    # Arguments
    comm::MPI.Comm,
    simulation_info::SimulationInfo;
    # Keyword Arguments
    delete_jld2_checkpoints::Bool = true
)

rename_complete_simulation(
    # Arguments
    simulation_info::SimulationInfo;
    # Keyword Arguments
    delete_jld2_checkpoints::Bool = true
)</code></pre><p>When a simulation is complete, this function renames the data folder the results were written to such that the directory name now begins with <code>&quot;complete_&quot;</code>, making it simpler to identify which simulations no longer need to be resumed if checkpointing is being used. This function also deletes the any checkpoint files written using the <a href="#SmoQyDQMC.write_jld2_checkpoint"><code>write_jld2_checkpoint</code></a> function if <code>delete_jld2_checkpoints = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/checkpointing_utilities.jl#L348-L369">source</a></section></details></article><h3 id="Process-Measurements"><a class="docs-heading-anchor" href="#Process-Measurements">Process Measurements</a><a id="Process-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Process-Measurements" title="Permalink"></a></h3><article><details class="docstring"><summary id="SmoQyDQMC.save_simulation_info"><a class="docstring-binding" href="#SmoQyDQMC.save_simulation_info"><code>SmoQyDQMC.save_simulation_info</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">save_simulation_info(
    # ARGUMENTS
    sim_info::SimulationInfo,
    metadata = nothing;
    # KEYWORD ARGUMENTS
    filename = @sprintf &quot;simulation_info_sID-%d_pID-%d.toml&quot; sim_info.sID sim_info.pID
)</code></pre><p>Save the contents <code>sim_info</code> to a TOML file, and add an optional additional table to the output file based on the contents of a dictionary <code>metadata</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/SimulationInfo.jl#L128-L139">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.process_measurements"><a class="docstring-binding" href="#SmoQyDQMC.process_measurements"><code>SmoQyDQMC.process_measurements</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">process_measurements(
    # ARGUMENTS
    comm::MPI.Comm;
    # KEYWORD ARGUMENTS
    datafolder::String,
    ...
)

process_measurements(;
    # KEYWORD ARGUMENTS
    datafolder::String,
    ...
)</code></pre><p>Process the HDF5 files containing the binned data generated by a DQMC simulation, and then write final statistics to a new HDF5 file(s). There is also functionality available that allows the final stats to then be exported to CSV files as well.</p><p>When the first passed arguments is <code>comm::MPI.Comm</code>, then the workflow is parallelized using MPI.</p><p><strong>Keyword Arguments</strong></p><p>This function has many possible keyword arguments. Below I group them together into related categories and define their meanings.</p><p><strong>Required Keyword Arguments</strong></p><ul><li><code>datafolder::String</code>: Specify the directory generated by a DQMC simulation into which all the results were written.</li></ul><p><strong>Keyword for Controlling Workflow</strong></p><ul><li><code>n_bins::Union{Int, Nothing} = nothing</code>: Number of bins used to calculate statistics. If <code>nothing</code> then set equal to the number of data bins written to file during the simulation. Must be a factor of the number of bins written to file during the DQMC simulation.</li><li><code>pIDs::Union{Int,Vector{Int}} = Int[]</code>: Specifies for which process IDs to calculate average statistics. If <code>pIDs = Int[]</code>, the calculate for all process IDs. If <code>comm::MPI.Comm</code> is passed as first function argument then <code>pIDs</code> must be of type <code>Vector{Int}</code> and not <code>Int</code>.</li><li><code>filename_prefix::String = &quot;stats&quot;</code>: Start of filename for HDF5 containing final statistics. HDF5 files containing statistics for a single process ID will end with <code>pID-$(pID).h5</code>.</li><li><code>rm_binned_data::Bool = false</code>: Whether to delete the binned data after final statistics are computed.</li></ul><p><strong>Keywords for Exporting Statistics to CSV</strong></p><ul><li><code>export_to_csv::Bool = true</code>: Whether to export the final statistics to CSV file.</li><li><code>scientific_notation::Bool = false</code>: Whether to use scientific notation when exporting statistics to CSV file.</li><li><code>decimals::Int = 9</code>: How many decimal places to include when exporting statistics to CSV files.</li><li><code>delimiter::String = &quot; &quot;</code>: Delimiter used when writing CSV files.</li></ul><p><strong>Keyword Acting as Boolean Flags Indicating Which Statistics to Compute</strong></p><ul><li><code>process_global_measurements::Bool = true</code>: Whether to calculate the statistics for global measurements.</li><li><code>process_local_measurements::Bool = true</code>: Whether to calculate the statistics for local measurements.</li><li><code>process_all_equal_time_measurements::Bool = true</code>: Whether to calculate statistics for all equal-time correlation measurements.</li><li><code>process_all_time_displaced_measurements::Bool = false</code>: Whether to calculate statistics for all time-displaced correlation measurements.</li><li><code>process_all_integrated_measurements::Bool = true</code>: Whether to calculate statistics for all integrated correlation measurements.</li></ul><p><strong>Keyword Specifying Specific Correlation Statistics to Compute</strong></p><p>If <code>process_all_equal_time_measurements = false</code>, then the keyword arguments below can be used to specify which specific equal-time correlation measurements to calculate statistics for.</p><ul><li><code>standard_equal_time::Vector{String} = String[]</code></li><li><code>composite_integrated::Vector{String} = String[]</code></li></ul><p>If <code>process_all_time_displaced_measurements = true</code>, then the keyword arguments below can be used to specify which specific time-displaced correlation measurements to calculate statistics for.</p><ul><li><code>standard_time_displaced::Vector{String} = String[]</code></li><li><code>composite_time_displaced::Vector{String} = String[]</code></li></ul><p>If <code>process_all_integrated_measurements = false</code>, then the keyword arguments below can be used to specify which specific integrated correlation measurements to calculate statistics for.</p><ul><li><code>standard_integrated::Vector{String} = String[]</code></li><li><code>composite_integrated::Vector{String} = String[]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/process_measurements.jl#L1-L71">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.compute_correlation_ratio"><a class="docstring-binding" href="#SmoQyDQMC.compute_correlation_ratio"><code>SmoQyDQMC.compute_correlation_ratio</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_correlation_ratio(
    comm::MPI.Comm;
    # KEYWORD ARGUMENTS
    datafolder::String,
    correlation::String,
    type::String,
    id_pairs::Vector{NTuple{2,Int}},
    id_pair_coefficients::Vector{T},
    q_point::NTuple{D,Int},
    q_neighbors::Vector{NTuple{D,Int}},
    num_bins::Int = 0,
    pIDs::Vector{Int} = Int[],
) where {D, T&lt;:Number}

compute_correlation_ratio(;
    # KEYWORD ARGUMENTS
    datafolder::String,
    correlation::String,
    type::String,
    id_pairs::Vector{NTuple{2,Int}},
    id_pair_coefficients::Vector{T},
    q_point::NTuple{D,Int},
    q_neighbors::Vector{NTuple{D,Int}},
    num_bins::Int = 0,
    pIDs::Union{Int,Vector{Int}} = Int[]
) where {D, T&lt;:Number}</code></pre><p>Compute the correlation ratio at the <span>$\mathbf{k}$</span>-point using a linear combination of standard correlation function measurements. The linear combination of correlation functions used is defined by <code>id_pairs</code> and <code>coefs</code>. If <code>type</code> is <code>&quot;equal-time&quot;</code> or <code>&quot;time-displaced&quot;</code> then the equal-time correlation ratio is calculated. If <code>type</code> is &quot;integrated&quot; then the integrated correlation ratio is calculated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/compute_correlation_ratio.jl#L1-L33">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.compute_composite_correlation_ratio"><a class="docstring-binding" href="#SmoQyDQMC.compute_composite_correlation_ratio"><code>SmoQyDQMC.compute_composite_correlation_ratio</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_composite_correlation_ratio(
    comm::MPI.Comm;
    # KEYWORD ARGUMENTS
    datafolder::String,
    name::String,
    type::String,
    q_point::NTuple{D,Int},
    q_neighbors::Vector{NTuple{D,Int}},
    pIDs::Vector{Int} = Int[]
) where {D}

compute_composite_correlation_ratio(;
    # Keyword Arguments
    datafolder::String,
    name::String,
    type::String,
    q_point::NTuple{D,Int},
    q_neighbors::Vector{NTuple{D,Int}},
    num_bins::Int = 0,
    pIDs::Union{Int,Vector{Int}} = Int[]
) where {D}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/compute_correlation_ratio.jl#L223-L247">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.compute_function_of_correlations"><a class="docstring-binding" href="#SmoQyDQMC.compute_function_of_correlations"><code>SmoQyDQMC.compute_function_of_correlations</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_function_of_correlations(
    # ARGUMENTS
    comm::MPI.Comm;
    # KEYWORD ARGUMENTS
    f::Function,
    datafolder::String,
    correlations::AbstractVector{&lt;:NamedTuple},
    num_bins::Int = 0,
    pIDs::Vector{Int} = Int[],
)

compute_function_of_correlations(;
    # KEYWORD ARGUMENTS
    f::Function,
    datafolder::String,
    correlations::AbstractVector{&lt;:NamedTuple},
    num_bins::Int = 0,
    pIDs::Union{Int,Vector{Int}} = Int[]
)</code></pre><p>Calculate the mean and error associated with computing a function of measured correlation functions.</p><p>The correlation measurements that are passed as arguments to the function to evaluate are specified by the vector of named tuples <code>correlations</code>. The keys of the named tuple used to specify the correlation measurements are given below:</p><ul><li><code>name::String</code>: Name of correlation function.</li><li><code>type::String</code>: Specifies whether to use &quot;EQUAL-TIME&quot;, &quot;TIME-DISPLACED&quot; or &quot;INTEGRATED&quot; correlation measurement.</li><li><code>id_pair::NTuple{2,Int}</code>: If a standard correlation measurement, then specifies the ID pair for the correlation measurement.</li><li><code>R::NTuple{D,Int}</code> xor <code>K::NTuple{D,Int}</code>: Specifies either displacement vector or momentum point in <code>D</code> dimensions.</li><li><code>τ::Float64</code> xor <code>l::Int</code>: Imaginary-time or imaginary-time slice used if the <code>type</code> is &quot;TIME-DISPLACED&quot;.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>f::Function</code>: The function to evaluate.</li><li><code>datafolder::String</code>: Output directory generated by SmoQyDQMC simulation.</li><li><code>correlations::AbstractVector{NamedTuple}</code>: Vector of named tuples specifying the correlation measurement function arguments.</li><li><code>num_bins::Int = 0</code>: Number of bins used to compute statistics. If zero then use all number of bins.</li><li><code>pIDs = Int[]</code>: Process ID&#39;s used when measuring function of correlation measurements. If is <code>Int[]</code>, then all process ID&#39;s are used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/compute_function_of_correlations.jl#L1-L40">source</a></section></details></article><h3 id="Export-Measurements"><a class="docs-heading-anchor" href="#Export-Measurements">Export Measurements</a><a id="Export-Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Export-Measurements" title="Permalink"></a></h3><article><details class="docstring"><summary id="SmoQyDQMC.export_global_stats_to_csv"><a class="docstring-binding" href="#SmoQyDQMC.export_global_stats_to_csv"><code>SmoQyDQMC.export_global_stats_to_csv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">export_global_stats_to_csv(
    # ARGUMENTS
    comm::MPI.Comm;
    # KEYWORD ARGUMENTS
    datafolder::String,
    h5filename::String = &quot;stats.h5&quot;,,
    csvfilename_prefix::String = &quot;global&quot;,
    measurements::Vector{String} = String[],
    decimals::Int = 6,
    scientific_notation::Bool = false,
    delimiter::String = &quot; &quot;
)

export_global_stats_to_csv(;
    # KEYWORD ARGUMENTS
    datafolder::String,
    h5filename::String = &quot;stats.h5&quot;,,
    csvfilename_prefix::String = &quot;global&quot;,
    measurements::Vector{String} = String[],
    decimals::Int = 6,
    scientific_notation::Bool = false,
    delimiter::String = &quot; &quot;
)</code></pre><p>This function writes the global measurement statistics stored in the <code>h5filename</code> HDF5 file found in the directory <code>datafolder</code> to CSV file, returning the name of the CSV file that was written. The <code>measurements</code> keyword argument specifies the measurements to be exported. If <code>measurements = String[]</code>, then all measurements are exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/export_global_stats_to_csv.jl#L1-L30">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.export_global_bins_to_h5"><a class="docstring-binding" href="#SmoQyDQMC.export_global_bins_to_h5"><code>SmoQyDQMC.export_global_bins_to_h5</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">export_global_bins_to_h5(
    # ARGUMENTS
    comm::MPI.Comm;
    # KEYWORD ARGUMENTS
    datafolder::String,
    filename_prefix::String = &quot;global_bins&quot;,
    pIDs::Union{Vector{Int},Int} = Int[],
    global_measurements::Vector{String} = String[] 
)

export_global_bins_to_h5(;
    # KEYWORD ARGUMENTS
    datafolder::String,
    filename_prefix::String = &quot;global_bins&quot;,
    pIDs::Union{Vector{Int},Int} = Int[],
    global_measurements::Vector{String} = String[]
)</code></pre><p>Export the binned global measurements for specified process IDs <code>pIDs</code> to a single HDF5 file. If <code>pIDs = Int[]</code>, then binned global measurements for all process IDs are exported. You can specify a subset of specific global measurements using the <code>global_measurements</code> keyword argument. If <code>global_measurements = String[]</code>, then all global measurements are exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/export_global_bins.jl#L1-L25">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.export_global_bins_to_csv"><a class="docstring-binding" href="#SmoQyDQMC.export_global_bins_to_csv"><code>SmoQyDQMC.export_global_bins_to_csv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">export_global_bins_to_csv(
    # ARGUMENTS
    comm::MPI.Comm;
    # KEYWORD ARGUMENTS
    datafolder::String,
    filename_prefix::String = &quot;global_bins&quot;,
    pIDs::Union{Vector{Int},Int} = Int[],
    global_measurements::Vector{String} = String[],
    decimals::Int = 9,
    scientific_notation::Bool = false,
    delimiter::String = &quot; &quot;
)

export_global_bins_to_csv(;
    # KEYWORD ARGUMENTS
    datafolder::String,
    filename_prefix::String = &quot;global_bins&quot;,
    pIDs::Union{Vector{Int},Int} = Int[],
    global_measurements::Vector{String} = String[],
    decimals::Int = 9,
    scientific_notation::Bool = false,
    delimiter::String = &quot; &quot;
)</code></pre><p>Export the binned global measurements for specified process IDs <code>pIDs</code> to a single CSV file. If <code>pIDs = Int[]</code>, then binned global measurements for all process IDs are exported. You can specify a subset of specific global measurements using the <code>global_measurements</code> keyword argument. If <code>global_measurements = String[]</code>, then all global measurements are exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/export_global_bins.jl#L119-L149">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.export_local_stats_to_csv"><a class="docstring-binding" href="#SmoQyDQMC.export_local_stats_to_csv"><code>SmoQyDQMC.export_local_stats_to_csv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">export_local_stats_to_csv(
    # ARGUMENTS
    comm::MPI.Comm;
    # KEYWORD ARGUMENTS
    datafolder::String,
    h5filename::String = &quot;stats.h5&quot;,
    csvfilename_prefix::String = &quot;local&quot;,
    measurements::Vector{String} = String[],
    decimals::Int = 6,
    scientific_notation::Bool = false,
    delimiter::String = &quot; &quot;
)

export_local_stats_to_csv(;
    # KEYWORD ARGUMENTS
    datafolder::String,
    h5filename::String = &quot;stats.h5&quot;,
    csvfilename_prefix::String = &quot;local&quot;,
    measurements::Vector{String} = String[],
    decimals::Int = 6,
    scientific_notation::Bool = false,
    delimiter::String = &quot; &quot;
)</code></pre><p>This function writes the local measurement statistics stored in the <code>h5filename</code> HDF5 file found in the directory <code>datafolder</code> to CSV file, returning the name of the CSV file that was written. The <code>measurements</code> keyword argument specifies the measurements to be exported. If <code>measurements = String[]</code>, then all measurements are exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/export_local_stats_to_csv.jl#L1-L30">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.export_local_bins_to_csv"><a class="docstring-binding" href="#SmoQyDQMC.export_local_bins_to_csv"><code>SmoQyDQMC.export_local_bins_to_csv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">export_local_bins_to_csv(
    # ARGUMENTS
    comm::MPI.Comm;
    # KEYWORD ARGUMENTS
    datafolder::String,
    filename_prefix::String = &quot;local_bins&quot;,
    pIDs::Union{Vector{Int},Int} = Int[],
    local_measurements::Vector{String} = String[],
    decimals::Int = 9,
    scientific_notation::Bool = false,
    delimiter::String = &quot; &quot;
)

export_local_bins_to_csv(;
    # KEYWORD ARGUMENTS
    datafolder::String,
    filename_prefix::String = &quot;local_bins&quot;,
    pIDs::Union{Vector{Int},Int} = Int[],
    local_measurements::Vector{String} = String[],
    decimals::Int = 9,
    scientific_notation::Bool = false,
    delimiter::String = &quot; &quot;
)</code></pre><p>Export the binned local measurements for specified process IDs <code>pIDs</code> to a single CSV file. If <code>pIDs = Int[]</code>, then binned local measurements for all process IDs are exported. You can specify a subset of specific local measurements using the <code>local_measurements</code> keyword argument. If <code>local_measurements = String[]</code>, then all local measurements are exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/export_local_bins.jl#L128-L158">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.export_local_bins_to_h5"><a class="docstring-binding" href="#SmoQyDQMC.export_local_bins_to_h5"><code>SmoQyDQMC.export_local_bins_to_h5</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">export_local_bins_to_h5(
    # ARGUMENTS
    comm::MPI.Comm;
    # KEYWORD ARGUMENTS
    datafolder::String,
    filename_prefix::String = &quot;local_bins&quot;,
    pIDs::Union{Vector{Int},Int} = Int[],
    local_measurements::Vector{String} = String[],
)

export_local_bins_to_h5(;
    # KEYWORD ARGUMENTS
    datafolder::String,
    filename_prefix::String = &quot;local_bins&quot;,
    pIDs::Union{Vector{Int},Int} = Int[],
    local_measurements::Vector{String} = String[],
)</code></pre><p>Export the binned local measurements for specified process IDs <code>pIDs</code> to a single HDF5 file. If <code>pIDs = Int[]</code>, then binned local measurements for all process IDs are exported. You can specify a subset of specific local measurements using the <code>local_measurements</code> keyword argument. If <code>local_measurements = String[]</code>, then all local measurements are exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/export_local_bins.jl#L1-L25">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.export_correlation_stats_to_csv"><a class="docstring-binding" href="#SmoQyDQMC.export_correlation_stats_to_csv"><code>SmoQyDQMC.export_correlation_stats_to_csv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">export_correlation_stats_to_csv(
    # ARGUMENTS
    comm::MPI.Comm;
    # KEYWORD ARGUMENTS
    datafolder::String,
    correlation::String,
    type::String,
    space::String,
    h5filename::HDF5.File = &quot;stats.h5&quot;,
    decimals::Int = 6,
    scientific_notation::Bool = false,
    delimiter::String = &quot; &quot;
)

export_correlation_stats_to_csv(;
    # KEYWORD ARGUMENTS
    datafolder::String,
    correlation::String,
    type::String,
    space::String,
    h5filename::HDF5.File = &quot;stats.h5&quot;,
    decimals::Int = 6,
    scientific_notation::Bool = false,
    delimiter::String = &quot; &quot;
)</code></pre><p>Export statistics for specified type of correlation function from HDF5 file to a CSV file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/export_correlation_stats_to_csv.jl#L1-L29">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.export_correlation_bins_to_csv"><a class="docstring-binding" href="#SmoQyDQMC.export_correlation_bins_to_csv"><code>SmoQyDQMC.export_correlation_bins_to_csv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">export_correlation_bins_to_csv(
    # ARGUMENTS
    comm::MPI.Comm;
    # KEYWORD ARGUMENTS
    datafolder::String,
    correlation::String,
    type::String,
    space::String,
    pIDs::Union{Vector{Int},Int} = Int[],
    write_index_key::Bool = true,
    decimals::Int = 6,
    scientific_notation::Bool = false,
    delimiter::String = &quot; &quot;
)

export_correlation_bins_to_csv(;
    # KEYWORD ARGUMENTS
    datafolder::String,
    correlation::String,
    type::String,
    space::String,
    pIDs::Union{Vector{Int},Int} = Int[],
    write_index_key::Bool = true,
    decimals::Int = 6,
    scientific_notation::Bool = false,
    delimiter::String = &quot; &quot;
)</code></pre><p>Export the binned data for a specified type of correlation to an CSV file living in the directory <code>/datafolder/type/correlation/space</code>. The type of correlation function is specified by <code>type ∈ (&quot;equal-time&quot;, &quot;time-displaced&quot;, &quot;integrated&quot;)</code>. Where the correlation function is in position or momentum space is given by <code>space ∈ (&quot;momentum&quot;, &quot;position&quot;)</code>. The <code>pIDs</code> keyword specifies for which process IDs the binned correlation data is exported. If <code>pIDs = Int[]</code>, then binned local measurements for all process IDs are exported. If <code>write_index_key = true</code>, then another CSV file is written to the <code>/datafolder/type/correlation/space</code> directory which provides a key on how to interpret the <code>INDEX</code> column appearing in the CSV file containing the binned data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/export_correlation_bins_to_csv.jl#L1-L37">source</a></section></details></article><article><details class="docstring"><summary id="SmoQyDQMC.export_correlation_bins_to_h5"><a class="docstring-binding" href="#SmoQyDQMC.export_correlation_bins_to_h5"><code>SmoQyDQMC.export_correlation_bins_to_h5</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">export_correlation_bins_to_h5(
    # ARGUMENTS
    comm::MPI.Comm;
    # KEYWORD ARGUMENTS
    datafolder::String,
    correlation::String,
    type::String,
    space::String,
    pIDs::Union{Vector{Int},Int} = Int[]
)

export_correlation_bins_to_h5(;
    # KEYWORD ARGUMENTS
    datafolder::String,
    correlation::String,
    type::String,
    space::String,
    pIDs::Union{Vector{Int},Int} = Int[]
)</code></pre><p>Export the binned data for a specified type of correlation to an HDF5 file living in the directory <code>/datafolder/type/correlation/space</code>. The type of correlation function is specified by <code>type ∈ (&quot;equal-time&quot;, &quot;time-displaced&quot;, &quot;integrated&quot;)</code>. Where the correlation function is in position or momentum space is given by <code>space ∈ (&quot;momentum&quot;, &quot;position&quot;)</code>. The <code>pIDs</code> keyword specifies for which process IDs the binned correlation data is exported. If <code>pIDs = Int[]</code>, then binned local measurements for all process IDs are exported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/86811cc8031d887698f21e6619e1d152b41b5cb8/src/Measurements/export_correlation_bins_to_h5.jl#L1-L27">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simulation_output/">« Simulation Output Overview</a><a class="docs-footer-nextpage" href="../tutorials/hubbard_square/">1a) Square Hubbard Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 28 January 2026 19:21">Wednesday 28 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
