var documenterSearchIndex = {"docs":
[{"location":"examples/hubbard_chain_mpi/","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/hubbard_chain_mpi/#Hubbard-Chain-with-MPI","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"","category":"section"},{"location":"examples/hubbard_chain_mpi/","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"In this example we simulate the same system as in example 1, the half-filled Hubbard chain. However, in this example we use MPI, via the MPI.jl, to perform multiple simulations in parallel, with the results getting automatically averaged over at the end of the simulation. A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"> mpiexecjl -n 8 julia hubbard_chain_mpi.jl 1 6.0 0.0 8.0 16 2000 10000 50","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"This would result in 8 identical simulations being run in parallel. It possible that this command may need to be modified slightly depending on how MPI is set up on your system. For more information I recommend you refer to the MPI.jl documenation.","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"using LinearAlgebra\nusing Random\nusing Printf\nusing MPI\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# initialize MPI\nMPI.Init()\n\n# Define top-level function for running DQMC simulation\nfunction run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_chain_U%.2f_mu%.2f_L%d_b%.2f\" U μ L β\n\n    # Get the MPI comm rank, which fixes the process ID (pID).\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID,\n        pID = pID\n    )\n\n    # Synchronize all the MPI processes.\n    # Here we need to make sure the data folder is initialized before letting\n    # all the various processes move beyond this point.\n    MPI.Barrier(comm)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"reflection_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted = false, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n        U_orbital = [1],\n        U_mean = [U],\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Write the model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    # Synchronize all the MPI processes.\n    # We need to ensure the sub-directories the measurements will be written are created\n    # prior to letting any of the processes move beyond this point.\n    MPI.Barrier(comm)\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters, hubbard_ising_parameters)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Synchronize all the MPI processes.\n    # Before we prcoess the binned data to get the final averages and error bars\n    # we need to make sure all the simulations running in parallel have run to\n    # completion.\n    MPI.Barrier(comm)\n\n    # Have the primary MPI process calculate the final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    if iszero(simulation_info.pID)\n        process_measurements(simulation_info.datafolder, N_bins)\n    end\n\n    return nothing\nend\n\n\n# Only excute if script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    μ = parse(Float64, ARGS[3])\n    β = parse(Float64, ARGS[4])\n    L = parse(Int, ARGS[5])\n    N_burnin = parse(Int, ARGS[6])\n    N_updates = parse(Int, ARGS[7])\n    N_bins = parse(Int, ARGS[8])\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins)\n\n    # Finalize MPI (not strictly required).\n    MPI.Finalize()\nend","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"Download this example as a Julia script.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#2c)-Honeycomb-Holstein-Model-with-Checkpointing","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"In this tutorial we demonstrate how to introduce checkpointing to the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial, allowing for simulations to be resumed if terminated prior to completion.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Import-packages","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Import packages","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"No changes need to made to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"using SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf\nusing MPI","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Specify-simulation-parameters","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Specify simulation parameters","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"Compared to the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial, we have added two new keyword arguments to the run_simulation function:","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"checkpoint_freq: When going to write a new checkpoint file, only write one if more than checkpoint_freq hours have passed since the last checkpoint file was written.\nruntime_limit: If after writing a new checkpoint file more than runtime_limit hours have passed since the simulation started, terminate the simulation.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"The runtime_limit = Inf default behavior means there is no runtime limit for the simulation.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_updates, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-simulation","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Initialize simulation","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"We need to make a few modifications to this portion of the code as compared to the previous tutorial in order for checkpointing to work. First, we record need to record the simulation start time, which we do by initializing a variable start_timestamp = time(). Second, we need to convert the checkpoint_freq and runtime_limit from hours to seconds.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_honeycomb_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-simulation-metadata","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Initialize simulation metadata","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"At this point we need to introduce branching logic to handle whether a new simulation is being started, or a previous simulation is being resumed. We do this by checking the simulation_info.resuming boolean value. If simulation_info.resuming = true, then we are resuming a previous simulation, while simulation_info.resuming = false indicates we are starting a new simulation. Therefore, the section of code immediately below handles the case that we are starting a new simulation.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"We also introduce and initialize two new variables n_therm = 1 and n_updates = 1 which will keep track of how many rounds of thermalization and measurement updates have been performed. These two variables will needed to be included in the checkpoint files we write later in the simulation, as they will indicate where to resume a previously terminated simulation.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_updates = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize additiona_info dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_updates\"] = N_updates\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"n_stab\"] = n_stab\n        metadata[\"dG_max\"] = δG_max\n        metadata[\"symmetric\"] = symmetric\n        metadata[\"checkerboard\"] = checkerboard\n        metadata[\"seed\"] = seed\n        metadata[\"hmc_acceptance_rate\"] = 0.0\n        metadata[\"reflection_acceptance_rate\"] = 0.0\n        metadata[\"swap_acceptance_rate\"] = 0.0","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-model","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Initialize model","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"No changes need to made to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"        # Define the unit cell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [[3/2,√3/2],\n                            [3/2,-√3/2]],\n            basis_vecs   = [[0.,0.],\n                            [1.,0.]]\n        )\n\n        # Define finite lattice with periodic boundary conditions.\n        lattice = lu.Lattice(\n            L = [L, L],\n            periodic = [true, true]\n        )\n\n        # Initialize model geometry.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the first nearest-neighbor bond in a honeycomb lattice.\n        bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n        # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_1_id = add_bond!(model_geometry, bond_1)\n\n        # Define the second nearest-neighbor bond in a honeycomb lattice.\n        bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n        # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_2_id = add_bond!(model_geometry, bond_2)\n\n        # Define the third nearest-neighbor bond in a honeycomb lattice.\n        bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n        # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_3_id = add_bond!(model_geometry, bond_3)\n\n        # Set neartest-neighbor hopping amplitude to unity,\n        # setting the energy scale in the model.\n        t = 1.0\n\n        # Define the honeycomb tight-binding model.\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds        = [bond_1, bond_2, bond_3], # defines hopping\n            t_mean         = [t, t, t], # defines corresponding hopping amplitude\n            μ              = μ, # set chemical potential\n            ϵ_mean         = [0.0, 0.0] # set the (mean) on-site energy\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n        phonon_1 = PhononMode(orbital = 1, Ω_mean = Ω)\n\n        # Add the phonon mode definition to the electron-phonon model.\n        phonon_1_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_1\n        )\n\n        # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n        phonon_2 = PhononMode(orbital = 2, Ω_mean = Ω)\n\n        # Add the phonon mode definition to the electron-phonon model.\n        phonon_2_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_2\n        )\n\n        # Define first local Holstein coupling for first phonon mode.\n        holstein_coupling_1 = HolsteinCoupling(\n            model_geometry = model_geometry,\n            phonon_mode = phonon_1_id,\n            # Couple the first phonon mode to first orbital in the unit cell.\n            bond = lu.Bond(orbitals = (1,1), displacement = [0, 0]),\n            α_mean = α\n        )\n\n        # Add the first local Holstein coupling definition to the model.\n        holstein_coupling_1_id = add_holstein_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            holstein_coupling = holstein_coupling_1,\n            model_geometry = model_geometry\n        )\n\n        # Define first local Holstein coupling for first phonon mode.\n        holstein_coupling_2 = HolsteinCoupling(\n            model_geometry = model_geometry,\n            phonon_mode = phonon_2_id,\n            # Couple the second phonon mode to second orbital in the unit cell.\n            bond = lu.Bond(orbitals = (2,2), displacement = [0, 0]),\n            α_mean = α\n        )\n\n        # Add the first local Holstein coupling definition to the model.\n        holstein_coupling_2_id = add_holstein_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            holstein_coupling = holstein_coupling_2,\n            model_geometry = model_geometry\n        )\n\n        # Write model summary TOML file specifying Hamiltonian that will be simulated.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-model-parameters","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Initialize model parameters","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"No changes need to made to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-meuasurements","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Initialize meuasurements","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"No changes need to made to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1), (2, 2), (1, 2)\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs of modes.\n                (1, 1), (2, 2), (1, 2)\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1), (2, 2),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1), (2, 2)\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1), (2, 2)\n            ]\n        )\n\n        # Initialize CDW correlation measurement.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"cdw\",\n            correlation = \"density\",\n            ids = [1, 2],\n            coefficients = [1.0, -1.0],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Initialize the sub-directories to which the various measurements will be written.\n        initialize_measurement_directories(comm, simulation_info, measurement_container)","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Write-first-checkpoint","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Write first checkpoint","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"This section of code needs to be added so that a first checkpoint file is written before beginning a new simulation. We do this using the write_jld2_checkpoint function. This function all return the epoch timestamp checkpoint_timestamp corresponding to when the checkpoint file was written.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_updates,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Load-checkpoint","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Load checkpoint","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"If we are resuming a simulation that was previously terminated prior to completion, then we need to load the most recent checkpoint file using the read_jld2_checkpoint function. The cotents of the checkpoint file are returned as a dictionary checkpoint by the read_jld2_checkpoint function. We then extract the cotents of the checkpoint file from the checkpoint dictionary.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters    = checkpoint[\"tight_binding_parameters\"]\n        electron_phonon_parameters  = checkpoint[\"electron_phonon_parameters\"]\n        measurement_container       = checkpoint[\"measurement_container\"]\n        model_geometry              = checkpoint[\"model_geometry\"]\n        metadata                    = checkpoint[\"metadata\"]\n        rng                         = checkpoint[\"rng\"]\n        n_therm                     = checkpoint[\"n_therm\"]\n        n_updates                   = checkpoint[\"n_updates\"]\n    end","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Setup-DQMC-simulation","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Setup DQMC simulation","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"No changes need to made to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing EFA-HMC, reflection and swap updates below.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allcoate equal-time electron Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize electron Green's function matrx, also calculating the matrix determinant as the same time.\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize diagonostic parameters to asses numerical stability.\n    δG = zero(logdetG)\n    δθ = zero(sgndetG)","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Setup-EFA-HMC-Updates","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Setup EFA-HMC Updates","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"No changes need to made to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"    # Number of fermionic time-steps in HMC update.\n    Nt = 10\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(2*Ω*Nt)\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Thermalize-system","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Thermalize system","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"The first change we need to make to this section is to have the for-loop iterate from n_therm:N_therm instead of 1:N_therm. The other change we need make to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial is to add a call to the write_jld2_checkpoint function at the end of each iteration of the for-loop in which we perform the thermalization updates. When calling this function we need to pass it the timestamp for the previous checkpoint checkpoint_timestamp so that the function can determine if a new checkpoint file needs to be written. If a new checkpoint file is written then the checkpoint_timestamp variable will be updated to reflect this, otherwise it will remain unchanged.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = update + 1,\n            n_updates = 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Make-measurements","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Make measurements","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"Again, we need to modify the for-loop so that it runs from n_updates:N_updates instead of 1:N_updates. The only other change we need to make to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial is to add a call to the write_jld2_checkpoint function at the end of each iteration of the for-loop in which we perform updates and measurements. Note that we set n_therm = N_therm + 1 when writing the checkpoint file to ensure that when the simulation is resumed the thermalization updates are not repeated.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"    # Reset diagonostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetG)\n    δθ = zero(sgndetG)\n\n    # Calculate the bin size.\n    bin_size = N_updates ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for update in n_updates:N_updates\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Make measurements.\n        (logdetG, sgndetG, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (electron_phonon_parameters,)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            update = update,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_updates = update + 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Record-simulation-metadata","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Record simulation metadata","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"No changes need to made to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_updates + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_updates + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_updates + N_therm)\n\n    # Record largest numerical error encountered during simulation.\n    metadata[\"dG\"] = δG\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Post-process-results","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Post-process results","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"From the last 2b) Honeycomb Holstein Model with MPI Parallelization tutorial, we now need to add a call to the rename_complete_simulation function once the results are processed. This function renames the data folder to begin with complete_*, making it simple to identify which simulations ran to completion and which ones need to be resumed from the last checkpoint file. This function also deletes the checkpoint files that were written during the simulation.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(comm, simulation_info.datafolder, N_bins, time_displaced = true)\n\n    # Merge binary files containing binned data into a single file.\n    compress_jld2_bins(comm, folder = simulation_info.datafolder)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Execute-script","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Execute script","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"To execute the script, we have added two new command line arguments allowing for the assignment of both the checkpoint_freq and runtime_limit values. Therefore, a simulation can be run with the command","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"mpiexecjl -n 16 julia holstein_honeycomb_checkpoint.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100 0.5","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"or","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"srun julia holstein_honeycomb_checkpoint.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100 0.5","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"Refer to the previous 1b) Square Hubbard Model with MPI Parallelization tutorial for more details on how to run the simulation script using MPI.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"In the example calls above the code will write a new checkpoint if more than 30 minutes (0.5 hours) has passed since the last checkpoint file was written. Note that these same commands are used to both begin a new simulation and also resume a previous simulation. This is a useful feature when submitting jobs on a cluster, as it allows the same job file to be used for both starting new simulations and resuming ones that still need to finish.","category":"page"},{"location":"tutorials/holstein_honeycomb_checkpoint/","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID             = parse(Int,     ARGS[1]),  # Simulation ID.\n        Ω               = parse(Float64, ARGS[2]),  # Phonon energy.\n        α               = parse(Float64, ARGS[3]),  # Electron-phonon coupling.\n        μ               = parse(Float64, ARGS[4]),  # Chemical potential.\n        L               = parse(Int,     ARGS[5]),  # System size.\n        β               = parse(Float64, ARGS[6]),  # Inverse temperature.\n        N_therm         = parse(Int,     ARGS[7]),  # Number of thermalization updates.\n        N_updates       = parse(Int,     ARGS[8]),  # Total number of measurements and measurement updates.\n        N_bins          = parse(Int,     ARGS[9]),  # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[10]), # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/bssh_chain/#Bond-Su-Schrieffer-Heeger-Chain","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"","category":"section"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"In this example we simulate the bond Su-Schrieffer-Heeger (BSSH) model on a 1D chain, with a Hamiltonian given by","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"beginalign*\nhatH = sum_i left( frac12MhatP_langle i+1 i rangle^2 + frac12MOmega^2hatX_langle i+1 i rangle^2 right)\n          - sum_sigmai t-alpha hatX_langle i+1 i rangle (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n          - mu sum_sigmai hatn_sigmai\nendalign*","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"in which dispersionless phonon modes are placed on each bond, and their positions modulates only that single corresponding hopping amplitude. In the above expression hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creation (annihilation) operator a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on the bond connecting sites i and i+1 is given by hatX_langle i+1 i rangle  (hatP_langle i+1 i rangle), where Omega and M are the phonon frequency and associated ion mass respectively. Lastly, the strength of the electron-phonon coupling is controlled by the parameter alpha.","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"> julia bssh_chain.jl 0 1.0 0.5 0.0 4.0 16 1000 5000 20","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"which simulates an L=16 chain with Omega = 10, alpha = 05 at half-filling (mu = 00) and an inverse temperature of beta = 40. In this example N_burnin = 1000 HMC thermalization updates are performed, followed an additional N_updates = 5000 HMC updates, after each of which measurements are made. Bin averaged measurements are then written to file N_bins = 20 during the simulation.","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running the DQMC simulation.\nfunction run_bssh_chain_simulation(sID, Ω, α, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"bssh_chain_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.05\n\n    # For performance reasons it is important that we represent the exponentiated hopping\n    # matrix with the checkerboard approximation when simulating an SSH model, where the\n    # phonons modulate the hopping amplitudes. Without the checkerboard approximation,\n    # each time a phonon field is updated the kinetic energy matrix would need to be diagonalized\n    # to calculate its exponential, which is very computationally expensive.\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = true\n\n    # As we are using the checkboard approximation, using a symmetric definition for the propagator\n    # matrices is important as it significantly improves the accuracy of approximation.\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = true\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bin size.\n    bin_size = div(N_updates, N_bins)\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 4\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(2*Ω)/Nt\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"swap_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"Nt\" => Nt,\n        \"dt\" => Δt,\n        \"seed\" => seed,\n    )\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Get the number of sites in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Unlike in the optical SSH model in the previous example, here we need to\n    # introduce two types of phonon modes. One of these phonon modes will have\n    # infinite ion mass, resulting in the associated phonon fields remaining\n    # pinned at zero. The means that when we couple these two types of phonon\n    # modes to the electrons with a SSH-like coupling mechanism, this effectively\n    # results in defining a phonon modes associated with a single bond/hopping\n    # in the lattice.\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon = PhononMode(orbital = 1, Ω_mean = Ω, M = 1.0)\n\n    # Add optical ssh phonon to electron-phonon model.\n    phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon\n    )\n\n    # Define a frozen phonon mode.\n    frozen_phonon = PhononMode(orbital = 1, Ω_mean = Ω, M = Inf)\n\n    # Add frozen phonon mode to electron-phonon model.\n    frozen_phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = frozen_phonon\n    )\n\n    # Define bond SSH coupling.\n    # Defines total effective hopping amplitude given by t_eff = t-α⋅X(i+1,i).\n    bssh_coupling = SSHCoupling(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        phonon_modes = (frozen_phonon_id, phonon_id),\n        bond = bond,\n        α_mean = α\n    )\n\n    # Add bond SSH coupling to the electron-phonon model.\n    bssh_coupling_id = add_ssh_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        ssh_coupling = bssh_coupling,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Write a model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )\n\n    #################################################\n    ### INITIALIZE FINITE LATTICE MODEL PARAMETERS ##\n    #################################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the measurement container.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the measurements associated with the tight-binding model.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the measurements associated with the electron-phonon model.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize time-displaced Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize time-displaced phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(phonon_id, phonon_id)]\n    )\n\n    # Initialize the density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurements.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (bond_id, bond_id)]\n    )\n\n    # Initialize the bond correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"bond\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(bond_id, bond_id)]\n    )\n\n    # Initialize current-current correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"current\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)] # Hopping ID pair.\n    )\n\n    # Initialize the sub-directories the various measurements will be written to.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Allocate and initialize propagators for each imaginary time slice.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize fermion greens calculator.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize equal-time Green's function matrix\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt\n    )\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a swap update.\n        # In a swap update, two phonon modes are randomly selected in the lattice\n        # and their phonon fields are exchanged for all imaginary time slices.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng, phonon_type_pairs = ((phonon_id, phonon_id),)\n        )\n\n        # Record whether the swap update was accepted or rejected.\n        additional_info[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a swap update..\n            (accepted, logdetG, sgndetG) = swap_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, rng = rng, phonon_type_pairs = ((phonon_id, phonon_id),)\n            )\n\n            # Record whether the swap update was accepted or rejected.\n            additional_info[\"swap_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Make measurements.\n            (logdetG, sgndetG, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (electron_phonon_parameters,)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate HMC acceptance rate.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Calculate swap update acceptance rate.\n    additional_info[\"swap_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ω = parse(Float64, ARGS[2])\n    α = parse(Float64, ARGS[3])\n    μ = parse(Float64, ARGS[4])\n    β = parse(Float64, ARGS[5])\n    L = parse(Int, ARGS[6])\n    N_burnin = parse(Int, ARGS[7])\n    N_updates = parse(Int, ARGS[8])\n    N_bins = parse(Int, ARGS[9])\n\n    # Run the simulation.\n    run_bssh_chain_simulation(sID, Ω, α, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"Download this example as a Julia script.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#1c)-Square-Hubbard-Model-with-Checkpointing","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"In this tutorial we demonstrate how to introduce checkpointing to the previous 1b) Square Hubbard Model with MPI Parallelization tutorial, allowing for simulations to be resumed if terminated prior to completion.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Import-Packages","page":"1c) Square Hubbard Model with Checkpointing","title":"Import Packages","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"No changes need to made to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"using SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf\nusing MPI","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Specify-simulation-parameters","page":"1c) Square Hubbard Model with Checkpointing","title":"Specify simulation parameters","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"Compared to the previous 1b) Square Hubbard Model with MPI Parallelization tutorial, we have added two new keyword arguments to the run_simulation function:","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"checkpoint_freq: When going to write a new checkpoint file, only write one if more than checkpoint_freq hours have passed since the last checkpoint file was written.\nruntime_limit = Inf: If after writing a new checkpoint file more than runtime_limit hours have passed since the simulation started, terminate the simulation.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"The runtime_limit = Inf default behavior means there is no runtime limit for the simulation.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    U, # Hubbard interaction.\n    t′, # Next-nearest-neighbor hopping amplitude.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_updates, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Initialize-simulation","page":"1c) Square Hubbard Model with Checkpointing","title":"Initialize simulation","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"We need to make a few modifications to this portion of the code as compared to the previous tutorial in order for checkpointing to work. First, we record need to record the simulation start time, which we do by initializing a variable start_timestamp = time(). Second, we need to convert the checkpoint_freq and runtime_limit from hours to seconds.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_square_U%.2f_tp%.2f_mu%.2f_L%d_b%.2f\" U t′ μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to if one does not already exist.\n    initialize_datafolder(comm, simulation_info)","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Initialize-simulation-metadata","page":"1c) Square Hubbard Model with Checkpointing","title":"Initialize simulation metadata","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"At this point we need to introduce branching logic to handle whether a new simulation is being started, or a previous simulation is being resumed. We do this by checking the simulation_info.resuming boolean value. If simulation_info.resuming = true, then we are resuming a previous simulation, while simulation_info.resuming = false indicates we are starting a new simulation. Therefore, the section of code immediately below handles the case that we are starting a new simulation.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"We also introduce and initialize two new variables n_therm = 1 and n_updates = 1 which will keep track of how many rounds of thermalization and measurement updates have been performed. These two variables will needed to be included in the checkpoint files we write later in the simulation, as they will indicate where to resume a previously terminated simulation.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_updates = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize additiona_info dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_updates\"] = N_updates\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"n_stab_init\"] = n_stab\n        metadata[\"dG_max\"] = δG_max\n        metadata[\"symmetric\"] = symmetric\n        metadata[\"checkerboard\"] = checkerboard\n        metadata[\"seed\"] = seed\n        metadata[\"avg_acceptance_rate\"] = 0.0","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Initialize-Model","page":"1c) Square Hubbard Model with Checkpointing","title":"Initialize Model","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"No changes need to made to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"        # Define unit cell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [[1.0, 0.0],\n                            [0.0, 1.0]],\n            basis_vecs = [[0.0, 0.0]]\n        )\n\n        # Define finite lattice with periodic boundary conditions.\n        lattice = lu.Lattice(\n            L = [L, L],\n            periodic = [true, true]\n        )\n\n        # Initialize model geometry.\n        model_geometry = ModelGeometry(\n            unit_cell, lattice\n        )\n\n        # Define the nearest-neighbor bond in +x direction.\n        bond_px = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, 0]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_px_id = add_bond!(model_geometry, bond_px)\n\n        # Define the nearest-neighbor bond in +y direction.\n        bond_py = lu.Bond(\n            orbitals = (1,1),\n            displacement = [0, 1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_py_id = add_bond!(model_geometry, bond_py)\n\n        # Define the next-nearest-neighbor bond in +x+y direction.\n        bond_pxpy = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, 1]\n        )\n\n        # Define the nearest-neighbor bond in -x direction.\n        # Will be used to make measurements later in this tutorial.\n        bond_nx = lu.Bond(\n            orbitals = (1,1),\n            displacement = [-1, 0]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n        # Define the nearest-neighbor bond in -y direction.\n        # Will be used to make measurements later in this tutorial.\n        bond_ny = lu.Bond(\n            orbitals = (1,1),\n            displacement = [0, -1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n        # Define the next-nearest-neighbor bond in +x+y direction.\n        bond_pxpy = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, 1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_pxpy_id = add_bond!(model_geometry, bond_pxpy)\n\n        # Define the next-nearest-neighbor bond in +x-y direction.\n        bond_pxny = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, -1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_pxny_id = add_bond!(model_geometry, bond_pxny)\n\n        # Set neartest-neighbor hopping amplitude to unity,\n        # setting the energy scale in the model.\n        t = 1.0\n\n        # Define the non-interacting tight-binding model.\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond_px, bond_py, bond_pxpy, bond_pxny], # defines hopping\n            t_mean  = [t, t, t′, t′], # defines corresponding mean hopping amplitude\n            t_std   = [0., 0., 0., 0.], # defines corresponding standard deviation in hopping amplitude\n            ϵ_mean  = [0.], # set mean on-site energy for each orbital in unit cell\n            ϵ_std   = [0.], # set standard deviation of on-site energy or each orbital in unit cell\n            μ       = μ # set chemical potential\n        )\n\n        # Define the Hubbard interaction in the model.\n        hubbard_model = HubbardModel(\n            shifted   = false, # if true, then Hubbard interaction is instead parameterized as U⋅nup⋅ndn\n            U_orbital = [1], # orbitals in unit cell with Hubbard interaction.\n            U_mean    = [U], # mean Hubbard interaction strength for corresponding orbital species in unit cell.\n            U_std     = [0.], # standard deviation of Hubbard interaction strength for corresponding orbital species in unit cell.\n        )\n\n        # Write model summary TOML file specifying Hamiltonian that will be simulated.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (hubbard_model,)\n        )","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Initialize-model-parameters","page":"1c) Square Hubbard Model with Checkpointing","title":"Initialize model parameters","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"No changes need to made to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize Hubbard interaction parameters.\n        hubbard_params = HubbardParameters(\n            model_geometry = model_geometry,\n            hubbard_model = hubbard_model,\n            rng = rng\n        )\n\n        # Apply Ising Hubbard-Stranonvich (HS) transformation to decouple the Hubbard interaction,\n        # and initialize the corresponding HS fields that will be sampled in the DQMC simulation.\n        hubbard_stratonovich_params = HubbardIsingHSParameters(\n            β = β, Δτ = Δτ,\n            hubbard_parameters = hubbard_params,\n            rng = rng\n        )","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Initialize-measurements","page":"1c) Square Hubbard Model with Checkpointing","title":"Initialize measurements","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"No changes need to made to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the Hubbard interaction related measurements.\n        initialize_measurements!(measurement_container, hubbard_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the d-wave pair susceptibility measurement.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"d-wave\",\n            correlation = \"pair\",\n            ids = [bond_px_id, bond_nx_id, bond_py_id, bond_ny_id],\n            coefficients = [0.5, 0.5, -0.5, -0.5],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Initialize the sub-directories to which the various measurements will be written.\n        initialize_measurement_directories(comm, simulation_info, measurement_container)","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Write-first-checkpoint","page":"1c) Square Hubbard Model with Checkpointing","title":"Write first checkpoint","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"This section of code needs to be added so that a first checkpoint file is written before beginning a new simulation. We do this using the write_jld2_checkpoint function. This function all return the epoch timestamp checkpoint_timestamp corresponding to when the checkpoint file was written.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_updates,\n            tight_binding_parameters, hubbard_params, hubbard_stratonovich_params,\n            measurement_container, model_geometry, metadata, rng\n        )","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Load-checkpoint","page":"1c) Square Hubbard Model with Checkpointing","title":"Load checkpoint","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"If we are resuming a simulation that was previously terminated prior to completion, then we need to load the most recent checkpoint file using the read_jld2_checkpoint function. The cotents of the checkpoint file are returned as a dictionary checkpoint by the read_jld2_checkpoint function. We then extract the cotents of the checkpoint file from the checkpoint dictionary.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters    = checkpoint[\"tight_binding_parameters\"]\n        hubbard_params              = checkpoint[\"hubbard_params\"]\n        hubbard_stratonovich_params = checkpoint[\"hubbard_stratonovich_params\"]\n        measurement_container       = checkpoint[\"measurement_container\"]\n        model_geometry              = checkpoint[\"model_geometry\"]\n        metadata                    = checkpoint[\"metadata\"]\n        rng                         = checkpoint[\"rng\"]\n        n_therm                     = checkpoint[\"n_therm\"]\n        n_updates                   = checkpoint[\"n_updates\"]\n    end","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Setup-DQMC-simulation","page":"1c) Square Hubbard Model with Checkpointing","title":"Setup DQMC simulation","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for Hubbard interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_params)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for the current\n    # Hubbard-Stratonovich field configuration.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_stratonovich_params)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices for spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type for spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # Gup(τ,τ)\n    Gup_τ0 = similar(Gup) # Gup(τ,0)\n    Gup_0τ = similar(Gup) # Gup(0,τ)\n    Gdn_ττ = similar(Gdn) # Gdn(τ,τ)\n    Gdn_τ0 = similar(Gdn) # Gdn(τ,0)\n    Gdn_0τ = similar(Gdn) # Gdn(0,τ)\n\n    # Initialize diagonostic parameters to asses numerical stability.\n    δG = zero(logdetGup)\n    δθ = zero(sgndetGup)","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Thermalize-system","page":"1c) Square Hubbard Model with Checkpointing","title":"Thermalize system","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"The first change we need to make to this section is to have the for-loop iterate from n_therm:N_therm instead of 1:N_therm. The other change we need make to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial is to add a call to the write_jld2_checkpoint function at the end of each iteration of the for-loop in which we perform the thermalization updates. When calling this function we need to pass it the timestamp for the previous checkpoint checkpoint_timestamp so that the function can determine if a new checkpoint file needs to be written. If a new checkpoint file is written then the checkpoint_timestamp variable will be updated to reflect this, otherwise it will remain unchanged.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_stratonovich_params,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n            update_stabilization_frequency = true\n        )\n\n        # Record acceptance rate for sweep.\n        metadata[\"avg_acceptance_rate\"] += acceptance_rate\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm = update + 1,\n            n_updates = 1,\n            tight_binding_parameters, hubbard_params, hubbard_stratonovich_params,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Make-measurements","page":"1c) Square Hubbard Model with Checkpointing","title":"Make measurements","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"Again, we need to modify the for-loop so that it runs from n_updates:N_updates instead of 1:N_updates. The only other change we need to make to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial is to add a call to the write_jld2_checkpoint function at the end of each iteration of the for-loop in which we perform updates and measurements. Note that we set n_therm = N_therm + 1 when writing the checkpoint file to ensure that when the simulation is resumed the thermalization updates are not repeated.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"    # Reset diagonostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetGup)\n    δθ = zero(sgndetGup)\n\n    # Calculate the bin size.\n    bin_size = N_updates ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for update in n_updates:N_updates\n\n        # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_stratonovich_params,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n            update_stabilization_frequency = true\n        )\n\n        # Record acceptance rate.\n        metadata[\"avg_acceptance_rate\"] += acceptance_rate\n\n        # Make measurements.\n        (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n            logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (hubbard_params, hubbard_stratonovich_params)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            update = update,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_updates = update + 1,\n            tight_binding_parameters, hubbard_params, hubbard_stratonovich_params,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Record-simulation-metadata","page":"1c) Square Hubbard Model with Checkpointing","title":"Record simulation metadata","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"No changes need to made to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"    # Normalize acceptance rate.\n    metadata[\"avg_acceptance_rate\"] /=  (N_therm + N_updates)\n\n    metadata[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record largest numerical error.\n    metadata[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Post-process-results","page":"1c) Square Hubbard Model with Checkpointing","title":"Post-process results","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"From the last 1b) Square Hubbard Model with MPI Parallelization tutorial, we now need to add a call to the rename_complete_simulation function once the results are processed. This function renames the data folder to begin with complete_*, making it simple to identify which simulations ran to completion and which ones need to be resumed from the last checkpoint file. This function also deletes the checkpoint files that were written during the simulation.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"    # Set the number of bins used to calculate the error in measured observables.\n    n_bins = N_bins\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(comm, simulation_info.datafolder, n_bins, time_displaced = false)\n\n    # Calculate AFM correlation ratio.\n    Rafm, ΔRafm = compute_correlation_ratio(\n        comm;\n        folder = simulation_info.datafolder,\n        correlation = \"spin_z\",\n        type = \"equal-time\",\n        id_pairs = [(1, 1)],\n        coefs = [1.0],\n        k_point = (L÷2, L÷2), # Corresponds to Q_afm = (π/a, π/a).\n        num_bins = n_bins\n    )\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rafm_real_mean\"] = real(Rafm)\n    metadata[\"Rafm_imag_mean\"] = imag(Rafm)\n    metadata[\"Rafm_std\"]       = ΔRafm\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Merge binary files containing binned data into a single file.\n    compress_jld2_bins(comm, folder = simulation_info.datafolder)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/#Execute-script","page":"1c) Square Hubbard Model with Checkpointing","title":"Execute script","text":"","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"To execute the script, we have added two new command line arguments allowing for the assignment of both the checkpoint_freq and runtime_limit values. Therefore, a simulation can be run with the command","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"mpiexecjl -n 16 julia hubbard_square_checkpoint.jl 1 5.0 -0.25 -2.0 4 4.0 2500 10000 100 1.0","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"or","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"srun julia hubbard_square_checkpoint.jl 1 5.0 -0.25 -2.0 4 4.0 2500 10000 100 1.0","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"Refer to the previous 1b) Square Hubbard Model with MPI Parallelization tutorial for more details on how to run the simulation script using MPI.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"In the example calls above the code will write a new checkpoint if more than 1 hour has passed since the last checkpoint file was written. Note that these same commands are used to both begin a new simulation and also resume a previous simulation. This is a useful feature when submitting jobs on a cluster, as it allows the same job file to be used for both starting new simulations and resuming ones that still need to finish.","category":"page"},{"location":"tutorials/hubbard_square_checkpoint/","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"if abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation, reading in command line arguments.\n    run_simulation(\n        comm;\n        sID             = parse(Int,     ARGS[1]), # Simulation ID.\n        U               = parse(Float64, ARGS[2]), # Hubbard interaction.\n        t′              = parse(Float64, ARGS[3]), # Next-nearest-neighbor hopping amplitude.\n        μ               = parse(Float64, ARGS[4]), # Chemical potential.\n        L               = parse(Int,     ARGS[5]), # System size.\n        β               = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm         = parse(Int,     ARGS[7]), # Number of thermalization updates.\n        N_updates       = parse(Int,     ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins          = parse(Int,     ARGS[9]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[10]) # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"Download this example as a Julia script.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#2d)-Honeycomb-Holstein-Model-with-Density-Tuning","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"In this example we demonstrate how to introduce chemical potential and density tuning to the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial. Specifically, we show how to use the algorithm introduced in Phys. Rev. E 105, 045311 for dynamically adjusting the chemical potential during the simulation in order to achieve a target electron density or filling fraction.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Import-Packages","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Import Packages","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"Compared to the previouse 1c) Square Hubbard Model with Checkpointing tutorial, we now need to import the MuTuner.jl package, which is reexported by SmoQyDQMC.jl","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"using SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\nimport SmoQyDQMC.MuTuner as mt\n\nusing Random\nusing Printf\nusing MPI","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Specify-simulation-parameters","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Specify simulation parameters","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"Here we introduce the keyword argument n to the run_simulation function which specifies the target electron density we want to achieve in the simulation. Now the μ argument specifies the initial chemical potential we begin the simulation with, but of course it will be adjusted during the simulation to achieve the target density n.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    n, # Target density.\n    μ, # Initial chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_updates, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-simulation","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Initialize simulation","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"No changes need to made to this section of the code from the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_honeycomb_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-simulation-metadata","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Initialize simulation metadata","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"Here it is useful to record the initial chemical potential μ used during the simulation in the metadata dictionary.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_updates = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize additiona_info dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"mu\"] = μ\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_updates\"] = N_updates\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"n_stab\"] = n_stab\n        metadata[\"dG_max\"] = δG_max\n        metadata[\"symmetric\"] = symmetric\n        metadata[\"checkerboard\"] = checkerboard\n        metadata[\"seed\"] = seed\n        metadata[\"hmc_acceptance_rate\"] = 0.0\n        metadata[\"reflection_acceptance_rate\"] = 0.0\n        metadata[\"swap_acceptance_rate\"] = 0.0","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-model","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Initialize model","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"No changes need to made to this section of the code from the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"        # Define the unit cell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [[3/2,√3/2],\n                            [3/2,-√3/2]],\n            basis_vecs   = [[0.,0.],\n                            [1.,0.]]\n        )\n\n        # Define finite lattice with periodic boundary conditions.\n        lattice = lu.Lattice(\n            L = [L, L],\n            periodic = [true, true]\n        )\n\n        # Initialize model geometry.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the first nearest-neighbor bond in a honeycomb lattice.\n        bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n        # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_1_id = add_bond!(model_geometry, bond_1)\n\n        # Define the second nearest-neighbor bond in a honeycomb lattice.\n        bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n        # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_2_id = add_bond!(model_geometry, bond_2)\n\n        # Define the third nearest-neighbor bond in a honeycomb lattice.\n        bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n        # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_3_id = add_bond!(model_geometry, bond_3)\n\n        # Set neartest-neighbor hopping amplitude to unity,\n        # setting the energy scale in the model.\n        t = 1.0\n\n        # Define the honeycomb tight-binding model.\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds        = [bond_1, bond_2, bond_3], # defines hopping\n            t_mean         = [t, t, t], # defines corresponding hopping amplitude\n            μ              = μ, # set chemical potential\n            ϵ_mean         = [0.0, 0.0] # set the (mean) on-site energy\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n        phonon_1 = PhononMode(orbital = 1, Ω_mean = Ω)\n\n        # Add the phonon mode definition to the electron-phonon model.\n        phonon_1_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_1\n        )\n\n        # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n        phonon_2 = PhononMode(orbital = 2, Ω_mean = Ω)\n\n        # Add the phonon mode definition to the electron-phonon model.\n        phonon_2_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_2\n        )\n\n        # Define first local Holstein coupling for first phonon mode.\n        holstein_coupling_1 = HolsteinCoupling(\n            model_geometry = model_geometry,\n            phonon_mode = phonon_1_id,\n            # Couple the first phonon mode to first orbital in the unit cell.\n            bond = lu.Bond(orbitals = (1,1), displacement = [0, 0]),\n            α_mean = α\n        )\n\n        # Add the first local Holstein coupling definition to the model.\n        holstein_coupling_1_id = add_holstein_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            holstein_coupling = holstein_coupling_1,\n            model_geometry = model_geometry\n        )\n\n        # Define first local Holstein coupling for first phonon mode.\n        holstein_coupling_2 = HolsteinCoupling(\n            model_geometry = model_geometry,\n            phonon_mode = phonon_2_id,\n            # Couple the second phonon mode to second orbital in the unit cell.\n            bond = lu.Bond(orbitals = (2,2), displacement = [0, 0]),\n            α_mean = α\n        )\n\n        # Add the first local Holstein coupling definition to the model.\n        holstein_coupling_2_id = add_holstein_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            holstein_coupling = holstein_coupling_2,\n            model_geometry = model_geometry\n        )\n\n        # Write model summary TOML file specifying Hamiltonian that will be simulated.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-model-parameters","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Initialize model parameters","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"In this section we need to make use of the MuTuner.jl package, initializing an instance of the MuTuner.MuTunerLogger type using the MuTuner.init_mutunerlogger function. Note that we use the LatticeUtilities.nsites function to calculate the total number of orbitals in our system.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize MuTunerLogger type that will be used to dynamically adjust the\n        # chemicaml potential during the simulation.\n        chemical_potential_tuner = mt.init_mutunerlogger(\n            target_density = n,\n            inverse_temperature = β,\n            system_size = lu.nsites(unit_cell, lattice),\n            initial_chemical_potential = μ,\n            complex_sign_problem = false\n        )","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-meuasurements","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Initialize meuasurements","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"No changes need to made to this section of the code from the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1), (2, 2), (1, 2)\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs of modes.\n                (1, 1), (2, 2), (1, 2)\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1), (2, 2),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1), (2, 2)\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1), (2, 2)\n            ]\n        )\n\n        # Initialize CDW correlation measurement.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"cdw\",\n            correlation = \"density\",\n            ids = [1, 2],\n            coefficients = [1.0, -1.0],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Initialize the sub-directories to which the various measurements will be written.\n        initialize_measurement_directories(comm, simulation_info, measurement_container)","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Write-first-checkpoint","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Write first checkpoint","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"Here we need to add the MuTuner.MuTunerLogger instance chemical_potential_tuner to the checkpoint file.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_updates,\n            tight_binding_parameters, electron_phonon_parameters, chemical_potential_tuner,\n            measurement_container, model_geometry, metadata, rng\n        )","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Load-checkpoint","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Load checkpoint","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"Here we need to make sure to load the MuTuner.MuTunerLogger instance chemical_potential_tuner from the checkpoint file.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters    = checkpoint[\"tight_binding_parameters\"]\n        electron_phonon_parameters  = checkpoint[\"electron_phonon_parameters\"]\n        chemical_potential_tuner    = checkpoint[\"chemical_potential_tuner\"]\n        measurement_container       = checkpoint[\"measurement_container\"]\n        model_geometry              = checkpoint[\"model_geometry\"]\n        metadata                    = checkpoint[\"metadata\"]\n        rng                         = checkpoint[\"rng\"]\n        n_therm                     = checkpoint[\"n_therm\"]\n        n_updates                   = checkpoint[\"n_updates\"]\n    end","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Setup-DQMC-simulation","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Setup DQMC simulation","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"No changes need to made to this section of the code from the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing EFA-HMC, reflection and swap updates below.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allcoate equal-time electron Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize electron Green's function matrx, also calculating the matrix determinant as the same time.\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize diagonostic parameters to asses numerical stability.\n    δG = zero(logdetG)\n    δθ = zero(sgndetG)","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Setup-EFA-HMC-Updates","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Setup EFA-HMC Updates","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"No changes need to made to this section of the code from the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"    # Number of fermionic time-steps in HMC update.\n    Nt = 10\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(2*Ω*Nt)\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Thermalize-system","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Thermalize system","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"Here we need to add a call to the update_chemical_potential! function after completeing the updates but before writing the checkpoint file is written. And again, we need to make sure the include the chemical_potential_tuner in the checkpoint file.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Update the chemical potential to achieve the target density.\n        (logdetG, sgndetG) = update_chemical_potential!(\n            G, logdetG, sgndetG;\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = update + 1,\n            n_updates = 1,\n            tight_binding_parameters, electron_phonon_parameters, chemical_potential_tuner,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Make-measurements","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Make measurements","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"Here we need to add a call to the update_chemical_potential! function after making and writing measurements but before writing the checkpoint file is written. And again, we need to make sure the include the chemical_potential_tuner in the checkpoint file.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"    # Reset diagonostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetG)\n    δθ = zero(sgndetG)\n\n    # Calculate the bin size.\n    bin_size = N_updates ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for update in n_updates:N_updates\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Make measurements.\n        (logdetG, sgndetG, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (electron_phonon_parameters,)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            update = update,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Update the chemical potential to achieve the target density.\n        (logdetG, sgndetG) = update_chemical_potential!(\n            G, logdetG, sgndetG;\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_updates = update + 1,\n            tight_binding_parameters, electron_phonon_parameters, chemical_potential_tuner,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Record-simulation-metadata","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Record simulation metadata","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"Here we can add a call to the save_density_tuning_profile, which records the full history of the chemical potential and density tuning process.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_updates + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_updates + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_updates + N_therm)\n\n    # Record largest numerical error encountered during simulation.\n    metadata[\"dG\"] = δG\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Save the density tuning profile to file.\n    save_density_tuning_profile(simulation_info, chemical_potential_tuner)","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Post-process-results","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Post-process results","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"No changes need to made to this section of the code from the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(comm, simulation_info.datafolder, N_bins, time_displaced = true)\n\n    # Merge binary files containing binned data into a single file.\n    compress_jld2_bins(comm, folder = simulation_info.datafolder)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Execute-script","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Execute script","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"Here we add an additional command line argument to specify the target density n we want to achieve in the simulation. Now the μ command line argument specifies the initial chemical potential we begin the simulation with. For instance, a simulation can be run with the command","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"mpiexecjl -n 16 julia holstein_honeycomb_density_tuning.jl 1 1.0 1.5 0.8 0.0 3 4.0 5000 10000 100 0.5","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"or","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"srun julia holstein_honeycomb_density_tuning.jl 1 1.0 1.5 0.8 0.0 3 4.0 5000 10000 100 0.5","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"where the target density is langle n rangle = 08 and the initial chemical potential is mu = 00.","category":"page"},{"location":"tutorials/holstein_honeycomb_density_tuning/","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID             = parse(Int,     ARGS[1]),  # Simulation ID.\n        Ω               = parse(Float64, ARGS[2]),  # Phonon energy.\n        α               = parse(Float64, ARGS[3]),  # Electron-phonon coupling.\n        n               = parse(Float64, ARGS[4]),  # Target density.\n        μ               = parse(Float64, ARGS[5]),  # Initial chemical potential.\n        L               = parse(Int,     ARGS[6]),  # System size.\n        β               = parse(Float64, ARGS[7]),  # Inverse temperature.\n        N_therm         = parse(Int,     ARGS[8]),  # Number of thermalization updates.\n        N_updates       = parse(Int,     ARGS[9]),  # Total number of measurements and measurement updates.\n        N_bins          = parse(Int,     ARGS[10]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[11]), # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/holstein_chain/#Holstein-Chain-with-Density-Tuning","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"","category":"section"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"In this example we simulate the Holstein model for electron-phonon models on a 1D chain given by","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"hatH = hatH_e + hatH_rm ph + hatH_etextrm-ph","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"The first term describes bare tight-binding Hamiltonian","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"hatH_e = -t sum_sigmai (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n            -mu sum_sigmai hatn_sigmai","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. The second terms is the bare phonon Hamiltonian","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"hatH_rm ph = sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"which describes a dispersionless phonon modes on each site in the lattice, where hatX_i  (hatP_i) is the position (momentum) operator for the phonon mode on site i in the lattice. The phonon frequency is given by Omega, and M is the corresponding ion mass associated with the phonon mode. Lastly, the third term introduces the Holstein electron-phonon interaction","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"hatH_etextrm-ph = alpha sum_sigmai hatX_i left( hatn_sigmai - frac12 right)","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"where the strength of the interaction is controlled by the parameter alpha.","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"The example script example_scripts/holstein_chain.jl additionally simulate the Holstein model with an algorithm recently recently introduced in Phys. Rev. E 105, 045311 that dynamically tunes the chemical potential during the simulation to achieve a target electron density.","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"> julia holstein_chain.jl 0 0.1 0.1 0.5 0.0 4.0 16 2000 10000 20","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"Here a Holstein chain of length L=16 is simulate with Omega = 01, alpha = 01 and inverse temperature beta = 40. The chemical potential is initialized to mu = 00, and then tuned to achieve are target electron density of langle n rangle = 05. In this example N_burnin = 2000 thermalizatoin HMC and refleciton updates are performed, followed by an additional N_updates = 10000 such updates, during which time an equivalent number of measurements are made. Bin averaged measurements are written to file N_bins = 20 during the simulation.","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n# Import the MuTuner module that implements the chemical potential tuning algorithm.\nimport SmoQyDQMC.MuTuner           as mt\n\n# Define top-level function for running the DQMC simulation.\nfunction run_holstein_chain_simulation(sID, Ω, α, n, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_chain_w%.2f_a%.2f_n%.2f_L%d_b%.2f\" Ω α n L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.05\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bin size.\n    bin_size = div(N_updates, N_bins)\n\n    # To update the phonon degrees of freedom in this code we primarily perform\n    # hybrid/hamiltonian Monte Carlo (HMC) updates. Below we specify some of the\n    # parameters associated with these HMC updates.\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 4\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(2*Ω)/Nt\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"reflection_acceptance_rate\" => 0.0,\n        \"radial_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"Nt\" => Nt,\n        \"dt\" => Δt,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Get the number of sites in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon\n    )\n\n    # Define a on-site Holstein coupling between the electron and the local dispersionless phonon mode.\n    holstein_coupling = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_id,\n    \tbond = lu.Bond(orbitals = (1,1), displacement = [0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model.\n    holstein_coupling_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Write a model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )\n\n    #################################################\n    ### INITIALIZE FINITE LATTICE MODEL PARAMETERS ##\n    #################################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize time-displaced phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(phonon_id, phonon_id)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Note that the spin-up and spin-down electron sectors are equivalent in the Holstein model\n    # without Hubbard interaction. Therefore, there is only a single Fermion determinant\n    # that needs to be calculated. This fact is reflected in the code below.\n\n    # Allocate fermion path integral type.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the fermion path integral type with respect to electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Allocate and initialize propagators for each imaginary time slice.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize fermion greens calculator.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize equal-time Green's function matrix\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt\n    )\n\n    # Initialize the density/chemical potential tuner.\n    # This type facilitates the tuning of the chemical potential to achieve\n    # at target electron density.\n    chemical_potential_tuner = mt.MuTunerLogger(n₀ = n, β = β, V = N, u₀ = 1.0, μ₀ = μ, c = 0.5)\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a reflection update.\n        # This update randomly selects a phonon mode in the lattice and reflects\n        # all the associated phonon about the origin, (xᵢ → -xᵢ).\n        # This updates all the phonon fields to cross the on-site energy barrier\n        # associated with bipolaron formation, helping reduce autocorrelation times.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng, phonon_types = (phonon_id,)\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a radial update.\n        (accepted, logdetG, sgndetG) = radial_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"radial_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n\n        # Update the chemical potential.\n        logdetG, sgndetG = update_chemical_potential!(\n            G, logdetG, sgndetG,\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B\n        )\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a reflection update.\n            (accepted, logdetG, sgndetG) = reflection_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, rng = rng, phonon_types = (phonon_id,)\n            )\n\n            # Record whether the reflection update was accepted or rejected.\n            additional_info[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform a radial update.\n            (accepted, logdetG, sgndetG) = radial_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, rng = rng\n            )\n\n            # Record whether the reflection update was accepted or rejected.\n            additional_info[\"radial_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Make measurements.\n            (logdetG, sgndetG, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (electron_phonon_parameters,)\n            )\n\n            # Update the chemical potential.\n            logdetG, sgndetG = update_chemical_potential!(\n                G, logdetG, sgndetG,\n                chemical_potential_tuner = chemical_potential_tuner,\n                tight_binding_parameters = tight_binding_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate HMC acceptance rate.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Calculate reflection update acceptance rate.\n    additional_info[\"reflection_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Calculate radial update acceptance rate.\n    additional_info[\"radial_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Save the density tuning profile.\n    save_density_tuning_profile(simulation_info, chemical_potential_tuner)\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ω = parse(Float64, ARGS[2])\n    α = parse(Float64, ARGS[3])\n    n = parse(Float64, ARGS[4]) # target electorn density\n    μ = parse(Float64, ARGS[5]) # intial chemical potential\n    β = parse(Float64, ARGS[6])\n    L = parse(Int, ARGS[7])\n    N_burnin = parse(Int, ARGS[8])\n    N_updates = parse(Int, ARGS[9])\n    N_bins = parse(Int, ARGS[10])\n\n    # Run the simulation.\n    run_holstein_chain_simulation(sID, Ω, α, n, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"Download this example as a Julia script.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#1d)-Square-Hubbard-Model-with-Density-Tuning","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"In this example we demonstrate how to introduce chemical potential and density tuning to the previous 1c) Square Hubbard Model with Checkpointing tutorial. Specifically, we show how to use the algorithm introduced in Phys. Rev. E 105, 045311 for dynamically adjusting the chemical potential during the simulation in order to achieve a target electron density or filling fraction.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"Note that when you dope the Hubbard model away from half-filling a sign problem is introduced. As with making measurements, if the sign problem becomes severe the density tuning algorithm will become very inefficient as simply providing an accurate measurement of the density and compressibility (which is used to adjust the chemical potential) will become challenging.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Import-Packages","page":"1d) Square Hubbard Model with Density Tuning","title":"Import Packages","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"Compared to the previouse 1c) Square Hubbard Model with Checkpointing tutorial, we now need to import the MuTuner.jl package, which is reexported by SmoQyDQMC.jl","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"using SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\nimport SmoQyDQMC.MuTuner as mt\n\nusing Random\nusing Printf\nusing MPI","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Specify-simulation-parameters","page":"1d) Square Hubbard Model with Density Tuning","title":"Specify simulation parameters","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"Here we introduce the keyword argument n to the run_simulation function which specifies the target electron density we want to achieve in the simulation. Now the μ argument specifies the initial chemical potential we begin the simulation with, but of course it will be adjusted during the simulation to achieve the target density n.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    U, # Hubbard interaction.\n    t′, # Next-nearest-neighbor hopping amplitude.\n    n, # Target density.\n    μ, # Initial chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_updates, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Initialize-simulation","page":"1d) Square Hubbard Model with Density Tuning","title":"Initialize simulation","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"No changes need to made to this section of the code from the previous 1c) Square Hubbard Model with Checkpointing tutorial.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_square_U%.2f_tp%.2f_n%.2f_L%d_b%.2f\" U t′ n L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to if one does not already exist.\n    initialize_datafolder(comm, simulation_info)","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Initialize-simulation-metadata","page":"1d) Square Hubbard Model with Density Tuning","title":"Initialize simulation metadata","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"Here it is useful to record the initial chemical potential μ used during the simulation in the metadata dictionary.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_updates = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize additiona_info dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"mu\"] = μ\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_updates\"] = N_updates\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"n_stab_init\"] = n_stab\n        metadata[\"dG_max\"] = δG_max\n        metadata[\"symmetric\"] = symmetric\n        metadata[\"checkerboard\"] = checkerboard\n        metadata[\"seed\"] = seed\n        metadata[\"avg_acceptance_rate\"] = 0.0","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Initialize-Model","page":"1d) Square Hubbard Model with Density Tuning","title":"Initialize Model","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"No changes need to made to this section of the code from the previous 1c) Square Hubbard Model with Checkpointing tutorial.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"        # Define unit cell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [[1.0, 0.0],\n                            [0.0, 1.0]],\n            basis_vecs = [[0.0, 0.0]]\n        )\n\n        # Define finite lattice with periodic boundary conditions.\n        lattice = lu.Lattice(\n            L = [L, L],\n            periodic = [true, true]\n        )\n\n        # Initialize model geometry.\n        model_geometry = ModelGeometry(\n            unit_cell, lattice\n        )\n\n        # Define the nearest-neighbor bond in +x direction.\n        bond_px = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, 0]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_px_id = add_bond!(model_geometry, bond_px)\n\n        # Define the nearest-neighbor bond in +y direction.\n        bond_py = lu.Bond(\n            orbitals = (1,1),\n            displacement = [0, 1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_py_id = add_bond!(model_geometry, bond_py)\n\n        # Define the next-nearest-neighbor bond in +x+y direction.\n        bond_pxpy = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, 1]\n        )\n\n        # Define the nearest-neighbor bond in -x direction.\n        # Will be used to make measurements later in this tutorial.\n        bond_nx = lu.Bond(\n            orbitals = (1,1),\n            displacement = [-1, 0]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n        # Define the nearest-neighbor bond in -y direction.\n        # Will be used to make measurements later in this tutorial.\n        bond_ny = lu.Bond(\n            orbitals = (1,1),\n            displacement = [0, -1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n        # Define the next-nearest-neighbor bond in +x+y direction.\n        bond_pxpy = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, 1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_pxpy_id = add_bond!(model_geometry, bond_pxpy)\n\n        # Define the next-nearest-neighbor bond in +x-y direction.\n        bond_pxny = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, -1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_pxny_id = add_bond!(model_geometry, bond_pxny)\n\n        # Set neartest-neighbor hopping amplitude to unity,\n        # setting the energy scale in the model.\n        t = 1.0\n\n        # Define the non-interacting tight-binding model.\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond_px, bond_py, bond_pxpy, bond_pxny], # defines hopping\n            t_mean  = [t, t, t′, t′], # defines corresponding mean hopping amplitude\n            t_std   = [0., 0., 0., 0.], # defines corresponding standard deviation in hopping amplitude\n            ϵ_mean  = [0.], # set mean on-site energy for each orbital in unit cell\n            ϵ_std   = [0.], # set standard deviation of on-site energy or each orbital in unit cell\n            μ       = μ # set chemical potential\n        )\n\n        # Define the Hubbard interaction in the model.\n        hubbard_model = HubbardModel(\n            shifted   = false, # if true, then Hubbard interaction is instead parameterized as U⋅nup⋅ndn\n            U_orbital = [1], # orbitals in unit cell with Hubbard interaction.\n            U_mean    = [U], # mean Hubbard interaction strength for corresponding orbital species in unit cell.\n            U_std     = [0.], # standard deviation of Hubbard interaction strength for corresponding orbital species in unit cell.\n        )\n\n        # Write model summary TOML file specifying Hamiltonian that will be simulated.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (hubbard_model,)\n        )","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Initialize-model-parameters","page":"1d) Square Hubbard Model with Density Tuning","title":"Initialize model parameters","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"In this section we need to make use of the MuTuner.jl package, initializing an instance of the MuTuner.MuTunerLogger type using the MuTuner.init_mutunerlogger function. Note that we use the LatticeUtilities.nsites function to calculate the total number of orbitals in our system.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize Hubbard interaction parameters.\n        hubbard_params = HubbardParameters(\n            model_geometry = model_geometry,\n            hubbard_model = hubbard_model,\n            rng = rng\n        )\n\n        # Apply Ising Hubbard-Stranonvich (HS) transformation to decouple the Hubbard interaction,\n        # and initialize the corresponding HS fields that will be sampled in the DQMC simulation.\n        hubbard_stratonovich_params = HubbardIsingHSParameters(\n            β = β, Δτ = Δτ,\n            hubbard_parameters = hubbard_params,\n            rng = rng\n        )\n\n        # Initialize MuTunerLogger type that will be used to dynamically adjust the\n        # chemicaml potential during the simulation.\n        chemical_potential_tuner = mt.init_mutunerlogger(\n            target_density = n,\n            inverse_temperature = β,\n            system_size = lu.nsites(unit_cell, lattice),\n            initial_chemical_potential = μ,\n            complex_sign_problem = false\n        )","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Initialize-measurements","page":"1d) Square Hubbard Model with Density Tuning","title":"Initialize measurements","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"No changes need to made to this section of the code from the previous 1c) Square Hubbard Model with Checkpointing tutorial.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the Hubbard interaction related measurements.\n        initialize_measurements!(measurement_container, hubbard_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the d-wave pair susceptibility measurement.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"d-wave\",\n            correlation = \"pair\",\n            ids = [bond_px_id, bond_nx_id, bond_py_id, bond_ny_id],\n            coefficients = [0.5, 0.5, -0.5, -0.5],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Initialize the sub-directories to which the various measurements will be written.\n        initialize_measurement_directories(comm, simulation_info, measurement_container)","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Write-first-checkpoint","page":"1d) Square Hubbard Model with Density Tuning","title":"Write first checkpoint","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"Here we need to add the MuTuner.MuTunerLogger instance chemical_potential_tuner to the checkpoint file.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_updates,\n            tight_binding_parameters, hubbard_params, hubbard_stratonovich_params,\n            chemical_potential_tuner, measurement_container, model_geometry, metadata, rng\n        )","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Load-checkpoint","page":"1d) Square Hubbard Model with Density Tuning","title":"Load checkpoint","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"Here we need to make sure to load the MuTuner.MuTunerLogger instance chemical_potential_tuner from the checkpoint file.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters    = checkpoint[\"tight_binding_parameters\"]\n        hubbard_params              = checkpoint[\"hubbard_params\"]\n        hubbard_stratonovich_params = checkpoint[\"hubbard_stratonovich_params\"]\n        chemical_potential_tuner    = checkpoint[\"chemical_potential_tuner\"]\n        measurement_container       = checkpoint[\"measurement_container\"]\n        model_geometry              = checkpoint[\"model_geometry\"]\n        metadata                    = checkpoint[\"metadata\"]\n        rng                         = checkpoint[\"rng\"]\n        n_therm                     = checkpoint[\"n_therm\"]\n        n_updates                   = checkpoint[\"n_updates\"]\n    end","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Setup-DQMC-simulation","page":"1d) Square Hubbard Model with Density Tuning","title":"Setup DQMC simulation","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"No changes need to made to this section of the code from the previous 1c) Square Hubbard Model with Checkpointing tutorial.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for Hubbard interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_params)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for the current\n    # Hubbard-Stratonovich field configuration.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_stratonovich_params)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices for spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type for spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # Gup(τ,τ)\n    Gup_τ0 = similar(Gup) # Gup(τ,0)\n    Gup_0τ = similar(Gup) # Gup(0,τ)\n    Gdn_ττ = similar(Gdn) # Gdn(τ,τ)\n    Gdn_τ0 = similar(Gdn) # Gdn(τ,0)\n    Gdn_0τ = similar(Gdn) # Gdn(0,τ)\n\n    # Initialize diagonostic parameters to asses numerical stability.\n    δG = zero(logdetGup)\n    δθ = zero(sgndetGup)","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Thermalize-system","page":"1d) Square Hubbard Model with Density Tuning","title":"Thermalize system","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"Here we need to add a call to the update_chemical_potential! function after completeing the updates but before writing the checkpoint file is written. And again, we need to make sure the include the chemical_potential_tuner in the checkpoint file.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_stratonovich_params,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n            update_stabilization_frequency = true\n        )\n\n        # Record acceptance rate for sweep.\n        metadata[\"avg_acceptance_rate\"] += acceptance_rate\n\n        # Update the chemical potential to achieve the target density.\n        (logdetGup, sgndetGup, logdetGdn, sgndetGdn) = update_chemical_potential!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn;\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm = update + 1,\n            n_updates = 1,\n            tight_binding_parameters, hubbard_params, hubbard_stratonovich_params,\n            chemical_potential_tuner, measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Make-measurements","page":"1d) Square Hubbard Model with Density Tuning","title":"Make measurements","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"Here we need to add a call to the update_chemical_potential! function after making and writing measurements but before writing the checkpoint file is written. And again, we need to make sure the include the chemical_potential_tuner in the checkpoint file.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"    # Reset diagonostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetGup)\n    δθ = zero(sgndetGup)\n\n    # Calculate the bin size.\n    bin_size = N_updates ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for update in n_updates:N_updates\n\n        # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_stratonovich_params,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n            update_stabilization_frequency = true\n        )\n\n        # Record acceptance rate.\n        metadata[\"avg_acceptance_rate\"] += acceptance_rate\n\n        # Make measurements.\n        (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n            logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (hubbard_params, hubbard_stratonovich_params)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            update = update,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Update the chemical potential to achieve the target density.\n        (logdetGup, sgndetGup, logdetGdn, sgndetGdn) = update_chemical_potential!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn;\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_updates = update + 1,\n            tight_binding_parameters, hubbard_params, hubbard_stratonovich_params,\n            chemical_potential_tuner, measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Record-simulation-metadata","page":"1d) Square Hubbard Model with Density Tuning","title":"Record simulation metadata","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"Here we can add a call to the save_density_tuning_profile, which records the full history of the chemical potential and density tuning process.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"    # Normalize acceptance rate.\n    metadata[\"avg_acceptance_rate\"] /=  (N_therm + N_updates)\n\n    metadata[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record largest numerical error.\n    metadata[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Save the density tuning profile to file.\n    save_density_tuning_profile(simulation_info, chemical_potential_tuner)","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Post-process-results","page":"1d) Square Hubbard Model with Density Tuning","title":"Post-process results","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"No changes need to made to this section of the code from the previous 1c) Square Hubbard Model with Checkpointing tutorial.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"    # Set the number of bins used to calculate the error in measured observables.\n    n_bins = N_bins\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(comm, simulation_info.datafolder, n_bins, time_displaced = false)\n\n    # Calculate AFM correlation ratio.\n    Rafm, ΔRafm = compute_correlation_ratio(\n        comm;\n        folder = simulation_info.datafolder,\n        correlation = \"spin_z\",\n        type = \"equal-time\",\n        id_pairs = [(1, 1)],\n        coefs = [1.0],\n        k_point = (L÷2, L÷2), # Corresponds to Q_afm = (π/a, π/a).\n        num_bins = n_bins\n    )\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rafm_real_mean\"] = real(Rafm)\n    metadata[\"Rafm_imag_mean\"] = imag(Rafm)\n    metadata[\"Rafm_std\"]       = ΔRafm\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Merge binary files containing binned data into a single file.\n    compress_jld2_bins(comm, folder = simulation_info.datafolder)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/#Execute-script","page":"1d) Square Hubbard Model with Density Tuning","title":"Execute script","text":"","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"Here we add an additional command line argument to specify the target density n we want to achieve in the simulation. Now the μ command line argument specifies the initial chemical potential we begin the simulation with. For instance, a simulation can be run with the command","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"mpiexecjl -n 16 julia hubbard_square_density_tuning.jl 1 5.0 -0.25 0.8 0.0 4 4.0 2500 10000 100 1.0","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"or","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"srun julia hubbard_square_density_tuning.jl 1 5.0 -0.25 0.8 0.0 4 4.0 2500 10000 100 1.0","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"where the target density is langle n rangle = 08 and the initial chemical potential is mu = 00.","category":"page"},{"location":"tutorials/hubbard_square_density_tuning/","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"if abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation, reading in command line arguments.\n    run_simulation(\n        comm;\n        sID             = parse(Int,     ARGS[1]),  # Simulation ID.\n        U               = parse(Float64, ARGS[2]),  # Hubbard interaction.\n        t′              = parse(Float64, ARGS[3]),  # Next-nearest-neighbor hopping amplitude.\n        n               = parse(Float64, ARGS[4]),  # Target density.\n        μ               = parse(Float64, ARGS[5]),  # Initial chemical potential.\n        L               = parse(Int,     ARGS[6]),  # System size.\n        β               = parse(Float64, ARGS[7]),  # Inverse temperature.\n        N_therm         = parse(Int,     ARGS[8]),  # Number of thermalization updates.\n        N_updates       = parse(Int,     ARGS[9]),  # Total number of measurements and measurement updates.\n        N_bins          = parse(Int,     ARGS[10]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[11])  # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/hubbard_threeband/#Three-Band-Hubbard-Model","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"","category":"section"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"In this example we simulate an effective two-dimensional 3-band Hubbard model meant to represent a copper-oxide plane in the superconducting cuprates, with a Hamiltonian written in hole language given by","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"beginalign*\nhatH=  sum_sigmalangle ijalpharanglet_pd^ijalpha(hatd_sigmai^daggerhatp_sigmajalpha^phantomdagger+rm hc)\n           + sum_sigmalangle ialphajalpharanglet_pp^ialphajalpha(hatp_sigmaialpha^daggerhatp_sigmajalpha^phantomdagger+rm hc)\n          +(epsilon_d-mu)sum_sigmaihatn_uparrowi^d+(epsilon_p-mu)sum_sigmajhatn_sigmajalpha^p\n          +U_dsum_ihatn_uparrowi^dhatn_downarrowi^d+U_psum_jalphahatn_uparrowjalpha^phatn_downarrowjalpha^p\nendalign*","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"The operator hatd^dagger_sigma i  (hatd^phantom dagger_sigma i) creates (annihilates) a spin-sigma hole on a Cu-3d_x^2-y^2 orbital in unit i in the lattice. The hatp^dagger_sigmaialpha  (hatp^phantom dagger_sigmaialpha) operator creates (annihilates) a spin-sigma hole on a O-2p_alpha orbital in unit cell i, where alpha = x  rm or  y The corresponding spin-sigma hole number operators for the Cu-3d_x^2-y^2 and O-2p_alpha orbitals in unit cell i are hatn^d_sigmai and hatn^p_sigmaialpha. The hopping integrals between the Cu-3d_x^2-y^2 orbitals and nearest-neighbor O-2p_alpha are parameterized as t_pd^ijalpha = P_pd^ijalpha t_pd where P_pd^ijalpha = pm 1 is a overall phase factor. Similarly, the hopping integral between nearest-neighbor O-2p_x and O-2p_y orbitals is parameterized as t_pp^ialphajalpha = P_pp^ialphajalpha t_pp, where again P_pp^ialphajalpha t_pp = pm 1 is an overall phase factor. Refer to Fig. 1 in PhysRevB.103.144514 to see a figure detailing these phase factor conventions. The on-site energies epsilon_d and epsilon_p are for the Cu-3d_x^2-y^2 and O-2p_alpha orbitals respectively, and mu is the global chemical potential. Finally, U_d and U_p are the on-site Hubbard interactions for the Cu-3d_x^2-y^2 and O-2p_alpha orbitals respectively.","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"> julia hubbard_threeband.jl 0 8.5 4.1 1.13 0.49 0.0 3.24 0.0 4.0 8 2 2000 10000 50","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"In this example we are simulating the three-band Hubbard model on a 8 times 2 unit cell finite lattice at inverse temperature beta = 40. The on-site Hubbard interaction on the Cu-3d_x^2-y^2 and O-2p_alpha is U_d = 85 and U_p = 41 respectively. The nearest-neighbor hopping integral amplitude between the Cu-3d_x^2-y^2 and O-2p_alpha orbitals is t_pd = 113, while it is t_pp = 049 between the nearest-neighbor O-2p_x and O-2p_y orbitals. The on-site energy for the Cu-3d_x^2-y^2 and O-2p_alpha orbitals epsilon_d = 00 and epsilon_p = 325. Lastly, the global chemical potential is set to mu = 00. In this simulation N_burnin = 2000 sweeps through the lattice updating the Hubbard-Stratonovich fields are performed to thermalize the system, followed by N_udpates = 10000 sweeps, after each of which measurements are made. Bin averaged measurements are written to file N_bins = 50 times during the simulation.","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running DQMC simulation\nfunction run_hubbard_threeband_simulation(sID, Ud, Up, tpd, tpp, ϵd, ϵp, μ, β, Lx, Ly, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_threeband_Ud%.2f_Up%.2f_tpd%.2f_tpp%.2f_ed%.2f_ep%.2f_mu%.2f_b%.2f_Lx%d_Ly%d\" Ud Up tpd tpp ϵd ϵp μ β Lx Ly\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[1.0, 0.0], [0.0, 1.0]],\n        basis_vecs   = [[0.0, 0.0], # Orbital ID = 1 <==> Cu-3d\n                        [0.5, 0.0], # Orbital ID = 2 <==> O-2px\n                        [0.0, 0.5]] # Orbital ID = 3 <==> O-2py\n    )\n\n    # Initialize variables to map orbitals to orbital ID.\n    (Cu_3d, O_2px, O_2py) = (1, 2, 3)\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [Lx, Ly],\n        periodic = [true, true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define bond going from Cu-3d to O-2px in +x direction.\n    bond_3d_2px_px = lu.Bond(orbitals = (Cu_3d, O_2px), displacement = [0,0])\n    bond_3d_2px_px_id = add_bond!(model_geometry, bond_3d_2px_px)\n\n    # Define bond going from Cu-3d to O-2py in +y direction.\n    bond_3d_2py_py = lu.Bond(orbitals = (Cu_3d, O_2py), displacement = [0,0])\n    bond_3d_2py_py_id = add_bond!(model_geometry, bond_3d_2py_py)\n\n    # Define bond going from Cu-3d to O-2px in -x direction.\n    bond_2px_3d_nx = lu.Bond(orbitals = (Cu_3d, O_2px), displacement = [-1,0])\n    bond_2px_3d_nx_id = add_bond!(model_geometry, bond_2px_3d_nx)\n\n    # Define bond going from Cu-3d to O-2py in -y direction.\n    bond_2py_3d_ny = lu.Bond(orbitals = (Cu_3d, O_2py), displacement = [0,-1])\n    bond_2py_3d_ny_id = add_bond!(model_geometry, bond_2py_3d_ny)\n\n    # Define bond going from O-2px to O-2py in the (-x+y)/√2 direction.\n    bond_2px_2py_nxpy = lu.Bond(orbitals = (O_2px, O_2py), displacement = [0,0])\n    bond_2px_2py_nxpy_id = add_bond!(model_geometry, bond_2px_2py_nxpy)\n\n    # Define bond going to O-2px to O-2py in the (-x-y)/√2 direction.\n    bond_2px_2py_nxny = lu.Bond(orbitals = (O_2px, O_2py), displacement = [0,-1])\n    bond_2px_2py_nxny_id = add_bond!(model_geometry, bond_2px_2py_nxny)\n\n    # Define bond going from O-2px to O-2py in the (+x+y)/√2 direction.\n    bond_2px_2py_pxpy = lu.Bond(orbitals = (O_2px, O_2py), displacement = [1,0])\n    bond_2px_2py_pxpy_id = add_bond!(model_geometry, bond_2px_2py_pxpy)\n\n    # Define bond going from O-2px to O-2py in the (+x-y)/√2 direction.\n    bond_2px_2py_pxny = lu.Bond(orbitals = (O_2px, O_2py), displacement = [1,-1])\n    bond_2px_2py_pxny_id = add_bond!(model_geometry, bond_2px_2py_pxny)\n\n    # These nexts bonds are needed to measuring a pairing channel needed to\n    # reconstruct the d-wave pair susceptibility.\n\n    # Define bond going from Cu-3d to Cu-3d in +x direction.\n    bond_3d_3d_px = lu.Bond(orbitals = (Cu_3d, Cu_3d), displacement = [1, 0])\n    bond_3d_3d_px_id = add_bond!(model_geometry, bond_3d_3d_px)\n\n    # Define bond going from Cu-3d to Cu-3d in -x direction.\n    bond_3d_3d_nx = lu.Bond(orbitals = (Cu_3d, Cu_3d), displacement = [-1, 0])\n    bond_3d_3d_nx_id = add_bond!(model_geometry, bond_3d_3d_nx)\n\n    # Define bond going from Cu-3d to Cu-3d in +y direction.\n    bond_3d_3d_py = lu.Bond(orbitals = (Cu_3d, Cu_3d), displacement = [0, 1])\n    bond_3d_3d_py_id = add_bond!(model_geometry, bond_3d_3d_py)\n\n    # Define bond going from Cu-3d to Cu-3d in -y direction.\n    bond_3d_3d_ny = lu.Bond(orbitals = (Cu_3d, Cu_3d), displacement = [0, -1])\n    bond_3d_3d_ny_id = add_bond!(model_geometry, bond_3d_3d_ny)\n\n    # Define tight binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        μ = μ,\n        ϵ_mean  = [ϵd, ϵp, ϵp],\n        t_bonds = [bond_3d_2px_px, bond_3d_2py_py, bond_2px_3d_nx, bond_2py_3d_ny,\n                   bond_2px_2py_nxpy, bond_2px_2py_nxny, bond_2px_2py_pxpy, bond_2px_2py_pxny],\n        t_mean  = [tpd, -tpd, -tpd, tpd, -tpp, tpp, tpp, -tpp]\n    )\n\n    # Initialize a finite Hubbard interaction just on copper orbitals.\n    if iszero(Up)\n        hubbard_model = HubbardModel(\n            shifted   = true, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n            U_orbital = [1, 2, 3],\n            U_mean    = [Ud, Up, Up],\n        )\n    # Initialize the Hubbard interaction on copper and oxygen orbitals.\n    else\n        hubbard_model = HubbardModel(\n            shifted   = true, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n            U_orbital = [1],\n            U_mean    = [Ud],\n        )\n    end\n\n    # Write the model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (Cu_3d, O_2px), (Cu_3d, O_2py), (O_2px, O_2py)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (Cu_3d, O_2px), (Cu_3d, O_2py), (O_2px, O_2py)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (Cu_3d, O_2px), (Cu_3d, O_2py), (O_2px, O_2py)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (Cu_3d, O_2px), (Cu_3d, O_2py), (O_2px, O_2py)]\n    )\n\n    # Measure all possible combinations of bond pairing channels\n    # for the bonds we have defined. We will need each of these\n    # pairs channels measured in order to reconstruct the extended\n    # s-wave and d-wave pair susceptibilities.\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (bond_3d_3d_px_id, bond_3d_3d_px_id), (bond_3d_3d_px_id, bond_3d_3d_nx_id),\n                 (bond_3d_3d_nx_id, bond_3d_3d_px_id), (bond_3d_3d_nx_id, bond_3d_3d_nx_id),\n                 (bond_3d_3d_py_id, bond_3d_3d_py_id), (bond_3d_3d_py_id, bond_3d_3d_ny_id),\n                 (bond_3d_3d_ny_id, bond_3d_3d_py_id), (bond_3d_3d_ny_id, bond_3d_3d_ny_id),\n                 (bond_3d_3d_px_id, bond_3d_3d_py_id), (bond_3d_3d_px_id, bond_3d_3d_ny_id),\n                 (bond_3d_3d_nx_id, bond_3d_3d_py_id), (bond_3d_3d_nx_id, bond_3d_3d_ny_id),\n                 (bond_3d_3d_py_id, bond_3d_3d_px_id), (bond_3d_3d_py_id, bond_3d_3d_nx_id),\n                 (bond_3d_3d_ny_id, bond_3d_3d_px_id), (bond_3d_3d_ny_id, bond_3d_3d_nx_id)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters, hubbard_ising_parameters)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    # Measure the d-wave pair suspcetibility.\n    P_d, ΔP_d = composite_correlation_stat(\n        folder = simulation_info.datafolder,\n        correlation = \"pair\",\n        space = \"momentum\",\n        type = \"integrated\",\n        ids = [(bond_3d_3d_px_id, bond_3d_3d_px_id), (bond_3d_3d_px_id, bond_3d_3d_nx_id),\n               (bond_3d_3d_nx_id, bond_3d_3d_px_id), (bond_3d_3d_nx_id, bond_3d_3d_nx_id),\n               (bond_3d_3d_py_id, bond_3d_3d_py_id), (bond_3d_3d_py_id, bond_3d_3d_ny_id),\n               (bond_3d_3d_ny_id, bond_3d_3d_py_id), (bond_3d_3d_ny_id, bond_3d_3d_ny_id),\n               (bond_3d_3d_px_id, bond_3d_3d_py_id), (bond_3d_3d_px_id, bond_3d_3d_ny_id),\n               (bond_3d_3d_nx_id, bond_3d_3d_py_id), (bond_3d_3d_nx_id, bond_3d_3d_ny_id),\n               (bond_3d_3d_py_id, bond_3d_3d_px_id), (bond_3d_3d_py_id, bond_3d_3d_nx_id),\n               (bond_3d_3d_ny_id, bond_3d_3d_px_id), (bond_3d_3d_ny_id, bond_3d_3d_nx_id)],\n        locs = [(0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0)],\n        num_bins = N_bins,\n        f = (P_px_px, P_px_nx,\n             P_nx_px, P_nx_nx,\n             P_py_py, P_py_ny,\n             P_ny_py, P_ny_ny,\n             P_px_py, P_px_ny,\n             P_nx_py, P_nx_ny,\n             P_py_px, P_py_nx,\n             P_ny_px, P_ny_nx) -> (P_px_px + P_px_nx +\n                                   P_nx_px + P_nx_nx +\n                                   P_py_py + P_py_ny +\n                                   P_ny_py + P_ny_ny -\n                                   P_px_py - P_px_ny -\n                                   P_nx_py - P_nx_ny -\n                                   P_py_px - P_py_nx -\n                                   P_ny_px - P_ny_nx)/4\n    )\n\n    # Record the d-wave pair suspcetibility.\n    additional_info[\"P_d_mean\"] = real(P_d)\n    additional_info[\"P_d_std\"]  = ΔP_d\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    return nothing\nend\n\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ud = parse(Float64, ARGS[2])\n    Up = parse(Float64, ARGS[3])\n    tpd = parse(Float64, ARGS[4])\n    tpp = parse(Float64, ARGS[5])\n    ϵd = parse(Float64, ARGS[6])\n    ϵp = parse(Float64, ARGS[7])\n    μ = parse(Float64, ARGS[8])\n    β = parse(Float64, ARGS[9])\n    Lx = parse(Int, ARGS[10])\n    Ly = parse(Int, ARGS[11])\n    N_burnin = parse(Int, ARGS[12])\n    N_updates = parse(Int, ARGS[13])\n    N_bins = parse(Int, ARGS[14])\n\n    # Run the simulation.\n    run_hubbard_threeband_simulation(sID, Ud, Up, tpd, tpp, ϵd, ϵp, μ, β, Lx, Ly, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"Download this example as a Julia script.","category":"page"},{"location":"tutorials/hubbard_square_mpi/#1b)-Square-Hubbard-Model-with-MPI-Parallelization","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"","category":"section"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"This tutorial will build on the previous 1a) Square Hubbard Model tutorial, demonstrating how to add parallelization with MPI using the MPI.jl package. By this we mean that each MPI process will act as independent walker, running it's own independent DQMC simulation, with the final reported estimates for measured quantities being the average across all walkers.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"The exposition in this tutorial will focus on the changes that need to be made to the 1a) Square Hubbard Model tutorial to introduce MPI parallelization, omitting a more comprehensive discussion of other parts of the code that were included in the previous tutorial.","category":"page"},{"location":"tutorials/hubbard_square_mpi/#Import-Packages","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Import Packages","text":"","category":"section"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"We now need to import the MPI.jl package as well.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"using SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf\nusing MPI","category":"page"},{"location":"tutorials/hubbard_square_mpi/#Specify-simulation-parameters","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Specify simulation parameters","text":"","category":"section"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"Here we have introduced the comm argument to the run_simulation function, which is a type exported by the MPI.jl package to facilitate communication and synchronization between the different MPI processes.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    U, # Hubbard interaction.\n    t′, # Next-nearest-neighbor hopping amplitude.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_updates, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"page"},{"location":"tutorials/hubbard_square_mpi/#Initialize-simulation","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Initialize simulation","text":"","category":"section"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"Now when initializing the SimulationInfo type, we also need to include the MPI process ID pID, which can be retrieved using the MPI.Comm_rank function.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"We also the initialize_datafolder function such that it takes the comm as the first argument. This ensures that all the MPI processes remained synchronized, and none try proceeding beyond this point until the data folder has been initialized.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_square_U%.2f_tp%.2f_mu%.2f_L%d_b%.2f\" U t′ μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)","category":"page"},{"location":"tutorials/hubbard_square_mpi/#Initialize-simulation-metadata","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Initialize simulation metadata","text":"","category":"section"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"    # Initialize random number generator\n    rng = Xoshiro(seed)\n\n    # Initialize additiona_info dictionary\n    metadata = Dict()\n\n    # Record simulation parameters.\n    metadata[\"N_therm\"] = N_therm\n    metadata[\"N_updates\"] = N_updates\n    metadata[\"N_bins\"] = N_bins\n    metadata[\"n_stab_init\"] = n_stab\n    metadata[\"dG_max\"] = δG_max\n    metadata[\"symmetric\"] = symmetric\n    metadata[\"checkerboard\"] = checkerboard\n    metadata[\"seed\"] = seed\n    metadata[\"avg_acceptance_rate\"] = 0.0","category":"page"},{"location":"tutorials/hubbard_square_mpi/#Initialize-model","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Initialize model","text":"","category":"section"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"    # Define unit cell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[1.0, 0.0],\n                        [0.0, 1.0]],\n        basis_vecs = [[0.0, 0.0]]\n    )\n\n    # Define finite lattice with periodic boundary conditions.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize model geometry.\n    model_geometry = ModelGeometry(\n        unit_cell, lattice\n    )\n\n    # Define the nearest-neighbor bond in +x direction.\n    bond_px = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, 0]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_px_id = add_bond!(model_geometry, bond_px)\n\n    # Define the nearest-neighbor bond in +y direction.\n    bond_py = lu.Bond(\n        orbitals = (1,1),\n        displacement = [0, 1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_py_id = add_bond!(model_geometry, bond_py)\n\n    # Define the next-nearest-neighbor bond in +x+y direction.\n    bond_pxpy = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, 1]\n    )\n\n    # Define the nearest-neighbor bond in -x direction.\n    # Will be used to make measurements later in this tutorial.\n    bond_nx = lu.Bond(\n        orbitals = (1,1),\n        displacement = [-1, 0]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n    # Define the nearest-neighbor bond in -y direction.\n    # Will be used to make measurements later in this tutorial.\n    bond_ny = lu.Bond(\n        orbitals = (1,1),\n        displacement = [0, -1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n    # Define the next-nearest-neighbor bond in +x+y direction.\n    bond_pxpy = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, 1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_pxpy_id = add_bond!(model_geometry, bond_pxpy)\n\n    # Define the next-nearest-neighbor bond in +x-y direction.\n    bond_pxny = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, -1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_pxny_id = add_bond!(model_geometry, bond_pxny)\n\n    # Set neartest-neighbor hopping amplitude to unity,\n    # setting the energy scale in the model.\n    t = 1.0\n\n    # Define the non-interacting tight-binding model.\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_px, bond_py, bond_pxpy, bond_pxny], # defines hopping\n        t_mean  = [t, t, t′, t′], # defines corresponding mean hopping amplitude\n        t_std   = [0., 0., 0., 0.], # defines corresponding standard deviation in hopping amplitude\n        ϵ_mean  = [0.], # set mean on-site energy for each orbital in unit cell\n        ϵ_std   = [0.], # set standard deviation of on-site energy or each orbital in unit cell\n        μ       = μ # set chemical potential\n    )\n\n    # Define the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted   = false, # if true, then Hubbard interaction is instead parameterized as U⋅nup⋅ndn\n        U_orbital = [1], # orbitals in unit cell with Hubbard interaction.\n        U_mean    = [U], # mean Hubbard interaction strength for corresponding orbital species in unit cell.\n        U_std     = [0.], # standard deviation of Hubbard interaction strength for corresponding orbital species in unit cell.\n    )\n\n    # Write model summary TOML file specifying Hamiltonian that will be simulated.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )","category":"page"},{"location":"tutorials/hubbard_square_mpi/#Initialize-model-parameters","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Initialize model parameters","text":"","category":"section"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_params = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation to decouple the Hubbard interaction,\n    # and initialize the corresponding HS fields that will be sampled in the DQMC simulation.\n    hubbard_stratonovich_params = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_params,\n        rng = rng\n    )","category":"page"},{"location":"tutorials/hubbard_square_mpi/#Initialize-meuasurements","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Initialize meuasurements","text":"","category":"section"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"The only change we need to make to this section of the code from the previous 1a) Square Hubbard Model tutorial is to add the comm as the first argument to the initialize_measurement_directories function. The ensures that not of the MPI processes proceed beyond that point until the directory structure has been initialized.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the d-wave pair susceptibility measurement.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"d-wave\",\n        correlation = \"pair\",\n        ids = [bond_px_id, bond_nx_id, bond_py_id, bond_ny_id],\n        coefficients = [0.5, 0.5, -0.5, -0.5],\n        time_displaced = false,\n        integrated = true\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(comm, simulation_info, measurement_container)","category":"page"},{"location":"tutorials/hubbard_square_mpi/#Setup-DQMC-simulation","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Setup DQMC simulation","text":"","category":"section"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for Hubbard interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_params)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for the current\n    # Hubbard-Stratonovich field configuration.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_stratonovich_params)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices for spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type for spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # Gup(τ,τ)\n    Gup_τ0 = similar(Gup) # Gup(τ,0)\n    Gup_0τ = similar(Gup) # Gup(0,τ)\n    Gdn_ττ = similar(Gdn) # Gdn(τ,τ)\n    Gdn_τ0 = similar(Gdn) # Gdn(τ,0)\n    Gdn_0τ = similar(Gdn) # Gdn(0,τ)\n\n    # Initialize diagonostic parameters to asses numerical stability.\n    δG = zero(logdetGup)\n    δθ = zero(sgndetGup)","category":"page"},{"location":"tutorials/hubbard_square_mpi/#Thermalize-system","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Thermalize system","text":"","category":"section"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"    # Iterate over number of thermalization updates to perform.\n    for n in 1:N_therm\n\n        # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_stratonovich_params,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n            update_stabilization_frequency = true\n        )\n\n        # Record acceptance rate for sweep.\n        metadata[\"avg_acceptance_rate\"] += acceptance_rate\n    end","category":"page"},{"location":"tutorials/hubbard_square_mpi/#Make-measurements","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Make measurements","text":"","category":"section"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"    # Reset diagonostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetGup)\n    δθ = zero(sgndetGup)\n\n    # Calculate the bin size.\n    bin_size = N_updates ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for update in 1:N_updates\n\n        # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_stratonovich_params,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n            update_stabilization_frequency = true\n        )\n\n        # Record acceptance rate.\n        metadata[\"avg_acceptance_rate\"] += acceptance_rate\n\n        # Make measurements.\n        (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n            logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (hubbard_params, hubbard_stratonovich_params)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            update = update,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end","category":"page"},{"location":"tutorials/hubbard_square_mpi/#Record-simulation-metadata","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Record simulation metadata","text":"","category":"section"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"    # Normalize acceptance rate.\n    metadata[\"avg_acceptance_rate\"] /=  (N_therm + N_updates)\n\n    metadata[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record largest numerical error.\n    metadata[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)","category":"page"},{"location":"tutorials/hubbard_square_mpi/#Post-rocess-results","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Post-rocess results","text":"","category":"section"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"The main change we need to make from the previos 1a) Square Hubbard Model tutorial is to call the process_measurements, compute_correlation_ratio and compress_jld2_bins function such that the first argument is the comm object, thereby ensuring a parallelized version of each method is called.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"    # Set the number of bins used to calculate the error in measured observables.\n    n_bins = N_bins\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(comm, simulation_info.datafolder, n_bins, time_displaced = false)\n\n    # Calculate AFM correlation ratio.\n    Rafm, ΔRafm = compute_correlation_ratio(\n        comm;\n        folder = simulation_info.datafolder,\n        correlation = \"spin_z\",\n        type = \"equal-time\",\n        id_pairs = [(1, 1)],\n        coefs = [1.0],\n        k_point = (L÷2, L÷2), # Corresponds to Q_afm = (π/a, π/a).\n        num_bins = n_bins\n    )\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rafm_real_mean\"] = real(Rafm)\n    metadata[\"Rafm_imag_mean\"] = imag(Rafm)\n    metadata[\"Rafm_std\"]       = ΔRafm\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Merge binary files containing binned data into a single file.\n    compress_jld2_bins(comm, folder = simulation_info.datafolder)\n\n    return nothing\nend # end of run_simulation function","category":"page"},{"location":"tutorials/hubbard_square_mpi/#Execute-script","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Execute script","text":"","category":"section"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"Here we first need to initialize MPI using the MPI.Init command. Then, we need to make sure to pass the comm = MPI.COMM_WORLD to the run_simulation function. At the very end of simulation it is good practice to run the MPI.Finalize() function even though it is typically not strictly required.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"Only excute if the script is run directly from the command line.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"if abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation, reading in command line arguments.\n    run_simulation(\n        comm;\n        sID       = parse(Int,     ARGS[1]), # Simulation ID.\n        U         = parse(Float64, ARGS[2]), # Hubbard interaction.\n        t′        = parse(Float64, ARGS[3]), # Next-nearest-neighbor hopping amplitude.\n        μ         = parse(Float64, ARGS[4]), # Chemical potential.\n        L         = parse(Int,     ARGS[5]), # System size.\n        β         = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm   = parse(Int,     ARGS[7]), # Number of thermalization updates.\n        N_updates = parse(Int,     ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins    = parse(Int,     ARGS[9])  # Number of times bin-averaged measurements are written to file.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"Here is an example of what the command to run this script might look like:","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"mpiexecjl -n 16 julia hubbard_square_mpi.jl 1 5.0 -0.25 -2.0 4 4.0 2500 10000 100","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"This will 16 MPI processes, each running and independent simulation using a different random seed the final results arrived at by averaging over all 16 walkers. Here mpiexecjl is the MPI exectuable that can be easily install using the directions found here in the MPI.jl documentation. However, you can substitute a different MPI executable here if one is already configured on your system.","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"Also, when submitting jobs via SLURM on a High-Performance Computing (HPC) cluster, if a default MPI exectuable is already configured on the system, as is frequently the case, then the script can likely be run inside the *.sh job file using the srun command:","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"srun julia hubbard_square_mpi.jl 1 5.0 -0.25 -2.0 4 4.0 2500 10000 100","category":"page"},{"location":"tutorials/hubbard_square_mpi/","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"The srun command should automatically detect the number of available cores requested by the job and run the script using the MPI executable with the appropriate number of processes.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Download this example as a Julia script.","category":"page"},{"location":"tutorials/hubbard_square/#1a)-Square-Hubbard-Model","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"","category":"section"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"In this example we will work through simulating the repulsive Hubbard model on a square lattice. The Hubbard Hamiltonian for a square lattice given by","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"beginalign\nhatH = \n-t sum_langle i j rangle sigma (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n-t^prime sum_langlelangle i j ranglerangle sigma (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc) \n + U sum_i (hatn_uparrowi-tfrac12)(hatn_downarrowi-tfrac12)\n- mu sum_isigma hatn_sigmai\nendalign","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. In the above Hamiltonian (t^prime)  t is the (next-) nearest-neighbor hopping amplitude and U  0 controls the strength of the on-site Hubbard repulsion. Lastly, we note the system is half-filled and particle-hole symmetric when the next-nearest-neighbor hopping amplitude and the chemical potential is zero (t^prime = mu = 00) in which case there is no sign problem.","category":"page"},{"location":"tutorials/hubbard_square/#hubbard_square_import_packages","page":"1a) Square Hubbard Model","title":"Import packages","text":"","category":"section"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Let us begin by importing SmoQyDQMC.jl, and its relevant submodules.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"using SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"The SmoQyDQMC package rexports several other packages that we will make use of in this tutorial. The first one is LatticeUtilities, which we will use to define the lattice geometry for our model. The second submodule is the JDQMCFramework package, which exports useful types and methods for writing a determinant quantum Monte Carlo (DQMC) code, taking care of things like numerical stabilization. We will see how to leverage both these packages in this tutorial.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"We will also  use the Standard Library packages Random and Printf for random number generation and C-style string formatting, respectively.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"using Random\nusing Printf","category":"page"},{"location":"tutorials/hubbard_square/#Specify-simulation-parameters","page":"1a) Square Hubbard Model","title":"Specify simulation parameters","text":"","category":"section"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"The entire main body of the simulation we will wrapped in a top-level function named run_simulation that will take as keyword arguments various model and simulation parameters that we may want to change. The function arguments with default values are ones that are typically left unchanged between simulations. The specific meaning of each argument will be discussed in more detail in later sections of the tutorial.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"# Top-level function to run simulation.\nfunction run_simulation(;\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    U, # Hubbard interaction.\n    t′, # Next-nearest-neighbor hopping amplitude.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_updates, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"page"},{"location":"tutorials/hubbard_square/#hubbard_square_initialize_simulation","page":"1a) Square Hubbard Model","title":"Initialize simulation","text":"","category":"section"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"In this first part of the script we name and initialize our simulation, creating the data folder our simulation results will be written to. This is done by initializing an instances of the SimulationInfo type, and then calling the initialize_datafolder function.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Next we record relevant simulation parameters to the metadata dictionary. Think of the metadata dictionary as a place to record any additional information during the simulation that will not otherwise be automatically recorded and written to file.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_square_U%.2f_tp%.2f_mu%.2f_L%d_b%.2f\" U t′ μ L β\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)","category":"page"},{"location":"tutorials/hubbard_square/#Initialize-simulation-metadata","page":"1a) Square Hubbard Model","title":"Initialize simulation metadata","text":"","category":"section"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"In this section of the code we record important metadata about the simulation, including initializing the random number generator that will be used throughout the simulation. The important metadata within the simulation will be recorded in the metadata dictionary.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Initialize random number generator\n    rng = Xoshiro(seed)\n\n    # Initialize additiona_info dictionary\n    metadata = Dict()\n\n    # Record simulation parameters.\n    metadata[\"N_therm\"] = N_therm\n    metadata[\"N_updates\"] = N_updates\n    metadata[\"N_bins\"] = N_bins\n    metadata[\"n_stab_init\"] = n_stab\n    metadata[\"dG_max\"] = δG_max\n    metadata[\"symmetric\"] = symmetric\n    metadata[\"checkerboard\"] = checkerboard\n    metadata[\"seed\"] = seed\n    metadata[\"avg_acceptance_rate\"] = 0.0","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"In the above, sID stands for simulation ID, which is used to distinguish simulations that would otherwise be identical i.e. to distinguish simulations that use the same parameters and are only different in the random seed used to initialize the simulation. A valid sID is any positive integer greater than zero, and is used when naming the data folder the simulation results will be written to. Specifically, the actual data folder created above will be \"$(filepath)/$(datafolder_prefix)-$(sID)\". Note that if you set sID = 0, then it will instead be assigned smallest previously unused integer value. For instance, suppose the directory \"$(filepath)/$(datafolder_prefix)-1\" already exits. Then if you pass sID = 0 to SimulationInfo, then the simulation ID sID = 2 will be used instead, and a directory \"$(filepath)/$(datafolder_prefix)-2\" will be created.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Another useful resource in the documentation is the Simulation Output Overview page, which describes the output written to the data folder generated during a SmoQyDQMC simulation.","category":"page"},{"location":"tutorials/hubbard_square/#Initialize-model","page":"1a) Square Hubbard Model","title":"Initialize model","text":"","category":"section"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"The next step is define the model we wish to simulate. In this example the relevant model parameters are the Hubbard interaction strength U (U), chemical potential mu (μ), next-nearest-neighbor hopping amplitude t^prime (t′) and lattice size L (L).","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"First we define the lattice geometry for our model, relying on the LatticeUtilities package to do so. We define a the unit cell and size of our finite lattice using the UnitCell and Lattice types, respectively. Lastly, we define various instances of the Bond type to represent the the nearest-neighbor and next-nearest-neighbor bonds. All of this information regarding the lattice geometry is then stored in an instance of the ModelGeometry type. Further documentation, with usage examples, for LatticeUtilities package can be found here.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Define unit cell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[1.0, 0.0],\n                        [0.0, 1.0]],\n        basis_vecs = [[0.0, 0.0]]\n    )\n\n    # Define finite lattice with periodic boundary conditions.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize model geometry.\n    model_geometry = ModelGeometry(\n        unit_cell, lattice\n    )\n\n    # Define the nearest-neighbor bond in +x direction.\n    bond_px = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, 0]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_px_id = add_bond!(model_geometry, bond_px)\n\n    # Define the nearest-neighbor bond in +y direction.\n    bond_py = lu.Bond(\n        orbitals = (1,1),\n        displacement = [0, 1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_py_id = add_bond!(model_geometry, bond_py)\n\n    # Define the next-nearest-neighbor bond in +x+y direction.\n    bond_pxpy = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, 1]\n    )\n\n    # Define the nearest-neighbor bond in -x direction.\n    # Will be used to make measurements later in this tutorial.\n    bond_nx = lu.Bond(\n        orbitals = (1,1),\n        displacement = [-1, 0]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n    # Define the nearest-neighbor bond in -y direction.\n    # Will be used to make measurements later in this tutorial.\n    bond_ny = lu.Bond(\n        orbitals = (1,1),\n        displacement = [0, -1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n    # Define the next-nearest-neighbor bond in +x+y direction.\n    bond_pxpy = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, 1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_pxpy_id = add_bond!(model_geometry, bond_pxpy)\n\n    # Define the next-nearest-neighbor bond in +x-y direction.\n    bond_pxny = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, -1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_pxny_id = add_bond!(model_geometry, bond_pxny)","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Next we specify the non-interacting tight-binding term in our Hamiltonian with the TightBindingModel type.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Set neartest-neighbor hopping amplitude to unity,\n    # setting the energy scale in the model.\n    t = 1.0\n\n    # Define the non-interacting tight-binding model.\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_px, bond_py, bond_pxpy, bond_pxny], # defines hopping\n        t_mean  = [t, t, t′, t′], # defines corresponding mean hopping amplitude\n        t_std   = [0., 0., 0., 0.], # defines corresponding standard deviation in hopping amplitude\n        ϵ_mean  = [0.], # set mean on-site energy for each orbital in unit cell\n        ϵ_std   = [0.], # set standard deviation of on-site energy or each orbital in unit cell\n        μ       = μ # set chemical potential\n    )","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Finally, we define the Hubbard interaction with the HubbardModel type.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Define the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted   = false, # if true, then Hubbard interaction is instead parameterized as U⋅nup⋅ndn\n        U_orbital = [1], # orbitals in unit cell with Hubbard interaction.\n        U_mean    = [U], # mean Hubbard interaction strength for corresponding orbital species in unit cell.\n        U_std     = [0.], # standard deviation of Hubbard interaction strength for corresponding orbital species in unit cell.\n    )","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Note that most terms in our model can support random disorder. However, we have suppressed this behavior by setting all relevant standard deviations in model values to zero. If these standard devaitions were not specified they would have also defaulted to zero We explicitly set them to zero here to simply highlight the presence of this functionality even though we are not using it.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Lastly, the model_summary function is used to write a model_summary.toml file, completely specifying the Hamiltonian that will be simulated.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Write model summary TOML file specifying Hamiltonian that will be simulated.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )","category":"page"},{"location":"tutorials/hubbard_square/#Initialize-model-parameters","page":"1a) Square Hubbard Model","title":"Initialize model parameters","text":"","category":"section"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"The next step is to initialize our model parameters given the size of our finite lattice. To clarify, both the TightBindingModel and HubbardModel types are agnostic to the size of the lattice being simulated, defining the model in a translationally invariant way. As SmoQyDQMC.jl supports random disorder in the terms appearing in the Hamiltonian, it is necessary to initialize seperate parameter values for each unit cell in the lattice. For instance, we need to initialize a seperate number to represent the on-site energy for each orbital in our finite lattice.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_params = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation to decouple the Hubbard interaction,\n    # and initialize the corresponding HS fields that will be sampled in the DQMC simulation.\n    hubbard_stratonovich_params = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_params,\n        rng = rng\n    )","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Let me quickly clarify the difference between the HubbardParameters and HubbardIsingHSParameters types initialized above. The HubbardParameters type simply defines the Hubbard interaction parameters, agnostic to Hubbard-Stratonovich (HS) transformation that will be used to decouple the Hubbard interaction. Then the HubbardIsingHSParameters type actually applies a HS transformation to the Hubbard interaction, with the hubbard_stratonovich_params.s array containing the HS fields that will be sampled during the DQMC simulation.","category":"page"},{"location":"tutorials/hubbard_square/#hubbard_square_initialize_measurements","page":"1a) Square Hubbard Model","title":"Initialize meuasurements","text":"","category":"section"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Having initialized both our model and the corresponding model parameters, the next step is to initialize the various measurements we want to make during our DQMC simulation. This includes defining the various types of correlation measurements that will be made, which is primarily done using the initialize_correlation_measurements! function.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Here the arguments β and Δτ correspond to the inverse temperature and imaginary-time axis discretization constant, which were passed as arguments to the run_simulation function.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"We also want to define define what we term a composite correlation measurement to measure d-wave pairing tendencies in our Hubbard model. Specifically, we would like to measure the d-wave pair susceptibility","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"chi_d(mathbfq) = frac1L^2 int_0^beta dtau sum_mathbfr mathbfi e^-textimathbfqcdotmathbfr\nlangle hatDelta^phantomdagger_dmathbfi+mathbfr(tau) hatDelta^dagger_dmathbfi(0) rangle","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"for all scattering momentum mathbfq, where","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"hatDelta^dagger_dmathbfi(tau) = frac12left\n(\n   hatc^dagger_uparrowmathbfi+mathbfx + hatc^dagger_uparrowmathbfi-mathbfx\n - hatc^dagger_uparrowmathbfi+mathbfy - hatc^dagger_uparrowmathbfi-mathbfy\n)\nhatc^dagger_downarrowmathbfi\nright","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"is the d-wave pair creation operator. We do this using the initialize_composite_correlation_measurement! function.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Initialize the d-wave pair susceptibility measurement.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"d-wave\",\n        correlation = \"pair\",\n        ids = [bond_px_id, bond_nx_id, bond_py_id, bond_ny_id],\n        coefficients = [0.5, 0.5, -0.5, -0.5],\n        time_displaced = false,\n        integrated = true\n    )","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"The initialize_measurement_directories can now be used used to initialize the various subdirectories in the data folder that the measurements will be written to. Again, for more information refer to the Simulation Output Overview page.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(simulation_info, measurement_container)","category":"page"},{"location":"tutorials/hubbard_square/#hubbard_square_setup_dqmc","page":"1a) Square Hubbard Model","title":"Setup DQMC simulation","text":"","category":"section"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"This section of the code sets up the DQMC simulation by allocating the initializing the relevant types and arrays we will need in the simulation.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"This section of code is perhaps the most opaque and difficult to understand, and will be discussed in more detail once written. That said, you do not need to fully comprehend everything that goes on in this section as most of it is fairly boilerplate, and will not need to be changed much once written. This is true even if you want to modify this script to perform a DQMC simulation for a different Hamiltonian.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for Hubbard interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_params)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for the current\n    # Hubbard-Stratonovich field configuration.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_stratonovich_params)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices for spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type for spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # Gup(τ,τ)\n    Gup_τ0 = similar(Gup) # Gup(τ,0)\n    Gup_0τ = similar(Gup) # Gup(0,τ)\n    Gdn_ττ = similar(Gdn) # Gdn(τ,τ)\n    Gdn_τ0 = similar(Gdn) # Gdn(τ,0)\n    Gdn_0τ = similar(Gdn) # Gdn(0,τ)\n\n    # Initialize diagonostic parameters to asses numerical stability.\n    δG = zero(logdetGup)\n    δθ = zero(sgndetGup)","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"At the start of this section, two instances of the FermionPathIntegral type are allocated, one for each electron spin species. Recall that after performing a HS transformation to decouple the Hubbard interaction, the resulting Hamiltonian is quadratic in fermion creation and annihilation operators, but fluctuates in imaginary-time as a result of introducing the HS fields. Therefore, this Hamiltonian may be expressed as","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"hatH_l = sum_sigma hatmathbfc_sigma^dagger left H_sigmal right hatmathbfc_sigma\n= sum_sigma hatmathbfc_sigma^dagger left K_sigmal + V_sigmal right hatmathbfc_sigma","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"at imaginary-time tau = Deltatau cdot l, where hatmathbfc_sigma  (hatmathbfc_sigma^dagger) is a column (row) vector of spin-sigma electron annihilation (creation) operators for each orbital in the lattice. Here H_sigmal is the spin-sigma Hamiltonian matrix for imaginary-time tau, which can be expressed as the sum of the electron kinetic and potential energy matrices K_sigmal and V_sigmal, respectively. The purpose of the FermionPathIntegral type is to contain the minimal information required to reconstruct each K_sigmal and V_sigmal matrices. Each instance of the FermionPathIntegral type is first allocated and initialized to just reflect the non-interacting component of the Hamiltonian. Then the two subsequent initialize! calls modify the FermionPathIntegral type to reflect the contributions from the Hubbard interaction and initial HS field configuration.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Then the initialize_propagators function allocates and initializes the B_sigmal propagator matrices to reflect the current state of the K_sigmal and V_sigmal matrices as represented by the FermionPathIntegral type. If symmetric = true, then the propagator matrices take the form","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"B_sigmal = left e^-Deltatau K_sigmal2 right^dagger cdot e^-Deltatau V_sigmal cdot e^-Deltatau K_sigmal2","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"whereas if symmetric = false then","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"B_sigmal = e^-Deltatau V_sigmal cdot e^-Deltatau K_sigmal","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"If checkerboard = true, then the exponentiated kinetic energy matrices e^-Deltatau K_sigmal  left( text or  e^-Deltatau K_sigmal2 right) are represented using the sparse checkerboard approximation, otherwise they are computed exactly.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Next, two instances of the FermionGreensCalculator type are initialized, which are used to take care of numerical stabilization behind the scenes in the DQMC simulation. Here n_stab is the period in imaginary-time with which numerical stabilization is performed, and is typically on the order of n_rm stab sim 10","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Now we allocate and initialize the equal-time Green's function matrix G_sigma(00) for both spin species (Gup and Gdn). The initiliazation process also returns log  det G_sigma(00)  (logdetGup and logdetGdn) and rm sgn det G_sigma(00) (sgndetGup and sgndetGdn).","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Finally, we allocate matrices to represent the equal-time and time-displaced Green's function matrices G_sigma(tautau) (Gup_ττ and Gdn_ττ), G_sigma(tau 0) (Gup_τ0 and Gdn_τ0), and G_sigma(0tau) (Gup_0τ and Gdn_0τ) for tau ne 0. All of these various Green's function matrices are required if we want to make time-displaced correlation function measurements.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Lastly, we initialize two diagonostic parameters δG and δθ to asses numerical stability during the simulation. The δG  parameter is particularly important to keep track of during the simulation, and is defined as","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"delta G = max left(  G^rm stab_sigma(00) - G^rm naive_sigma(00)  right)","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"i.e. the maximum magnitude numerical error corrected by numerical stabilization for any Green's function matrix element. The delta theta diagnostic parameter reports the error in the phase of the fermion determnant as it can in general be complex, but this is less important to keep track of in most situations.","category":"page"},{"location":"tutorials/hubbard_square/#Thermalize-system","page":"1a) Square Hubbard Model","title":"Thermalize system","text":"","category":"section"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"The next section of code performs updates to thermalize the system prior to beginning measurements. The structure of this function should be fairly inuitive, mainly consisting of a loop inside of which the local_updates! function is called to sweep through all imaginary-time slices and orbitals, attempting an update to each HS field. Here, N_therm the number of thermalization sweeps that will be performed.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Lastly, if the local_updates! argument update_stabilization_frequency = true, then the δG_max parameter acts a maximum threshold for δG. If δG exceeds δG_max, then n_stab is decrimented by one (the frequency of numerical stabilization is increased) and δG is reset to zero. In the case update_stabilization_frequency = false, then δG_max doesn't do anything and n_stab remains unchanged during the simulation, with δG is simply reporting the maximum observed numerical error during the simulation.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Iterate over number of thermalization updates to perform.\n    for n in 1:N_therm\n\n        # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_stratonovich_params,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n            update_stabilization_frequency = true\n        )\n\n        # Record acceptance rate for sweep.\n        metadata[\"avg_acceptance_rate\"] += acceptance_rate\n    end","category":"page"},{"location":"tutorials/hubbard_square/#hubbard_square_make_measurements","page":"1a) Square Hubbard Model","title":"Make measurements","text":"","category":"section"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"In this next section of code we continue to sample the HS field with local_updates! function, but begin making measurements as well. Here, N_updates refers to the number of times local_updates! is called, as well as the number of times measurements are made using the make_measurements! function. The parameter N_bins then controls the number of times bin-averaged measurements are written to binary JLD2 files, subject to the constraint that (N_updates % N_bins) == 0. Therefore, the number of measurements that are averaged over per bin is given by bin_size = N_updates ÷ N_bins. The bin-averaged measurements are written to file once bin_size measurements are accumulated using the write_measurements! function.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Reset diagonostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetGup)\n    δθ = zero(sgndetGup)\n\n    # Calculate the bin size.\n    bin_size = N_updates ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for update in 1:N_updates\n\n        # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_stratonovich_params,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n            update_stabilization_frequency = true\n        )\n\n        # Record acceptance rate.\n        metadata[\"avg_acceptance_rate\"] += acceptance_rate\n\n        # Make measurements.\n        (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n            logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (hubbard_params, hubbard_stratonovich_params)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            update = update,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end","category":"page"},{"location":"tutorials/hubbard_square/#Record-simulation-metadata","page":"1a) Square Hubbard Model","title":"Record simulation metadata","text":"","category":"section"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"At this point we are done sampling and taking measurements. Next, we want to calculate the final acceptance rate for the Monte Carlo updates, as well as write the simulation metadata to file, including the contents of the metadata dictionary. This is done using the save_simulation_info function.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Normalize acceptance rate.\n    metadata[\"avg_acceptance_rate\"] /=  (N_therm + N_updates)\n\n    # Record final stabilization period used at the end of the simulation.\n    metadata[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record largest numerical error.\n    metadata[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)","category":"page"},{"location":"tutorials/hubbard_square/#hubbard_square_process_results","page":"1a) Square Hubbard Model","title":"Post-process results","text":"","category":"section"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"In this final section of code we post-process the binned data. This includes calculating the final estimates for the mean and error of all measured observables, which get written to CSV files using the function process_measurements function. Inside this function the binned data gets further rebinned into n_bins, where n_bins is any positive integer satisfying the constraints (N_bins ≥ n_bin) and (N_bins % n_bins == 0). The time_displaced keyword argument in the process_measurements function determines whether or not final statistics are computed for the time-displaced measurements. The default behavior is time_displaced = false, as computing these average statistics can be somewhat time-consuming, but if they are required, simply set time_displaced = true. Again, for more information on how to interpret the output refer the Simulation Output Overview page.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Set the number of bins used to calculate the error in measured observables.\n    n_bins = N_bins\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, n_bins, time_displaced = false)","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"A common measurements that needs to be reconstructed at the end of a DQMC simulation is something called the correlation ratio with respect to the ordering wave-vector for a specified type of correlation function measured during the simulation. In the case of the square Hubbard model, we are interested in measureing the correlation ratio","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"R_z(mathbfQ_textAFM) = 1 - frac14 sum_deltamathbfq fracS_z(mathbfQ_textAFM + deltamathbfq)S_z(mathbfQ_textAFM)","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"with respect to the equal-time antiferromagnetic (AFM) structure factor S_z(mathbfQ_textAFM), where S_z(mathbfq) is the spin-z equal-time structure factor and mathbfQ_textAFM = (pia pia) is the AFM ordering wave-vector. The sum over deltamathbfq runs over the four wavevectors that neigboring mathbfQ_textAFM Here we use the compute_correlation_ratio function to calculate this correlation ratio, and then we record the mean and error for this measurement in the metadata dictionary.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Calculate AFM correlation ratio.\n    Rafm, ΔRafm = compute_correlation_ratio(\n        folder = simulation_info.datafolder,\n        correlation = \"spin_z\",\n        type = \"equal-time\",\n        id_pairs = [(1, 1)],\n        coefs = [1.0],\n        k_point = (L÷2, L÷2), # Corresponds to Q_afm = (π/a, π/a).\n        num_bins = n_bins\n    )","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Next, we record the measurement in the metadata dictionary, and then write a new version of the simulation summary TOML file that contains this new information using the save_simulation_info function.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rafm_real_mean\"] = real(Rafm)\n    metadata[\"Rafm_imag_mean\"] = imag(Rafm)\n    metadata[\"Rafm_std\"]       = ΔRafm\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"The convention used for specifying the ordering wave-vector mathbfQ_textAFM using the k_point keyword argument in the compute_correlation_ratio function call are described here in the Simulation Output Overview page.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Note that as long as the binned data generated by the simulation persists in an uncompressed format (see below), the process_measurements, and compute_correlation_ratio functions can be called multiple times to recompute the final statistics for the measurements without needing to rerun the simulation.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Lastly, it is worth mentioning that running many DQMC simulations will generate many seperate binary files, which can eventually exceed the file quota limit on the system. To help prevent this problem from arising, we can use the function compress_jld2_bins to merge all the seperate JLD2 binary files into a single compressed one. However, to go back and reanalyze the binned binary data  in the future, it will first need to be decompressed using the decompress_jld2_bins method. Alternately, if storage space becomes an issue and you are certain that you no longer need binary binned data, you can delete it using the delete_jld2_bins function. Keep in mind though, once the binned binary data is deleted it cannot be recovered!","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"    # Merge binary files containing binned data into a single file.\n    compress_jld2_bins(folder = simulation_info.datafolder)\n\n    return nothing\nend # end of run_simulation function","category":"page"},{"location":"tutorials/hubbard_square/#Execute-script","page":"1a) Square Hubbard Model","title":"Execute script","text":"","category":"section"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"DQMC simulations are typically run from the command line as jobs on a computing cluster. With this in mind, the following block of code only executes if the Julia script is run from the command line, also reading in additional command line arguments.","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Run the simulation, reading in command line arguments.\n    run_simulation(;\n        sID       = parse(Int,     ARGS[1]), # Simulation ID.\n        U         = parse(Float64, ARGS[2]), # Hubbard interaction strength.\n        t′        = parse(Float64, ARGS[3]), # Next-nearest-neighbor hopping amplitude.\n        μ         = parse(Float64, ARGS[4]), # Chemical potential.\n        L         = parse(Int,     ARGS[5]), # Lattice size.\n        β         = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm   = parse(Int,     ARGS[7]), # Number of thermalization sweeps.\n        N_updates = parse(Int,     ARGS[8]), # Number of measurement sweeps.\n        N_bins    = parse(Int,     ARGS[9])  # Number times binned data is written to file.\n    )\nend","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"For instance, the command","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"> julia hubbard_square.jl 1 5.0 -0.25 -2.0 4 4.0 2500 10000 100","category":"page"},{"location":"tutorials/hubbard_square/","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"runs a DQMC simulation of a N = 4 times 4 doped square Hubbard model at inverse temperature beta = 40 with interaction strength U = 50 chemical potential mu = -20 and next-nearest-neighbor hopping amplitude t^prime = -025. In the DQMC simulation, 2500 sweeps through the lattice are be performed to thermalize the system. Then an additional 10000 sweeps are performed, after each of which measurements are made. During the simulation, bin-averaged measurements are written to file 100 times, with each bin of data containing the average of 10000100 = 100 sequential measurements.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Simulation-Information-Type-and-Methods","page":"API","title":"Simulation Information Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SimulationInfo\ninitialize_datafolder\nmodel_summary","category":"page"},{"location":"api/#SmoQyDQMC.SimulationInfo","page":"API","title":"SmoQyDQMC.SimulationInfo","text":"SimulationInfo\n\nContains identification information about simulation, including the location data is written to, the simulation ID, and MPI process ID, and whether this simulation started a new simulation or resumed a previous simulation.\n\nFields\n\nfilepath::String: File path to where data folder lives.\ndatafolder_prefix: Prefix for the data folder name.\ndatafolder_name::String: The data folder name, given by $(datafolder_prefix)_$(sID).\ndatafolder::String: The data folder, including filepath, given by joinpath(filepath, datafolder_name).\npID::Int: MPI process ID, defaults to 0 if MPI not being used.\nsID::Int: Simulation ID.\nresuming::Bool: Whether current simulation is resuming a previous simulation (true) or starting a new one (false).\nsmoqy_version::VersionNumber: Version of SmoQyDQMC.jl used in simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SimulationInfo-Tuple{}","page":"API","title":"SmoQyDQMC.SimulationInfo","text":"SimulationInfo(; datafolder_prefix::String, filepath::String = \".\", sID::Int=0, pID::Int=0)\n\nInitialize and return in instance of the type SimulationInfo.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize_datafolder","page":"API","title":"SmoQyDQMC.initialize_datafolder","text":"initialize_datafolder(comm::MPI.Comm, sim_info::SimulationInfo)\n\ninitialize_datafolder(sim_info::SimulationInfo)\n\nInitalize sim_info.datafolder directory if it does not already exist. If comm::MPI.Comm is passed as the first argument, this this function will synchronize all the MPI processes, ensuring that none proceed beyond this function call until the data folder that results will be written to is successfully initialized.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.model_summary","page":"API","title":"SmoQyDQMC.model_summary","text":"model_summary(;\n    simulation_info::SimulationInfo,\n    β::T, Δτ::T, model_geometry::ModelGeometry,\n    tight_binding_model::Union{TightBindingModel,Nothing} = nothing,\n    tight_binding_model_up::Union{TightBindingModel,Nothing} = nothing,\n    tight_binding_model_dn::Union{TightBindingModel,Nothing} = nothing,\n    interactions::Tuple\n) where {T<:AbstractFloat}\n\nWrite model to summary to file. Note that either tight_binding_model or tight_binding_model_up and tight_binding_model_dn need to be specified.\n\n\n\n\n\n","category":"function"},{"location":"api/#Model-Geometry-Type-and-Methods","page":"API","title":"Model Geometry Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ModelGeometry\nadd_bond!\nget_bond_id","category":"page"},{"location":"api/#SmoQyDQMC.ModelGeometry","page":"API","title":"SmoQyDQMC.ModelGeometry","text":"ModelGeometry{D, T<:AbstractFloat, N}\n\nContains all the information defining the lattice geometry for the model in D spatial dimensions.\n\nComment\n\nThe bond ID associated with a bond::Bond{D} corresponds to the index associated with it into the bonds vector field.\n\nFields\n\nunit_cell::UnitCell{D,T,N}: Defines unit cell.\nlattice::Lattice{D}: Defines finite lattice extent.\nbonds::Vector{Bond{D}}: All available bond definitions in simulation, with vector indices giving the bond ID.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ModelGeometry-Union{Tuple{D}, Tuple{UnitCell{D}, Lattice{D}}} where D","page":"API","title":"SmoQyDQMC.ModelGeometry","text":"ModelGeometry(unit_cell::UnitCell, lattice::Lattice)\n\nInitialize and return a ModelGeometry instance. Defines a \"trivial\" bond defintion for each orbital in the unit cell that connects an orbital to itself.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.add_bond!","page":"API","title":"SmoQyDQMC.add_bond!","text":"addbond!(modelgeometry::ModelGeometry{D,T}, bond::Bond{D}) where {D, T}   \n\nAdd bond definition to model_geometry, returning the bond ID i.e. the index to bond in the vector model_geometry.bonds. This method first checks that bond is not already defined. If it is this method simply returns the corresponding bond ID. If bond is not already defined, then it is appended to the vector model_geometry.bonds.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.get_bond_id","page":"API","title":"SmoQyDQMC.get_bond_id","text":"get_bond_id(model_geometry::ModelGeometry{D,T}, bond::Bond{D}) where {D, T}\n\nReturn the bond ID associated with the bond defintion bond, returning bond_id=0 if the it is not a recorded bond.\n\n\n\n\n\n","category":"function"},{"location":"api/#Fermion-Path-Integral-Type-and-Methods","page":"API","title":"Fermion Path Integral Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FermionPathIntegral\ninitialize_propagators\ncalculate_propagators!\ncalculate_propagator!","category":"page"},{"location":"api/#SmoQyDQMC.FermionPathIntegral","page":"API","title":"SmoQyDQMC.FermionPathIntegral","text":"FermionPathIntegral{T<:Number, E<:AbstractFloat}\n\nA type to represent a fermion path integral. In particular, this type contains the information required to reconstruct the diagonal on-site energy matrices V_l and hopping matrices K_l for each imaginary time slice l in 1 L_tau where tau = Deltatau cdot l and beta = Deltatau cdot L_tau\n\nFields\n\nβ::E: Inverse temperature.\nΔτ::E: Discretization in imaginary time.\nLτ::Int: Length of the imaginary time axis.\nN::Int: Number of orbitals in the lattice.\nneighbor_table::Matrix{Int}: Neighbor table for each pair of orbitals in the lattice connected by a hopping.\nt::Matrix{T}: Hopping amplitudes for imaginary-time slice l are stored in t[:,l].\nV::Matrix{T}: The diagonal on-site energy matrices V_l for imaginary-time slice l are stored in V[:,l].\nK::Matrix{T}: Used to construct hopping matrix to cacluate exponentiated hopping matrix if checkerboard approximation is not being used.\neigen_ws::HermitianEigenWs{T,Matrix{T},E}: For calculating eigenvalues and eigenvectors of K while avoiding dynamic memory allocations.\nu::Vector{T}: Temporary vector to avoid dynamic allocation when performing local updates.\nv::Vector{T}: Temporary vector to avoid dynamic allocation when performing local updates.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.FermionPathIntegral-Tuple{}","page":"API","title":"SmoQyDQMC.FermionPathIntegral","text":"FermionPathIntegral(;\n    tight_binding_parameters::TightBindingParameters{T,E},\n    β::E, Δτ::E\n) where {T,E}\n\nInitialize an instance of FermionPathIntegral an instance of TightBindingParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize_propagators","page":"API","title":"SmoQyDQMC.initialize_propagators","text":"initialize_propagators(fpi::FermionPathIntegral{T,E}; symmetric::Bool, checkerboard::Bool) where {T,E}\n\nInitialize a propagator for each imaginary time slice, returning a vector of type Vector{<:AbstractPropagators{T,E}}.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.calculate_propagators!","page":"API","title":"SmoQyDQMC.calculate_propagators!","text":"calculate_propagators!(B::Vector{P}, fpi::FermionPathIntegral{T,E};\n                       calculate_exp_V::Bool, calculate_exp_K::Bool) where {T, E, P<:AbstractPropagator{T,E}}\n\nCalculate the propagator matrices B_l, given by B[l], for all imaginary time slice tau = Deltatau cdot l If calculate_exp_V = true, then calculate the diagonal exponentiated on-site energy matrices. If calculate_exp_K = true, then calculate the exponentiated hopping matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.calculate_propagator!","page":"API","title":"SmoQyDQMC.calculate_propagator!","text":"calculate_propagator!(B::AbstractPropagator{T,E}, fpi::FermionPathIntegral{T,E}, l::Int;\n                      calculate_exp_V::Bool, calculate_exp_K::Bool) where {T,E}\n\nCalculate the propagator matrix B_l for imaginary time slice tau = Deltatau cdot l If calculate_exp_V = true, then calculate the diagonal exponentiated on-site energy matrix. If calculate_exp_K = true, then calculate the exponentiated hopping matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#Update-Numerical-Stabilization-Frequency","page":"API","title":"Update Numerical Stabilization Frequency","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"update_stabalization_frequency!","category":"page"},{"location":"api/#SmoQyDQMC.update_stabalization_frequency!","page":"API","title":"SmoQyDQMC.update_stabalization_frequency!","text":"update_stabalization_frequency!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n                                Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T;\n                                fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                                fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                                Bup::Vector{P}, Bdn::Vector{P}, δG::E, δθ::E, n_stab::Int,\n                                δG_max::E) where {E<:AbstractFloat, T<:Number, P<:AbstractPropagator{T,E}}\n\nIf the corrected error in the Green's function matrix is too large, δG > δG_max, then increase the frequency of numerical stablization by decrementing n_stab such that it is updated to n_stab = max(n_stab - 1, 1), and update the equal-time Green's function matrices and all related variables and types. If the frequency of stabilization is udpated, then δG and δθ are reset to zero. This method returns a tuple of the following variables:\n\n(logdetGup, sgndetGdn, logdetGup, sgndetGdn, δG, δθ),\n\nwhere updated = true if n_stab was decremented.\n\n\n\n\n\nupdate_stabalization_frequency!(G::Matrix{T}, logdetG::E, sgndetG::T;\n                                fermion_greens_calculator::FermionGreensCalculator{T,E},\n                                B::Vector{P}, δG::E, δθ::E, n_stab::Int,\n                                δG_max::E) where {E<:AbstractFloat, T<:Number, P<:AbstractPropagator{T,E}}\n\nIf the corrected error in the Green's function matrix is too large, δG > δG_max, then increase the frequency of numerical stablization by decrementing n_stab such that it is updated to n_stab = max(n_stab - 1, 1), and update the equal-time Green's function matrices and all related variables and types. If the frequency of stabilization is udpated, then δG and δθ are reset to zero. This method returns a tuple of the following variables:\n\n(updated, logdetG, sgndetG, δG, δθ),\n\nwhere updated = true if n_stab was decremented.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tight-Binding-Model","page":"API","title":"Tight-Binding Model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TightBindingModel\nTightBindingParameters\nmeasure_onsite_energy\nmeasure_hopping_energy\nmeasure_bare_hopping_energy\nmeasure_hopping_amplitude\nmeasure_hopping_inversion\nmeasure_hopping_inversion_avg","category":"page"},{"location":"api/#SmoQyDQMC.TightBindingModel","page":"API","title":"SmoQyDQMC.TightBindingModel","text":"TightBindingModel{T<:Number, E<:AbstractFloat, D}\n\nDefines a tight binding model in D dimensions. Note that spin = 1 (spin = 2) corresponds to spin-up (spin-down), and spin = 0 corresponds to both spin-up and spin-down.\n\nFields\n\nμ::E: Chemical potential.\nϵ_mean::Vector{E}: Mean on-site energy for each orbital in the unit cell. \nϵ_std::Vector{E}: Standard deviation of on-site energy for each orbital in the unit cell.\nt_bond_ids::Vector{Int}: The bond ID for each bond/hopping definition.\nt_bonds::Vector{Bond{D}}: Bond definition for each type of hopping in the tight binding model.\nt_mean::Vector{T}: Mean hopping energy for each type of hopping.\nt_std::Vector{E}: Standard deviation of hopping energy for each type of hopping.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.TightBindingModel-Tuple{}","page":"API","title":"SmoQyDQMC.TightBindingModel","text":"TightBindingModel(;\n    model_geometry::ModelGeometry{D,E,N},\n    μ::E,\n    ϵ_mean::Vector{E},\n    ϵ_std::Vector{E} = zeros(eltype(ϵ_mean), length(ϵ_mean)),\n    t_bonds::Vector{Bond{D}} = Bond{ndims(model_geometry.unit_cell)}[],\n    t_mean::Vector{T} = eltype(ϵ_mean)[],\n    t_std::Vector{E} = zeros(eltype(ϵ_mean), length(t_mean))\n) where {T<:Number, E<:AbstractFloat, D, N}\n\nInitialize and return an instance of TightBindingModel, also adding/recording the bond defintions t_bonds to the ModelGeometry instance model_geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.TightBindingParameters","page":"API","title":"SmoQyDQMC.TightBindingParameters","text":"TightBindingParameters{T<:Number, E<:AbstractFloat}\n\nA mutable struct containing all the parameters needed to characterize a finite tight-binding Hamiltonian for a single spin species sigma on a finite lattice with periodic boundary conditions of the form\n\nhatH_0sigma=-sum_langle ijrangle(t_ij hatc_sigmai^daggerhatc_sigmaj+textrmhc)+sum_i(epsilon_i-mu)hatn_sigmai\n\nwhere hatc_sigmai^dagger is the fermion creation operator for an electron with spin sigma on orbital i t_ij are the hopping energies, epsilon_i are the on-site energies for each orbital in the lattice, and mu is the chemical potential.\n\nFields\n\nμ::E: The chemical potential mu\nconst ϵ::Vector{E}: A vector containing the on-site energy epsilon_i for each orbital in the lattice.\nconst t::Vector{T}: The hopping energy t_ij associated with each pair of neighboring orbitals connected by a bond in the lattice.\nconst neighbor_table::Matrix{Int}: Neighbor table containing all pairs of orbitals in the lattices connected by a bond, with a non-zero hopping energy between them.\nconst bond_ids::Vector{Int}: The bond ID definitions that define the types of hopping in the lattice.\nconst bond_slices::Vector{UnitRange{Int}}: Slices of neighbor_table corresponding to given bond ID i.e. the neighbors neighbor_table[:,bond_slices[1]] corresponds the bond_ids[1] bond defintion.\nconst norbital::Int: Number of orbitals per unit cell.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.TightBindingParameters-Tuple{}","page":"API","title":"SmoQyDQMC.TightBindingParameters","text":"TightBindingParameters(;\n    tight_binding_model::TightBindingModel{T,E,D},\n    model_geometry::ModelGeometry{D,E},\n    rng::AbstractRNG\n) where {T,E,D}\n\nInitialize and return an instance of TightBindingParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.measure_onsite_energy","page":"API","title":"SmoQyDQMC.measure_onsite_energy","text":"measure_onsite_energy(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    G::Matrix{T}, orbital_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nMeasure and return the on-site energy epsilon_textrmon-site = (epsilon - mu)langle hatn_sigma rangle for the orbital_id in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_hopping_energy","page":"API","title":"SmoQyDQMC.measure_hopping_energy","text":"measure_hopping_energy(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{T,E},\n    G::Matrix{T}, hopping_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average hopping energy epsilon_rm hopping = -langle t_llangle ij rangle hatc^dagger_sigmai hatc_sigmaj + rm hc rangle for the hopping defined by the the hopping_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_bare_hopping_energy","page":"API","title":"SmoQyDQMC.measure_bare_hopping_energy","text":"measure_bare_hopping_energy(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    G::Matrix{T}, hopping_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average bare hopping energy epsilon_rm hopping = -langle t_langle ij rangle hatc^dagger_sigmai hatc_sigmaj + rm hc rangle for the hopping defined by the hopping_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_hopping_amplitude","page":"API","title":"SmoQyDQMC.measure_hopping_amplitude","text":"measure_hopping_amplitude(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{T,E},\n    hopping_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average hopping amplitude for the hopping defined by the hopping_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_hopping_inversion","page":"API","title":"SmoQyDQMC.measure_hopping_inversion","text":"measure_hopping_inversion(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{T,E},\n    hopping_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nMeasure the fraction of time the sign of the instaneous modulated hopping ampltiude t_l(mathbfinu)(mathbfjgamma) is inverted relative to the bare hopping amplitude t_(mathbfinu)(mathbfjgamma), where l is the imaginary time-slice index.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_hopping_inversion_avg","page":"API","title":"SmoQyDQMC.measure_hopping_inversion_avg","text":"measure_hopping_inversion_avg(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{T,E},\n    hopping_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nMeasure the fraction of time the sign of the imaginary-time averaged modulated hopping ampltiude bart_(mathbfinu)(mathbfjgamma) is inverted relative to the bare hopping amplitude t_(mathbfinu)(mathbfjgamma).\n\n\n\n\n\n","category":"function"},{"location":"api/#Hubbard-Model","page":"API","title":"Hubbard Model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HubbardModel\nHubbardParameters\ninitialize!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Hubbard Model Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"measure_hubbard_energy","category":"page"},{"location":"api/","page":"API","title":"API","text":"Hubbard Ising Hubbard-Stratonovich Transformation Types and Methods","category":"page"},{"location":"api/","page":"API","title":"API","text":"HubbardIsingHSParameters\ninitialize!\nlocal_updates!\nreflection_update!\nswap_update!","category":"page"},{"location":"api/#SmoQyDQMC.HubbardModel","page":"API","title":"SmoQyDQMC.HubbardModel","text":"HubbardModel{T<:AbstractFloat}\n\nIf shifted = true, then a Hubbard interaction of the form\n\nhatH_U=sum_mathbfinuU_numathbfihatn_uparrownumathbfihatn_downarrownumathbfi\n\nis assumed, where mathbfi specifies the unit cell, and nu denotes the orbital in the unit cell. For a bipartite lattice with only nearest neighbor hopping, the on-site energy corresponding to half-filling and particle-hole symmetry is epsilon_numathbfi = -U_numathbfi2\n\nIf shifted = false, then a Hubbard interaction of the form\n\nhatH_U=sum_mathbfinuU_numathbfi(hatn_uparrownumathbfi-tfrac12)(hatn_downarrownumathbfi-tfrac12)\n\nis assumed. In this case, for a bipartite lattice with only nearest neighbor hopping, the on-site energy corresponding to half-filling and particle-hole symmetry is epsilon_numathbfi = 0\n\nFields\n\nshifted::Bool: Determines which form for Hubbard interaction is used, and whether the on-site energies need to be shifted.\nU_orbital::Vector{Int}: Orbital species in unit cell with finite Hubbard interaction.\nU_mean::Vector{T}: Average Hubbard U_nu for a given orbital species in the lattice.\nU_std::Vector{T}: Standard deviation of Hubbard U_nu for a given orbital species in the lattice.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardModel-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardModel","text":"HubbardModel(;\n    shifted::Bool,\n    U_orbital::AbstractVector{Int},\n    U_mean::AbstractVector{T},\n    U_std::AbstractVector{T} = zero(U_mean)\n) where {T<:AbstractFloat}\n\nInitialize and return an instance of the type HubbardModel.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.HubbardParameters","page":"API","title":"SmoQyDQMC.HubbardParameters","text":"HubbardParameters{T<:AbstractFloat}\n\nHubbard parameters for finite lattice.\n\nFields\n\nU::Vector{T}: On-site Hubbard interaction for each site with finite Hubbard interaction.\nsites::Vector{Int}: Site index associated with each finite Hubbard U interaction.\norbitals::Vector{Int}: Orbital species in unit cell with finite Hubbard interaction.\nshifted::Bool: Convention used for Hubbard interaction, refer to HubbardModel for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardParameters-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardParameters","text":"HubbardParameters(;\n    hubbard_model::HubbardModel{T},\n    model_geometry::ModelGeometry{D,T},\n    rng::AbstractRNG\n) where {D, T<:AbstractFloat}\n\nInitialize an instance of HubbardParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, HubbardParameters{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    hubbard_parameters::HubbardParameters{E}\n) where {T,E}\n\ninitialize!(\n    fermion_path_integral::FermionPathIntegral{T,E},\n    hubbard_parameters::HubbardParameters{E}\n) where {T,E}\n\nInitialize the contribution from the Hubbard interaction to a FermionPathIntegral instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hubbard-Model-Measurements","page":"API","title":"Hubbard Model Measurements","text":"","category":"section"},{"location":"api/#SmoQyDQMC.measure_hubbard_energy","page":"API","title":"SmoQyDQMC.measure_hubbard_energy","text":"measure_hubbard_energy(\n    hubbard_parameters::HubbardParameters{E},\n    Gup::Matrix{T}, Gdn::Matrix{T},\n    orbital_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average Hubbard energy U langle hatn_uparrow hatn_downarrow rangle if shifted = true and U langle (hatn_uparrow - tfrac12)(hatn_downarrow - tfrac12)rangle if shifted = false for the orbital corresponding orbital_id in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#Hubbard-Ising-Hubbard-Stratonovich-Transformation-Types-and-Methods","page":"API","title":"Hubbard Ising Hubbard-Stratonovich Transformation Types and Methods","text":"","category":"section"},{"location":"api/#SmoQyDQMC.HubbardIsingHSParameters","page":"API","title":"SmoQyDQMC.HubbardIsingHSParameters","text":"HubbardIsingHSParameters{T<:AbstractFloat}\n\nParameters associated with decoupling the Hubbard interaction using the standard Ising Hubbard-Stratonovich (HS) transformation.\n\nFields\n\nβ::T: Inverse temperature.\nΔτ::T: Discretization in imaginary time.\nLτ::Int: Length of imaginary time axis.\nN::Int: Number of orbitals in the lattice.\nU::Vector{T}: Each hubbard interaction.\nα::Vector{T}: The constant given by cosh(alpha_i) = e^Deltatau vert U_i vert2\nsites::Vector{Int}: Site index associated with each finite Hubbard U interaction.\ns::Matrix{Int}: Ising Hubbard-Stratonovich fields.\nupdate_perm::Vector{Int}: Order in which to iterate over HS fields in time slice when performing local updates.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardIsingHSParameters-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardIsingHSParameters","text":"HubbardIsingHSParameters(; β::E, Δτ::E,\n                         hubbard_parameters::HubbardParameters{E},\n                         rng::AbstractRNG) where {E<:AbstractFloat}\n\nInitialize and return an instance of the HubbardIsingHSParameters type. Note that on-site energies fpi.V are shifted by -U_i2 if hmshifted = true.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, HubbardIsingHSParameters{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(fermion_path_integral_up::FermionPathIntegral{T,E},\n            fermion_path_integral_dn::FermionPathIntegral{T,E},\n            hubbard_ising_parameters::HubbardIsingHSParameters{E}) where {T,E}\n\nInitialize the contribution from the Hubbard interaction to the FermionPathIntegral instance fermion_path_integral_up for spin up and fermion_path_integral_dn spin down.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, HubbardIsingHSParameters{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(fermion_path_integral::FermionPathIntegral{T,E},\n            hubbard_ising_parameters::HubbardIsingHSParameters{E}) where {T,E}\n\nInitialize the contribution from an attractive Hubbard interaction to the FermionPathIntegral instance fermion_path_integral.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.local_updates!","text":"local_updates!(\n    Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n    Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n    hubbard_ising_parameters::HubbardIsingHSParameters{E};\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P},\n    δG::E, δθ::E,  rng::AbstractRNG,\n    δG_max::E = 1e-5,\n    update_stabilization_frequency::Bool = true\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nSweep through every imaginary time slice and orbital in the lattice, peforming local updates to every Ising Hubbard-Stratonovich (HS) field.\n\nThis method returns the a tuple containing (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ).\n\nArguments\n\nGup::Matrix{T}: Spin-up equal-time Green's function matrix.\nlogdetGup::E: The log of the absolute value of the determinant of the spin-up equal-time Green's function matrix, log vert det G_uparrow(tautau) vert\nsgndetGup::T: The sign/phase of the determinant of the spin-up equal-time Green's function matrix, det G_uparrow(tautau)  vert det G_uparrow(tautau) vert\nGdn::Matrix{T}: Spin-down equal-time Green's function matrix.\nlogdetGdn::E: The log of the absolute value of the determinant of the spin-down equal-time Green's function matrix, log vert det G_downarrow(tautau) vert\nsgndetGdn::T: The sign/phase of the determinant of the spin-down equal-time Green's function matrix, det G_downarrow(tautau)  vert det G_downarrow(tautau) vert\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of the FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of the FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: An instance of the FermionGreensCalculator type for the spin-up electrons.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: An instance of the FermionGreensCalculator type for the spin-down electrons.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-dn propagators for each imaginary time slice.\nδG_max::E: Maximum allowed error corrected by numerical stabilization.\nδG::E: Previously recorded maximum error in the Green's function corrected by numerical stabilization.\nδθ::T: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green's function matrix corrected by numerical stabilization.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nupdate_stabilization_frequency::Bool=true: If true, allows the stabilization frequency n_stab to be dynamically adjusted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.local_updates!","text":"local_updates!(\n    G::Matrix{T}, logdetG::E, sgndetG::T,\n    hubbard_ising_parameters::HubbardIsingHSParameters{E};\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    B::Vector{P}, δG::E, δθ::E, rng::AbstractRNG,\n    δG_max::E = 1e-5,\n    update_stabilization_frequency::Bool = true\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nSweep through every imaginary time slice and orbital in the lattice, performing local updates to every Ising Hubbard-Stratonovich (HS) field, assuming strictly attractive Hubbard interactions and perfect spin symmetry.\n\nThis method returns the a tuple containing (acceptance_rate, logdetG, sgndetG, δG, δθ).\n\nArguments\n\nG::Matrix{T}: Equal-time Green's function matrix.\nlogdetG::E: The log of the absolute value of the determinant of theequal-time Green's function matrix, log vert det G_uparrow(tautau) vert\nsgndetG::T: The sign/phase of the determinant of the equal-time Green's function matrix, det G_uparrow(tautau)  vert det G_uparrow(tautau) vert\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of the FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: An instance of the FermionGreensCalculator type.\nB::Vector{P}: Propagators for each imaginary time slice.\nδG_max::E: Maximum allowed error corrected by numerical stabilization.\nδG::E: Previously recorded maximum error in the Green's function corrected by numerical stabilization.\nδθ::T: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green's function matrix corrected by numerical stabilization.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nupdate_stabilization_frequency::Bool=true:  If true, allows the stabilization frequency n_stab to be dynamically adjusted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(\n    Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n    Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n    hubbard_ising_parameters::HubbardIsingHSParameters{E};\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P},\n    rng::AbstractRNG\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform a reflection update where the sign of every Ising Hubbard-Stratonovich field on a randomly chosen orbital in the lattice is changed. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(\n    G::Matrix{T}, logdetG::E, sgndetG::T,\n    hubbard_ising_parameters::HubbardIsingHSParameters{E};\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n    B::Vector{P},\n    rng::AbstractRNG\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform a reflection update where the sign of every Ising Hubbard-Stratonovich field on a randomly chosen orbital in the lattice is changed. This function returns (accepted, logdetG, sgndetG). This method assumes strictly attractive Hubbard interactions.\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(\n    Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n    Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n    hubbard_ising_parameters::HubbardIsingHSParameters{E};\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P},\n    rng::AbstractRNG\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform a swap update where the HS fields associated with two randomly chosen sites in the lattice are exchanged. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(\n    G::Matrix{T}, logdetG::E, sgndetG::T,\n    hubbard_ising_parameters::HubbardIsingHSParameters{E};\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n    B::Vector{P}, rng::AbstractRNG\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nFor strictly attractive Hubbard interactions, perform a swap update where the HS fields associated with two randomly chosen sites in the lattice are exchanged. This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#Electron-Phonon-Model","page":"API","title":"Electron-Phonon Model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Model Types and Method","category":"page"},{"location":"api/","page":"API","title":"API","text":"ElectronPhononModel\nPhononMode\nHolsteinCoupling\nSSHCoupling\nPhononDispersion\nadd_phonon_mode!\nadd_holstein_coupling!\nadd_ssh_coupling!\nadd_phonon_dispersion!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Parameter Types and Methods","category":"page"},{"location":"api/","page":"API","title":"API","text":"ElectronPhononParameters\nSmoQyDQMC.PhononParameters\nSmoQyDQMC.HolsteinParameters\nSmoQyDQMC.SSHParameters\nSmoQyDQMC.DispersionParameters\ninitialize!\nupdate!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"measure_phonon_kinetic_energy\nmeasure_phonon_potential_energy\nmeasure_phonon_position_moment\nmeasure_holstein_energy\nmeasure_ssh_energy\nmeasure_dispersion_energy","category":"page"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Updates","category":"page"},{"location":"api/","page":"API","title":"API","text":"HMCUpdater\nEFAHMCUpdater\nhmc_update!\nSmoQyDQMC.FourierMassMatrix\nreflection_update!\nswap_update!\nradial_update!","category":"page"},{"location":"api/#Electron-Phonon-Model-Types-and-Method","page":"API","title":"Electron-Phonon Model Types and Method","text":"","category":"section"},{"location":"api/#SmoQyDQMC.ElectronPhononModel","page":"API","title":"SmoQyDQMC.ElectronPhononModel","text":"ElectronPhononModel{T<:Number, E<:AbstractFloat, D}\n\nDefines an electron-phonon model.\n\nFields\n\nphonon_modes::Vector{PhononModes{E}}: A vector of PhononMode definitions.\nphonon_dispersions::Vector{PhononDispersion{E,D}}: A vector of PhononDispersion defintions.\nholstein_couplings_up::Vector{HolsteinCoupling{E,D}}: A vector of HolsteinCoupling definitions for spin-up.\nholstein_couplings_dn::Vector{HolsteinCoupling{E,D}}: A vector of HolsteinCoupling definitions for spin-down.\nssh_couplings_up::Vector{SSHCoupling{T,E,D}}: A vector of SSHCoupling defintions for spin-up.\nssh_couplings_dn::Vector{SSHCoupling{T,E,D}}: A vector of SSHCoupling defintions for spin-down.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ElectronPhononModel-Tuple{}","page":"API","title":"SmoQyDQMC.ElectronPhononModel","text":"ElectronPhononModel(;\n    model_geometry::ModelGeometry{D,E},\n    tight_binding_model::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    tight_binding_model_up::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    tight_binding_model_dn::Union{TightBindingModel{T,E,D}, Nothing} = nothing\n) where {T<:Number, E<:AbstractFloat, D}\n\nInitialize and return a null (empty) instance of ElectronPhononModel. Note that either tight_binding_model or tight_binding_model_up and tight_binding_model_dn needs to be specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononMode","page":"API","title":"SmoQyDQMC.PhononMode","text":"PhononMode{E<:AbstractFloat}\n\nDefines a phonon mode on the orbital species orbital in the unit cell. Specifically, it defines the phonon Hamiltonian terms\n\nhatH_rm ph = sum_mathbfi\n  left\n      frac12 M_mathbfinuOmega_mathbfinu^2hatX_mathbfinu^2\n    + frac112M_mathbfinuOmega_4mathbfinu^2hatX_mathbfinu^4\n    + frac12M_mathbfinuhatP_mathbfinu^2\n  right\n\nwhere the sum runs over unit cell mathbfi, nu denotes the orbital species orbital in the unit cell, M_mathbfinu is the phonon mass M, Omega_mathbfinu is the phonon frequency that is distributed according to a normal distribution with mean Ω_mean and standard deviation Ω_std. Lastly, Omega_4mathbfinu is the anhmaronic coefficient, and is distributed according to a normal distribution with mean Ω4_mean and standard deviation Ω4_std.\n\nFields\n\norbital::Int: Orbital species nu in the unit cell.\nM::E:: The phonon mass M_mathbfinu\nΩ_mean::E: Mean of normal distribution the phonon frequency Omega_mathbfinu is sampled from.\nΩ_std::E: Standard deviation of normal distribution the phonon frequency Omega_mathbfinu is sampled from.\nΩ4_mean::E: Mean of normal distribution the anharmonic coefficient Omega_4mathbfinu is sampled from.\nΩ4_std::E: Standard deviation of normal distribution the anharmonic coefficient Omega_4mathbfinu is sampled from.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.PhononMode-Tuple{}","page":"API","title":"SmoQyDQMC.PhononMode","text":"PhononMode(;\n    orbital::Int, Ω_mean::E, Ω_std::E = 0.,\n    M::E = 1., Ω4_mean::E = 0.0, Ω4_std::E = 0.0\n) where {E<:AbstractFloat}\n\nInitialize and return a instance of PhononMode.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.HolsteinCoupling","page":"API","title":"SmoQyDQMC.HolsteinCoupling","text":"HolsteinCoupling{E<:AbstractFloat, D}\n\nDefines a Holstein coupling between a specified phonon mode and orbital density. Specifically, if shifted = true a Holstein interaction term is given by\n\nbeginalign*\nH = sum_mathbfi Big \n         (alpha_mathbfi(mathbfrkappanu) hatX_mathbfinu\n        + alpha_3mathbfi(mathbfrkappanu) hatX^3_mathbfinu)  (hatn_sigmamathbfi+mathbfrkappa-tfrac12)\n         + (alpha_2mathbfi(mathbfrkappanu) hatX^2_mathbfinu\n        + alpha_4mathbfi(mathbfrkappanu) hatX^4_mathbfinu)  hatn_sigmamathbfi+mathbfrkappa \nBig\nendalign*\n\nwhereas if shifted = false then it is given by\n\nbeginalign*\nH = sum_mathbfi Big \n         (alpha_mathbfi(mathbfrkappanu) hatX_mathbfinu\n        + alpha_3mathbfi(mathbfrkappanu) hatX^3_mathbfinu)  hatn_sigmamathbfi+mathbfrkappa\n         + (alpha_2mathbfi(mathbfrkappanu) hatX^2_mathbfinu\n        + alpha_4mathbfi(mathbfrkappanu) hatX^4_mathbfinu)  hatn_sigmamathbfi+mathbfrkappa \nBig\nendalign*\n\nIn the above, sigma specifies the sum, and the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa specify orbital species in the unit cell, and mathbfr is a static displacement in unit cells.\n\nFields\n\nshifted::Bool: If the odd powered interaction terms are shifted to render them particle-hole symmetric in the atomic limit.\nphonon_mode::Int: The phonon mode getting coupled to.\nbond::Bond{D}: Static displacement from hatX_mathbfinu to hatn_sigmamathbfi+mathbfrkappa\nbond_id::Int: Bond ID associtated with bond field.\nα_mean::E: Mean of the linear Holstein coupling coefficient alpha_1mathbfi(mathbfrkappanu)\nα_std::E: Standard deviation of the linear Holstein coupling coefficient alpha_1mathbfi(mathbfrkappanu)\nα2_mean::E: Mean of the squared Holstein coupling coefficient alpha_2mathbfi(mathbfrkappanu)\nα2_std::E: Standard deviation of the squared Holstein coupling coefficient alpha_2mathbfi(mathbfrkappanu)\nα3_mean::E: Mean of the cubic Holstein coupling coefficient alpha_3mathbfi(mathbfrkappanu)\nα3_std::E: Standard deviation of the cubic Holstein coupling coefficient alpha_3mathbfi(mathbfrkappanu)\nα4_mean::E: Mean of the quartic Holstein coupling coefficient alpha_4mathbfi(mathbfrkappanu)\nα4_std::E: Standard deviation of the quartic Holstein coupling coefficient alpha_4mathbfi(mathbfrkappanu)\n\nComment\n\nNote that the initial orbital bond.orbital[1] must match the orbital species associated with phonon mode PhononMode getting coupled to.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HolsteinCoupling-Tuple{}","page":"API","title":"SmoQyDQMC.HolsteinCoupling","text":"HolsteinCoupling(;\n    model_geometry::ModelGeometry{D,E},\n    phonon_mode::Int,\n    bond::Bond{D},\n    α_mean::E,        α_std::E  = 0.0,\n    α2_mean::E = 0.0, α2_std::E = 0.0,\n    α3_mean::E = 0.0, α3_std::E = 0.0,\n    α4_mean::E = 0.0, α4_std::E = 0.0,\n    shifted::Bool = true\n) where {D, E<:AbstractFloat}\n\nInitialize and return a instance of HolsteinCoupling.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.SSHCoupling","page":"API","title":"SmoQyDQMC.SSHCoupling","text":"SSHCoupling{T<:Number, E<:AbstractFloat, D}\n\nDefines a Su-Schrieffer-Heeger (SSH) coupling between a pair of phonon modes. Specifically, it defines the SSH interaction term\n\nhatH_rm ssh = -sum_sigmamathbfi\n    left t_mathbfi(mathbfrkappanu) - left( sum_n=1^4alpha_nmathbfi(mathbfrkappanu)\n    left( hatX_mathbfi+mathbfrkappa - hatX_mathbfinuright)^nright) right\n    left( hatc_sigmamathbfi+mathbfrkappa^daggerhatc_sigmamathbfinu+rm hc right)\n\nwhere sigma specifies the sum, and the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa specify orbital species in the unit cell, and mathbfr is a static displacement in unit cells. In that above expression t_mathbfi(mathbfrkappanu) is the bare hopping amplitude, which is not specified here.\n\nFields\n\nphonon_modes::NTuple{2,Int}: Pair of phonon modes getting coupled together.\nbond::Bond{D}: Static displacement seperating the two phonon modes getting coupled.\nbond_id::Int: Bond ID associated with the bond field.\nα_mean::T: Mean of the linear SSH coupling constant alpha_1mathbfi(mathbfrkappanu)\nα_std::T: Standard deviation of the linear SSH coupling constant alpha_1mathbfi(mathbfrkappanu)\nα2_mean::T: Mean of the quadratic SSH coupling constant alpha_2mathbfi(mathbfrkappanu)\nα2_std::T: Standard deviation of the quadratic SSH coupling constant alpha_2mathbfi(mathbfrkappanu)\nα3_mean::T: Mean of the cubic SSH coupling constant alpha_3mathbfi(mathbfrkappanu)\nα3_std::T: Standard deviation of the cubic SSH coupling constant alpha_3mathbfi(mathbfrkappanu)\nα4_mean::T: Mean of the quartic SSH coupling constant alpha_4mathbfi(mathbfrkappanu)\nα4_std::T: Standard deviation of the quartic SSH coupling constant alpha_4mathbfi(mathbfrkappanu)\n\nComment\n\nThe pair of orbitals appearing in bond.orbitals must correspond to the orbital species associated with the two coupling phonon modes specified by phonon_modes.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SSHCoupling-Tuple{}","page":"API","title":"SmoQyDQMC.SSHCoupling","text":"SSHCoupling(;\n    model_geometry::ModelGeometry{D,E},\n    tight_binding_model::TightBindingModel{T,E,D},\n    phonon_modes::NTuple{2,Int},\n    bond::Bond{D},\n    α_mean::Union{T,E},        α_std::E  = 0.0,\n    α2_mean::Union{T,E} = 0.0, α2_std::E = 0.0,\n    α3_mean::Union{T,E} = 0.0, α3_std::E = 0.0,\n    α4_mean::Union{T,E} = 0.0, α4_std::E = 0.0\n) where {D, T<:Number, E<:AbstractFloat}\n\nInitialize and return a instance of SSHCoupling.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononDispersion","page":"API","title":"SmoQyDQMC.PhononDispersion","text":"PhononDispersion{E<:AbstractFloat, D}\n\nDefines a dispersive phonon coupling between phonon modes. Specifically, it defines the dispersive phonon term\n\nhatH_rm disp = sum_mathbfi\n    left(\n        fracM_mathbfi+mathbfrkappaM_mathbfinuM_mathbfi+mathbfrkappa+M_mathbfinu\n    right)\n    bigg\n                    Omega_mathbfi(mathbfrkappanu)^2Big(hatX_mathbfi+mathbfrkappa-hatX_mathbfinuBig)^2\n       +frac112Omega_4mathbfi(mathbfrkappanu)^2Big(hatX_mathbfi+mathbfrkappa-hatX_mathbfinuBig)^4\n    bigg\n\nwhere the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa specify orbital species in the unit cell, and mathbfr is a static displacement in unit cells.\n\nFields\n\nphonon_modes::NTuple{2,Int}: Pair of phonon modes getting coupled together.\nbond::Bond{D}: Static displacement seperating the two phonon modes getting coupled.\nbond_id::Int: Bond ID associated with the bond field.\nΩ_mean::E: Mean dispersive phonon frequency Omega_mathbfi(mathbfrkappanu)\nΩ_std::E: Standard deviation of dispersive phonon frequency Omega_mathbfi(mathbfrkappanu)\nΩ4_mean::E: Mean quartic dispersive phonon coefficient Omega_4mathbfi(mathbfrkappanu)\nΩ4_std::E: Standard deviation of quartic dispersive phonon coefficient Omega_4mathbfi(mathbfrkappanu)\n\nComment\n\nThe pair of orbitals appearing in bond.orbitals must correspond to the orbital species associated with the two coupling phonon modes specified by phonon_modes.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.PhononDispersion-Tuple{}","page":"API","title":"SmoQyDQMC.PhononDispersion","text":"PhononDispersion(;\n    model_geometry::ModelGeometry{D,E},\n    phonon_modes::NTuple{2,Int},\n    bond::Bond{D},\n    Ω_mean::E, Ω_std::E=0.0,\n    Ω4_mean::E=0.0, Ω4_std::E=0.0\n) where {E<:AbstractFloat, D}\n\nInitialize and return a instance of PhononDispersion.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.add_phonon_mode!","page":"API","title":"SmoQyDQMC.add_phonon_mode!","text":"add_phonon_mode!(;\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    phonon_mode::PhononMode{E}\n) where {T<:Number, E<:AbstractFloat, D}\n\nAdd a PhononMode to an ElectronPhononModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_holstein_coupling!","page":"API","title":"SmoQyDQMC.add_holstein_coupling!","text":"add_holstein_coupling!(;\n    model_geometry::ModelGeometry{D,E},\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    holstein_coupling::Union{HolsteinCoupling{E,D}, Nothing} = nothing,\n    holstein_coupling_up::Union{HolsteinCoupling{E,D}, Nothing} = nothing,\n    holstein_coupling_dn::Union{HolsteinCoupling{E,D}, Nothing} = nothing\n) where {T,E,D}\n\nAdd the HolsteinCoupling to an ElectronPhononModel. Note that either holstein_coupling or holstein_coupling_up and holstein_coupling_dn must be specified.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_ssh_coupling!","page":"API","title":"SmoQyDQMC.add_ssh_coupling!","text":"add_ssh_coupling!(;\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    tight_binding_model::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    ssh_coupling::Union{SSHCoupling{T,E,D}, Nothing} = nothing,\n    tight_binding_model_up::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    tight_binding_model_dn::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    ssh_coupling_up::Union{SSHCoupling{T,E,D}, Nothing} = nothing,\n    ssh_coupling_dn::Union{SSHCoupling{T,E,D}, Nothing} = nothing\n) where {T,E,D}\n\nAdd a SSHCoupling to an ElectronPhononModel. Note that either ssh_coupling and tight_binding_model or ssh_coupling_up, ssh_coupling_dn, tight_binding_model_up and tight_binding_model_dn need to be specified.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_phonon_dispersion!","page":"API","title":"SmoQyDQMC.add_phonon_dispersion!","text":"add_phonon_dispersion!(;\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    phonon_dispersion::PhononDispersion{E,D},\n    model_geometry::ModelGeometry{D,E}\n) where {T,E,D}\n\nAdd a PhononDispersion to an ElectronPhononModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#Electron-Phonon-Parameter-Types-and-Methods","page":"API","title":"Electron-Phonon Parameter Types and Methods","text":"","category":"section"},{"location":"api/#SmoQyDQMC.ElectronPhononParameters","page":"API","title":"SmoQyDQMC.ElectronPhononParameters","text":"ElectronPhononParameters{T<:Number, E<:AbstractFloat}\n\nDescribes all parameters in the electron-phonon model.\n\nFields\n\nβ::E: Inverse temperature.\nΔτ::E: Discretization in imaginary time.\nLτ::Int: Length of imaginary time axis.\nx::Matrix{E}: Phonon fields, where each column represents the phonon fields for a given imaginary time slice.\nphonon_parameters::PhononParameters{E}: Refer to PhononParameters.\nholstein_parameters_up::HolsteinParameters{E}: Spin up HolsteinParameters.\nholstein_parameters_dn::HolsteinParameters{E}: Spin down HolsteinParameters.\nssh_parameters_up::SSHParameters{T}: Spin up SSHParameters.\nssh_parameters_dn::SSHParameters{T}: Spin down SSHParameters.\ndispersion_parameters::DispersionParameters{E}: Refer to DispersionParameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ElectronPhononParameters-Tuple{}","page":"API","title":"SmoQyDQMC.ElectronPhononParameters","text":"ElectronPhononParameters(;\n    β::E, Δτ::E,\n    model_geometry::ModelGeometry{D,E},\n    tight_binding_parameters::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    tight_binding_parameters_up::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    tight_binding_parameters_dn::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    rng::AbstractRNG\n) where {T,E,D}\n\nInitialize and return an instance of ElectronPhononParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononParameters","page":"API","title":"SmoQyDQMC.PhononParameters","text":"PhononParameters{E<:AbstractFloat}\n\nDefines the parameters for each phonon in the lattice, includes the phonon field configuration.\n\nFields\n\nnphonon::Int: Number of type of phonon modes.\nNphonon::Int: Total number of phonon modes in finite lattice.\nM::Int: Mass of each phonon mode.\nΩ::Int: Frequency of each phonon mode.\nΩ4::Int: Quartic phonon coefficient for each phonon mode.\nphonon_to_site::Vector{Int}: Map each phonon to the site it lives on in the lattice.\nsite_to_phonons::Vector{Vector{Int}}: Maps the site to the phonon modes on it, allowing for multiple modes to reside on a single site.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HolsteinParameters","page":"API","title":"SmoQyDQMC.HolsteinParameters","text":"HolsteinParameters{E<:AbstractFloat}\n\nDefines the Holstein coupling parameters in lattice.\n\nFields\n\nnholstein::Int: The number of type of holstein couplings.\nNholstein::Int: Total number of Holstein couplings in lattice.\nα::Vector{T}: Linear Holstein coupling.\nα2::Vector{T}: Quadratic Holstein coupling.\nα3::Vector{T}: Cubic Holstein coupling.\nα4::Vector{T}: Quartic Holstein coupling.\nshifted::Vector{Bool}: If the density multiplying the odd powered interaction terms is shifted.\nneighbor_table::Matrix{Int}: Neighbor table where the first row specifies the site where the phonon mode is located, and the second row specifies the site corresponding to the density getting coupled to.\ncoupling_to_phonon::Vector{Int}: Maps each Holstein coupling in the lattice to the corresponding phonon mode.\nphonon_to_coupling::Vector{Vector{Int}}: Maps each phonon model to correspond Holstein couplings.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SSHParameters","page":"API","title":"SmoQyDQMC.SSHParameters","text":"SSHParameters{T<:Number}\n\nDefines the SSH coupling parameters in lattice.\n\nFields\n\nnssh::Int: Number of types of SSH couplings.\nNssh::Int: Number of SSH couplings in lattice.\nα::Vector{T}: Linear SSH coupling.\nα2::Vector{T}: Quadratic SSH coupling.\nα3::Vector{T}: Cubic SSH coupling.\nα4::Vector{T}: Quartic SSH coupling.`\nneighbor_table::Matrix{Int}: Neighbor table to SSH coupling.\ncoupling_to_phonon::Matrix{Int}: Maps each SSH coupling onto that pair of coupled phonons.\ninit_phonon_to_coupling::Vector{Vector{Int}}: Maps initial phonon mode to corresponding SSH coupling(s).\nfinal_phonon_to_coupling::Vector{Vector{Int}}: Maps final phonon mode to corresponding SSH coupling(s).\nhopping_to_couplings::Vector{Vector{Int}}: Maps hopping in the tight-binding model onto SSH couplings.\ncoupling_to_hopping::Vector{Int}: Maps each SSH coupling onto the corresponding hopping in the tight-binding model.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.DispersionParameters","page":"API","title":"SmoQyDQMC.DispersionParameters","text":"DispersionParameters{E<:AbstractFloat}\n\nDefines the dispersive phonon coupling parameters in the lattice.\n\nFields\n\nndispersion::Int: Number of types of dispersive couplings.\nNdispersion::Int: Number of dispersive couplings in the lattice.\nΩ::Vector{E}: Frequency of dispersive phonon coupling.\nΩ4::Vector{E}: Quartic coefficient for the phonon dispersion.\ndispersion_to_phonon::Matrix{Int}: Pair of phonon modes in lattice coupled by dispersive coupling.\ninit_phonon_to_coupling::Vector{Vector{Int}}: Maps initial phonon mode to corresponding dispersive phonon coupling.\nfinal_phonon_to_coupling::Vector{Vector{Int}}: Maps final phonon mode to corresponding dispersive phonon coupling.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, ElectronPhononParameters{T, E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    electron_phonon_parameters::ElectronPhononParameters{T,E}\n) where {T,E}\n\nInitialize the contribution of an ElectronPhononParameters to a FermionPathIntegral.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, ElectronPhononParameters{T, E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(\n    fermion_path_integral::FermionPathIntegral{T,E},\n    electron_phonon_parameters::ElectronPhononParameters{T,E};\n    spin::Int = +1,\n) where {T,E}\n\nInitialize the contribution of an ElectronPhononParameters to a FermionPathIntegral.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.update!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, ElectronPhononParameters{T, E}, Matrix{E}, Matrix{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.update!","text":"update!(\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    x′::Matrix{E},\n    x::Matrix{E}\n) where {T,E}\n\nUpdate a FermionPathIntegral to reflect a change in the phonon configuration from x to x′.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.update!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, ElectronPhononParameters{T, E}, Matrix{E}, Matrix{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.update!","text":"update!(\n    fermion_path_integral::FermionPathIntegral{T,E},\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    x′::Matrix{E},\n    x::Matrix{E};\n    spin::Int = +1\n) where {T,E}\n\nUpdate a FermionPathIntegral to reflect a change in the phonon configuration from x to x′.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.update!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, ElectronPhononParameters{T, E}, Matrix{E}, Int64}} where {T, E}","page":"API","title":"SmoQyDQMC.update!","text":"update!(fermion_path_integral::FermionPathIntegral{T,E},\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    x::Matrix{E},\n    sgn::Int;\n    spin::Int = +1\n) where {T,E}\n\nUpdate a FermionPathIntegral according to sgn * x.\n\n\n\n\n\n","category":"method"},{"location":"api/#Electron-Phonon-Measurements","page":"API","title":"Electron-Phonon Measurements","text":"","category":"section"},{"location":"api/#SmoQyDQMC.measure_phonon_kinetic_energy","page":"API","title":"SmoQyDQMC.measure_phonon_kinetic_energy","text":"measure_phonon_kinetic_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                              n::Int) where {T<:Number, E<:AbstractFloat}\n\nEvaluate the average phonon kinetic energy for phonon mode n. The measurement is made using the expression\n\nlangle K rangle = frac12Deltatau - fracM2bigglanglefrac(x_l+1-x_l)^2Deltatau^2biggrangle \n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_phonon_potential_energy","page":"API","title":"SmoQyDQMC.measure_phonon_potential_energy","text":"measure_phonon_potential_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                                n::Int) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average phonon potential energy, given by\n\nU = frac12 M Omega^2 langle hatX^2 rangle + frac124 M Omega_4^2 langle hatX^4 rangle\n\nfor phonon mode n in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_phonon_position_moment","page":"API","title":"SmoQyDQMC.measure_phonon_position_moment","text":"measure_phonon_position_moment(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                               n::Int, m::Int) where {T<:Number, E<:AbstractFloat}\n\nMeasure langle X^m rangle for phonon mode n in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_holstein_energy","page":"API","title":"SmoQyDQMC.measure_holstein_energy","text":"measure_holstein_energy(\n    holstein_parameters::HolsteinParameters{E},\n    G::Matrix{T},\n    x::Matrix{E},\n    holstein_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate and return both the spin-resolved Holstein interaction energy\n\nepsilon_rm holsigma = \n                            leftlangle\n                                \n                                    alpha   hatX   + alpha_2 hatX^2\n                                  + alpha_3 hatX^3 + alpha_4 hatX^4\n                                \n                                left(\n                                    hatn_sigma - frac12\n                                right)\n                            rightrangle\n\ncorresponding to holstein_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_ssh_energy","page":"API","title":"SmoQyDQMC.measure_ssh_energy","text":"measure_ssh_energy(\n    ssh_parameters::SSHParameters{T},\n    G::Matrix{T}, x::Matrix{E}, ssh_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the return the SSH interaction energy\n\nepsilon_rm ssh = leftlangle alpha hatX     + alpha_2 hatX^2\n                                   alpha_3 hatX^3 + alpha_4 hatX^4\n                        (hatc^dagger_sigmai hatc_sigmaj + rm hc) rightrangle\n\nfor coupling definition specified by ssh_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_dispersion_energy","page":"API","title":"SmoQyDQMC.measure_dispersion_energy","text":"measure_dispersion_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                       dispersion_id::Int) where {T<:Number, E<:AbstractFloat}\n\nEvaluate the average dispersion energy\n\nepsilon_rm disp = frac12 M_rm red Omega^2 langle(hatX_i - hatX_j)^2rangle\n                    + frac124 Mrm red Omega_4^2 langle(hatX_i - hatX_j)^4rangle\n\nwhere M_rm red = fracM_i M_jM_i + M_j is the reduced mass, for the dispersive coupling definition specified by dispersion_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#Electron-Phonon-Updates","page":"API","title":"Electron-Phonon Updates","text":"","category":"section"},{"location":"api/#SmoQyDQMC.HMCUpdater","page":"API","title":"SmoQyDQMC.HMCUpdater","text":"HMCUpdater{T<:Number, E<:AbstractFloat, PFFT, PIFFT}\n\nDefines a hybrid/hamiltonian monte carlo (HMC) update for the phonon degrees of freedom.\n\nFields\n\nNt::Int: Mean trajectory length in terms of the number of fermionic time-steps.\nΔt::E: Average fermionic time-step size used in HMC update.\nnt::Int: Number of bosonic time-steps per fermionic time-step using a bosonic time-step Δt′=Δt/nt.\nδ::E: Time-step used in HMC update is jittered by an amount Δt = Δt * (1 + δ*(2*rand(rng)-1)).\nM::FourierMassMatrix{E,PFFT,PIFFT}: Defines the FourierMassMatrix.\ndSdx::Matrix{E}: Array to contain derivative of fermionic and bosonic action during HMC trajectory.\ndSfdx0::Matrix{E}: Initial derivative of fermionic action associated with the initial phonon configuration.\nGup′::Matrix{T}: Matrix to contain itermediate spin-up Green's function matrices.\nGdn′::Matrix{T}: Matrix to contain itermediate spin-down Green's function matrices.\nx′::Matrix{E}: Array to record intermediate phonon configurations.\nx0::Matrix{E}: Array to record initial phonon configuration.\nv::Matrix{E}: Conjugate momentum to phonon fields in HMC trajectory.\nfirst_update::Bool: A flag indicating whether the next update will be the first update\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HMCUpdater-Tuple{}","page":"API","title":"SmoQyDQMC.HMCUpdater","text":"HMCUpdater(;\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    G::Matrix{T},\n    Nt::Int,\n    Δt::E,\n    nt::Int,\n    reg::E\n) where {T,E}\n\nInitialize and return an instance of HMCUpdater.\n\nArguments\n\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Defines electron phonon model.\nG::Matrix{T}: Template Green's function matrix.\nNt::Int: Number of fermionic timesteps in HMC trajectory.\nΔt::E: Fermionic time-step.\nnt::Int: Number of bosonic time-steps per fermionic time-step.\nreg::E: Regularization parameter for defining an instance of FourierMassMatrix.\nδ::E = 0.05: Proportion by which the HMC time-step is jittered befored each update.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.EFAHMCUpdater","page":"API","title":"SmoQyDQMC.EFAHMCUpdater","text":"EFAHMCUpdater{T<:Number, E<:AbstractFloat, PFFT, PIFFT}\n\nDefines an Exact Fourier Acceleration Hamiltonian/Hybrid Monte Carlo (EFA-HMC) update for the phonon degrees of freedom.\n\nFields\n\nNt::Int: Number of time-steps in HMC trajectory.\nΔt::E: Average time-step size used in HMC update.\nδ::E: Time-step used in EFA-HMC update is jittered by an amount Δt = Δt * (1 + δ*(2*rand(rng)-1)).\nx::Matrix{E}: Records initial phonon configuration in position space.\np::Matrix{E}: Conjugate momentum in HMC dynamics.\ndSdx::Matrix{E}: Stores the derivative of the action.\nGup′::Matrix{T}: Intermediate spin-up Green's function matrix during HMC trajectory.\nGdn′::Matrix{T}: Intermediate spin-down Green's function matrix during HMC trajectory.\nefa::ExactFourierAccelerator{E,PFFT,PIFFT}: Type to perform exact integration of equations of motion of quantum harmonic oscillator. \n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.EFAHMCUpdater-Tuple{}","page":"API","title":"SmoQyDQMC.EFAHMCUpdater","text":"EFAHMCUpdater(;\n    # Keyword Arguments Start Here\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    G::Matrix{T},\n    Nt::Int,\n    Δt::E,\n    reg::E = 0.0,\n    δ::E = 0.05\n) where {T<:Number, E<:AbstractFloat}\n\nArguments\n\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Defines electron-phonon model.\nG::Matrix{T}: Sample Green's function matrix.\nNt::Int: Number of time-steps used in EFA-HMC update.\nΔt::E: Average step size used for HMC update.\nreg::E = Inf: Regularization used for mass in equations of motion.\nδ::E = 0.05: Amount of jitter added to time-step used in EFA-HMC update.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}, HMCUpdater{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(\n    Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n    Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    hmc_updater::HMCUpdater{T,E};\n    # Keyword Arguments Start Here\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P},\n    δG::E, δθ::E, rng::AbstractRNG,\n    update_stabilization_frequency::Bool = false,\n    δG_max::E = 1e-5,\n    δG_reject::E = 1e-2,\n    initialize_force::Bool = true,\n    recenter!::Function = identity,\n    Nt::Int = hmc_updater.Nt,\n    nt::Int = hmc_updater.nt,\n    Δt::E = hmc_updater.Δt,\n    δ::E = hmc_updater.δ\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform HMC update to the phonon degrees of freedom. This method returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ), where accepted is a boolean field indicating whether the proposed HMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}, HMCUpdater{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(\n    G::Matrix{T}, logdetG::E, sgndetG::T,\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    hmc_updater::HMCUpdater{T,E};\n    # Keyword Arguments Start Here\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n    B::Vector{P}, δG::E, δθ::E, rng::AbstractRNG,\n    update_stabilization_frequency::Bool = false,\n    δG_max::E = 1e-5,\n    δG_reject::E = 1e-2,\n    initialize_force::Bool = true,\n    recenter!::Function = identity,\n    Nt::Int = hmc_updater.Nt,\n    nt::Int = hmc_updater.nt,\n    Δt::E = hmc_updater.Δt,\n    δ::E = hmc_updater.δ\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform HMC update to the phonon degrees of freedom assuming the spin-up and spin-down sectors are equivalent. This method returns (accepted, logdetG, sgndetG, δG, δθ), where accepted is a boolean field indicating whether the proposed HMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}, EFAHMCUpdater{T, E}}} where {T, E, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(\n    Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n    Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    hmc_updater::EFAHMCUpdater{T,E};\n    # Keyword Arguments Start Here\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P},\n    δG::E, δθ::E, rng::AbstractRNG,\n    update_stabilization_frequency::Bool = false,\n    δG_max::E = 1e-5,\n    δG_reject::E = 1e-2,\n    recenter!::Function = identity,\n    Nt::Int = hmc_updater.Nt,\n    Δt::E = hmc_updater.Δt,\n    δ::E = hmc_updater.δ\n) where {T, E, P<:AbstractPropagator{T,E}}\n\nPerform EFA-HMC update to the phonon degrees of freedom. This method returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ), where accepted is a boolean field indicating whether the proposed HMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}, EFAHMCUpdater{T, E}}} where {T, E, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(\n    G::Matrix{T}, logdetG::E, sgndetG::T,\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    hmc_updater::EFAHMCUpdater{T,E};\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n    B::Vector{P},\n    δG::E, δθ::E, rng::AbstractRNG,\n    update_stabilization_frequency::Bool = false,\n    δG_max::E = 1e-5,\n    δG_reject::E = 1e-2,\n    recenter!::Function = identity,\n    Nt::Int = hmc_updater.Nt,\n    Δt::E = hmc_updater.Δt,\n    δ::E = hmc_updater.δ\n) where {T, E, P<:AbstractPropagator{T,E}}\n\nPerform EFA-HMC update to the phonon degrees of freedom. This method returns (accepted, logdetG, sgndetG, δG, δθ), where accepted is a boolean field indicating whether the proposed HMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.FourierMassMatrix","page":"API","title":"SmoQyDQMC.FourierMassMatrix","text":"FourierMassMatrix{E<:AbstractFloat, PFFT, PIFFT}\n\nDefines the mass matrix that implements fourier acceleration when performing either hybrid/hamiltonian monte carlo or langevin monte carlo updates to the phonon fields.\n\nFields\n\nM̃::Matrix{E}: Matrix elements of fourier mass matrix in frequency space.\nv′::Matrix{Complex{E}}: Temporary storage array to contain velocities as complex numbers to avoid dynamic memory allocations.\nṽ::Matrix{Complex{E}}: Temporary storage to avoid some dynamic memory allocations when performing fourier transforms.\npfft::PFFT: Forward FFT plan to perform transformation from imaginary time to frequency space without allocations.\npifft::PIFFT: Inverse FFT plan to perform transformation from frequency to imaginary time space without allocations.\nis_scalar::Bool: If the mass matrix is equivalent to a simple scalar.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(\n    # ARGUMENTS\n    Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n    Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n    electron_phonon_parameters::ElectronPhononParameters{T,E};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,\n    phonon_types = nothing\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a phonon mode in the lattice, and propose an update that reflects all the phonon fields associated with that phonon mode x rightarrow -x This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_types = nothing: Collection of phonon types in the unit cell to randomly sample a phonon mode from. If nothing then all phonon modes in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(\n    # ARGUMENTS\n    G::Matrix{T}, logdetG::E, sgndetG::T,\n    electron_phonon_parameters::ElectronPhononParameters{T,E};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n    B::Vector{P}, rng::AbstractRNG,\n    phonon_types = nothing\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a phonon mode in the lattice, and propose an update that reflects all the phonon fields associated with that phonon mode x rightarrow -x This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_types = nothing: Collection of phonon types (specified my PHONON_ID) in the unit cell to randomly sample a phonon mode from. If nothing then all phonon modes in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(\n    # ARGUMENTS\n    Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n    Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n    electron_phonon_parameters::ElectronPhononParameters{T,E};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,\n    phonon_type_pairs = nothing\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a pairs of phonon modes and exchange the phonon fields associated with the pair of phonon modes. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_type_pairs = nothing: Collection of phonon type pairs (specified by pairs of PHONON_ID values) in the unit cell to randomly sample a phonon modes from. If nothing then all phonon mode pairs in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(\n    # ARGUMENTS\n    G::Matrix{T}, logdetG::E, sgndetG::T,\n    electron_phonon_parameters::ElectronPhononParameters{T,E};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n    B::Vector{P}, rng::AbstractRNG,\n    phonon_type_pairs = nothing\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a pairs of phonon modes and exchange the phonon fields associated with the pair of phonon modes. This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_type_pairs = nothing: Collection of phonon type pairs in the unit cell to randomly sample a phonon modes from. If nothing then all phonon mode pairs in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.radial_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.radial_update!","text":"radial_update!(\n    # ARGUMENTS\n    Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n    Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n    electron_phonon_parameters::ElectronPhononParameters{T,E};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,\n    phonon_id::Union{Int, Nothing} = nothing,\n    σ::E = 1.0\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform a radial update to the phonon fields, as described by Algorithm 1 in the paper arXiv:2411.18218. Specifically, the proposed update to the phonon fields x is a rescaling such that x rightarrow e^gamma x where gamma sim N(0 sigmasqrtd) and d is the number of phonon fields being updated.\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_id::Union{Int, Nothing} = nothing: Apply radial update to phonon fields corresponding tp specified PHONON_ID. If phonon_id = nothing, then radial update is applied to all phonon fields.\nσ::E = 1.0: Relative size of the radial update.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.radial_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.radial_update!","text":"radial_update!(\n    # ARGUMENTS\n    G::Matrix{T}, logdetG::E, sgndetG::T,\n    electron_phonon_parameters::ElectronPhononParameters{T,E};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n    B::Vector{P}, rng::AbstractRNG,\n    phonon_id::Union{Int, Nothing} = nothing,\n    σ::E = 1.0\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform a radial update to the phonon fields, as described by Algorithm 1 in the paper arXiv:2411.18218. Specifically, the proposed update to the phonon fields x is a rescaling such that x rightarrow e^gamma x where gamma sim N(0 sigmasqrtd) and d is the number of phonon fields being updated.\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_id::Union{Int, Nothing} = nothing: Apply radial update to phonon fields corresponding tp specified PHONON_ID. If phonon_id = nothing, then radial update is applied to all phonon fields.\nσ::E = 1.0: Relative size of the radial update.\n\n\n\n\n\n","category":"method"},{"location":"api/#Density-and-Chemical-Potential-Tuning","page":"API","title":"Density and Chemical Potential Tuning","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"update_chemical_potential!\nsave_density_tuning_profile","category":"page"},{"location":"api/#SmoQyDQMC.update_chemical_potential!","page":"API","title":"SmoQyDQMC.update_chemical_potential!","text":"update_chemical_potential!(\n    Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n    Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T;\n    chemical_potential_tuner::MuTunerLogger{E,T},\n    tight_binding_parameters::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    tight_binding_parameters_up::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    tight_binding_parameters_dn::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P}\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nUpdate the chemical potential mu in the simulation to approach the target density/filling. This method returns the new values for (logdetGup, sgndetGup, logdetGup, sgndetGup). Note that either the keywork tight_binding_parameters needs to be specified, or tight_binding_parameters_up and tight_binding_parameters_dn both need to be specified.\n\n\n\n\n\nupdate_chemical_potential!(\n    G::Matrix{T}, logdetG::E, sgndetG::T;\n    chemical_potential_tuner::MuTunerLogger{E,T},\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    B::Vector{P}\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nUpdate the chemical potential mu in the simulation to approach the target density/filling. This method returns the new values for (logdetG, sgndetG).\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.save_density_tuning_profile","page":"API","title":"SmoQyDQMC.save_density_tuning_profile","text":"save_density_tuning_profile(\n    simulation_info::SimulationInfo,\n    chemical_potential_tuner::MuTunerLogger{E,T}\n) where {E,T}\n\nWrite the full density tuning history to a CSV file, typically done at the end of a simulation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Measurement-Methods","page":"API","title":"Measurement Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"GLOBAL_MEASUREMENTS\nLOCAL_MEASUREMENTS\nCORRELATION_FUNCTIONS","category":"page"},{"location":"api/","page":"API","title":"API","text":"Initialize Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"initialize_measurement_container\ninitialize_measurements!\ninitialize_correlation_measurements!\ninitialize_composite_correlation_measurement!\ninitialize_measurement_directories","category":"page"},{"location":"api/","page":"API","title":"API","text":"Make Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"make_measurements!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Write Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"write_measurements!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Checkpointing Utilities","category":"page"},{"location":"api/","page":"API","title":"API","text":"write_jld2_checkpoint\nread_jld2_checkpoint\nrename_complete_simulation","category":"page"},{"location":"api/","page":"API","title":"API","text":"Process Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"save_simulation_info\nprocess_measurements\nprocess_correlation_measurement\ncomposite_correlation_stat\ncompute_correlation_ratio\ncompute_composite_correlation_ratio\nglobal_measurement_bins_to_csv\nlocal_measurement_bins_to_csv\ncorrelation_bins_to_csv\ncompress_jld2_bins\ndecompress_jld2_bins\ndelete_jld2_bins","category":"page"},{"location":"api/#SmoQyDQMC.GLOBAL_MEASUREMENTS","page":"API","title":"SmoQyDQMC.GLOBAL_MEASUREMENTS","text":"const GLOBAL_MEASUREMENTS = (\n    \"logdetGup\",\n    \"logdetGdn\",\n    \"sgndetGup\",\n    \"sgndetGdn\",\n    \"sgn\",\n    \"action_total\",\n    \"action_bosonic\",\n    \"action_fermionic\",\n    \"density\",\n    \"density_up\",\n    \"density_dn\",\n    \"double_occ\",\n    \"Nsqrd\"\n)\n\nList of all the global measurements that are made.\n\n\n\n\n\n","category":"constant"},{"location":"api/#SmoQyDQMC.LOCAL_MEASUREMENTS","page":"API","title":"SmoQyDQMC.LOCAL_MEASUREMENTS","text":"const LOCAL_MEASUREMENTS = Base.ImmutableDict(\n    \"density\"                  => \"ORBITAL_ID\",\n    \"density_up\"               => \"ORBITAL_ID\",\n    \"density_dn\"               => \"ORBITAL_ID\",\n    \"double_occ\"               => \"ORBITAL_ID\",\n    \"onsite_energy\"            => \"ORBITAL_ID\",\n    \"onsite_energy_up\"         => \"ORBITAL_ID\",\n    \"onsite_energy_dn\"         => \"ORBITAL_ID\",\n    \"bare_hopping_energy\"      => \"HOPPING_ID\",\n    \"bare_hopping_energy_up\"   => \"HOPPING_ID\",\n    \"bare_hopping_energy_dn\"   => \"HOPPING_ID\",\n    \"hopping_energy\"           => \"HOPPING_ID\",\n    \"hopping_energy_up\"        => \"HOPPING_ID\",\n    \"hopping_energy_dn\"        => \"HOPPING_ID\",\n    \"hopping_amplitude_up\"     => \"HOPPING_ID\",\n    \"hopping_amplitude_dn\"     => \"HOPPING_ID\",\n    \"hopping_amplitude\"        => \"HOPPING_ID\",\n    \"hopping_inversion_avg_up\" => \"HOPPING_ID\",\n    \"hopping_inversion_avg_dn\" => \"HOPPING_ID\",\n    \"hopping_inversion_avg\"    => \"HOPPING_ID\",\n    \"hopping_inversion_up\"     => \"HOPPING_ID\",\n    \"hopping_inversion_dn\"     => \"HOPPING_ID\",\n    \"hopping_inversion\"        => \"HOPPING_ID\",\n    \"hubbard_energy\"           => \"ORBITAL_ID\",\n    \"phonon_kin_energy\"        => \"PHONON_ID\",\n    \"phonon_pot_energy\"        => \"PHONON_ID\",\n    \"X\"                        => \"PHONON_ID\",\n    \"X2\"                       => \"PHONON_ID\",\n    \"X3\"                       => \"PHONON_ID\",\n    \"X4\"                       => \"PHONON_ID\",\n    \"holstein_energy\"          => \"HOLSTEIN_ID\",\n    \"holstein_energy_up\"       => \"HOLSTEIN_ID\",\n    \"holstein_energy_dn\"       => \"HOLSTEIN_ID\",\n    \"ssh_energy\"               => \"SSH_ID\",\n    \"ssh_energy_up\"            => \"SSH_ID\",\n    \"ssh_energy_dn\"            => \"SSH_ID\",\n    \"dispersion_energy\"        => \"DISPERSION_ID\"\n)\n\nList of all the local measurements than can be made, with a mapping to the corresponding type of ID each measurement is reported in terms of.\n\n\n\n\n\n","category":"constant"},{"location":"api/#SmoQyDQMC.CORRELATION_FUNCTIONS","page":"API","title":"SmoQyDQMC.CORRELATION_FUNCTIONS","text":"CORRELATION_FUNCTIONS = Base.ImmutableDict(\n    \"greens\"           => \"ORBITAL_ID\",\n    \"greens_up\"        => \"ORBITAL_ID\",\n    \"greens_dn\"        => \"ORBITAL_ID\",\n    \"greens_tautau\"    => \"ORBITAL_ID\",\n    \"greens_tautau_up\" => \"ORBITAL_ID\",\n    \"greens_tautau_dn\" => \"ORBITAL_ID\",\n    \"density\"          => \"ORBITAL_ID\",\n    \"density_upup\"     => \"ORBITAL_ID\",\n    \"density_dndn\"     => \"ORBITAL_ID\",\n    \"density_updn\"     => \"ORBITAL_ID\",\n    \"density_dnup\"     => \"ORBITAL_ID\",\n    \"spin_x\"           => \"ORBITAL_ID\",\n    \"spin_z\"           => \"ORBITAL_ID\",\n    \"pair\"             => \"BOND_ID\",\n    \"bond\"             => \"BOND_ID\",\n    \"bond_upup\"        => \"BOND_ID\",\n    \"bond_dndn\"        => \"BOND_ID\",\n    \"bond_updn\"        => \"BOND_ID\",\n    \"bond_dnup\"        => \"BOND_ID\",\n    \"current\"          => \"HOPPING_ID\",\n    \"current_upup\"     => \"HOPPING_ID\",\n    \"current_dndn\"     => \"HOPPING_ID\",\n    \"current_updn\"     => \"HOPPING_ID\",\n    \"current_dnup\"     => \"HOPPING_ID\",\n    \"phonon_greens\"    => \"PHONON_ID\"\n)\n\nList of all the correlation functions that can be measured, along with the corresponding type of ID the correlation measurement is reported in terms of. Correlation functions are well defined in both position and momentum space.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Initialize-Measurements","page":"API","title":"Initialize Measurements","text":"","category":"section"},{"location":"api/#SmoQyDQMC.initialize_measurement_container","page":"API","title":"SmoQyDQMC.initialize_measurement_container","text":"initialize_measurement_container(\n    model_geometry::ModelGeometry{D,T,N},\n    β::T, Δτ::T\n) where {T<:AbstractFloat, D, N}\n\nInitialize and return a measurement container of type NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_measurements!","page":"API","title":"SmoQyDQMC.initialize_measurements!","text":"initialize_measurements!(\n    measurement_container::NamedTuple,\n    tight_binding_model_up::TightBindingModel{T,E},\n    tight_binding_model_dn::TightBindingModel{T,E},\n) where {T<:Number, E<:AbstractFloat}\n\ninitialize_measurements!(\n    measurement_container::NamedTuple,\n    tight_binding_model::TightBindingModel{T,E}\n) where {T<:Number, E<:AbstractFloat}\n\nInitialize tight-binding model related measurements.\n\nInitialized Measurements\n\nonsite_energy: Refer to measure_onsite_energy.\nonsite_energy_up: Refer to measure_onsite_energy.\nonsite_energy_dn: Refer to measure_onsite_energy.\nhopping_energy: Refer to measure_hopping_energy.\nhopping_energy_up: Refer to measure_hopping_energy.\nhopping_energy_dn: Refer to measure_hopping_energy.\n\n\n\n\n\ninitialize_measurements!(\n    measurement_container::NamedTuple,\n    hubbard_model::HubbardModel{T}\n) where {T<:AbstractFloat}\n\nInitialize Hubbard model related measurements.\n\nInitialized Measurements:\n\nhubbard_energy: Refer to measure_hopping_energy.\n\n\n\n\n\ninitialize_measurements!(\n    measurement_container::NamedTuple,\n    electron_phonon_model::ElectronPhononModel{T, E, D}\n) where {T<:Number, E<:AbstractFloat, D}\n\nInitialize electron-phonon model related measurements.\n\nInitialized Measurements:\n\nphonon_kinetic_energy: Refer to measure_phonon_kinetic_energy.\nphonon_potential_energy: Refer to measure_phonon_potential_energy.\nX: Measure langle hatX rangle, refer to measure_phonon_position_moment.\nX2: Measure langle hatX^2 rangle, refer to measure_phonon_position_moment.\nX3: Measure langle hatX^3 rangle, refer to measure_phonon_position_moment.\nX4: Measure langle hatX^4 rangle, refer to measure_phonon_position_moment.\nholstein_energy: Refer to measure_holstein_energy.\nholstein_energy_up: Refer to measure_holstein_energy.\nholstein_energy_dn: Refer to measure_holstein_energy.\nssh_energy: Refer to measure_ssh_energy.\nssh_energy_up: Refer to measure_ssh_energy.\nssh_energy_dn: Refer to measure_ssh_energy.\ndispersion_energy: Refer to measure_dispersion_energy.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_correlation_measurements!","page":"API","title":"SmoQyDQMC.initialize_correlation_measurements!","text":"initialize_correlation_measurements!(;\n    measurement_container::NamedTuple,\n    model_geometry::ModelGeometry{D,T,N},\n    correlation::String,\n    pairs::AbstractVector{NTuple{2,Int}},\n    time_displaced::Bool,\n    integrated::Bool = false\n)  where {T<:AbstractFloat, D, N}\n\nInitialize measurements of correlation for all ID pairs; refer to CORRELATION_FUNCTIONS for ID type associated with each correlation measurement. The name correlation must therefore also appear in [CORRELATION_FUNCTIONS]@ref. If time_displaced = true then time-displaced and integrated correlation measurements are made. If time_displaced = false and integrated = false, then just equal-time correlation measurements are made. If time_displaced = false and integrated = true, then both equal-time and integrated correlation measurements are made.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_composite_correlation_measurement!","page":"API","title":"SmoQyDQMC.initialize_composite_correlation_measurement!","text":"initialize_composite_correlation_measurement!(;\n    measurement_container::NamedTuple,\n    model_geometry::ModelGeometry{D,T,N},\n    name::String,\n    correlation::String,\n    ids,\n    coefficients,\n    time_displaced::Bool,\n    integrated::Bool = false\n)  where {T<:AbstractFloat, D, N}\n\nInitialize a composite correlation measurement called name based on a linear combination of local operators used in a standard correlation measurement, with ids and coefficients specifying the linear combination.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_measurement_directories","page":"API","title":"SmoQyDQMC.initialize_measurement_directories","text":"initialize_measurement_directories(;\n    # KEYWORD ARGUMENTS\n    simulation_info::SimulationInfo,\n    measurement_container::NamedTuple\n)\n\ninitialize_measurement_directories(\n        # ARGUMENTS\n        comm::MPI.Comm;\n        # KEYWORD ARGUMENTS\n        simulation_info::SimulationInfo,\n        measurement_container::NamedTuple\n)\n\ninitialize_measurement_directories(\n    # ARGUMENTS\n    simulation_info::SimulationInfo,\n    measurement_container::NamedTuple\n)\n\ninitialize_measurement_directories(\n        # ARGUMENTS\n        comm::MPI.Comm,\n        simulation_info::SimulationInfo,\n        measurement_container::NamedTuple\n)\n\nInitialize the measurement directories for simulation. If using MPI and a comm::MPI.Comm object is passed as the first argument, then none of the MPI processes will proceed beyond this function call until the measurement directories have been initialized.\n\n\n\n\n\n","category":"function"},{"location":"api/#Make-Measreuments","page":"API","title":"Make Measreuments","text":"","category":"section"},{"location":"api/#SmoQyDQMC.make_measurements!","page":"API","title":"SmoQyDQMC.make_measurements!","text":"make_measurements!(\n    measurement_container::NamedTuple,\n    logdetGup::E, sgndetGup::T, Gup::AbstractMatrix{T},\n    Gup_ττ::AbstractMatrix{T}, Gup_τ0::AbstractMatrix{T}, Gup_0τ::AbstractMatrix{T},\n    logdetGdn::E, sgndetGdn::T, Gdn::AbstractMatrix{T},\n    Gdn_ττ::AbstractMatrix{T}, Gdn_τ0::AbstractMatrix{T}, Gdn_0τ::AbstractMatrix{T};\n    # Keyword Arguments Start Here\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P},\n    model_geometry::ModelGeometry{D,E,N},\n    tight_binding_parameters::Union{Nothing, TightBindingParameters{T,E}} = nothing,\n    tight_binding_parameters_up::Union{Nothing, TightBindingParameters{T,E}} = nothing,\n    tight_binding_parameters_dn::Union{Nothing, TightBindingParameters{T,E}} = nothing,\n    coupling_parameters::Tuple,\n    δG::E, δθ::E, δG_max::E = 1e-6\n) where {T<:Number, E<:AbstractFloat, D, N, P<:AbstractPropagator{T,E}}\n\nMake measurements, including time-displaced correlation and zero Matsubara frequency measurements. This method also returns (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ). Note that either the keywork tight_binding_parameters needs to be specified, or tight_binding_parameters_up and tight_binding_parameters_dn both need to be specified.\n\n\n\n\n\nmake_measurements!(\n    measurement_container::NamedTuple,\n    logdetG::E, sgndetG::T, G::AbstractMatrix{T},\n    G_ττ::AbstractMatrix{T}, G_τ0::AbstractMatrix{T}, G_0τ::AbstractMatrix{T};\n    # Keyword Arguments Start Here\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    B::Vector{P},\n    model_geometry::ModelGeometry{D,E,N},\n    tight_binding_parameters::TightBindingParameters{T,E},\n    coupling_parameters::Tuple,\n    δG::E, δθ::E, δG_max::E = 1e-6\n) where {T<:Number, E<:AbstractFloat, D, N, P<:AbstractPropagator{T,E}}\n\nMake measurements, including time-displaced correlation and zero Matsubara frequency measurements. This method also returns (logdetG, sgndetG, δG, δθ).\n\n\n\n\n\n","category":"function"},{"location":"api/#Write-Measreuments","page":"API","title":"Write Measreuments","text":"","category":"section"},{"location":"api/#SmoQyDQMC.write_measurements!","page":"API","title":"SmoQyDQMC.write_measurements!","text":"write_measurements!(;\n    measurement_container::NamedTuple,\n    simulation_info::SimulationInfo,\n    model_geometry::ModelGeometry{D, E, N},\n    Δτ::E,\n    bin_size::Int,\n    update::Int = 0,\n    bin::Int = update ÷ bin_size,\n) where {D, E<:AbstractFloat, N}\n\nWrite the measurements contained in measurement_container to file if update % bin_size == 0. Measurements are written to file in a binary format using the JLD2.jl package.\n\nThis function also does a few other things:\n\nNormalizes all the measurements by the bin_size i.e. the number of measurements that were accumlated into the measurement container.\nTake position space correlation function measurements and fourier transform them to momentum space.\nIntegrate relevant time-displaced correlation function measurements over imaginary time to get the corresponding zero matsubara frequency correlation function.\nReset all the measurements in measurement_container to zero after the measurements are written to file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Checkpointing-Utilities","page":"API","title":"Checkpointing Utilities","text":"","category":"section"},{"location":"api/#SmoQyDQMC.write_jld2_checkpoint","page":"API","title":"SmoQyDQMC.write_jld2_checkpoint","text":"write_jld2_checkpoint(\n    # Arguments\n    comm::MPI.Comm,\n    simulation_info::SimulationInfo;\n    # Keyword Arguments\n    checkpoint_timestamp::T = 0.0,\n    checkpoint_freq::T = 0.0,\n    start_timestamp::T = 0.0,\n    runtime_limit::T = Inf,\n    error_code::Int = 13,\n    # Abitrary Keyword Arguments Written to Checkpoint\n    kwargs...\n) where {T<:AbstractFloat}\n\nwrite_jld2_checkpoint(\n    # Arguments\n    simulation_info::SimulationInfo;\n    # Keyword Arguments\n    checkpoint_timestamp::T = 0.0,\n    checkpoint_freq::T = 0.0,\n    start_timestamp::T = 0.0,\n    runtime_limit::T = Inf,\n    error_code::Int = 13,\n    # Abitrary Keyword Arguments Written to Checkpoint\n    kwargs...\n) where {T<:AbstractFloat}\n\nCheckpoint a simulation by writing a new checkpoint file if necessary The checkpoint file is a JLD2 binary file.\n\nArguments\n\ncomm::MPI.Comm: (optional) MPI communicator object used to synchronize processes. Ensures all MPI processes remain syncrhonized.\nsimulation_info::SimulationInfo: Contains datafolder and MPI process ID information.\n\nKeyword Arguments\n\ncheckpoint_timestamp::T = 0.0: (optional) Epoch timestap of previously written checkpoint file.\ncheckpoint_freq::T = 0.0: (optional) Frequency with with checkpoint files are written; new checkpoint is written only if this many seconds has elapsed since previous checkpoint.\nstart_timestamp::T = 0.0: (optional) Epoch timestamp of the start time of the simulation.\nruntime_limit::T = Inf: (optional) Maximum runtime for simulation in seconds; if after writing a new checkpoint file the next checkpoint file that would be written in the future exceeds the runtime limit then exit the simulation.\nerror_code::Int = 13: (optional) Error code used to exit simulation if the runtime limit is exceeded.\nkwargs...: Additional keyword arguments containing the information that will stored in the checkpoint file; keyword arguments can point to arbitrary Julia objects.\n\nNotes\n\nThe default values for the checkpoint_timestamp, checkpoint_freq, start_timestamp, and runtime_limit keyword arguments result in there being no runtime limit for the simulation and a new checkpoint file being written every time this function is called.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.read_jld2_checkpoint","page":"API","title":"SmoQyDQMC.read_jld2_checkpoint","text":"read_jld2_checkpoint(\n    simulation_info::SimulationInfo\n)\n\nRead in a checkpoint file written using the write_jld2_checkpoint function and return its contents as a dictionary. This function returns the tuple (checkpoint, checkpoint_timestamp) where checkpoint is a dictionary containing the contents of the checkpoint file and checkpoint_timestamp is the epoch timestamp corresponding to when the checkpoint file was read in. Behind the scenes, the JLD2.jl package is used to read (and write) the checkpoint files.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.rename_complete_simulation","page":"API","title":"SmoQyDQMC.rename_complete_simulation","text":"rename_complete_simulation(\n    # Arguments\n    comm::MPI.Comm,\n    simulation_info::SimulationInfo;\n    # Keyword Arguments\n    delete_jld2_checkpoints::Bool = true\n)\n\nrename_complete_simulation(\n    # Arguments\n    simulation_info::SimulationInfo;\n    # Keyword Arguments\n    delete_jld2_checkpoints::Bool = true\n)\n\nWhen a simulation is complete, this function renames the data folder the results were written to such that the directory name now begins with \"complete_\", making it simpler to identify which simulations no longer need to be resumed if checkpointing is being used. This function also deletes the any checkpoint files written using the write_jld2_checkpoint function if delect_checkpoints = true.\n\n\n\n\n\n","category":"function"},{"location":"api/#Process-Measurements","page":"API","title":"Process Measurements","text":"","category":"section"},{"location":"api/#SmoQyDQMC.save_simulation_info","page":"API","title":"SmoQyDQMC.save_simulation_info","text":"save_simulation_info(sim_info::SimulationInfo, additional_info = nothing)\n\nSave the contents sim_info to a TOML file, and add an optional additional table to the output file based on the contents of a dictionary additional_info.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.process_measurements","page":"API","title":"SmoQyDQMC.process_measurements","text":"process_measurements(\n    # ARGUMENTS\n    folder::String,\n    N_bins::Int,\n    pIDs::Union{Vector{Int},Int} = Int[];\n    # KEYWORD ARGUMENTS\n    time_displaced::Bool = false\n)\n\nprocess_measurements(\n    # ARGUMENTS\n    comm::MPI.Comm,\n    folder::String,\n    N_bins::Int,\n    pIDs::Union{Vector{Int},Int} = Int[];\n    # KEYWORD ARGUMENTS\n    time_displaced::Bool = false\n)\n\nProcess the measurements recorded in the simulation directory folder, where N_bins is the number of bins the data is grouped into for calculating error bars. Note that this method will over-write an existing correlation stats file if there already is one. The boolean flag time_displaced determines whether or not to calculate error bars for time-displaced correlation measurements, as this can take a non-negligible amount of time for large system, especially when many simulations were run in parallel. Note that using pIDs argument you can filter which MPI walker to use when calculting the statistics.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.process_global_measurements","page":"API","title":"SmoQyDQMC.process_global_measurements","text":"process_global_measurements(\n    folder::String,\n    N_bins::Int,\n    pIDs::Union{Vector{Int},Int} = Int[]\n)\n\nprocess_global_measurements(\n    comm::MPI.Comm,\n    folder::String,\n    N_bins::Int,\n    pIDs::Vector{Int} = Int[]\n)\n\nProcess global measurents for the specified process IDs, calculating the average and error for all global measurements and writing the result to CSV file. If pIDs is not specified, then results for all MPI walkers are averaged over.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.process_local_measurements","page":"API","title":"SmoQyDQMC.process_local_measurements","text":"process_local_measurements(\n    folder::String,\n    N_bins::Int,\n    pIDs::Union{Vector{Int},Int} = Int[]\n)\n\nprocess_local_measurements(\n    comm::MPI.Comm,\n    folder::String,\n    N_bins::Int,\n    pIDs::Vector{Int} = Int[]\n)\n\nProcess local measurents for the specified process IDs, calculating the average and error for all local measurements and writing the result to CSV file. If pIDs is not specified, then the statistics are calculated using all MPI walker results.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.process_correlation_measurements","page":"API","title":"SmoQyDQMC.process_correlation_measurements","text":"process_correlation_measurements(\n    folder::String,\n    N_bins::Int,\n    pIDs::Union{Vector{Int},Int} = Int[],\n    types::Vector{String} = [\"equal-time\", \"time-displaced\", \"integrated\"],\n    spaces::Vector{String} = [\"position\", \"momentum\"]\n)\n\nfunction process_correlation_measurements(\n    comm::MPI.Comm,\n    folder::String,\n    N_bins::Int,\n    pIDs::Vector{Int} = Int[],\n    types::Vector{String} = [\"equal-time\", \"time-displaced\", \"integrated\"],\n    spaces::Vector{String} = [\"position\", \"momentum\"]\n)\n\nProcess correlation measurements, calculating the average and errors and writing the result to CSV file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.process_correlation_measurement","page":"API","title":"SmoQyDQMC.process_correlation_measurement","text":"process_correlation_measurement(\n    folder::String,\n    correlation::String,\n    type::String,\n    space::String,\n    N_bins::Int,\n    pIDs::Union{Vector{Int}, Int} = Int[]\n)\n\nProcess results for the specified correlation function, calculating the associated average and error statistics for it and writing the result to CSV file. If pIDs is not specified, then the calculated statistics are arrived at by averaging over the results for all MPI walkers.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.composite_correlation_stat","page":"API","title":"SmoQyDQMC.composite_correlation_stat","text":"composite_correlation_stat(;\n    folder::String,\n    correlations::Vector{String},\n    spaces::Vector{String},\n    types::Vector{String},\n    ids::Vector{NTuple{2,Int}},\n    locs::Vector{NTuple{D,Int}},\n    Δls::Vector{Int} = Int[],\n    num_bins::Int = 0,\n    pIDs::Vector{Int} = Int[],\n    f::Function = identity\n) where {D}\n\nfunction composite_correlation_stat(\n    comm::MPI.Comm;\n    # Keyword Arguments Below\n    folder::String,\n    correlations::Vector{String},\n    spaces::Vector{String},\n    types::Vector{String},\n    ids::Vector{NTuple{2,Int}},\n    locs::Vector{NTuple{D,Int}},\n    Δls::Vector{Int} = Int[],\n    num_bins::Int = 0,\n    pIDs::Vector{Int} = Int[],\n    f::Function = identity\n) where {D}\n\nCalaculate the mean and error for a composite correlation measurement based on the function f. Note that D indicates the spatial dimension of the system.\n\nKeywords\n\nfolder::String: The directory all the simulation results were written to.\ncorrelations::Vector{String}: Vector specifying the correlation types.\nspaces::Vector{String}: Space of each correlation measurement \"position\" or \"momentum\".\ntypes::Vector{String}: The type of each correlation measurement \"equal-time\", \"time-displaced\" or \"integrated\".\nids::Vector{NTuple{2,Int}}: Vector of ID pairs to read for each correlation.\nlocs::Vector{NTuple{D,Int}}: Species displacement vector for position space, or k-point for momentum space.\nΔls::Vector{Int} = Int[]: Displacement in imaginary time for time-displaced correlation measurements. Igonored otherwise.\nnum_bins::Int = 0: Number of bins used to calcuate error for each MPI walker, defaults to the number of JLD2 binary data files.\npIDs::Vector{Int} = Int[]: MPI walkers to average over when calculating states, defaults to using all MPI walkers if not specified.\nf::Function = identity: Function evaluated to calculate the composite correlation that is measured.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.compute_correlation_ratio","page":"API","title":"SmoQyDQMC.compute_correlation_ratio","text":"compute_correlation_ratio(\n    comm::MPI.Comm;\n    folder::String,\n    correlation::String,\n    type::String,\n    id_pairs::Vector{NTuple{2,Int}},\n    coefs,\n    k_point,\n    num_bins::Int = 0,\n    pIDs::Vector{Int} = Int[],\n)\n\ncompute_correlation_ratio(;\n    # Keyword Arguments\n    folder::String,\n    correlation::String,\n    type::String,\n    id_pairs::Vector{NTuple{2,Int}},\n    coefs,\n    k_point,\n    num_bins::Int = 0,\n    pIDs::Vector{Int} = Int[],\n)\n\nCompute the correlation ratio at the mathbfk-point using a linear combination of standard correlation function measurements. The linear combination of correlation functions used is defined by id_pairs and coefs. If type is \"equal-time\" or \"time-displaced\" then the equal-time correlation ratio is calculated. If type is \"integrated\" then the integrated correlation ratio is calculated.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.compute_composite_correlation_ratio","page":"API","title":"SmoQyDQMC.compute_composite_correlation_ratio","text":"compute_composite_correlation_ratio(\n    comm::MPI.Comm;\n    # Keyword Arguments\n    folder::String,\n    correlation::String,\n    type::String,\n    k_point,\n    num_bins::Int = 0,\n    pIDs::Vector{Int} = Int[],\n)\n\ncompute_composite_correlation_ratio(;\n    # Keyword Arguments\n    folder::String,\n    correlation::String,\n    type::String,\n    k_point,\n    num_bins::Int = 0,\n    pIDs::Vector{Int} = Int[],\n)\n\nCompute the correlation ratio for a specified mathbfk-point for the specified composite correlation function. If type is \"equal-time\" or \"time-displaced\" then the equal-time correlation ratio is calculated. If type is \"integrated\" then the integrated correlation ratio is calculated.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.global_measurement_bins_to_csv","page":"API","title":"SmoQyDQMC.global_measurement_bins_to_csv","text":"global_measurement_bins_to_csv(\n    folder::String,\n    pID::Int = -1\n)\n\nWrite the binned global measurements to file corresponding to process ID pID. If pID = -1, then write binned global measurements for all processes to file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.local_measurement_bins_to_csv","page":"API","title":"SmoQyDQMC.local_measurement_bins_to_csv","text":"local_measurement_bins_to_csv(\n    folder::String,\n    measurement::String,\n    pID::Int = -1\n)\n\nWrite the binned values for the local measurement measurement to a CSV file for process ID pID. If pID = -1, then write it to file for all process IDs.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.correlation_bins_to_csv","page":"API","title":"SmoQyDQMC.correlation_bins_to_csv","text":"correlation_bins_to_csv(\n    pID::Int = -1;\n    folder::String,\n    correlation::String,\n    type::String,\n    space::String,\n    write_index_key::Bool = true\n)\n\nWrite binned correlation data for pID to a CSV file. The field type must be set equal to \"equal-time\", \"time-displaced\" or \"integrated\", and the field space but bet set to either \"position\" or \"momentum\". If pID = -1, then write binned data for all walkers to file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.compress_jld2_bins","page":"API","title":"SmoQyDQMC.compress_jld2_bins","text":"compress_jld2_bins(\n    # ARGUMENTS\n    comm::MPI.Comm;\n    # KEYWORD ARGUMENTS\n    folder::String,\n    pID::Int = -1,\n    compress::Bool = true\n)\n\ncompress_jld2_bins(;\n    # KEYWORD ARGUMENTS\n    folder::String,\n    pID::Int = -1,\n    compress::Bool = true\n)\n\nCombine the many JLD2 binary files containing the binned data into a single JLD2 file. If pID ≥ 0, then only the binned files corresponding to the passed pID values merged into a single file binned_data_pID-$(pID).jld2. If pID = -1, then all the binned files, regardless are merged into a single filed called binned_data.jld2. Note that if many simulations were run in parallel, this can take quite a while, and doing it for a single pID at a time may be advisable.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.decompress_jld2_bins","page":"API","title":"SmoQyDQMC.decompress_jld2_bins","text":"decompress_jld2_bins(;\n    # KEYWORD ARGUMENTS\n    folder::String,\n    pID::Int = -1\n)\n\nDecompress compressed binned data stored in a single JLD2 file into the original population of many JLD2 files, eaching containing the binned data for a certain type of measurement. If pID ≥ 0, then the file binary_data_pID-$(pID).jld2 will be decompressed. If pID = -1, then the file binary_data.jld2 will be decompressed.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.delete_jld2_bins","page":"API","title":"SmoQyDQMC.delete_jld2_bins","text":"delete_jld2_bins(;\n    # KEYWORD ARGUMENTS\n    folder::String,\n    pID::Int = -1\n)\n\nGo through and delete all the binary files in the data folder directory. Please be cautious, once done this operation cannot be undone, data will be lost permanently!\n\n\n\n\n\n","category":"function"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/hubbard_chain/#Hubbard-Chain","page":"Hubbard Chain","title":"Hubbard Chain","text":"","category":"section"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"In this first example we will work through simulating the repulsive Hubbard model on a 1D chain at half-filling. The Hubbard Hamiltonian for a 1D chain is given by","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"hatH = -t sum_sigmai (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n+ U sum_i (hatn_uparrowi-tfrac12)(hatn_downarrowi-tfrac12)\n- mu sum_sigmai hatn_sigmai","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. In the above Hamiltonian t is the nearest neighbor hopping integral and U  0 controls the strength of the on-site Hubbard repulsion. Lastly, we consider the case that the system is half-filled and particle-hole symmetric, which occurs when when the chemical potential is zero, mu = 00.","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"Suppose we want to simulate a half-filled Hubbard chain (mu = 00) of length L=16 with U=80 at an inverse temperature of beta = 80. This is accomplished by running the script associated with this example using the command","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"> julia hubbard_chain.jl 1 6.0 0.0 8.0 16 2000 10000 50","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"with the resulting data being written to a local directory hubbard_chain_U6.00_mu0.00_L16_b8.00-1 that will be created. The first command line argument is the simulation ID (sID = 1), and reuslts in the directory name ending in -1. The second, third, fourth and fifth command line arguments correspond to U, mu, beta and L respectively. The sixth command line argument specifies the number thermalization/burnin sweeps (N_burnin = 2000) that are performed, where an update to each Hubbard-Stratonovich field is attempted. The seventh command line argument specifies the subsequent number of sweeps through the lattice (N_udpates = 10000), after each of which measurements are performed. Finally, the eighth command line argument specifies the number of times during the simulation data is written to file (N_bins = 50). Note that this example only runs for a few minutes on most systems and can be easily run on most personal computers.","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"However, it should be stressed that this structure for the simulation is not enforced by the SmoQyDQMC.jl package itself, but rather is simply a function of how the example_scripts/hubbard_chain.jl script is structured.","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"Below you will find a more heavily commented version of the example_scripts/hubbard_chain.jl script that includes additional exposition on what each part of the code is doing.","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"# First we import the required packages, including all of the required SmoQyDQMC submodules.\n\nusing LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# To start, we define a top-level function for running the DQMC simulation.\n# Note that the arguments to this function correspond to the command line arguments\n# used to run this script.\nfunction run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    # Note that the simulation ID `sID`` will be appended to this foldername as `*-sID`\n    datafolder_prefix = @sprintf \"hubbard_chain_U%.2f_mu%.2f_L%d_b%.2f\" U μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    # This type helps keep track of where data will be written to, and also what versions of\n    # SmoQyDQMC and Julia were used to run the script.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    # For convenience, we seed this function with a randomly sampled number for the\n    # global random number generator.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    # The function  dqmcf.eval_length_imaginary_axis() simply ensures\n    # that Lτ can be appropriately defined as an integer.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    # The bin size is the number of measurements that are averaged over each time data is written\n    # to file during the simulation.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    # Thinks of this as a simulation notebook where you can store any parameters you would like to record\n    # about how the DQMC simulation was run. For instance, it may be good to record the seed\n    # used to initialize the random number generator for reproducibility reasons. This dictionary\n    # will be appended as a table to the simulation information TOML file generated at the end of\n    # the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    # This struct defines the UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    # The struct describes the size of the finite periodic lattice to be simulated.\n    # Note that curretly periodic boundary condition must be used.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    # This type helps keep track of all the relevant features of the lattice\n    # geometry being simulated, including the defintion of the unit cell,\n    # the size of the finite periodic lattice, and all the relevant\n    # bond defintions that may arise in the model.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted = false, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n        U_orbital = [1],\n        U_mean = [U],\n    )\n\n    # Write the model summary to file.\n    # The model summary file, \"model_summary.toml\", is a very important file.\n    # It fully describes the model and system being simulated. It also defines all the\n    # various tID definitions (ORBITAL_ID, BOND_ID, HOPPING_ID, PHONON_ID)\n    # that measurements are reported in terms of. Therefore, this file is useful\n    # for understanding out the interpret and process the output data files.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n    # Above we defined the both the model and lattice size. Next, we initialize\n    # the actual system parameters. This is different because in general any\n    # parameter appearing in the model can support disorder. For instance, you\n    # can in simulate a system with random disorder in the on-site energy.\n    # Therefore, we need to initialize the parameters for the model on the lattice\n    # size we actually want to simulate.\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Here we initialize/define all the measurements we plan on making during the simulation.\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    # Because `time_displaced = true`, the time-displaced Greens function will be measured.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize density correlation function measurement.\n    # Because `time_displaced = false` and `integrated = true` the equal-time\n    # density correlation function, and the charge susceptibility will\n    # be measured. Note that the charge susceptibilty can be understood as the\n    # integral of the time-displaced density correlation function over\n    # the imaginary-time axis from τ=0 to τ=β.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    # Measure the local s-wave equal-time pair correlation function (`time-displaced = false`),\n    # and the corresponding pair susceptibility (`integrated = true`).\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # The code appearing in this section of the code is relatively boiler plate.\n    # While it may change in some small ways from system to system, the overall\n    # structure should remain relatively static.\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters, hubbard_ising_parameters)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    # This simulation summary file records the version number of SmoQyDQMC and Julia\n    # used to perform the simulation. The dictionary `additional_info` is appended\n    # as a table to the end of the simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n   # Note that everyting appearing in this section of the code is considered post-processing,\n   # and can be re-run so long as the data folder generated by the DQMC simulation persists\n   # and none of the binned data has been deleted from it.\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    μ = parse(Float64, ARGS[3])\n    β = parse(Float64, ARGS[4])\n    L = parse(Int, ARGS[5])\n    N_burnin = parse(Int, ARGS[6])\n    N_updates = parse(Int, ARGS[7])\n    N_bins = parse(Int, ARGS[8])\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"Download this example as a Julia script.","category":"page"},{"location":"tutorials/holstein_honeycomb/#2a)-Honeycomb-Holstein-Model","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"In this example we will work through simulating the Holstein model on a honeycomb lattice. The Holstein Hamiltonian is given by","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"beginalign*\nhatH =  -t sum_langle i j rangle sigma (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n- mu sum_isigma hatn_sigmai \n + frac12 M Omega^2 sum_i hatX_i^2 + sum_i frac12M hatP_i^2\n+ alpha sum_i hatX_i (hatn_uparrowi + hatn_downarrowi - 1)\nendalign*","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. Here mu is the chemical potential and  t is the nearest-neighbor hopping amplitude, with the sum over langle ij rangle denoting a sum over all nearest-neighbor pairs of sites. A local dispersionless phonon mode is then placed on each site in the lattice, with hatX_i and hatP_i the corresponding phonon position and momentum operator on site i in the lattice. The phonon mass and energy are denoted M and Omega respectively. Lastly, the phonon displacement hatX_i couples to the total local density hatn_uparrowi + hatn_downarrowi with the parameter alpha controlling the strength of this coupling.","category":"page"},{"location":"tutorials/holstein_honeycomb/#Import-packages","page":"2a) Honeycomb Holstein Model","title":"Import packages","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"As in the previous tutorial, we begin by importing the necessary packages; for more details refer to here.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"using SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf","category":"page"},{"location":"tutorials/holstein_honeycomb/#Specify-simulation-parameters","page":"2a) Honeycomb Holstein Model","title":"Specify simulation parameters","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"The entire main body of the simulation we will wrapped in a top-level function named run_simulation that will take as keyword arguments various model and simulation parameters that we may want to change. The function arguments with default values are ones that are typically left unchanged between simulations.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"# Top-level function to run simulation.\nfunction run_simulation(;\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_updates, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"page"},{"location":"tutorials/holstein_honeycomb/#Initialize-simulation","page":"2a) Honeycomb Holstein Model","title":"Initialize simulation","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"In this first part of the script we name and initialize our simulation, record important metadata about the simulation and create the data folder our simulation results will be written to. For more information refer to here.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_honeycomb_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)","category":"page"},{"location":"tutorials/holstein_honeycomb/#Initialize-simulation-metadata","page":"2a) Honeycomb Holstein Model","title":"Initialize simulation metadata","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"In this section of the code we record important metadata about the simulation, including initializing the random number generator that will be used throughout the simulation. The important metadata within the simulation will be recorded in the metadata dictionary.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Initialize random number generator\n    rng = Xoshiro(seed)\n\n    # Initialize additiona_info dictionary\n    metadata = Dict()\n\n    # Record simulation parameters.\n    metadata[\"N_therm\"] = N_therm\n    metadata[\"N_updates\"] = N_updates\n    metadata[\"N_bins\"] = N_bins\n    metadata[\"n_stab\"] = n_stab\n    metadata[\"dG_max\"] = δG_max\n    metadata[\"symmetric\"] = symmetric\n    metadata[\"checkerboard\"] = checkerboard\n    metadata[\"seed\"] = seed","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"Here we also update variables to keep track of the acceptance rates for the various types of Monte Carlo updates that will be performed during the simulation. This will be discussed in more detail in later sections of the tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    metadata[\"hmc_acceptance_rate\"] = 0.0\n    metadata[\"reflection_acceptance_rate\"] = 0.0\n    metadata[\"swap_acceptance_rate\"] = 0.0","category":"page"},{"location":"tutorials/holstein_honeycomb/#Initialize-model","page":"2a) Honeycomb Holstein Model","title":"Initialize model","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"The next step is define the model we wish to simulate. In this example the relevant model parameters the phonon energy Omega (Ω), electron-phonon coupling alpha (α), chemical potential mu (μ), and lattice size L (L). The neasrest-neighbor hopping amplitude and phonon mass are normalized to unity, t = M = 1.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Define the unit cell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[3/2,√3/2],\n                        [3/2,-√3/2]],\n        basis_vecs   = [[0.,0.],\n                        [1.,0.]]\n    )\n\n    # Define finite lattice with periodic boundary conditions.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize model geometry.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the first nearest-neighbor bond in a honeycomb lattice.\n    bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n    # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_1_id = add_bond!(model_geometry, bond_1)\n\n    # Define the second nearest-neighbor bond in a honeycomb lattice.\n    bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n    # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_2_id = add_bond!(model_geometry, bond_2)\n\n    # Define the third nearest-neighbor bond in a honeycomb lattice.\n    bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n    # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_3_id = add_bond!(model_geometry, bond_3)","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"Next we specify the Honeycomb tight-binding term in our Hamiltonian with the TightBindingModel type.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Set neartest-neighbor hopping amplitude to unity,\n    # setting the energy scale in the model.\n    t = 1.0\n\n    # Define the honeycomb tight-binding model.\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds        = [bond_1, bond_2, bond_3], # defines hopping\n        t_mean         = [t, t, t], # defines corresponding hopping amplitude\n        μ              = μ, # set chemical potential\n        ϵ_mean         = [0.0, 0.0] # set the (mean) on-site energy\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"Now we need to initialize the electron-phonon part of the Hamiltonian with the ElectronPhononModel type.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"Then we need to define and add two types phonon modes to the model, one for each orbital in the Honeycomb unit cell, using the PhononMode type and add_phonon_mode! function.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon_1 = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_1_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_1\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon_2 = PhononMode(orbital = 2, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_2_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_2\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"Now we need to define and add a local Holstein couplings to our model for each of the two phonon modes in each unit cell using the HolsteinCoupling type and add_holstein_coupling! function.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Define first local Holstein coupling for first phonon mode.\n    holstein_coupling_1 = HolsteinCoupling(\n        model_geometry = model_geometry,\n        phonon_mode = phonon_1_id,\n        # Couple the first phonon mode to first orbital in the unit cell.\n        bond = lu.Bond(orbitals = (1,1), displacement = [0, 0]),\n        α_mean = α\n    )\n\n    # Add the first local Holstein coupling definition to the model.\n    holstein_coupling_1_id = add_holstein_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        holstein_coupling = holstein_coupling_1,\n        model_geometry = model_geometry\n    )\n\n    # Define first local Holstein coupling for first phonon mode.\n    holstein_coupling_2 = HolsteinCoupling(\n        model_geometry = model_geometry,\n        phonon_mode = phonon_2_id,\n        # Couple the second phonon mode to second orbital in the unit cell.\n        bond = lu.Bond(orbitals = (2,2), displacement = [0, 0]),\n        α_mean = α\n    )\n\n    # Add the first local Holstein coupling definition to the model.\n    holstein_coupling_2_id = add_holstein_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        holstein_coupling = holstein_coupling_2,\n        model_geometry = model_geometry\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"Lastly, the model_summary function is used to write a model_summary.toml file, completely specifying the Hamiltonian that will be simulated.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Write model summary TOML file specifying Hamiltonian that will be simulated.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/#Initialize-model-parameters","page":"2a) Honeycomb Holstein Model","title":"Initialize model parameters","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"The next step is to initialize our model parameters given the size of our finite lattice. To clarify, both the TightBindingModel and ElectronPhononModel types are agnostic to the size of the lattice being simulated, defining the model in a translationally invariant way. As SmoQyDQMC.jl supports random disorder in the terms appearing in the Hamiltonian, it is necessary to initialize seperate parameter values for each unit cell in the lattice. For instance, we need to initialize a seperate number to represent the on-site energy for each orbital in our finite lattice.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/#Initialize-meuasurements","page":"2a) Honeycomb Holstein Model","title":"Initialize meuasurements","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"Having initialized both our model and the corresponding model parameters, the next step is to initialize the various measurements we want to make during our DQMC simulation. For more information refer to here.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [\n            # Measure green's functions for all pairs or orbitals.\n            (1, 1), (2, 2), (1, 2)\n        ]\n    )\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [\n            # Measure green's functions for all pairs of modes.\n            (1, 1), (2, 2), (1, 2)\n        ]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            (1, 1), (2, 2),\n        ]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            # Measure local s-wave pair susceptibility associated with\n            # each orbital in the unit cell.\n            (1, 1), (2, 2)\n        ]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            (1, 1), (2, 2)\n        ]\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"It is also useful to initialize more specialized composite correlation function measurements. Specifically, to detect the formation of charge-density wave order where the electrons preferentially localize on one of the two sub-lattices of the honeycomb lattice, it is useful to measure the correlation function","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"C_textcdw(mathbfrtau) = frac1L^2sum_mathbfi langle hatPhi^dagger_mathbfi+mathbfr(tau) hatPhi^phantomdagger_mathbfi(0) rangle","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"where","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"hatPhi_mathbfi(tau) = hatn_mathbfiA(tau) - hatn_mathbfiB(tau)","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"and hatn_mathbfigamma = (hatn_uparrowmathbfio + hatn_downarrowmathbfio) is the total electron number operator for orbital gamma in AB in unit cell mathbfi. It is then also useful to calculate the corresponding structure factor S_textcdw(mathbfqtau) and susceptibility chi_textcdw(mathbfq) This can all be easily calculated using the initialize_composite_correlation_measurement! function, as shown below.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Initialize CDW correlation measurement.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"cdw\",\n        correlation = \"density\",\n        ids = [1, 2],\n        coefficients = [1.0, -1.0],\n        time_displaced = false,\n        integrated = true\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"The initialize_measurement_directories can now be used used to initialize the various subdirectories in the data folder that the measurements will be written to. Again, for more information refer to the Simulation Output Overview page.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(simulation_info, measurement_container)","category":"page"},{"location":"tutorials/holstein_honeycomb/#Setup-DQMC-simulation","page":"2a) Honeycomb Holstein Model","title":"Setup DQMC simulation","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"This section of the code sets up the DQMC simulation by allocating the initializing the relevant types and arrays we will need in the simulation.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"This section of code is perhaps the most opaque and difficult to understand, and will be discussed in more detail once written. That said, you do not need to fully comprehend everything that goes on in this section as most of it is fairly boilerplate, and will not need to be changed much once written. This is true even if you want to modify this script to perform a DQMC simulation for a different Hamiltonian. For more information refer to here.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing EFA-HMC, reflection and swap updates below.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allcoate equal-time electron Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize electron Green's function matrx, also calculating the matrix determinant as the same time.\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize diagonostic parameters to asses numerical stability.\n    δG = zero(logdetG)\n    δθ = zero(sgndetG)","category":"page"},{"location":"tutorials/holstein_honeycomb/#holstein_square_efa-hmc_updates","page":"2a) Honeycomb Holstein Model","title":"Setup EFA-HMC Updates","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"Before we begin the simulation, we also want to initialize an instance of the EFAHMCUpdater type, which will be used to perform hybrid Monte Carlo (HMC) udpates to the phonon fields that use exact fourier acceleration (EFA) to further reduce autocorrelation times.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"The two main parameters that need to be specified are the time-step size Delta t and number of time-steps N_t performed in the HMC update, with the corresponding integrated trajectory time then equalling T_t = N_t cdot Delta t Note that the computational cost of an HMC update is linearly proportional to N_t while the acceptance rate is inversely proportional to Delta t","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"Previous studies have shown that a good place to start with the integrated trajectory time T_t is a quarter the period of the bare phonon mode, T_t approx frac14 left( frac2piOmega right) = pi(2Omega) It is also important to keep the acceptance rate for the HMC updates above sim 90 to help prevent numerical instabilities from occuring.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"Based on user experience, a good (conservative) starting place is to set the number of time-step to N_t approx 10 and then set the time-step size to Delta t approx pi(2Omega N_t) effectively setting the integrated trajectory time to T_t = pi(2Omega) Then, if the acceptance rate is too low you increase N_t which results in a reduction of Delta t Conversely, if the acceptance rate is very high (gtrsim 99  ) it can be useful to decrease N_t, thereby increasing Delta t as this will reduce the computational cost of performing an EFA-HMC update.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Number of fermionic time-steps in HMC update.\n    Nt = 10\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(2*Ω*Nt)\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb/#Thermalize-system","page":"2a) Honeycomb Holstein Model","title":"Thermalize system","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"The next section of code performs updates to thermalize the system prior to beginning measurements. In addition to EFA-HMC updates that will be performed using the EFAHMCUpdater type initialized above and the hmc_update! function below, we will also perform reflection and swap updates using the reflection_update! and swap_update! functions respectively.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Iterate over number of thermalization updates to perform.\n    for n in 1:N_therm\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n    end","category":"page"},{"location":"tutorials/holstein_honeycomb/#Make-measurements","page":"2a) Honeycomb Holstein Model","title":"Make measurements","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"In this next section of code we continue to sample the phonon fields as above, but will also begin making measurements as well. For more discussion on the overall structure of this part of the code, refer to here.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Reset diagonostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetG)\n    δθ = zero(sgndetG)\n\n    # Calculate the bin size.\n    bin_size = N_updates ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for update in 1:N_updates\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Make measurements.\n        (logdetG, sgndetG, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (electron_phonon_parameters,)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            update = update,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end","category":"page"},{"location":"tutorials/holstein_honeycomb/#Record-simulation-metadata","page":"2a) Honeycomb Holstein Model","title":"Record simulation metadata","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"At this point we are done sampling and taking measurements. Next, we want to calculate the final acceptance rate for the various types of udpates we performed, as well as write the simulation metadata to file, including the contents of the metadata dictionary.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_updates + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_updates + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_updates + N_therm)\n\n    # Record largest numerical error encountered during simulation.\n    metadata[\"dG\"] = δG\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)","category":"page"},{"location":"tutorials/holstein_honeycomb/#Post-process-results","page":"2a) Honeycomb Holstein Model","title":"Post-process results","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"In this final section of code we post-process the binned data. This includes calculating final estimates for the mean and error of all measured observables. The final statistics are written to CSV files using the function process_measurements function. For more information refer to here.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins, time_displaced = true)\n\n    # Merge binary files containing binned data into a single file.\n    compress_jld2_bins(folder = simulation_info.datafolder)\n\n    return nothing\nend # end of run_simulation function","category":"page"},{"location":"tutorials/holstein_honeycomb/#Execute-script","page":"2a) Honeycomb Holstein Model","title":"Execute script","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"DQMC simulations are typically run from the command line as jobs on a computing cluster. With this in mind, the following block of code only executes if the Julia script is run from the command line, also reading in additional command line arguments.","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Run the simulation.\n    run_simulation(;\n        sID       = parse(Int,     ARGS[1]), # Simulation ID.\n        Ω         = parse(Float64, ARGS[2]), # Phonon energy.\n        α         = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ         = parse(Float64, ARGS[4]), # Chemical potential.\n        L         = parse(Int,     ARGS[5]), # System size.\n        β         = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm   = parse(Int,     ARGS[7]), # Number of thermalization updates.\n        N_updates = parse(Int,     ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins    = parse(Int,     ARGS[9])  # Number of times bin-averaged measurements are written to file.\n    )\nend","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"For instance, the command","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"> julia holstein_honeycomb.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100","category":"page"},{"location":"tutorials/holstein_honeycomb/","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"runs a DQMC simulation of a Holstein model on a 3 times 3 unit cell (N = 2 \\times 3^2 = 18 site) honeycomb lattice at half-filling (mu = 0) and inverse temperature beta = 40. The phonon energy is set to Omega = 10 and the electron-phonon coupling is set to alpha = 15 In the DQMC simulation, 5,000 EFA-HMC, reflection and swap updates are performed to thermalize the system. Then an additional 10,000 such udpates are performed, after each of set of which measurements are made. During the simulation, bin-averaged measurements are written to file 100 times, with each bin of data containing the average of 10,000/100 = 100 sequential measurements.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"Download this example as a Julia script.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/#2b)-Honeycomb-Holstein-Model-with-MPI-Parallelization","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Import-packages","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Import packages","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"We now need to import the MPI.jl package as well.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"using SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf\nusing MPI","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/#Specify-simulation-parameters","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Specify simulation parameters","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"Here we have introduced the comm argument to the run_simulation function, which is a type exported by the MPI.jl package to facilitate communication and synchronization between the different MPI processes.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_updates, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-simulation","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize simulation","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"Now when initializing the SimulationInfo type, we also need to include the MPI process ID pID, which can be retrieved using the MPI.Comm_rank function.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"We also the initialize_datafolder function such that it takes the comm as the first argument. This ensures that all the MPI processes remained synchronized, and none try proceeding beyond this point until the data folder has been initialized.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_honeycomb_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-simulation-metadata","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize simulation metadata","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"    # Initialize random number generator\n    rng = Xoshiro(seed)\n\n    # Initialize additiona_info dictionary\n    metadata = Dict()\n\n    # Record simulation parameters.\n    metadata[\"N_therm\"] = N_therm\n    metadata[\"N_updates\"] = N_updates\n    metadata[\"N_bins\"] = N_bins\n    metadata[\"n_stab\"] = n_stab\n    metadata[\"dG_max\"] = δG_max\n    metadata[\"symmetric\"] = symmetric\n    metadata[\"checkerboard\"] = checkerboard\n    metadata[\"seed\"] = seed\n    metadata[\"hmc_acceptance_rate\"] = 0.0\n    metadata[\"reflection_acceptance_rate\"] = 0.0\n    metadata[\"swap_acceptance_rate\"] = 0.0","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-model","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize model","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"    # Define the unit cell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[3/2,√3/2],\n                        [3/2,-√3/2]],\n        basis_vecs   = [[0.,0.],\n                        [1.,0.]]\n    )\n\n    # Define finite lattice with periodic boundary conditions.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize model geometry.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the first nearest-neighbor bond in a honeycomb lattice.\n    bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n    # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_1_id = add_bond!(model_geometry, bond_1)\n\n    # Define the second nearest-neighbor bond in a honeycomb lattice.\n    bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n    # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_2_id = add_bond!(model_geometry, bond_2)\n\n    # Define the third nearest-neighbor bond in a honeycomb lattice.\n    bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n    # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_3_id = add_bond!(model_geometry, bond_3)\n\n    # Set neartest-neighbor hopping amplitude to unity,\n    # setting the energy scale in the model.\n    t = 1.0\n\n    # Define the honeycomb tight-binding model.\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds        = [bond_1, bond_2, bond_3], # defines hopping\n        t_mean         = [t, t, t], # defines corresponding hopping amplitude\n        μ              = μ, # set chemical potential\n        ϵ_mean         = [0.0, 0.0] # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon_1 = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_1_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_1\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon_2 = PhononMode(orbital = 2, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_2_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_2\n    )\n\n    # Define first local Holstein coupling for first phonon mode.\n    holstein_coupling_1 = HolsteinCoupling(\n        model_geometry = model_geometry,\n        phonon_mode = phonon_1_id,\n        # Couple the first phonon mode to first orbital in the unit cell.\n        bond = lu.Bond(orbitals = (1,1), displacement = [0, 0]),\n        α_mean = α\n    )\n\n    # Add the first local Holstein coupling definition to the model.\n    holstein_coupling_1_id = add_holstein_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        holstein_coupling = holstein_coupling_1,\n        model_geometry = model_geometry\n    )\n\n    # Define first local Holstein coupling for first phonon mode.\n    holstein_coupling_2 = HolsteinCoupling(\n        model_geometry = model_geometry,\n        phonon_mode = phonon_2_id,\n        # Couple the second phonon mode to second orbital in the unit cell.\n        bond = lu.Bond(orbitals = (2,2), displacement = [0, 0]),\n        α_mean = α\n    )\n\n    # Add the first local Holstein coupling definition to the model.\n    holstein_coupling_2_id = add_holstein_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        holstein_coupling = holstein_coupling_2,\n        model_geometry = model_geometry\n    )\n\n    # Write model summary TOML file specifying Hamiltonian that will be simulated.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-model-parameters","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize model parameters","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-meuasurements","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize meuasurements","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"The only change we need to make to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial is to add the comm as the first argument to the initialize_measurement_directories function. The ensures that not of the MPI processes proceed beyond that point until the directory structure has been initialized.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [\n            # Measure green's functions for all pairs or orbitals.\n            (1, 1), (2, 2), (1, 2)\n        ]\n    )\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [\n            # Measure green's functions for all pairs of modes.\n            (1, 1), (2, 2), (1, 2)\n        ]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            (1, 1), (2, 2),\n        ]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            # Measure local s-wave pair susceptibility associated with\n            # each orbital in the unit cell.\n            (1, 1), (2, 2)\n        ]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            (1, 1), (2, 2)\n        ]\n    )\n\n    # Initialize CDW correlation measurement.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"cdw\",\n        correlation = \"density\",\n        ids = [1, 2],\n        coefficients = [1.0, -1.0],\n        time_displaced = false,\n        integrated = true\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(comm, simulation_info, measurement_container)","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/#Setup-DQMC-simulation","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Setup DQMC simulation","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing EFA-HMC, reflection and swap updates below.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allcoate equal-time electron Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize electron Green's function matrx, also calculating the matrix determinant as the same time.\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize diagonostic parameters to asses numerical stability.\n    δG = zero(logdetG)\n    δθ = zero(sgndetG)","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/#Setup-EFA-HMC-Updates","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Setup EFA-HMC Updates","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"    # Number of fermionic time-steps in HMC update.\n    Nt = 10\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(2*Ω*Nt)\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt\n    )","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/#Thermalize-system","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Thermalize system","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"    # Iterate over number of thermalization updates to perform.\n    for update in 1:N_therm\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n    end","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/#Make-measurements","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Make measurements","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"    # Reset diagonostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetG)\n    δθ = zero(sgndetG)\n\n    # Calculate the bin size.\n    bin_size = N_updates ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for update in 1:N_updates\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Make measurements.\n        (logdetG, sgndetG, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (electron_phonon_parameters,)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            update = update,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/#Record-simulation-metadata","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Record simulation metadata","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_updates + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_updates + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_updates + N_therm)\n\n    # Record largest numerical error encountered during simulation.\n    metadata[\"dG\"] = δG\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/#Post-process-results","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Post-process results","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"The main change we need to make from the previos 2a) Honeycomb Holstein Model tutorial is to call the process_measurements, compute_correlation_ratio and compress_jld2_bins function such that the first argument is the comm object, thereby ensuring a parallelized version of each method is called.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(comm, simulation_info.datafolder, N_bins, time_displaced = true)\n\n    # Merge binary files containing binned data into a single file.\n    compress_jld2_bins(comm, folder = simulation_info.datafolder)\n\n    return nothing\nend # end of run_simulation function","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/#Execute-script","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Execute script","text":"","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"Here we first need to initialize MPI using the MPI.Init command. Then, we need to make sure to pass the comm = MPI.COMM_WORLD to the run_simulation function. At the very end of simulation it is good practice to run the MPI.Finalize() function even though it is typically not strictly required.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID       = parse(Int,     ARGS[1]), # Simulation ID.\n        Ω         = parse(Float64, ARGS[2]), # Phonon energy.\n        α         = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ         = parse(Float64, ARGS[4]), # Chemical potential.\n        L         = parse(Int,     ARGS[5]), # System size.\n        β         = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm   = parse(Int,     ARGS[7]), # Number of thermalization updates.\n        N_updates = parse(Int,     ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins    = parse(Int,     ARGS[9])  # Number of times bin-averaged measurements are written to file.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"Here is an example of what the command to run this script might look like:","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"mpiexecjl -n 16 julia holstein_honeycomb_mpi.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"This will 16 MPI processes, each running and independent simulation using a different random seed the the final results arrived at by averaging over all 16 walkers. Here mpiexecjl is the MPI exectuable that can be easily install using the directions found here in the MPI.jl documentation. However, you can substitute a different MPI executable here if one is already configured on your system.","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"Also, when submitting jobs via SLURM on a High-Performance Computing (HPC) cluster, if a default MPI exectuable is already configured on the system, as is frequently the case, then the script can likely be run inside the *.sh job file using the srun command:","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"srun julia holstein_honeycomb_mpi.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100","category":"page"},{"location":"tutorials/holstein_honeycomb_mpi/","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"The srun command should automatically detect the number of available cores requested by the job and run the script using the MPI executable with the appropriate number of processes.","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/holstein_zeeman_square/#Square-Holstein-Model-with-Zeeman-Splitting","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"","category":"section"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"In this example we write a script to simulate the Holstein model on a square lattice in an external applied magentic field perpendicular to the lattice, manifesting as a Zeeman splitting in the on-site energies between the spin up and down electrons. More generally, this examples demonstrates how to simulate models with explicit spin-dependence appearing in the Hamiltonian. The Hamiltonian is given by","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"beginalign*\nhatH =  -t sum_sigmalangle i j rangle (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n            + sum_sigmai(epsilon_sigma - mu) hatn_sigmai\n           + alpha sum_sigmai hatX_i (hatn_sigmai - tfrac12) \n           + sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)\nendalign*","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. The nearest-neighbor hopping amplitude is t and mu is the chemical potential. The Zeeman splitting is reflected in the on-site energies taking on spin-resolved values epsilon_pm = pm Deltaepsilon2. The strength of the repulsive Hubbard interaction is controlled by U0. hatX_i  (hatP_i) is the phonon position (momentum) operator for a dispersionless mode placed on site i with phonon frequency Omega and corresponding ion mass M. The stength of the Holstein electron-phonon is controlled by the parameter alpha.","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"> julia hubbard_holstein_square.jl 0 1.0 0.1 0.1 0.0 4.0 4 1000 5000 50","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"which simulates the Holstein model on a L = 4 square lattice, with Deltaepsilon = 10, Omega = 01, alpha = 01 and mu = 00 at an inverse temperature of beta = 40. In this simulation the Hubbard-Stranonovich and phonon fields are thermalized with N_burnin = 1000 rounds of updates, followed by N_udpates = 5000 rounds of updates with measurements being made. Bin averaged measurements are written to file N_bins = 50 during the simulation.","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing. Additionally, this script demonstrates how to calculate the extended s-wave and d-wave pair susceptibilities.","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running DQMC simulation\nfunction run_holstein_zeeman_square_simulation(sID, Δϵ, Ω, α, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_zeeman_square_ez%.2f_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Δϵ Ω α μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    bin_size = div(N_updates, N_bins)\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 4\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(2*Ω)/Nt\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"reflection_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n        \"Nt\" => Nt,\n        \"dt\" => Δt,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0, 0.0],\n                                            [0.0, 1.0]],\n                            basis_vecs   = [[0.0, 0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Get the number of orbitals in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond in the +x direction.\n    bond_px = lu.Bond(orbitals = (1,1), displacement = [1,0])\n\n    # Add nearest-neighbor bond in the +x direction.\n    bond_px_id = add_bond!(model_geometry, bond_px)\n\n    # Define the nearest-neighbor bond in the +y direction.\n    bond_py = lu.Bond(orbitals = (1,1), displacement = [0,1])\n\n    # Add the nearest-neighbor bond in the +y direction.\n    bond_py_id = add_bond!(model_geometry, bond_py)\n\n    # Here we define bonds to points in the negative x and y directions respectively.\n    # We do this in order to be able to measure all the pairing channels we need\n    # in order to reconstruct the extended s-wave and d-wave pair susceptibilities.\n\n    # Define the nearest-neighbor bond in the -x direction.\n    bond_nx = lu.Bond(orbitals = (1,1), displacement = [-1,0])\n\n    # Add nearest-neighbor bond in the -x direction.\n    bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n    # Define the nearest-neighbor bond in the -y direction.\n    bond_ny = lu.Bond(orbitals = (1,1), displacement = [0,-1])\n\n    # Add the nearest-neighbor bond in the -y direction.\n    bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n    # Next we define the various Hamiltonian parameters for spin-up and spin-down seperately.\n    # Here, only the on-site energy will be different between the two spin species, but in\n    # general any other parameter appearing in the tight-binding model could as well, including\n    # including the mircoscropic interaction constants.\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the spin-up tight-binding model\n    tight_binding_model_up = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_px, bond_py],\n        t_mean = [t, t],\n        μ = μ,\n        ϵ_mean = [+Δϵ]\n    )\n\n    # Define the spin-down tight-binding model\n    tight_binding_model_dn = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_px, bond_py],\n        t_mean = [t, t],\n        μ = μ,\n        ϵ_mean = [-Δϵ]\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model_up = tight_binding_model_up,\n        tight_binding_model_dn = tight_binding_model_up\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon\n    )\n\n    # Define a spin-up on-site Holstein coupling between the electron and the local dispersionless phonon mode.\n    holstein_coupling_up = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_id,\n    \tbond = lu.Bond(orbitals = (1,1), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Define a spin-down on-site Holstein coupling between the electron and the local dispersionless phonon mode.\n    holstein_coupling_dn = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_id,\n    \tbond = lu.Bond(orbitals = (1,1), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model.\n    holstein_coupling_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling_up = holstein_coupling_up,\n        holstein_coupling_dn = holstein_coupling_dn,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Write the model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model_up = tight_binding_model_up,\n        tight_binding_model_dn = tight_binding_model_dn,\n        interactions = (electron_phonon_model,)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n    # Initialize spin-up tight-binding parameters.\n    tight_binding_parameters_up = TightBindingParameters(\n        tight_binding_model = tight_binding_model_up,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize spin-down tight-binding parameters.\n    tight_binding_parameters_dn = TightBindingParameters(\n        tight_binding_model = tight_binding_model_dn,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters_up = tight_binding_parameters_up,\n        tight_binding_parameters_dn = tight_binding_parameters_dn,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model_up, tight_binding_model_up)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Now we define the various correlation function measurements we would like to make.\n    # Note that relative to the other examples, we include spin-resolved correlation\n    # measurements as the underlying model being simulated is spin-dependent.\n\n    # Initialize the single-particle spin-up electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens_up\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the single-particle spin-down electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens_dn\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize total density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize spin-up density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density_upup\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize spin-down density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density_dndn\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize mixed-spin density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density_updn\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the total current correlation function measurement\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"current\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), # hopping ID pair for x-direction hopping\n                 (2, 2)] # hopping ID pair for y-direction hopping\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters_up, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters_dn, β = β, Δτ = Δτ)\n\n    # Initialize the fermion path integral type with respect to electron-phonon interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, electron_phonon_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_up_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_up)\n    fermion_greens_calculator_dn_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_dn)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = Gup, Nt = Nt, Δt = Δt\n    )\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a reflection update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, rng = rng, phonon_types = (phonon_id,)\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = hmc_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters,\n            hmc_updater,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn,\n            δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a reflection update.\n            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn,\n                electron_phonon_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n                Bup = Bup, Bdn = Bdn, rng = rng, phonon_types = (phonon_id,)\n            )\n\n            # Record whether the reflection update was accepted or rejected.\n            additional_info[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = hmc_update!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn,\n                electron_phonon_parameters,\n                hmc_updater,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n                Bup = Bup, Bdn = Bdn,\n                δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry,\n                tight_binding_parameters_up = tight_binding_parameters_up,\n                tight_binding_parameters_dn = tight_binding_parameters_dn,\n                coupling_parameters = (electron_phonon_parameters,)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rates.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n    additional_info[\"reflection_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    return nothing\nend\n\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Δϵ = parse(Float64, ARGS[2])\n    Ω = parse(Float64, ARGS[3])\n    α = parse(Float64, ARGS[4])\n    μ = parse(Float64, ARGS[5])\n    β = parse(Float64, ARGS[6])\n    L = parse(Int, ARGS[7])\n    N_burnin = parse(Int, ARGS[8])\n    N_updates = parse(Int, ARGS[9])\n    N_bins = parse(Int, ARGS[10])\n\n    # Run the simulation.\n    run_holstein_zeeman_square_simulation(sID, Δϵ, Ω, α, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/hubbard_honeycomb/#Honeycomb-Hubbard-model","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"","category":"section"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"In this script we simulate the Hubbard model on a Honeycomb lattice, with a Hamiltonian given by","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"beginalign*\nhatH =  -t sum_sigmalangle i j rangle (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n            -mu sum_sigmaihatn_sigmai\n           + U sum_i (hatn_uparrowi-tfrac12)(hatn_downarrowi-tfrac12)\nendalign*","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. The nearest-neighbor hopping amplitude is t and mu is the chemical potential. The strength of the repulsive Hubbard interaction is controlled by U0.","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"> julia hubbard_honeycomb.jl 0 6.0 0.0 4.0 3 2000 10000 50","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"This simulates a half-filled (mu = 00) Hubabrd model on a 3 times 3 unit cell honeycomb lattice, with a Hubbard interaction of U = 60, at inverse temperature beta = 40.","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running DQMC simulation.\nfunction run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_honeycomb_U%.2f_mu%.2f_L%d_b%.2f\" U μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[3/2,√3/2],\n                        [3/2,-√3/2]],\n        basis_vecs   = [[0.,0.],\n                        [1.,0.]]\n    )\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the first nearest-neighbor bond in a honeycomb lattice.\n    bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n    # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_1_id = add_bond!(model_geometry, bond_1)\n\n    # Define the second nearest-neighbor bond in a honeycomb lattice.\n    bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n    # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_2_id = add_bond!(model_geometry, bond_2)\n\n    # Define the third nearest-neighbor bond in a honeycomb lattice.\n    bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n    # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_3_id = add_bond!(model_geometry, bond_3)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds        = [bond_1, bond_2, bond_3], # defines hopping\n        t_mean         = [t, t, t], # defines corresponding hopping amplitude\n        μ              = μ, # set chemical potential\n        ϵ_mean         = [0.0, 0.0] # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted   = false, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n        U_orbital = [1, 2],\n        U_mean    = [U, U],\n    )\n\n    # Write the model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1), (2, 2), (1, 2)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (1, 2)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (1, 2)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (1, 2)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters, hubbard_ising_parameters)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    μ = parse(Float64, ARGS[3])\n    β = parse(Float64, ARGS[4])\n    L = parse(Int, ARGS[5])\n    N_burnin = parse(Int, ARGS[6])\n    N_updates = parse(Int, ARGS[7])\n    N_bins = parse(Int, ARGS[8])\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Hubbard Chain with Checkpointing","title":"Hubbard Chain with Checkpointing","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/hubbard_chain_checkpoint/#Hubbard-Chain-with-Checkpointing","page":"Hubbard Chain with Checkpointing","title":"Hubbard Chain with Checkpointing","text":"","category":"section"},{"location":"examples/hubbard_chain_checkpoint/","page":"Hubbard Chain with Checkpointing","title":"Hubbard Chain with Checkpointing","text":"In this script we take the script from the previous example and introduce checkpointing, so that if the simulation is killed at some point it can resumed from the previous checkpoint. It is important to note that how checkpointing is introduced in this script is not unique, and other checkpointing schemes could be implemented in a script. For instance, in this script the checkpointing is implemented such that the number of checkpoints written to file during the simulation is a fixed number at the start of the simulation. It is possible, though slightly more involved, to implement a checkpointing scheme that instead writes checkpoints to file based on the wall clock and the amount of time that has passed since the previous checkpoint was written to file.","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Hubbard Chain with Checkpointing","title":"Hubbard Chain with Checkpointing","text":"To write the checkpoints we use the package JLD2, which allows the checkpoint files to be written to file as binary files that are HDF5 compatible. In this script, following the thermalziation/burnin updates, a checkpoint is written to file whenever measurements are written to file, so a total of N_bins checkpoints are written following the initial thermalization/burnin period of the simulation. During the thermalization/burnin updates, checkpoints are written with the same frequency as they are going to be once measurements start getting made.","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Hubbard Chain with Checkpointing","title":"Hubbard Chain with Checkpointing","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Hubbard Chain with Checkpointing","title":"Hubbard Chain with Checkpointing","text":"using LinearAlgebra\nusing Random\nusing Printf\nusing MPI\n\n# Import JLD2 package for write checkpoints during the simulation\n# to file as a binary file.\nusing JLD2\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# initialize MPI\nMPI.Init()\n\n# Define top-level function for running DQMC simulation\nfunction run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_chain_U%.2f_mu%.2f_L%d_b%.2f\" U μ L β\n\n    # Get the MPI comm rank, which fixes the process ID (pID).\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID,\n        pID = pID\n    )\n\n    # Define checkpoint filename.\n    # We implement three checkpoint files, an old, current and new one,\n    # that get cycled through to ensure a checkpoint file always exists in the off\n    # chance that the simulation is killed while a checkpoint is getting written to file.\n    # Additionally, each simulation that is running in parallel with MPI will have their own\n    # checkpoints written to file.\n    datafolder = simulation_info.datafolder\n    sID        = simulation_info.sID\n    pID        = simulation_info.pID\n    checkpoint_name_old          = @sprintf \"checkpoint_sID%d_pID%d_old.jld2\" sID pID\n    checkpoint_filename_old      = joinpath(datafolder, checkpoint_name_old)\n    checkpoint_name_current      = @sprintf \"checkpoint_sID%d_pID%d_current.jld2\" sID pID\n    checkpoint_filename_current  = joinpath(datafolder, checkpoint_name_current)\n    checkpoint_name_new          = @sprintf \"checkpoint_sID%d_pID%d_new.jld2\" sID pID\n    checkpoint_filename_new      = joinpath(datafolder, checkpoint_name_new)\n\n    ######################################################\n    ### DEFINE SOME RELEVANT DQMC SIMULATION PARAMETERS ##\n    ######################################################\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = 0.0\n    δθ = 0.0\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted = false, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n        U_orbital = [1],\n        U_mean = [U],\n    )\n\n    #######################################################\n    ### BRANCHING BEHAVIOR BASED ON WHETHER STARTING NEW ##\n    ### SIMULAIOTN OR RESUMING PREVIOUS SIMULATION.      ##\n    #######################################################\n\n    # Synchronize all the MPI processes.\n    MPI.Barrier(comm)\n\n    # If starting a new simulation.\n    if !simulation_info.resuming\n\n        # Initialize a random number generator that will be used throughout the simulation.\n        seed = abs(rand(Int))\n        rng = Xoshiro(seed)\n\n        # Initialize the directory the data will be written to.\n        initialize_datafolder(simulation_info)\n\n        # Write the model summary to file.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (hubbard_model,)\n        )\n\n        # Calculate the bins size.\n        bin_size = div(N_updates, N_bins)\n\n        # Initialize a dictionary to store additional information about the simulation.\n        additional_info = Dict(\n            \"dG_max\" => δG_max,\n            \"N_burnin\" => N_burnin,\n            \"N_updates\" => N_updates,\n            \"N_bins\" => N_bins,\n            \"bin_size\" => bin_size,\n            \"local_acceptance_rate\" => 0.0,\n            \"reflection_acceptance_rate\" => 0.0,\n            \"n_stab_init\" => n_stab,\n            \"symmetric\" => symmetric,\n            \"checkerboard\" => checkerboard,\n            \"seed\" => seed,\n        )\n\n        #########################################\n        ### INITIALIZE FINITE MODEL PARAMETERS ##\n        #########################################\n\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize Hubbard interaction parameters.\n        hubbard_parameters = HubbardParameters(\n            model_geometry = model_geometry,\n            hubbard_model = hubbard_model,\n            rng = rng\n        )\n\n        # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n        # corresponding HS fields that will be sampled in DQMC simulation.\n        hubbard_ising_parameters = HubbardIsingHSParameters(\n            β = β, Δτ = Δτ,\n            hubbard_parameters = hubbard_parameters,\n            rng = rng\n        )\n\n        ##############################\n        ### INITIALIZE MEASUREMENTS ##\n        ##############################\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the Hubbard interaction related measurements.\n        initialize_measurements!(measurement_container, hubbard_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the sub-directories to which the various measurements will be written.\n        initialize_measurement_directories(\n            simulation_info = simulation_info,\n            measurement_container = measurement_container\n        )\n\n        #############################\n        ### WRITE FIRST CHECKPOINT ##\n        #############################\n\n        # Calculate the bin size.\n        bin_size = div(N_updates, N_bins)\n\n        # Calculate the number of thermalization/burnin bins.\n        # This determines the number times the simulations checkpoints\n        # during the initial thermalziation/burnin period.\n        N_bins_burnin = div(N_burnin, bin_size)\n\n        # Initialize variable to keep track of the current burnin bin.\n        n_bin_burnin = 1\n\n        # Initialize variable to keep track of the current bin.\n        n_bin = 1\n\n        # Write an initial checkpoint to file.\n        JLD2.jldsave(\n            checkpoint_filename_current;\n            rng, additional_info,\n            N_burnin, N_updates, N_bins,\n            bin_size, N_bins_burnin, n_bin_burnin, n_bin,\n            measurement_container,\n            model_geometry,\n            tight_binding_parameters,\n            hubbard_parameters,\n            dG = δG, dtheta = δθ, n_stab = n_stab\n        )\n\n    # If resuming simulation from previous checkpoint.\n    else\n\n        # Initialize checkpoint to nothing before it is loaded.\n        checkpoint = nothing\n\n        # Try loading in the new checkpoint.\n        if isfile(checkpoint_filename_new)\n            try\n                # Load the new checkpoint.\n                checkpoint = JLD2.load(checkpoint_filename_new)\n            catch\n                nothing\n            end\n        end\n\n        # Try loading in the current checkpoint.\n        if isfile(checkpoint_filename_current) && isnothing(checkpoint)\n            try\n                # Load the current checkpoint.\n                checkpoint = JLD2.load(checkpoint_filename_current)\n            catch\n                nothing\n            end\n        end\n\n        # Try loading in the current checkpoint.\n        if isfile(checkpoint_filename_old) && isnothing(checkpoint)\n            try\n                # Load the old checkpoint.\n                checkpoint = JLD2.load(checkpoint_filename_old)\n            catch\n                nothing\n            end\n        end\n\n        # Throw an error if no checkpoint was succesfully loaded.\n        if isnothing(checkpoint)\n            error(\"Failed to load checkpoint successfully!\")\n        end\n\n        # Unpack the contents of the checkpoint.\n        rng                      = checkpoint[\"rng\"]\n        additional_info          = checkpoint[\"additional_info\"]\n        N_burnin                 = checkpoint[\"N_burnin\"]\n        N_updates                = checkpoint[\"N_updates\"]\n        N_bins                   = checkpoint[\"N_bins\"]\n        bin_size                 = checkpoint[\"bin_size\"]\n        N_bins_burnin            = checkpoint[\"N_bins_burnin\"]\n        n_bin_burnin             = checkpoint[\"n_bin_burnin\"]\n        n_bin                    = checkpoint[\"n_bin\"]\n        model_geometry           = checkpoint[\"model_geometry\"]\n        measurement_container    = checkpoint[\"measurement_container\"]\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        hubbard_parameters       = checkpoint[\"hubbard_parameters\"]\n        hubbard_ising_parameters = checkpoint[\"hubbard_ising_parameters\"]\n        δG                       = checkpoint[\"dG\"]\n        δθ                       = checkpoint[\"dtheta\"]\n        n_stab                   = checkpoint[\"n_stab\"]\n    end\n\n    # Synchronize all the MPI processes.\n    MPI.Barrier(comm)\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization bins.\n    for bin in n_bin_burnin:N_bins_burnin\n\n        # Iterate over updates in current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n        end\n\n        # Write the new checkpoint to file.\n        JLD2.jldsave(\n            checkpoint_filename_new;\n            rng, additional_info,\n            N_burnin, N_updates, N_bins,\n            bin_size, N_bins_burnin,\n            n_bin_burnin = bin + 1,\n            n_bin = 1,\n            measurement_container,\n            model_geometry,\n            tight_binding_parameters,\n            hubbard_parameters,\n            hubbard_ising_parameters,\n            dG = δG, dtheta = δθ, n_stab = n_stab\n        )\n        # Make the current checkpoint the old checkpoint.\n        mv(checkpoint_filename_current, checkpoint_filename_old, force = true)\n        # Make the new checkpoint the current checkpoint.\n        mv(checkpoint_filename_new, checkpoint_filename_current, force = true)\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in n_bin:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters, hubbard_ising_parameters)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write the new checkpoint to file.\n        JLD2.jldsave(\n            checkpoint_filename_new;\n            rng, additional_info,\n            N_burnin, N_updates, N_bins,\n            bin_size, N_bins_burnin,\n            n_bin_burnin = N_bins_burnin+1,\n            n_bin = bin + 1,\n            measurement_container,\n            model_geometry,\n            tight_binding_parameters,\n            hubbard_parameters,\n            hubbard_ising_parameters,\n            dG = δG, dtheta = δθ, n_stab = n_stab\n        )\n        # Make the current checkpoint the old checkpoint.\n        mv(checkpoint_filename_current, checkpoint_filename_old, force = true)\n        # Make the new checkpoint the current checkpoint.\n        mv(checkpoint_filename_new, checkpoint_filename_current, force = true)\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Synchronize all the MPI processes.\n    MPI.Barrier(comm)\n\n    # Have the primary MPI process calculate the final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    if iszero(simulation_info.pID)\n        process_measurements(simulation_info.datafolder, N_bins)\n    end\n\n    return nothing\nend\n\n\n# Only excute if script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    μ = parse(Float64, ARGS[3])\n    β = parse(Float64, ARGS[4])\n    L = parse(Int, ARGS[5])\n    N_burnin = parse(Int, ARGS[6])\n    N_updates = parse(Int, ARGS[7])\n    N_bins = parse(Int, ARGS[8])\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins)\n\n    # Finalize MPI (not strictly required).\n    MPI.Finalize()\nend","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/ossh_chain/#Optical-Su-Schrieffer-Heeger-Chain","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"","category":"section"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"In this example we simulate the optical Su-Schrieffer-Heeger (OSSH) model on a 1D chain, with a Hamiltonian given by","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"beginalign*\nhatH = sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)\n          - sum_sigmai t-alpha(hatX_i+1-hatX_i) (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n          - mu sum_sigmai hatn_sigmai\nendalign*","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"in which the fluctuations in the position of dispersionless phonon modes placed on each site in the lattice modulate the hopping amplitude between neighboring sites. In the above expression hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creation (annihilation) operator a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on site i is given by hatX_i  (hatP_i), where Omega and M are the phonon frequency and associated ion mass respectively. Lastly, the strength of the electron-phonon coupling is controlled by the parameter alpha.","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"> julia ossh_chain.jl 0 1.0 0.5 0.0 4.0 16 1000 5000 20","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"which simulates an L=16 chain with Omega = 10, alpha = 05 at half-filling (mu = 00) and an inverse temperature of beta = 40. In this example N_burnin = 1000 HMC thermalization updates are performed, followed an additional N_updates = 5000 HMC updates, after each of which measurements are made. Bin averaged measurements are then written to file N_bins = 20 during the simulation.","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running the DQMC simulation.\nfunction run_ossh_chain_simulation(sID, Ω, α, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"ossh_chain_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.05\n\n    # For performance reasons it is important that we represent the exponentiated hopping\n    # matrix with the checkerboard approximation when simulating an SSH model, where the\n    # phonons modulate the hopping amplitudes. Without the checkerboard approximation,\n    # each time a phonon field is updated the kinetic energy matrix would need to be diagonalized\n    # to calculate its exponential, which is very computationally expensive.\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = true\n\n    # As we are using the checkboard approximation, using a symmetric definition for the propagator\n    # matrices is important as it significantly improves the accuracy of approximation.\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = true\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bin size.\n    bin_size = div(N_updates, N_bins)\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 4\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(2*Ω)/Nt\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"swap_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"Nt\" => Nt,\n        \"dt\" => Δt,\n        \"seed\" => seed,\n    )\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Get the number of sites in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add optical ssh phonon to electron-phonon model.\n    phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon\n    )\n\n    # Define optical SSH coupling.\n    # Defines total effective hopping amplitude given by t_eff = t-α⋅(Xᵢ₊₁-Xᵢ).\n    ossh_coupling = SSHCoupling(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        phonon_modes = (phonon_id, phonon_id),\n        bond = bond,\n        α_mean = α\n    )\n\n    # Add optical SSH coupling to the electron-phonon model.\n    ossh_coupling_id = add_ssh_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        ssh_coupling = ossh_coupling,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Write a model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )\n\n    #################################################\n    ### INITIALIZE FINITE LATTICE MODEL PARAMETERS ##\n    #################################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the measurement container.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the measurements associated with the tight-binding model.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the measurements associated with the electron-phonon model.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize time-displaced Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize time-displaced phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(phonon_id, phonon_id)]\n    )\n\n    # Initialize the density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurements.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (bond_id, bond_id)]\n    )\n\n    # Initialize the bond correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"bond\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(bond_id, bond_id)]\n    )\n\n    # Initialize current-current correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"current\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)] # Hopping ID pair.\n    )\n\n    # Initialize the sub-directories the various measurements will be written to.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Allocate and initialize propagators for each imaginary time slice.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize fermion greens calculator.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize equal-time Green's function matrix\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt\n    )\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a swap update.\n        # In a swap update, to phonon modes are randomly selected in the lattice\n        # and their phonon fields are exchanged for all imaginary time slices.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng, phonon_type_pairs = ((phonon_id, phonon_id),)\n        )\n\n        # Record whether the swap update was accepted or rejected.\n        additional_info[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a swap update..\n            (accepted, logdetG, sgndetG) = swap_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, rng = rng, phonon_type_pairs = ((phonon_id, phonon_id),)\n            )\n\n            # Record whether the swap update was accepted or rejected.\n            additional_info[\"swap_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Make measurements.\n            (logdetG, sgndetG, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (electron_phonon_parameters,)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate HMC acceptance rate.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Calculate swap update acceptance rate.\n    additional_info[\"swap_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ω = parse(Float64, ARGS[2])\n    α = parse(Float64, ARGS[3])\n    μ = parse(Float64, ARGS[4])\n    β = parse(Float64, ARGS[5])\n    L = parse(Int, ARGS[6])\n    N_burnin = parse(Int, ARGS[7])\n    N_updates = parse(Int, ARGS[8])\n    N_bins = parse(Int, ARGS[9])\n\n    # Run the simulation.\n    run_ossh_chain_simulation(sID, Ω, α, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/hubbard_holstein_square/#Square-Hubbard-Holstein-Model","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"","category":"section"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"In this example we write a script to simulate the Hubbard-Holstein model on a square lattice, with a Hamiltonian given by","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"beginalign*\nhatH =  -t sum_sigmalangle i j rangle (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n            -mu sum_sigmaihatn_sigmai\n           + U sum_i (hatn_uparrowi-tfrac12)(hatn_downarrowi-tfrac12)\n            + alpha sum_sigmai hatX_i (hatn_sigmai - tfrac12) \n           + sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)\nendalign*","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. The nearest-neighbor hopping amplitude is t and mu is the chemical potential. The strength of the repulsive Hubbard interaction is controlled by U0. hatX_i  (hatP_i) is the phonon position (momentum) operator for a dispersionless mode placed on site i with phonon frequency Omega and corresponding ion mass M. The stength of the Holstein electron-phonon is controlled by the parameter alpha.","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"> julia hubbard_holstein_square.jl 0 6.0 0.1 0.1 0.0 4.0 4 1000 5000 50","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"which simulates the Hubbard-Holstein model on a L = 4 square lattice, with U = 60, Omega = 01, alpha = 01 and mu = 00 at an inverse temperature of beta = 40. In this simulation the Hubbard-Stranonovich and phonon fields are thermalized with N_burnin = 1000 rounds of updates, followed by N_udpates = 5000 rounds of updates with measurements being made. Bin averaged measurements are written to file N_bins = 50 during the simulation.","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing. Additionally, this script demonstrates how to calculate the extended s-wave and d-wave pair susceptibilities.","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running DQMC simulation\nfunction run_hubbard_holstein_square_simulation(sID, U, Ω, α, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_holstein_square_U%.2f_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" U Ω α μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    bin_size = div(N_updates, N_bins)\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 4\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(2*Ω)/Nt\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"reflection_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n        \"Nt\" => Nt,\n        \"dt\" => Δt,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0, 0.0],\n                                            [0.0, 1.0]],\n                            basis_vecs   = [[0.0, 0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Get the number of orbitals in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond in the +x direction.\n    bond_px = lu.Bond(orbitals = (1,1), displacement = [1,0])\n\n    # Add nearest-neighbor bond in the +x direction.\n    bond_px_id = add_bond!(model_geometry, bond_px)\n\n    # Define the nearest-neighbor bond in the +y direction.\n    bond_py = lu.Bond(orbitals = (1,1), displacement = [0,1])\n\n    # Add the nearest-neighbor bond in the +y direction.\n    bond_py_id = add_bond!(model_geometry, bond_py)\n\n    # Here we define bonds to points in the negative x and y directions respectively.\n    # We do this in order to be able to measure all the pairing channels we need\n    # in order to reconstruct the extended s-wave and d-wave pair susceptibilities.\n\n    # Define the nearest-neighbor bond in the -x direction.\n    bond_nx = lu.Bond(orbitals = (1,1), displacement = [-1,0])\n\n    # Add nearest-neighbor bond in the -x direction.\n    bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n    # Define the nearest-neighbor bond in the -y direction.\n    bond_ny = lu.Bond(orbitals = (1,1), displacement = [0,-1])\n\n    # Add the nearest-neighbor bond in the -y direction.\n    bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_px, bond_py], # defines hopping\n        t_mean = [t, t],            # defines corresponding hopping amplitude\n        μ = μ,                      # set chemical potential\n        ϵ_mean = [0.]               # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted = false,\n        U_orbital = [1],\n        U_mean = [U],\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon\n    )\n\n    # Define a on-site Holstein coupling between the electron and the local dispersionless phonon mode.\n    holstein_coupling = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_id,\n    \tbond = lu.Bond(orbitals = (1,1), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model.\n    holstein_coupling_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Write the model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model, electron_phonon_model)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # measure equal-times green's function for all τ\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens_tautau\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Measure all possible combinations of bond pairing channels\n    # for the bonds we have defined. We will need each of these\n    # pairs channels measured in order to reconstruct the extended\n    # s-wave and d-wave pair susceptibilities.\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1),\n                 (bond_px_id, bond_px_id), (bond_px_id, bond_nx_id),\n                 (bond_nx_id, bond_px_id), (bond_nx_id, bond_nx_id),\n                 (bond_py_id, bond_py_id), (bond_py_id, bond_ny_id),\n                 (bond_ny_id, bond_py_id), (bond_ny_id, bond_ny_id),\n                 (bond_px_id, bond_py_id), (bond_px_id, bond_ny_id),\n                 (bond_nx_id, bond_py_id), (bond_nx_id, bond_ny_id),\n                 (bond_py_id, bond_px_id), (bond_py_id, bond_nx_id),\n                 (bond_ny_id, bond_px_id), (bond_ny_id, bond_nx_id)]\n    )\n\n    # Initialize the current correlation function measurement\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"current\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), # hopping ID pair for x-direction hopping\n                 (2, 2)] # hopping ID pair for y-direction hopping\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the fermion path integral type with respect to electron-phonon interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, electron_phonon_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_up_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_up)\n    fermion_greens_calculator_dn_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_dn)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = Gup, Nt = Nt, Δt = Δt\n    )\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a reflection update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, rng = rng, phonon_types = (phonon_id,)\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = hmc_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters,\n            hmc_updater,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn,\n            δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a reflection update.\n            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn,\n                electron_phonon_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n                Bup = Bup, Bdn = Bdn, rng = rng, phonon_types = (phonon_id,)\n            )\n\n            # Record whether the reflection update was accepted or rejected.\n            additional_info[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = hmc_update!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn,\n                electron_phonon_parameters,\n                hmc_updater,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n                Bup = Bup, Bdn = Bdn,\n                δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (\n                    hubbard_parameters,\n                    hubbard_ising_parameters,\n                    electron_phonon_parameters\n                )\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rates.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n    additional_info[\"reflection_acceptance_rate\"] /= (N_updates + N_burnin)\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    # Here we use the `composite_correlation_stats` to reconstruct the extended\n    # s-wave and d-wave pair susceptibilities. We also subract off the background\n    # signal associated with the zero-momentum transfer charge susceptibility.\n    # Behind the scenes, uses the binning\n    # method to calculate the error bars by calculating both susceptibilities for\n    # each bin of data that was written to file.\n\n    # Measure the extended s-wave pair susceptibility.\n    Pes, ΔPes = composite_correlation_stat(\n        folder = simulation_info.datafolder,\n        correlations = [\"pair\", \"pair\", \"pair\", \"pair\",\n                        \"pair\", \"pair\", \"pair\", \"pair\",\n                        \"pair\", \"pair\", \"pair\", \"pair\",\n                        \"pair\", \"pair\", \"pair\", \"pair\"],\n        spaces = [\"momentum\", \"momentum\", \"momentum\", \"momentum\",\n                  \"momentum\", \"momentum\", \"momentum\", \"momentum\",\n                  \"momentum\", \"momentum\", \"momentum\", \"momentum\",\n                  \"momentum\", \"momentum\", \"momentum\", \"momentum\"],\n        types = [\"integrated\", \"integrated\", \"integrated\", \"integrated\",\n                 \"integrated\", \"integrated\", \"integrated\", \"integrated\",\n                 \"integrated\", \"integrated\", \"integrated\", \"integrated\",\n                 \"integrated\", \"integrated\", \"integrated\", \"integrated\"],\n        ids = [(bond_px_id, bond_px_id), (bond_nx_id, bond_nx_id), (bond_px_id, bond_nx_id), (bond_nx_id, bond_px_id),\n               (bond_py_id, bond_py_id), (bond_ny_id, bond_ny_id), (bond_py_id, bond_ny_id), (bond_ny_id, bond_py_id),\n               (bond_px_id, bond_py_id), (bond_nx_id, bond_ny_id), (bond_px_id, bond_ny_id), (bond_nx_id, bond_py_id),\n               (bond_py_id, bond_px_id), (bond_ny_id, bond_nx_id), (bond_py_id, bond_nx_id), (bond_ny_id, bond_px_id)],\n        locs = [(0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0)],\n        num_bins = N_bins,\n        f = (P_px_px, P_nx_nx, P_px_nx, P_nx_px,\n             P_py_py, P_ny_ny, P_py_ny, P_ny_py,\n             P_px_py, P_nx_ny, P_px_ny, P_nx_py,\n             P_py_px, P_ny_nx, P_py_nx, P_ny_px) -> (P_px_px + P_nx_nx + P_px_nx + P_nx_px +\n                                                     P_py_py + P_ny_ny + P_py_ny + P_ny_py +\n                                                     P_px_py + P_nx_ny + P_px_ny + P_nx_py +\n                                                     P_py_px + P_ny_nx + P_py_nx + P_ny_px)/4\n    )\n    additional_info[\"P_ext-s_avg\"] = Pes\n    additional_info[\"P_ext-s_err\"] = ΔPes\n\n    # Measure the d-wave pair susceptibility.\n    Pd, ΔPd = composite_correlation_stat(\n        folder = simulation_info.datafolder,\n        correlations = [\"pair\", \"pair\", \"pair\", \"pair\",\n                        \"pair\", \"pair\", \"pair\", \"pair\",\n                        \"pair\", \"pair\", \"pair\", \"pair\",\n                        \"pair\", \"pair\", \"pair\", \"pair\"],\n        spaces = [\"momentum\", \"momentum\", \"momentum\", \"momentum\",\n                  \"momentum\", \"momentum\", \"momentum\", \"momentum\",\n                  \"momentum\", \"momentum\", \"momentum\", \"momentum\",\n                  \"momentum\", \"momentum\", \"momentum\", \"momentum\"],\n        types = [\"integrated\", \"integrated\", \"integrated\", \"integrated\",\n                 \"integrated\", \"integrated\", \"integrated\", \"integrated\",\n                 \"integrated\", \"integrated\", \"integrated\", \"integrated\",\n                 \"integrated\", \"integrated\", \"integrated\", \"integrated\"],\n        ids = [(bond_px_id, bond_px_id), (bond_nx_id, bond_nx_id), (bond_px_id, bond_nx_id), (bond_nx_id, bond_px_id),\n               (bond_py_id, bond_py_id), (bond_ny_id, bond_ny_id), (bond_py_id, bond_ny_id), (bond_ny_id, bond_py_id),\n               (bond_px_id, bond_py_id), (bond_nx_id, bond_ny_id), (bond_px_id, bond_ny_id), (bond_nx_id, bond_py_id),\n               (bond_py_id, bond_px_id), (bond_ny_id, bond_nx_id), (bond_py_id, bond_nx_id), (bond_ny_id, bond_px_id)],\n        locs = [(0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0)],\n        num_bins = N_bins,\n        f = (P_px_px, P_nx_nx, P_px_nx, P_nx_px,\n             P_py_py, P_ny_ny, P_py_ny, P_ny_py,\n             P_px_py, P_nx_ny, P_px_ny, P_nx_py,\n             P_py_px, P_ny_nx, P_py_nx, P_ny_px) -> (P_px_px + P_nx_nx + P_px_nx + P_nx_px +\n                                                     P_py_py + P_ny_ny + P_py_ny + P_ny_py -\n                                                     P_px_py - P_nx_ny - P_px_ny - P_nx_py -\n                                                     P_py_px - P_ny_nx - P_py_nx - P_ny_px)/4\n    )\n    additional_info[\"P_d_avg\"] = Pd\n    additional_info[\"P_d_err\"] = ΔPd\n\n    # Calculate the charge susceptibility for zero momentum transfer (q=0)\n    # with the net charge background signal subtracted off.\n\n    # Calculate the Cu-Cu charge susceptibility at q=0 with the background signal removed.\n    C0, ΔC0 = composite_correlation_stat(\n        folder = simulation_info.datafolder,\n        correlations = [\"density\", \"greens_tautau\", \"greens\"],\n        spaces = [\"momentum\", \"position\", \"position\"],\n        types = [\"integrated\", \"integrated\", \"time-displaced\"],\n        ids = [(1,1), (1,1), (1,1)],\n        locs = [(0,0), (0,0), (0,0)],\n        Δls = [0, 0, 0],\n        num_bins = N_bins,\n        f = (x, y, z) -> x - (L^2)*4*(β-y)*(1-z)\n    )\n    additional_info[\"Chi_C_q0_avg\"] = C0\n    additional_info[\"Chi_C_q0_err\"] = ΔC0\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    return nothing\nend\n\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    Ω = parse(Float64, ARGS[3])\n    α = parse(Float64, ARGS[4])\n    μ = parse(Float64, ARGS[5])\n    β = parse(Float64, ARGS[6])\n    L = parse(Int, ARGS[7])\n    N_burnin = parse(Int, ARGS[8])\n    N_updates = parse(Int, ARGS[9])\n    N_bins = parse(Int, ARGS[10])\n\n    # Run the simulation.\n    run_hubbard_holstein_square_simulation(sID, U, Ω, α, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"hamiltonian/#Supported-Hamiltonians","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"","category":"section"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"This section describes the class of Hamiltonians SmoQyDQMC.jl currently supports, and how the various terms appearing in the Hamiltonian are parameterized within the code. We start by partitioning the full Hamiltonian as ","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalH = hatmathcalU + hatmathcalK + hatmathcalV\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"where hatmathcalU is the bare lattice energy, hatmathcalK the total electron kinetic energy, and hatmathcalV the total electron potential energy. In the discussion that follows we apply the normalization hbar = 1 throughout.","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"The bare lattice term is further decomposed into","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalU = hatmathcalU_rm ph + hatmathcalU_rm disp\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"where","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalU_rm ph = sum_mathbfinusum_n_mathbfinu\n        left\n            frac12M_n_mathbfinuhatP_n_mathbfinu\n            + frac12M_n_mathbfinuOmega_0n_mathbfinu^2hatX_n_mathbfinu^2\n            + frac124M_n_mathbfinuOmega_an_mathbfinu^2hatX_n_mathbfinu^4\n        right\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"describes the placement of local dispersionless phonon (LDP) modes in the lattice, i.e. an Einstein solid, and","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalU_rm disp = sum_substackmathbfinu  mathbfjgammasum_substackn_mathbfinu  n_mathbfjgamma\n        fracM_n_mathbfialphaM_n_mathbfjgammaM_n_mathbfialpha+M_n_mathbfjgammaleft\n            tildeOmega^2_0n_mathbfialphan_mathbfjgamma(hatX_n_mathbfinu-hatX_n_mathbfjgamma)^2\n            + frac112tildeOmega^2_an_mathbfialphan_mathbfjgamma(hatX_n_mathbfinu-hatX_n_mathbfjgamma)^4\n        right\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"introduces dispersion between the LDP modes. The sums over mathbfi  (mathbfj) and nu  (gamma) run over unit cells in the lattice and orbitals within each unit cell respectively. A sum over n_mathbfinu  (n_mathbfjgamma) then runs over the LDP modes placed on a given orbital in the lattice.","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"The position and momentum operators for each LPD mode are given by hatX_n_mathbfinu and hatP_n_mathbfinu respectively, with corresponding phonon mass M_n_mathbfinu. The spring constant is K_n_mathbfinu = M_n_mathbfinu Omega_0n_n_mathbfinu^2, with Omega_0n_n_mathbfinu specifying the phonon frequency. The U_rm ph also supports an anharmonic hatX_n_mathbfinu^4 contribution to the LDP potential energy that is controlled by the parameter Omega_an_n_mathbfinu. Similary, tildeOmega_0n_mathbfialphan_mathbfjgamma  (tildeOmega_an_mathbfialphan_mathbfjgamma) is the coefficient controlling harmonic (anhmaronic) dispersion between LDP modes.","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"Next we trace out the phonon degrees of freedom ","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"The electron kinetic energy is decomposed as","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalK = sum_sigma=uparrowdownarrow left hatmathcalK_sigma0 + hatmathcalK_sigmarm ssh right\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"where","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalK_sigma0 = -sum_substackmathbfinu  mathbfjgamma\n        left\n            t_sigma(mathbfinu)(mathbfjgamma) hatc^dagger_sigmamathbfinuhatc_sigmamathbfjgamma + rm hc\n        right\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"is the non-interacting spin-sigma electron kinetic energy, and","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalK_sigmarm ssh = sum_substackmathbfinu  mathbfjgammasum_substackn_mathbfinu  n_mathbfjgammasum_m=1^4\n        (hatX_n_mathbfinu-hatX_n_mathbfjgamma)^mleft\n            alpha_sigmamn_mathbfinun_mathbfjgamma hatc^dagger_sigmamathbfinuhatc_sigmamathbfjgamma + rm hc\n        right\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"is describes the interaction between the lattice degrees of freedom and the spin-sigma electron kinetic energy via a Su-Schrieffer-Heeger (SSH)-like coupling mechanism. The hopping integral between from orbital gamma in unit cell mathbfj to orbital nu in unit cell mathbfi is given by t_(mathbfinu)(mathbfjgamma), and may in general be complex. The modulations to this hopping integral are controlled by the parameters alpha_m(mathbfinu)(mathbfjgamma), where min 14 specifies the order of the difference in the phonon positions that modulates the hopping integral.","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"Lastly, the electron potential energy is broken down into the three terms","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalV = sum_sigma=uparrowdownarrow left hatmathcalV_sigma0 + hatmathcalV_sigmarm hol right + hatmathcalV_rm hub\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"where","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalV_sigma0 = sum_mathbfinu\n        left\n            (epsilon_sigmamathbfinu - mu) hatn_sigmamathbfinu\n        right\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"is the non-interacting spin-sigma electron potential energy,","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalV_sigmarm hol =\n    begincases\n        sum_mathbfinu summathbfjgamma sum_n_mathbfinu leftsum_m=13tildealpha_sigmamn_mathbfinu(mathbfjgamma)  hatX^m_n_mathbfinu(hatn_sigmamathbfjgamma - tfrac12) + sum_m=24tildealpha_sigmamn_mathbfinu(mathbfjgamma)  hatX^m_n_mathbfinuhatn_sigmamathbfjgammaright \n        sum_mathbfinu summathbfjgamma sum_n_mathbfinu sum_m=1^4 tildealpha_sigmamn_mathbfinu(mathbfjgamma)  hatX^m_n_mathbfinu hatn_sigmamathbfjgamma\n    endcases\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"is the contribution to the spin-sigma electron potential energy that results from a Holstein-like coupling to the lattice degrees of freedom, and","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalV_rm hub=\n    begincases\n        sum_mathbfinuU_mathbfinubig(hatn_uparrowmathbfinu-tfrac12big)big(hatn_downarrowmathbfinu-tfrac12big)\n        sum_mathbfinuU_mathbfinuhatn_uparrowmathbfinuhatn_downarrowmathbfinu\n    endcases\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"is the on-site Hubbard interaction contribution to the electron potential energy. In hatmathcalV_0 the chemical potential is given by mu, and epsilon_mathbfinu is the on-site energy, the parameter tildealpha_mn_mathbfinu(mathbfjgamma) controls the strength of the Holstein-like coupling in hatmathcalV_rm ph, and U_mathbfinu is the on-site Hubbard interaction strength in hatmathcalV_rm hub. Note that either functional form for hatmathcalV_rm hub and hatmathcalV_sigma rm hub can be used in the code. Note that the two possible parameterizations for hatmathcalV_sigma rm hub are inequivalent! ","category":"page"},{"location":"simulation_output/#Simulation-Output-Overview","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"In this section we define and provide an overview of the output generated by a DQMC simulation performed using the SmoQyDQMC.jl package.","category":"page"},{"location":"simulation_output/#Output-Data-Folder-Structure","page":"Simulation Output Overview","title":"Output Data Folder Structure","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"Each simulation performed with SmoQyDQMC.jl will generate a directory with a user defined name that all the output of the simulation will be written to. Here we will simply refer to this top-level directory as the datafolder, but again, the user may call it whatever they like. Inside the datafolder a set of files and folders resembling the structure outlined below will be found:","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"[datafolder]: \nmodel_summary.toml: A TOML file that describes the Hamiltonian that was simulated, and defines the various types of IDs that measurements are reported in terms of.\nsimulation_info_pID*_sID*.toml: A TOML file reporting basic information about the simulation, including the version of Julia and SmoQyDQMC.jl that was used to run the simulation. An [additional_info] table contains the contents of a user defined dictionary as well. One such file is generated for each pID MPI rank if multiple simulations are being performed in parallel using MPI.\nglobal_stats.csv: CSV file containing final average and error for all global measurements.\nlocal_stats.csv: CSV file containing final average and error for all local measurements.\n[global]: Directory contained binned global measurements written as binary JDL2 files.\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[local]: Directory contained binned local measurements written as binary JDL2 files.\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[equal-time]: Top-level directory containing all equal-time correlation function measurement results.\n[density]: As an example, directory containing equal-time density-density correlations.\ndensity_momentum_equal-time_stats.csv: CSV file containing average and error for density-density correlation in momentum space.\ndensity_position_equal-time_stats.csv: CSV file containing average and error for density-density correlation in position space.\n[momentum]: Directory containing binned momentum space density-density correlation data as binary JLD2 files.\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[position]: Directory containing binned position space density-density correlation data as binary JLD2 files.\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[...]\n[time-displaced]: Top-level directory containing all time-displaced correlation function measurement results.\n[greens]\ngreens_momentum_equal-time_stats.csv\ngreens_position_equal-time_stats.csv\n[momentum]\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[position]\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[...]\n[integrated]: Top-level directory containing all integrated correlation function measurement results.\n[density]\ndensity_momentum_integrated_stats.csv\ndensity_position_integrated_stats.csv\n[momentum]\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[position]\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[...]","category":"page"},{"location":"simulation_output/#Model-Summary","page":"Simulation Output Overview","title":"Model Summary","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"The function model_summary is used to a TOML file named model_summary.toml that full describes and parameterizes the Hamiltonian simulated in a DQMC simulation using SmoQyDQMC.jl. Significantly, this method also defines the types of IDs (ORBITAL_ID, BOND_ID, HOPPING_ID, PHONON_ID, HOLSTEIN_ID, SSH_ID, DISPERSION_ID) that the various measurements are reported in terms of. The type of ID used to report correlation and local measurements are recorded in the exported dictionaries CORRELATION_FUNCTIONS and LOCAL_MEASUREMENTS.","category":"page"},{"location":"simulation_output/#Uncertainty-Reporting-Conventions","page":"Simulation Output Overview","title":"Uncertainty Reporting Conventions","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"The average value barC for any measured expectation value langle C rangle is reported as a complex number in all  *_stats.csv files, even if it is known formally to be a strictly real quantity. On the other hand, the error, or standard deviation, associated with each measurement is reported as a strictly positive real number such that the error associated with the complex expectation value langle C rangle is given by Delta C = sqrtDelta C_rm Re^2 + Delta C_rm Im^2.","category":"page"},{"location":"simulation_output/#Global-Measurements","page":"Simulation Output Overview","title":"Global Measurements","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"At the end of a simulation once the measurements are processed using the process_measurements method, a file global_stats.csv file is created that contains the final estimates and errors for all \"global\" measurements. The corresponding binned global data is stored as binary JLD2 files in the directory global inside the simulation directory. We define each global measurement below.","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"sgn: The average sign mathcalS = langle rm sign( det G_uparrow cdot det G_downarrow ) rangle.\nsgndetGup: The average spin-up sign mathcalS_uparrow = langle rm sign(det G_uparrow) rangle.\nsgndetGdn: The average spin-up sign mathcalS_downarrow = langle rm sign(det G_downarrow) rangle.\ndensity: Average global total charge density langle n rangle = langle n_uparrow rangle + langle n_downarrow rangle.\ndensity_up: Average global spin-up charge density langle n_uparrow rangle.\ndensity_dn: Average global spin-down charge density langle n_downarrow rangle.\ndouble_occ: Average global double occupancy langle n_uparrow n_downarrow rangle.\nNsqrd: Expectation value for total electron number squared langle N^2 rangle, where hatN = sum_sigmamathbfinu hatn_sigma mathbfi nu.\nchemical_potential: The measured chemical potential mu.\ncompressibility: The measured compressibility kappa = fracd langle n rangled mu = fracbetamathcalNleft( langle N^2 rangle - langle N rangle^2 right).","category":"page"},{"location":"simulation_output/#Local-Measurement","page":"Simulation Output Overview","title":"Local Measurement","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"At the end of a simulation once the measurements are processed using the process_measurements method, a file local_stats.csv file is created that contains the final estimates and errors for all \"local\" measurements. The corresponding binned local data is stored as binary JLD2 files in the directory local inside the simulation directory. All \"local\" measurements are reported in terms of an ID type, defined in the model_summary.toml file generated by the model_summary function. The definition for each local measurement that may be reported, including the type of ID it is reported in terms of, is defined below.","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"density: (ORBITAL_ID) The charge density langle n_nu rangle = langle n_uparrownu rangle + langle n_downarrownu rangle for orbital nu in the unit cell.\ndensity_up: (ORBITAL_ID) The spin-up charge density langle n_uparrownu rangle for orbital nu in the unit cell.\ndensity_dn: (ORBITAL_ID) The spin-down charge density langle n_downarrownu rangle for orbital nu in the unit cell.\ndouble_occ: (ORBITAL_ID) The double-occupance langle n_uparrownu n_downarrownu rangle for orbital nu in the unit cell.","category":"page"},{"location":"simulation_output/#Local-Tight-Binding-Measurements","page":"Simulation Output Overview","title":"Local Tight-Binding Measurements","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"onsite_energy: (ORBITAL_ID) The total on-site energy sum_sigma (epsilon_sigmanu - mu) langle n_sigmanu rangle for orbital nu in the unit cell.\nonsite_energy_up: (ORBITAL_ID) The spin-up on-site energy (epsilon_uparrownu - mu) langle n_uparrownu rangle for orbital nu in the unit cell.\nonsite_energy_dn: (ORBITAL_ID) The spin-down on-site energy (epsilon_downarrownu - mu) langle n_downarrownu rangle for orbital nu in the unit cell.\nbare_hopping_energy: (HOPPING_ID) The bare hopping energy -sum_sigma langle t_sigma(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_sigmamathbfi+mathbfrnu c^phantomdagger_sigmamathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_(mathbfi+mathbfrnu)(mathbfigamma) is the bare hopping amplitude.\nbare_hopping_energy_up: (HOPPING_ID) The bare spin-up hopping energy -langle t_uparrow(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_uparrowmathbfi+mathbfrnu c^phantomdagger_uparrowmathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_sigma(mathbfi+mathbfrnu)(mathbfigamma) is the bare hopping amplitude.\nbare_hopping_energy_dn: (HOPPING_ID) The bare spin-up hopping energy -langle t_downarrow(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_downarrowmathbfi+mathbfrnu c^phantomdagger_downarrowmathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_downarrow(mathbfi+mathbfrnu)(mathbfigamma) is the bare hopping amplitude.\nhopping_energy: (HOPPING_ID) The total hopping energy -sum_sigma langle t_lsigma(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_sigmamathbfi+mathbfrnu c^phantomdagger_sigmamathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_l(mathbfi+mathbfrnu)(mathbfigamma) is the modulated hopping amplitude.\nhopping_energy_up: (HOPPING_ID) The spin-up hopping energy -langle t_luparrow(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_uparrowmathbfi+mathbfrnu c^phantomdagger_uparrowmathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_lsigma(mathbfi+mathbfrnu)(mathbfigamma) is the modulated hopping amplitude.\nhopping_energy_dn: (HOPPING_ID) The spin-up hopping energy -langle t_ldownarrow(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_downarrowmathbfi+mathbfrnu c^phantomdagger_downarrowmathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_ldownarrow(mathbfi+mathbfrnu)(mathbfigamma) is the modulated hopping amplitude.\nhopping_amplitude: (HOPPING_ID) The average hopping amplitude frac12 N sum_sigmamathbfi langle t_sigma(mathbfi+mathbfrnu)(mathbfigamma)rangle.\nhopping_amplitude_up: (HOPPING_ID) The average spin-up hopping amplitude frac1N sum_mathbfi langle t_uparrow(mathbfi+mathbfrnu)(mathbfigamma)rangle.\nhopping_amplitude_dn: (HOPPING_ID) The average spin-down hopping amplitude frac1N sum_mathbfi langle t_downarrow(mathbfi+mathbfrnu)(mathbfigamma)rangle.\nhopping_inversion: (HOPPING_ID) Fraction of the time the overall sign of the total hopping amplitude is inverted as a result of interactions, without first averaging the hopping amplitude over imaginary time.\nhopping_inversion_up: (HOPPING_ID) Fraction of the time the overall sign of the spin-up hopping amplitude is inverted as a result of interactions, without first averaging the hopping amplitude over imaginary time.\nhopping_inversion_dn: (HOPPING_ID) Fraction of the time the overall sign of the spin-down hopping amplitude is inverted as a result of interactions, without first averaging the hopping amplitude over imaginary time.\nhopping_inversion_avg: (HOPPING_ID) Fraction of the time the overall sign of the total hopping amplitude is inverted as a result of interactions, as calculated after first averaging the hopping amplitude over imaginary time.\nhopping_inversion_avg_up: (HOPPING_ID) Fraction of the time the overall sign of the spin-up hopping amplitude is inverted as a result of interactions, as calculated after first averaging the hopping amplitude over imaginary time.\nhopping_inversion_avg_dn: (HOPPING_ID) Fraction of the time the overall sign of the spin-down hopping amplitude is inverted as a result of interactions,as calculated after first averaging the hopping amplitude over imaginary time.","category":"page"},{"location":"simulation_output/#Local-Hubbard-Measurements","page":"Simulation Output Overview","title":"Local Hubbard Measurements","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"hubbard_energy: (ORBITAL_ID) The Hubbard interaction energy U_nu langle n_uparrownu n_downarrownu rangle for orbital nu in the unit cell.","category":"page"},{"location":"simulation_output/#Local-Phonon-Measurements","page":"Simulation Output Overview","title":"Local Phonon Measurements","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"phonon_kin_energy: (PHONON_ID) The phonon kinetic energy frac12 M_n_nu langle P_n_nu^2 rangle for phonon mode n_nu in unit cell.\nphonon_pot_energy: (PHONON_ID) The phonon potential energy frac12M_n_nuOmega_0n_nu^2langle X_n_nu^2 rangle + frac124M_n_nuOmega_an_nu^2langle X_n_nu^4 rangle for phonon mode n_nu in unit cell.\nX: (PHONON_ID): The expecation values langle X_n_nu rangle for phonon mode n_nu in unit cell.\nX2: (PHONON_ID): The expecation values langle X_n_nu^2 rangle for phonon mode n_nu in unit cell.\nX3: (PHONON_ID): The expecation values langle X_n_nu^3 rangle for phonon mode n_nu in unit cell.\nX4: (PHONON_ID): The expecation values langle X_n_nu^4 rangle for phonon mode n_nu in unit cell.\ndispersion_energy: (DISPERSION_ID) The dispersion energy langle mathcalU_rm disp (mathbfr n_nu n_gamma) rangle between the two phonon models n_nu and n_gamma displaced mathbfr unit cells from eachother.","category":"page"},{"location":"simulation_output/#Local-Electron-Phonon-Interaction-Measurements","page":"Simulation Output Overview","title":"Local Electron-Phonon Interaction Measurements","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"holstein_energy: (HOLSTEIN_ID) The total Holstein interaction energy langle hatmathcalV_rm hol n_mathbfinu (mathbfi+mathbfrgamma) rangle between a phonon mode n_mathbfinu and total charge density on orbital gamma displaced mathbfr unit cells away.\nholstein_energy_up: (HOLSTEIN_ID) The spin-up Holstein interaction energy langle hatmathcalV_rm hol uparrow n_mathbfinu (mathbfi+mathbfrgamma) rangle between a phonon mode n_mathbfinu and the spin-uparrow density on orbital gamma displaced mathbfr unit cells away.\nholstein_energy_dn: (HOLSTEIN_ID) The spin-down Holstein interaction energy langle hatmathcalV_rm hol downarrow n_mathbfinu (mathbfi+mathbfrgamma) rangle between a phonon mode n_mathbfinu and the spin-downarrow on orbital gamma displaced mathbfr unit cells away.\nssh_energy: (SSH_ID) The total SSH interaction enery langle mathcalK_rm ssh(n_mathbfinun_mathbfi+mathbfrgamma)rangle between phonon modes n_nu and n_gamma displaced mathbfr unit cells from eachother.\nssh_energy_up: (SSH_ID) The spin-up SSH interaction enery langle mathcalK_rm sshuparrow(n_mathbfinun_mathbfi+mathbfrgamma)rangle between phonon modes n_nu and n_gamma displaced mathbfr unit cells from eachother.\nssh_energy_dn: (SSH_ID) The spin-down SSH interaction enery langle mathcalK_rm sshdownarrow(n_mathbfinun_mathbfi+mathbfrgamma)rangle between phonon modes n_nu and n_gamma displaced mathbfr unit cells from eachother.","category":"page"},{"location":"simulation_output/#Correlation-Function-Measurements","page":"Simulation Output Overview","title":"Correlation Function Measurements","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"Three types of correlation functions are reported by SmoQyDQMC.jl package. Let hatO_mathbfinu represent some operator associated with unit cell mathbfi and ID index nu. For instance, in the case of a density-density correlation, nu corresponds to an ORBITAL_ID index. The first type of correlation that may be reported are equal-time correlation function of the form","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"C_nugamma(mathbfr) = frac1N sum_mathbfi langle O^dagger_mathbfi+mathbfrnu O^phantomdagger_mathbfigamma rangle","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"in position space, where the sum over mathbfi runs over all unit cells, and mathbfr represents a displacement in unit cells. The corresponding equal-time correlation function in momentum space is given by","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"C_nugamma(mathbfq) = sum_mathbfr e^-rm imathbfqcdot(mathbfr+mathbfr_nu-mathbfr_gamma) C_nugamma(mathbfr)","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"where mathbfr_nu and mathbfr_gamma are static displacement vector associated with the operators hatO_mathbfinu and hatO_mathbfigamma. For instance, in the case of the density-density correlation, mathbfr_nu is the location of the orbital nu in the unit cell.","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"The second type of correlation function is the time-displaced correlation function in position space is given by","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"C_nugamma(mathbfrtau) = frac1N sum_mathbfi langle O^dagger_mathbfi+mathbfrnu(tau) O^phantomdagger_mathbfigamma(0) rangle","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"and in momentum space by","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"C_nugamma(mathbfqtau) = sum_mathbfr e^-rm imathbfqcdot(mathbfr+mathbfr_nu-mathbfr_gamma) C_nugamma(mathbfrtau)","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"The last type is the integrated correlation functions in position space, given by","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"chi_nugamma(mathbfr) = int_0^beta dtau  C_nugamma(mathbfrtau)","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"and in momentum space by","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"chi_nugamma(mathbfq) = int_0^beta dtau  C_nugamma(mathbfqtau)","category":"page"},{"location":"simulation_output/#vector_reporting_conventions","page":"Simulation Output Overview","title":"Displacement Vector and Momentum Reporting Conventions","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"Consider a D dimensional finite periodic lattice, where mathbfa_d and mathbfb_d denote the corresponding lattice vectors and reciprocal lattice vectors, where d in 1D. The extent of the lattice in unit cells in the direction of each of the lattice vectors is denoted by L_d. Given these definitions, the displacement vectors are parametetized as","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"mathbfr = sum_d=1^D left( fracmathttR_dL_d right) mathbfa_d","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"and then reported in terms of the set of integers mathttR_d in 0 L_d). Similarly, the set of mathbfk-points associated with the finite lattice are given by","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"mathbfk = sum_d=1^D left( fracmathttK_dL_d right) mathbfb_d","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"and then reported in term of the set of integers mathttK_d in 0 L_d).","category":"page"},{"location":"simulation_output/#Correlation-Function-Reporting-Conventions","page":"Simulation Output Overview","title":"Correlation Function Reporting Conventions","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"In addition to reporting the set of integers mathttR_d  (mathttK_d) used to define correlation functions in position (momentum) space, they are also identified by an ID pair (mathtt*_ID_2 mathtt*_ID_1) specifying the subscripts nu and gamma. Lastly, time-displaced correlation functions also report the displacement in imaginary time, given as an integer mathttTAU in 0 L_tau such that tau = Deltatau cdot mathttTAU where beta = Deltatau cdot L_tau.","category":"page"},{"location":"simulation_output/#Defined-Correlation-Functions","page":"Simulation Output Overview","title":"Defined Correlation Functions","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"In this section we review the various correlation measurements that the SmoQyDQMC.jl package currently supports.","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"greens: (ORBITAL_ID) Measures spin averaged single-particle electron Green's functions.\ngreens_up: (ORBITAL_ID) Measures spin-up single-particle electron Green's functions..\ngreens_dn: (ORBITAL_ID) Measures spin-down single-particle electron Green's functions..\ndensity: (ORBITAL_ID) Measures total density correlation functions.\nspin_z: (ORBITAL_ID) Measures spin-z correlation functions.\nspin_x: (ORBITAL_ID) Measures spin-z correlation functions.\npair: (BOND_ID) Measures pair correlation functions.\nbond: (BOND_ID) Measures bond correlation functions.\ncurrent: (HOPPING_ID) Measures current correlation functions.\nphonon_greens: (PHONON_ID) Measures phonon Green's functions, parameterized as the phonon position correlation function. The position space definition is given below, with n_alpha and n_gamma specifying phonon modes associated with orbitals alpha and gamma in the unit cell respectively.","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"mathcalD_mathbfr^n_alpha n_gamma(tau) = frac1N sum_mathbfi langle hatX_n_alphamathbfi+mathbfr(tau) hatX_n_gammamathbfi(0) rangle","category":"page"},{"location":"simulation_output/#Composite-Correlation-Measurements","page":"Simulation Output Overview","title":"Composite Correlation Measurements","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"Lastly, with the initialize_composite_correlation_measurement! it is possible to make user named composite correlation measurements, defined by a linear combination of one of the above correlation measuremesnts of the form","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"hatO_mathbfi = sum_nu c_nu hatO_mathbfinu","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"where c_nu are user-specified (complex or real) coefficients. Note that all cross-terms are automatically expanded out when making the composite correlation measurement, by which we mean that","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"langle hatO^dagger_mathbfi+mathbfr(tau) hatO^phantomdagger_mathbfi(0)  rangle\n= sum_nunu c_nu^* c_nu^phantom * langle hatO^dagger_mathbfi+mathbfrnu(tau) hatO^phantomdagger_mathbfinu(0)  rangle","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"is measured. Note that the ID pair (mathtt*_ID_2 mathtt*_ID_1) columns are omitted from the composite correlation CSV stat files generated at the end of a simulation.","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/holstein_kagome/#Kagome-Holstein-Model-with-Density-Tuning","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"","category":"section"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"In this script we simulate the Holstein model on the Kagome lattice, with a Hamiltonian given by","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"beginalign*\nhatH =  -t sum_sigmalangle i j rangle (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n            -mu sum_sigmaihatn_sigmai + alpha sum_sigmai hatX_i (hatn_sigmai - tfrac12)\n           + sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)\nendalign*","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. The nearest-neighbor hopping amplitude is t and mu is the chemical potential. The phonon position (momentum) operators hatX_i  (hatP_i) describe a dispersionless mode placed on site i with phonon frequency Omega and corresponding ion mass M. The stength of the Holstein electron-phonon is controlled by the parameter alpha.","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"> julia holstein_chain.jl 0 0.1 0.1 0.667 0.0 4.0 3 2000 10000 50","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"Here the Holstein model on a 3 times 3 unit cell Kagome lattice is simulated with Omega = 01, alpha = 01 and inverse temperature beta = 40. The chemical potential is initialized to mu = 00, and then tuned to achieve are target electron density of langle n rangle = 0667. In this example N_burnin = 2000 thermalizatoin HMC and refleciton updates are performed, followed by an additional N_updates = 10000 such updates, during which time an equivalent number of measurements are made. Bin averaged measurements are written to file N_bins = 50 during the simulation.","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n# Import the MuTuner module that implements the chemical potential tuning algorithm.\nimport SmoQyDQMC.MuTuner           as mt\n\n# Define top-level function for running the DQMC simulation.\nfunction run_holstein_chain_simulation(sID, Ω, α, n, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_kagome_w%.2f_a%.2f_n%.2f_L%d_b%.2f\" Ω α n L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.05\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bin size.\n    bin_size = div(N_updates, N_bins)\n\n    # To update the phonon degrees of freedom in this code we primarily perform\n    # hybrid/hamiltonian Monte Carlo (HMC) updates. Below we specify some of the\n    # parameters associated with these HMC updates.\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 4\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(2*Ω)/Nt\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"reflection_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"Nt\" => Nt,\n        \"dt\" => Δt,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[1.0,0.0],\n                        [1/2,√3/2]],\n        basis_vecs   = [[0.0,0.0],\n                        [1/2,0.0],\n                        [1/4,√3/4]]\n    )\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Get the number of sites in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond.\n    bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n    # Add nearest neighbor bond to the model.\n    bond_1_id = add_bond!(model_geometry, bond_1)\n\n    # Define the nearest-neighbor bond.\n    bond_2 = lu.Bond(orbitals = (1,3), displacement = [0,0])\n\n    # Add nearest neighbor bond to the model.\n    bond_2_id = add_bond!(model_geometry, bond_2)\n\n    # Define the nearest-neighbor bond.\n    bond_3 = lu.Bond(orbitals = (2,3), displacement = [0,0])\n\n    # Add nearest neighbor bond to the model.\n    bond_3_id = add_bond!(model_geometry, bond_3)\n\n    # Define the nearest-neighbor bond.\n    bond_4 = lu.Bond(orbitals = (2,1), displacement = [1,0])\n\n    # Add nearest neighbor bond to the model.\n    bond_4_id = add_bond!(model_geometry, bond_4)\n\n    # Define the nearest-neighbor bond.\n    bond_5 = lu.Bond(orbitals = (3,1), displacement = [0,1])\n\n    # Add nearest neighbor bond to the model.\n    bond_5_id = add_bond!(model_geometry, bond_5)\n\n    # Define the nearest-neighbor bond.\n    bond_6 = lu.Bond(orbitals = (3,2), displacement = [-1,1])\n\n    # Add nearest neighbor bond to the model.\n    bond_6_id = add_bond!(model_geometry, bond_6)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_1, bond_2, bond_3, bond_4, bond_5, bond_6], # defines hopping\n        t_mean  = [t, t, t, t, t, t],     # defines corresponding hopping amplitude\n        μ       = μ,            # set chemical potential\n        ϵ_mean  = [0.0, 0.0, 0.0]     # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live the first sub-lattice.\n    phonon_1 = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_1_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_1\n    )\n\n    # Define a dispersionless electron-phonon mode to live the second sub-lattice.\n    phonon_2 = PhononMode(orbital = 2, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_2_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_2\n    )\n\n    # Define a dispersionless electron-phonon mode to live the third sub-lattice.\n    phonon_3 = PhononMode(orbital = 3, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_3_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_3\n    )\n\n    # Define a on-site Holstein coupling for first sub-lattice.\n    holstein_coupling_1 = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_1_id,\n    \tbond = lu.Bond(orbitals = (1,1), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model for first sub-lattice.\n    holstein_coupling_1_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling_1,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Define a on-site Holstein coupling for second sub-lattice.\n    holstein_coupling_2 = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_2_id,\n    \tbond = lu.Bond(orbitals = (2,2), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model for first sub-lattice.\n    holstein_coupling_2_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling_2,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Define a on-site Holstein coupling for first sub-lattice.\n    holstein_coupling_3 = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_3_id,\n    \tbond = lu.Bond(orbitals = (3,3), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model for first sub-lattice.\n    holstein_coupling_3_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling_3,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Write a model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )\n\n    #################################################\n    ### INITIALIZE FINITE LATTICE MODEL PARAMETERS ##\n    #################################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1), (2, 2), (3, 3),\n                 (1, 2), (1, 3), (2, 3)]\n    )\n\n    # Initialize time-displaced phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(1, 1), (2, 2), (3, 3),\n                 (1, 2), (1, 3), (2, 3)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (3, 3),\n                 (1, 2), (1, 3), (2, 3)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (3, 3)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (3, 3),\n                 (1, 2), (1, 3), (2, 3)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Note that the spin-up and spin-down electron sectors are equivalent in the Holstein model\n    # without Hubbard interaction. Therefore, there is only a single Fermion determinant\n    # that needs to be calculated. This fact is reflected in the code below.\n\n    # Allocate fermion path integral type.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the fermion path integral type with respect to electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Allocate and initialize propagators for each imaginary time slice.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize fermion greens calculator.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize equal-time Green's function matrix\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = HMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt, nt = nt, reg = reg\n    )\n\n    # Initialize the density/chemical potential tuner.\n    # This type facilitates the tuning of the chemical potential to achieve\n    # at target electron density.\n    chemical_potential_tuner = mt.MuTunerLogger(n₀ = n, β = β, V = N, u₀ = 1.0, μ₀ = μ, c = 0.5)\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a reflection update.\n        # This update randomly selects a phonon mode in the lattice and reflects\n        # all the associated phonon about the origin, (xᵢ → -xᵢ).\n        # This updates all the phonon fields to cross the on-site energy barrier\n        # associated with bipolaron formation, helping reduce autocorrelation times.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng, phonon_types = (phonon_1_id, phonon_2_id, phonon_3_id)\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n\n        # Update the chemical potential.\n        logdetG, sgndetG = update_chemical_potential!(\n            G, logdetG, sgndetG,\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B\n        )\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a reflection update.\n            (accepted, logdetG, sgndetG) = reflection_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, rng = rng, phonon_types = (phonon_1_id, phonon_2_id, phonon_3_id)\n            )\n\n            # Record whether the reflection update was accepted or rejected.\n            additional_info[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Make measurements.\n            (logdetG, sgndetG, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (electron_phonon_parameters,)\n            )\n\n            # Update the chemical potential.\n            logdetG, sgndetG = update_chemical_potential!(\n                G, logdetG, sgndetG,\n                chemical_potential_tuner = chemical_potential_tuner,\n                tight_binding_parameters = tight_binding_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate HMC acceptance rate.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Calculate reflection update acceptance rate.\n    additional_info[\"reflection_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Save the density tuning profile.\n    save_density_tuning_profile(simulation_info, chemical_potential_tuner)\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ω = parse(Float64, ARGS[2])\n    α = parse(Float64, ARGS[3])\n    n = parse(Float64, ARGS[4]) # target electorn density\n    μ = parse(Float64, ARGS[5]) # intial chemical potential\n    β = parse(Float64, ARGS[6])\n    L = parse(Int, ARGS[7])\n    N_burnin = parse(Int, ARGS[8])\n    N_updates = parse(Int, ARGS[9])\n    N_bins = parse(Int, ARGS[10])\n\n    # Run the simulation.\n    run_holstein_chain_simulation(sID, Ω, α, n, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"#SmoQyDQMC","page":"Home","title":"SmoQyDQMC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SmoQyDQMC.jl. This package implements the determinant quantum Monte Carlo (DQMC) method for Hubbard, and electron-phonon interactions, including both Holstein and Su-Schrieffer-Heeger (SSH) style electron-phonon coupling.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This code is currently in the experimental phase of development.","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The development of this code was supported by the U.S. Department of Energy, Office of Science, Basic Energy Sciences, under Award Number DE-SC0022311.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the SmoQyDQMC.jl, simply open the Julia REPL and run the commands","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add SmoQyDQMC","category":"page"},{"location":"","page":"Home","title":"Home","text":"or equivalently via Pkg do","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"SmoQyDQMC\")","category":"page"},{"location":"#Publication-List","page":"Home","title":"Publication List","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This sections lists of some of the publications that report results generated using the SmoQyDQMC.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A. Tanjaroon Ly, B. Cohen-Stead, S. Malkaruge Costa and S. Johnston. Comparative study of the superconductivity in the Holstein and optical Su-Schrieffer-Heeger models. Phys. Rev. B 108, 184501 (2023).\n\n\n\nS. Malkaruge Costa, B. Cohen-Stead, A. T. Ly, J. Neuhaus and S. Johnston. Comparative determinant quantum Monte Carlo study of the acoustic and optical variants of the Su-Schrieffer-Heeger model. Phys. Rev. B 108, 165138 (2023).\n\n\n\nG.-H. Huang and Z. Wu. Magnetic correlations of a doped and frustrated Hubbard model: Benchmarking the two-particle self-consistent theory against a quantum simulator. Phys. Rev. B 110, L100406 (2024).\n\n\n\nT. Shen, H. Barghathi, A. Del Maestro and B. M. Rubenstein. Disentangling the physics of the attractive Hubbard model as a fully interacting model of fermions via the accessible and symmetry-resolved entanglement entropies. Phys. Rev. B 109, 195119 (2024).\n\n\n\nS. Malkaruge Costa, B. Cohen-Stead and S. Johnston. Kekulé valence bond order in the honeycomb lattice optical Su-Schrieffer-Heeger model and its relevance to graphene. Phys. Rev. B 110, 115130 (2024).\n\n\n\nJ. Neuhaus, N. S. Nichols, D. Banerjee, B. Cohen-Stead, T. A. Maier, A. D. Maestro and S. Johnston. SmoQyDEAC.jl: A differential evolution package for the analytic continuation of imaginary time correlation functions, arXiv:2407.04568 (2024).\n\n\n\nM. Naamneh, E. Paris, D. McNally, Y. Tseng, W. R. Pudelko, D. J. Gawryluk, J. Shamblin, E. OQuinn, B. Cohen-Stead, M. Shi, M. Radovic, M. Lang, T. Schmitt, S. Johnston and N. C. Plumb. Persistence of small polarons into the superconducting phase of Ba_1-xK_xBiO_3, arXiv:2408.00401 (2024).\n\n\n\nP. Mai, B. Cohen-Stead, T. A. Maier and S. Johnston. Fluctuating charge-density-wave correlations in the three-band Hubbard model, arXiv:2405.13164 (2024).\n\n\n\n","category":"page"},{"location":"#Notable-Package-Dependencies","page":"Home","title":"Notable Package Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This section reviews some notable package dependencies.","category":"page"},{"location":"#Re-exported-Packages","page":"Home","title":"Re-exported Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SmoQyDQMC.jl re-exports certain packages using the Reexport.jl package in order to simplify the installation process.","category":"page"},{"location":"","page":"Home","title":"Home","text":"LatticeUtilties.jl: Used to represent arbitrary lattice geometries.\nJDQMCFramework.jl: Implements and exports the basic framework for running a DQMC simulation.\nJDQMCMeasurements.jl: Implements various global, local and correlation measurements for a DQMC simulation.\nMuTuner.jl: Impelments and exports an algorithm for tuning the chemical potential to achieve a target density in grand canonical Monte Carlo simulations.","category":"page"},{"location":"#External-Dependencies","page":"Home","title":"External Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StableLinearAlgebra.jl: Implements optimized numerical stabilizaiton methods required by DQMC simulations.\nCheckerboard.jl: Implements and exports the checkerboard method for approximating exponentiated hopping matrices by a sparse matrix.\nJLD2.jl: Package used to write data to binary files in an HDF5 compatible format. It is also recommended this package be used at the scripting level to implement checkpointing in a simulation.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you found this library to be useful in the course of academic work, please consider citing us:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@Article{SmoQyDQMC.jl,\n\ttitle={{SmoQyDQMC.jl: A flexible implementation of determinant quantum Monte Carlo for Hubbard and electron-phonon interactions}},\n\tauthor={Benjamin Cohen-Stead and Sohan Malkaruge Costa and James Neuhaus and Andy Tanjaroon Ly and Yutan Zhang and Richard Scalettar and Kipton Barros and Steven Johnston},\n\tjournal={SciPost Phys. Codebases},\n\tpages={29},\n\tyear={2024},\n\tpublisher={SciPost},\n\tdoi={10.21468/SciPostPhysCodeb.29},\n\turl={https://scipost.org/10.21468/SciPostPhysCodeb.29},\n}","category":"page"},{"location":"#Contact-Us","page":"Home","title":"Contact Us","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For question and comments regarding this package, please email either Dr. Benjamin Cohen-Stead at bcohenst@utk.edu or Professor Steven Johnston at sjohn145@utk.edu.","category":"page"}]
}
