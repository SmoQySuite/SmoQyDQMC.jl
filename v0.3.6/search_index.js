var documenterSearchIndex = {"docs":
[{"location":"examples/hubbard_chain_mpi/","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"EditURL = \"../../../examples/hubbard_chain_mpi.jl\"","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/hubbard_chain_mpi/#Hubbard-Chain-with-MPI","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"","category":"section"},{"location":"examples/hubbard_chain_mpi/","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"In this example we simulate the same system as in example 1, the half-filled Hubbard chain. However, in this example we use MPI, via the MPI.jl, to perform multiple simulations in parallel, with the results getting automatically averaged over at the end of the simulation. A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"> mpiexecjl -n 8 julia hubbard_chain_mpi.jl 1 6.0 0.0 8.0 16 2000 10000 50","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"This would result in 8 identical simulations being run in parallel. It possible that this command may need to be modified slightly depending on how MPI is set up on your system. For more information I recommend you refer to the MPI.jl documenation.","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Hubbard Chain with MPI","title":"Hubbard Chain with MPI","text":"using LinearAlgebra\nusing Random\nusing Printf\nusing MPI\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# initialize MPI\nMPI.Init()\n\n# Define top-level function for running DQMC simulation\nfunction run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_chain_U%.2f_mu%.2f_L%d_b%.2f\" U μ L β\n\n    # Get the MPI comm rank, which fixes the process ID (pID).\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID,\n        pID = pID\n    )\n\n    # Synchronize all the MPI processes.\n    # Here we need to make sure the data folder is initialized before letting\n    # all the various processes move beyond this point.\n    MPI.Barrier(comm)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"reflection_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted = false, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n        U_orbital = [1],\n        U_mean = [U],\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Write the model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    # Synchronize all the MPI processes.\n    # We need to ensure the sub-directories the measurements will be written are created\n    # prior to letting any of the processes move beyond this point.\n    MPI.Barrier(comm)\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters, hubbard_ising_parameters)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Synchronize all the MPI processes.\n    # Before we prcoess the binned data to get the final averages and error bars\n    # we need to make sure all the simulations running in parallel have run to\n    # completion.\n    MPI.Barrier(comm)\n\n    # Have the primary MPI process calculate the final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    if iszero(simulation_info.pID)\n        process_measurements(simulation_info.datafolder, N_bins)\n    end\n\n    return nothing\nend\n\n\n# Only excute if script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    μ = parse(Float64, ARGS[3])\n    β = parse(Float64, ARGS[4])\n    L = parse(Int, ARGS[5])\n    N_burnin = parse(Int, ARGS[6])\n    N_updates = parse(Int, ARGS[7])\n    N_bins = parse(Int, ARGS[8])\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins)\n\n    # Finalize MPI (not strictly required).\n    MPI.Finalize()\nend","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"EditURL = \"../../../examples/bssh_chain.jl\"","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/bssh_chain/#Bond-Su-Schrieffer-Heeger-Chain","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"","category":"section"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"In this example we simulate the bond Su-Schrieffer-Heeger (BSSH) model on a 1D chain, with a Hamiltonian given by","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"beginalign*\nhatH = sum_i left( frac12MhatP_langle i+1 i rangle^2 + frac12MOmega^2hatX_langle i+1 i rangle^2 right)\n          - sum_sigmai t-alpha hatX_langle i+1 i rangle (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n          - mu sum_sigmai hatn_sigmai\nendalign*","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"in which dispersionless phonon modes are placed on each bond, and their positions modulates only that single corresponding hopping amplitude. In the above expression hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creation (annihilation) operator a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on the bond connecting sites i and i+1 is given by hatX_langle i+1 i rangle  (hatP_langle i+1 i rangle), where Omega and M are the phonon frequency and associated ion mass respectively. Lastly, the strength of the electron-phonon coupling is controlled by the parameter alpha.","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"> julia bssh_chain.jl 0 1.0 0.5 0.0 4.0 16 1000 5000 20","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"which simulates an L=16 chain with Omega = 10, alpha = 05 at half-filling (mu = 00) and an inverse temperature of beta = 40. In this example N_burnin = 1000 HMC thermalization updates are performed, followed an additional N_updates = 5000 HMC updates, after each of which measurements are made. Bin averaged measurements are then written to file N_bins = 20 during the simulation.","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/bssh_chain/","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running the DQMC simulation.\nfunction run_bssh_chain_simulation(sID, Ω, α, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"bssh_chain_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.05\n\n    # For performance reasons it is important that we represent the exponentiated hopping\n    # matrix with the checkerboard approximation when simulating an SSH model, where the\n    # phonons modulate the hopping amplitudes. Without the checkerboard approximation,\n    # each time a phonon field is updated the kinetic energy matrix would need to be diagonalized\n    # to calculate its exponential, which is very computationally expensive.\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = true\n\n    # As we are using the checkboard approximation, using a symmetric definition for the propagator\n    # matrices is important as it significantly improves the accuracy of approximation.\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = true\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bin size.\n    bin_size = div(N_updates, N_bins)\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 4\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(Nt*Ω)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"swap_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"Nt\" => Nt,\n        \"dt\" => Δt,\n        \"seed\" => seed,\n    )\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Get the number of sites in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Unlike in the optical SSH model in the previous example, here we need to\n    # introduce two types of phonon modes. One of these phonon modes will have\n    # infinite ion mass, resulting in the associated phonon fields remaining\n    # pinned at zero. The means that when we couple these two types of phonon\n    # modes to the electrons with a SSH-like coupling mechanism, this effectively\n    # results in defining a phonon modes associated with a single bond/hopping\n    # in the lattice.\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon = PhononMode(orbital = 1, Ω_mean = Ω, M = 1.0)\n\n    # Add optical ssh phonon to electron-phonon model.\n    phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon\n    )\n\n    # Define a frozen phonon mode.\n    frozen_phonon = PhononMode(orbital = 1, Ω_mean = Ω, M = Inf)\n\n    # Add frozen phonon mode to electron-phonon model.\n    frozen_phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = frozen_phonon\n    )\n\n    # Define bond SSH coupling.\n    # Defines total effective hopping amplitude given by t_eff = t-α⋅X(i+1,i).\n    bssh_coupling = SSHCoupling(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        phonon_modes = (frozen_phonon_id, phonon_id),\n        bond = bond,\n        α_mean = α\n    )\n\n    # Add bond SSH coupling to the electron-phonon model.\n    bssh_coupling_id = add_ssh_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        ssh_coupling = bssh_coupling,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Write a model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )\n\n    #################################################\n    ### INITIALIZE FINITE LATTICE MODEL PARAMETERS ##\n    #################################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the measurement container.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the measurements associated with the tight-binding model.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the measurements associated with the electron-phonon model.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize time-displaced Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize time-displaced phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(phonon_id, phonon_id)]\n    )\n\n    # Initialize the density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurements.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (bond_id, bond_id)]\n    )\n\n    # Initialize the bond correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"bond\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(bond_id, bond_id)]\n    )\n\n    # Initialize current-current correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"current\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)] # Hopping ID pair.\n    )\n\n    # Initialize the sub-directories the various measurements will be written to.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Allocate and initialize propagators for each imaginary time slice.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize fermion greens calculator.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize equal-time Green's function matrix\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt\n    )\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a swap update.\n        # In a swap update, two phonon modes are randomly selected in the lattice\n        # and their phonon fields are exchanged for all imaginary time slices.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng, phonon_type_pairs = ((phonon_id, phonon_id),)\n        )\n\n        # Record whether the swap update was accepted or rejected.\n        additional_info[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a swap update..\n            (accepted, logdetG, sgndetG) = swap_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, rng = rng, phonon_type_pairs = ((phonon_id, phonon_id),)\n            )\n\n            # Record whether the swap update was accepted or rejected.\n            additional_info[\"swap_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Make measurements.\n            (logdetG, sgndetG, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (electron_phonon_parameters,)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate HMC acceptance rate.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Calculate swap update acceptance rate.\n    additional_info[\"swap_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ω = parse(Float64, ARGS[2])\n    α = parse(Float64, ARGS[3])\n    μ = parse(Float64, ARGS[4])\n    β = parse(Float64, ARGS[5])\n    L = parse(Int, ARGS[6])\n    N_burnin = parse(Int, ARGS[7])\n    N_updates = parse(Int, ARGS[8])\n    N_bins = parse(Int, ARGS[9])\n\n    # Run the simulation.\n    run_bssh_chain_simulation(sID, Ω, α, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"EditURL = \"../../../examples/holstein_chain.jl\"","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/holstein_chain/#Holstein-Chain-with-Density-Tuning","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"","category":"section"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"In this example we simulate the Holstein model for electron-phonon models on a 1D chain given by","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"hatH = hatH_e + hatH_rm ph + hatH_etextrm-ph","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"The first term describes bare tight-binding Hamiltonian","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"hatH_e = -t sum_sigmai (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n            -mu sum_sigmai hatn_sigmai","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. The second terms is the bare phonon Hamiltonian","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"hatH_rm ph = sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"which describes a dispersionless phonon modes on each site in the lattice, where hatX_i  (hatP_i) is the position (momentum) operator for the phonon mode on site i in the lattice. The phonon frequency is given by Omega, and M is the corresponding ion mass associated with the phonon mode. Lastly, the third term introduces the Holstein electron-phonon interaction","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"hatH_etextrm-ph = alpha sum_sigmai hatX_i left( hatn_sigmai - frac12 right)","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"where the strength of the interaction is controlled by the parameter alpha.","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"The example script example_scripts/holstein_chain.jl additionally simulate the Holstein model with an algorithm recently recently introduced in Phys. Rev. E 105, 045311 that dynamically tunes the chemical potential during the simulation to achieve a target electron density.","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"> julia holstein_chain.jl 0 0.1 0.1 0.5 0.0 4.0 16 2000 10000 20","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"Here a Holstein chain of length L=16 is simulate with Omega = 01, alpha = 01 and inverse temperature beta = 40. The chemical potential is initialized to mu = 00, and then tuned to achieve are target electron density of langle n rangle = 05. In this example N_burnin = 2000 thermalizatoin HMC and refleciton updates are performed, followed by an additional N_updates = 10000 such updates, during which time an equivalent number of measurements are made. Bin averaged measurements are written to file N_bins = 20 during the simulation.","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/holstein_chain/","page":"Holstein Chain with Density Tuning","title":"Holstein Chain with Density Tuning","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n# Import the MuTuner module that implements the chemical potential tuning algorithm.\nimport SmoQyDQMC.MuTuner           as mt\n\n# Define top-level function for running the DQMC simulation.\nfunction run_holstein_chain_simulation(sID, Ω, α, n, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_chain_w%.2f_a%.2f_n%.2f_L%d_b%.2f\" Ω α n L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.05\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bin size.\n    bin_size = div(N_updates, N_bins)\n\n    # To update the phonon degrees of freedom in this code we primarily perform\n    # hybrid/hamiltonian Monte Carlo (HMC) updates. Below we specify some of the\n    # parameters associated with these HMC updates.\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 4\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(Nt*Ω)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"reflection_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"Nt\" => Nt,\n        \"dt\" => Δt,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Get the number of sites in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon\n    )\n\n    # Define a on-site Holstein coupling between the electron and the local dispersionless phonon mode.\n    holstein_coupling = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_id,\n    \tbond = lu.Bond(orbitals = (1,1), displacement = [0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model.\n    holstein_coupling_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Write a model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )\n\n    #################################################\n    ### INITIALIZE FINITE LATTICE MODEL PARAMETERS ##\n    #################################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize time-displaced phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(phonon_id, phonon_id)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Note that the spin-up and spin-down electron sectors are equivalent in the Holstein model\n    # without Hubbard interaction. Therefore, there is only a single Fermion determinant\n    # that needs to be calculated. This fact is reflected in the code below.\n\n    # Allocate fermion path integral type.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the fermion path integral type with respect to electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Allocate and initialize propagators for each imaginary time slice.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize fermion greens calculator.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize equal-time Green's function matrix\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt\n    )\n\n    # Initialize the density/chemical potential tuner.\n    # This type facilitates the tuning of the chemical potential to achieve\n    # at target electron density.\n    chemical_potential_tuner = mt.MuTunerLogger(n₀ = n, β = β, V = N, u₀ = 1.0, μ₀ = μ, c = 0.5)\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a reflection update.\n        # This update randomly selects a phonon mode in the lattice and reflects\n        # all the associated phonon about the origin, (xᵢ → -xᵢ).\n        # This updates all the phonon fields to cross the on-site energy barrier\n        # associated with bipolaron formation, helping reduce autocorrelation times.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng, phonon_types = (phonon_id,)\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n\n        # Update the chemical potential.\n        logdetG, sgndetG = update_chemical_potential!(\n            G, logdetG, sgndetG,\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B\n        )\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a reflection update.\n            (accepted, logdetG, sgndetG) = reflection_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, rng = rng, phonon_types = (phonon_id,)\n            )\n\n            # Record whether the reflection update was accepted or rejected.\n            additional_info[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Make measurements.\n            (logdetG, sgndetG, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (electron_phonon_parameters,)\n            )\n\n            # Update the chemical potential.\n            logdetG, sgndetG = update_chemical_potential!(\n                G, logdetG, sgndetG,\n                chemical_potential_tuner = chemical_potential_tuner,\n                tight_binding_parameters = tight_binding_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate HMC acceptance rate.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Calculate reflection update acceptance rate.\n    additional_info[\"reflection_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Save the density tuning profile.\n    save_density_tuning_profile(simulation_info, chemical_potential_tuner)\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ω = parse(Float64, ARGS[2])\n    α = parse(Float64, ARGS[3])\n    n = parse(Float64, ARGS[4]) # target electorn density\n    μ = parse(Float64, ARGS[5]) # intial chemical potential\n    β = parse(Float64, ARGS[6])\n    L = parse(Int, ARGS[7])\n    N_burnin = parse(Int, ARGS[8])\n    N_updates = parse(Int, ARGS[9])\n    N_bins = parse(Int, ARGS[10])\n\n    # Run the simulation.\n    run_holstein_chain_simulation(sID, Ω, α, n, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"EditURL = \"../../../examples/hubbard_threeband.jl\"","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/hubbard_threeband/#Three-Band-Hubbard-Model","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"","category":"section"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"In this example we simulate an effective two-dimensional 3-band Hubbard model meant to represent a copper-oxide plane in the superconducting cuprates, with a Hamiltonian written in hole language given by","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"beginalign*\nhatH=  sum_sigmalangle ijalpharanglet_pd^ijalpha(hatd_sigmai^daggerhatp_sigmajalpha^phantomdagger+rm hc)\n           + sum_sigmalangle ialphajalpharanglet_pp^ialphajalpha(hatp_sigmaialpha^daggerhatp_sigmajalpha^phantomdagger+rm hc)\n          +(epsilon_d-mu)sum_sigmaihatn_uparrowi^d+(epsilon_p-mu)sum_sigmajhatn_sigmajalpha^p\n          +U_dsum_ihatn_uparrowi^dhatn_downarrowi^d+U_psum_jalphahatn_uparrowjalpha^phatn_downarrowjalpha^p\nendalign*","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"The operator hatd^dagger_sigma i  (hatd^phantom dagger_sigma i) creates (annihilates) a spin-sigma hole on a Cu-3d_x^2-y^2 orbital in unit i in the lattice. The hatp^dagger_sigmaialpha  (hatp^phantom dagger_sigmaialpha) operator creates (annihilates) a spin-sigma hole on a O-2p_alpha orbital in unit cell i, where alpha = x  rm or  y The corresponding spin-sigma hole number operators for the Cu-3d_x^2-y^2 and O-2p_alpha orbitals in unit cell i are hatn^d_sigmai and hatn^p_sigmaialpha. The hopping integrals between the Cu-3d_x^2-y^2 orbitals and nearest-neighbor O-2p_alpha are parameterized as t_pd^ijalpha = P_pd^ijalpha t_pd where P_pd^ijalpha = pm 1 is a overall phase factor. Similarly, the hopping integral between nearest-neighbor O-2p_x and O-2p_y orbitals is parameterized as t_pp^ialphajalpha = P_pp^ialphajalpha t_pp, where again P_pp^ialphajalpha t_pp = pm 1 is an overall phase factor. Refer to Fig. 1 in PhysRevB.103.144514 to see a figure detailing these phase factor conventions. The on-site energies epsilon_d and epsilon_p are for the Cu-3d_x^2-y^2 and O-2p_alpha orbitals respectively, and mu is the global chemical potential. Finally, U_d and U_p are the on-site Hubbard interactions for the Cu-3d_x^2-y^2 and O-2p_alpha orbitals respectively.","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"> julia hubbard_threeband.jl 0 8.5 4.1 1.13 0.49 0.0 3.24 0.0 4.0 8 2 2000 10000 50","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"In this example we are simulating the three-band Hubbard model on a 8 times 2 unit cell finite lattice at inverse temperature beta = 40. The on-site Hubbard interaction on the Cu-3d_x^2-y^2 and O-2p_alpha is U_d = 85 and U_p = 41 respectively. The nearest-neighbor hopping integral amplitude between the Cu-3d_x^2-y^2 and O-2p_alpha orbitals is t_pd = 113, while it is t_pp = 049 between the nearest-neighbor O-2p_x and O-2p_y orbitals. The on-site energy for the Cu-3d_x^2-y^2 and O-2p_alpha orbitals epsilon_d = 00 and epsilon_p = 325. Lastly, the global chemical potential is set to mu = 00. In this simulation N_burnin = 2000 sweeps through the lattice updating the Hubbard-Stratonovich fields are performed to thermalize the system, followed by N_udpates = 10000 sweeps, after each of which measurements are made. Bin averaged measurements are written to file N_bins = 50 times during the simulation.","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/hubbard_threeband/","page":"Three-Band Hubbard Model","title":"Three-Band Hubbard Model","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running DQMC simulation\nfunction run_hubbard_threeband_simulation(sID, Ud, Up, tpd, tpp, ϵd, ϵp, μ, β, Lx, Ly, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_threeband_Ud%.2f_Up%.2f_tpd%.2f_tpp%.2f_ed%.2f_ep%.2f_mu%.2f_b%.2f_Lx%d_Ly%d\" Ud Up tpd tpp ϵd ϵp μ β Lx Ly\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[1.0, 0.0], [0.0, 1.0]],\n        basis_vecs   = [[0.0, 0.0], # Orbital ID = 1 <==> Cu-3d\n                        [0.5, 0.0], # Orbital ID = 2 <==> O-2px\n                        [0.0, 0.5]] # Orbital ID = 3 <==> O-2py\n    )\n\n    # Initialize variables to map orbitals to orbital ID.\n    (Cu_3d, O_2px, O_2py) = (1, 2, 3)\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [Lx, Ly],\n        periodic = [true, true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define bond going from Cu-3d to O-2px in +x direction.\n    bond_3d_2px_px = lu.Bond(orbitals = (Cu_3d, O_2px), displacement = [0,0])\n    bond_3d_2px_px_id = add_bond!(model_geometry, bond_3d_2px_px)\n\n    # Define bond going from Cu-3d to O-2py in +y direction.\n    bond_3d_2py_py = lu.Bond(orbitals = (Cu_3d, O_2py), displacement = [0,0])\n    bond_3d_2py_py_id = add_bond!(model_geometry, bond_3d_2py_py)\n\n    # Define bond going from Cu-3d to O-2px in -x direction.\n    bond_2px_3d_nx = lu.Bond(orbitals = (Cu_3d, O_2px), displacement = [-1,0])\n    bond_2px_3d_nx_id = add_bond!(model_geometry, bond_2px_3d_nx)\n\n    # Define bond going from Cu-3d to O-2py in -y direction.\n    bond_2py_3d_ny = lu.Bond(orbitals = (Cu_3d, O_2py), displacement = [0,-1])\n    bond_2py_3d_ny_id = add_bond!(model_geometry, bond_2py_3d_ny)\n\n    # Define bond going from O-2px to O-2py in the (-x+y)/√2 direction.\n    bond_2px_2py_nxpy = lu.Bond(orbitals = (O_2px, O_2py), displacement = [0,0])\n    bond_2px_2py_nxpy_id = add_bond!(model_geometry, bond_2px_2py_nxpy)\n\n    # Define bond going to O-2px to O-2py in the (-x-y)/√2 direction.\n    bond_2px_2py_nxny = lu.Bond(orbitals = (O_2px, O_2py), displacement = [0,-1])\n    bond_2px_2py_nxny_id = add_bond!(model_geometry, bond_2px_2py_nxny)\n\n    # Define bond going from O-2px to O-2py in the (+x+y)/√2 direction.\n    bond_2px_2py_pxpy = lu.Bond(orbitals = (O_2px, O_2py), displacement = [1,0])\n    bond_2px_2py_pxpy_id = add_bond!(model_geometry, bond_2px_2py_pxpy)\n\n    # Define bond going from O-2px to O-2py in the (+x-y)/√2 direction.\n    bond_2px_2py_pxny = lu.Bond(orbitals = (O_2px, O_2py), displacement = [1,-1])\n    bond_2px_2py_pxny_id = add_bond!(model_geometry, bond_2px_2py_pxny)\n\n    # These nexts bonds are needed to measuring a pairing channel needed to\n    # reconstruct the d-wave pair susceptibility.\n\n    # Define bond going from Cu-3d to Cu-3d in +x direction.\n    bond_3d_3d_px = lu.Bond(orbitals = (Cu_3d, Cu_3d), displacement = [1, 0])\n    bond_3d_3d_px_id = add_bond!(model_geometry, bond_3d_3d_px)\n\n    # Define bond going from Cu-3d to Cu-3d in -x direction.\n    bond_3d_3d_nx = lu.Bond(orbitals = (Cu_3d, Cu_3d), displacement = [-1, 0])\n    bond_3d_3d_nx_id = add_bond!(model_geometry, bond_3d_3d_nx)\n\n    # Define bond going from Cu-3d to Cu-3d in +y direction.\n    bond_3d_3d_py = lu.Bond(orbitals = (Cu_3d, Cu_3d), displacement = [0, 1])\n    bond_3d_3d_py_id = add_bond!(model_geometry, bond_3d_3d_py)\n\n    # Define bond going from Cu-3d to Cu-3d in -y direction.\n    bond_3d_3d_ny = lu.Bond(orbitals = (Cu_3d, Cu_3d), displacement = [0, -1])\n    bond_3d_3d_ny_id = add_bond!(model_geometry, bond_3d_3d_ny)\n\n    # Define tight binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        μ = μ,\n        ϵ_mean  = [ϵd, ϵp, ϵp],\n        t_bonds = [bond_3d_2px_px, bond_3d_2py_py, bond_2px_3d_nx, bond_2py_3d_ny,\n                   bond_2px_2py_nxpy, bond_2px_2py_nxny, bond_2px_2py_pxpy, bond_2px_2py_pxny],\n        t_mean  = [tpd, -tpd, -tpd, tpd, -tpp, tpp, tpp, -tpp]\n    )\n\n    # Initialize a finite Hubbard interaction just on copper orbitals.\n    if iszero(Up)\n        hubbard_model = HubbardModel(\n            shifted   = true, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n            U_orbital = [1, 2, 3],\n            U_mean    = [Ud, Up, Up],\n        )\n    # Initialize the Hubbard interaction on copper and oxygen orbitals.\n    else\n        hubbard_model = HubbardModel(\n            shifted   = true, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n            U_orbital = [1],\n            U_mean    = [Ud],\n        )\n    end\n\n    # Write the model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (Cu_3d, O_2px), (Cu_3d, O_2py), (O_2px, O_2py)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (Cu_3d, O_2px), (Cu_3d, O_2py), (O_2px, O_2py)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (Cu_3d, O_2px), (Cu_3d, O_2py), (O_2px, O_2py)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (Cu_3d, O_2px), (Cu_3d, O_2py), (O_2px, O_2py)]\n    )\n\n    # Measure all possible combinations of bond pairing channels\n    # for the bonds we have defined. We will need each of these\n    # pairs channels measured in order to reconstruct the extended\n    # s-wave and d-wave pair susceptibilities.\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (bond_3d_3d_px_id, bond_3d_3d_px_id), (bond_3d_3d_px_id, bond_3d_3d_nx_id),\n                 (bond_3d_3d_nx_id, bond_3d_3d_px_id), (bond_3d_3d_nx_id, bond_3d_3d_nx_id),\n                 (bond_3d_3d_py_id, bond_3d_3d_py_id), (bond_3d_3d_py_id, bond_3d_3d_ny_id),\n                 (bond_3d_3d_ny_id, bond_3d_3d_py_id), (bond_3d_3d_ny_id, bond_3d_3d_ny_id),\n                 (bond_3d_3d_px_id, bond_3d_3d_py_id), (bond_3d_3d_px_id, bond_3d_3d_ny_id),\n                 (bond_3d_3d_nx_id, bond_3d_3d_py_id), (bond_3d_3d_nx_id, bond_3d_3d_ny_id),\n                 (bond_3d_3d_py_id, bond_3d_3d_px_id), (bond_3d_3d_py_id, bond_3d_3d_nx_id),\n                 (bond_3d_3d_ny_id, bond_3d_3d_px_id), (bond_3d_3d_ny_id, bond_3d_3d_nx_id)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters, hubbard_ising_parameters)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    # Measure the d-wave pair suspcetibility.\n    P_d, ΔP_d = composite_correlation_stats(\n        folder = simulation_info.datafolder,\n        correlation = \"pair\",\n        space = \"momentum\",\n        type = \"integrated\",\n        ids = [(bond_3d_3d_px_id, bond_3d_3d_px_id), (bond_3d_3d_px_id, bond_3d_3d_nx_id),\n               (bond_3d_3d_nx_id, bond_3d_3d_px_id), (bond_3d_3d_nx_id, bond_3d_3d_nx_id),\n               (bond_3d_3d_py_id, bond_3d_3d_py_id), (bond_3d_3d_py_id, bond_3d_3d_ny_id),\n               (bond_3d_3d_ny_id, bond_3d_3d_py_id), (bond_3d_3d_ny_id, bond_3d_3d_ny_id),\n               (bond_3d_3d_px_id, bond_3d_3d_py_id), (bond_3d_3d_px_id, bond_3d_3d_ny_id),\n               (bond_3d_3d_nx_id, bond_3d_3d_py_id), (bond_3d_3d_nx_id, bond_3d_3d_ny_id),\n               (bond_3d_3d_py_id, bond_3d_3d_px_id), (bond_3d_3d_py_id, bond_3d_3d_nx_id),\n               (bond_3d_3d_ny_id, bond_3d_3d_px_id), (bond_3d_3d_ny_id, bond_3d_3d_nx_id)],\n        locs = [(0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0)],\n        num_bins = N_bins,\n        f = (P_px_px, P_px_nx,\n             P_nx_px, P_nx_nx,\n             P_py_py, P_py_ny,\n             P_ny_py, P_ny_ny,\n             P_px_py, P_px_ny,\n             P_nx_py, P_nx_ny,\n             P_py_px, P_py_nx,\n             P_ny_px, P_ny_nx) -> (P_px_px + P_px_nx +\n                                   P_nx_px + P_nx_nx +\n                                   P_py_py + P_py_ny +\n                                   P_ny_py + P_ny_ny -\n                                   P_px_py - P_px_ny -\n                                   P_nx_py - P_nx_ny -\n                                   P_py_px - P_py_nx -\n                                   P_ny_px - P_ny_nx)/4\n    )\n\n    # Record the d-wave pair suspcetibility.\n    additional_info[\"P_d_mean\"] = real(P_d)\n    additional_info[\"P_d_std\"]  = ΔP_d\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    return nothing\nend\n\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ud = parse(Float64, ARGS[2])\n    Up = parse(Float64, ARGS[3])\n    tpd = parse(Float64, ARGS[4])\n    tpp = parse(Float64, ARGS[5])\n    ϵd = parse(Float64, ARGS[6])\n    ϵp = parse(Float64, ARGS[7])\n    μ = parse(Float64, ARGS[8])\n    β = parse(Float64, ARGS[9])\n    Lx = parse(Int, ARGS[10])\n    Ly = parse(Int, ARGS[11])\n    N_burnin = parse(Int, ARGS[12])\n    N_updates = parse(Int, ARGS[13])\n    N_bins = parse(Int, ARGS[14])\n\n    # Run the simulation.\n    run_hubbard_threeband_simulation(sID, Ud, Up, tpd, tpp, ϵd, ϵp, μ, β, Lx, Ly, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Simulation-Information-Type-and-Methods","page":"API","title":"Simulation Information Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SimulationInfo\ninitialize_datafolder\nmodel_summary","category":"page"},{"location":"api/","page":"API","title":"API","text":"SimulationInfo\nSimulationInfo(;)\ninitialize_datafolder\nmodel_summary","category":"page"},{"location":"api/#SmoQyDQMC.SimulationInfo","page":"API","title":"SmoQyDQMC.SimulationInfo","text":"SimulationInfo\n\nContains identification information about simulation, including the location data is written to, the simulation ID, and MPI process ID, and whether this simulation started a new simulation or resumed a previous simulation.\n\nFields\n\nfilepath::String: File path to where data folder lives.\ndatafolder_prefix: Prefix for the data folder name.\ndatafolder_name::String: The data folder name, given by $(datafolder_prefix)_$(sID).\ndatafolder::String: The data folder, including filepath, given by joinpath(filepath, datafolder_name).\npID::Int: MPI process ID, defaults to 0 if MPI not being used.\nsID::Int: Simulation ID.\nresuming::Bool: Whether current simulation is resuming a previous simulation (true) or starting a new one (false).\nsmoqy_version::VersionNumber: Version of SmoQyDQMC.jl used in simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SimulationInfo-Tuple{}","page":"API","title":"SmoQyDQMC.SimulationInfo","text":"SimulationInfo(; datafolder_prefix::String, filepath::String = \".\", sID::Int=0, pID::Int=0)\n\nInitialize and return in instance of the type SimulationInfo.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize_datafolder","page":"API","title":"SmoQyDQMC.initialize_datafolder","text":"initialize_datafolder(sim_info::SimulationInfo)\n\nInitalize sim_info.datafolder directory if it does not already exist.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.model_summary","page":"API","title":"SmoQyDQMC.model_summary","text":"model_summary(;\n    simulation_info::SimulationInfo,\n    β::T, Δτ::T, model_geometry::ModelGeometry,\n    tight_binding_model::Union{TightBindingModel,Nothing} = nothing,\n    tight_binding_model_up::Union{TightBindingModel,Nothing} = nothing,\n    tight_binding_model_dn::Union{TightBindingModel,Nothing} = nothing,\n    interactions::Tuple\n) where {T<:AbstractFloat}\n\nWrite model to summary to file. Note that either tight_binding_model or tight_binding_model_up and tight_binding_model_dn need to be specified.\n\n\n\n\n\n","category":"function"},{"location":"api/#Model-Geometry-Type-and-Methods","page":"API","title":"Model Geometry Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ModelGeometry\nadd_bond!\nget_bond_id","category":"page"},{"location":"api/","page":"API","title":"API","text":"ModelGeometry\nModelGeometry(::UnitCell{D}, ::Lattice{D}) where {D}\nadd_bond!\nget_bond_id","category":"page"},{"location":"api/#SmoQyDQMC.ModelGeometry","page":"API","title":"SmoQyDQMC.ModelGeometry","text":"ModelGeometry{D, T<:AbstractFloat, N}\n\nContains all the information defining the lattice geometry for the model in D spatial dimensions.\n\nComment\n\nThe bond ID associated with a bond::Bond{D} corresponds to the index associated with it into the bonds vector field.\n\nFields\n\nunit_cell::UnitCell{D,T,N}: Defines unit cell.\nlattice::Lattice{D}: Defines finite lattice extent.\nbonds::Vector{Bond{D}}: All available bond definitions in simulation, with vector indices giving the bond ID.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ModelGeometry-Union{Tuple{D}, Tuple{UnitCell{D}, Lattice{D}}} where D","page":"API","title":"SmoQyDQMC.ModelGeometry","text":"ModelGeometry(unit_cell::UnitCell, lattice::Lattice)\n\nInitialize and return a ModelGeometry instance. Defines a \"trivial\" bond defintion for each orbital in the unit cell that connects an orbital to itself.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.add_bond!","page":"API","title":"SmoQyDQMC.add_bond!","text":"addbond!(modelgeometry::ModelGeometry{D,T}, bond::Bond{D}) where {D, T}   \n\nAdd bond definition to model_geometry, returning the bond ID i.e. the index to bond in the vector model_geometry.bonds. This method first checks that bond is not already defined. If it is this method simply returns the corresponding bond ID. If bond is not already defined, then it is appended to the vector model_geometry.bonds.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.get_bond_id","page":"API","title":"SmoQyDQMC.get_bond_id","text":"get_bond_id(model_geometry::ModelGeometry{D,T}, bond::Bond{D}) where {D, T}\n\nReturn the bond ID associated with the bond defintion bond, returning bond_id=0 if the it is not a recorded bond.\n\n\n\n\n\n","category":"function"},{"location":"api/#Fermion-Path-Integral-Type-and-Methods","page":"API","title":"Fermion Path Integral Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FermionPathIntegral\ninitialize_propagators\ncalculate_propagators!\ncalculate_propagator!","category":"page"},{"location":"api/","page":"API","title":"API","text":"FermionPathIntegral\nFermionPathIntegral(;)\ninitialize_propagators\ncalculate_propagators!\ncalculate_propagator!","category":"page"},{"location":"api/#SmoQyDQMC.FermionPathIntegral","page":"API","title":"SmoQyDQMC.FermionPathIntegral","text":"FermionPathIntegral{T<:Number, E<:AbstractFloat}\n\nRepresents a fermion path integral. In particular, contains the information to represent each diagonal on-site energy matrix V_l and hopping matrix K_l for each imaginary time slicel in 1 L_tau such that tau = Deltatau cdot l and beta = Deltatau cdot L_tau\n\nFields\n\nβ::E: Inverse temperature.\nΔτ::E: Discretization in imaginary time.\nLτ::Int: Length of the imaginary time axis.\nN::Int: Number of orbitals in the lattice.\nneighbor_table::Matrix{Int}: Neighbor table for each pair of orbitals in the lattice connected by a hopping.\nt::Matrix{T}: Hopping amplitudes for imaginary time slice l is stored in t[:,l].\nV::Matrix{T}: Diagonal on-site energy matrix V_l for imaginary time slice l is stored in V[:,l].\nK::Matrix{T}: Used to construct hopping matrix to cacluate exponentiated hopping matrix if checkerboard approximation is not being used.\neigen_ws::HermitianEigenWs{T,Matrix{T},E}: For calculating eigenvalues and eigenvectors of K while avoiding dynamic memory allocations.\nu::Vector{T}: Temporary vector to avoid dynamic allocation when performing local updates.\nv::Vector{T}: Temporary vector to avoid dynamic allocation when performing local updates.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.FermionPathIntegral-Tuple{}","page":"API","title":"SmoQyDQMC.FermionPathIntegral","text":"FermionPathIntegral(;\n    tight_binding_parameters::TightBindingParameters{T,E},\n    β::E, Δτ::E\n) where {T,E}\n\nInitialize an instance of FermionPathIntegral an instance of TightBindingParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize_propagators","page":"API","title":"SmoQyDQMC.initialize_propagators","text":"initialize_propagators(fpi::FermionPathIntegral{T,E}; symmetric::Bool, checkerboard::Bool) where {T,E}\n\nInitialize a propagator for each imaginary time slice, returning a vector of type Vector{<:AbstractPropagators{T,E}}.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.calculate_propagators!","page":"API","title":"SmoQyDQMC.calculate_propagators!","text":"calculate_propagators!(B::Vector{P}, fpi::FermionPathIntegral{T,E};\n                       calculate_exp_V::Bool, calculate_exp_K::Bool) where {T, E, P<:AbstractPropagator{T,E}}\n\nCalculate the propagator matrices B_l, given by B[l], for all imaginary time slice tau = Deltatau cdot l If calculate_exp_V = true, then calculate the diagonal exponentiated on-site energy matrices. If calculate_exp_K = true, then calculate the exponentiated hopping matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.calculate_propagator!","page":"API","title":"SmoQyDQMC.calculate_propagator!","text":"calculate_propagator!(B::AbstractPropagator{T,E}, fpi::FermionPathIntegral{T,E}, l::Int;\n                      calculate_exp_V::Bool, calculate_exp_K::Bool) where {T,E}\n\nCalculate the propagator matrix B_l for imaginary time slice tau = Deltatau cdot l If calculate_exp_V = true, then calculate the diagonal exponentiated on-site energy matrix. If calculate_exp_K = true, then calculate the exponentiated hopping matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#Update-Numerical-Stabilization-Frequency","page":"API","title":"Update Numerical Stabilization Frequency","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"update_stabalization_frequency!","category":"page"},{"location":"api/","page":"API","title":"API","text":"update_stabalization_frequency!","category":"page"},{"location":"api/#SmoQyDQMC.update_stabalization_frequency!","page":"API","title":"SmoQyDQMC.update_stabalization_frequency!","text":"update_stabalization_frequency!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n                                Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T;\n                                fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                                fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                                Bup::Vector{P}, Bdn::Vector{P}, δG::E, δθ::E, n_stab::Int,\n                                δG_max::E) where {E<:AbstractFloat, T<:Number, P<:AbstractPropagator{T,E}}\n\nIf the corrected error in the Green's funciton matrix is too large, δG > δG_max, then increase the frequency of numerical stablization by decrementing n_stab such that it is updated to n_stab = max(n_stab - 1, 1), and update the equal-time Green's function matrices and all related variables and types. If the frequency of stabilization is udpated, then δG and δθ are reset to zero. This method returns a tuple of the following variables:\n\n(logdetGup, sgndetGdn, logdetGup, sgndetGdn, δG, δθ),\n\nwhere updated = true if n_stab was decremented.\n\n\n\n\n\nupdate_stabalization_frequency!(G::Matrix{T}, logdetG::E, sgndetG::T;\n                                fermion_greens_calculator::FermionGreensCalculator{T,E},\n                                B::Vector{P}, δG::E, δθ::E, n_stab::Int,\n                                δG_max::E) where {E<:AbstractFloat, T<:Number, P<:AbstractPropagator{T,E}}\n\nIf the corrected error in the Green's funciton matrix is too large, δG > δG_max, then increase the frequency of numerical stablization by decrementing n_stab such that it is updated to n_stab = max(n_stab - 1, 1), and update the equal-time Green's function matrices and all related variables and types. If the frequency of stabilization is udpated, then δG and δθ are reset to zero. This method returns a tuple of the following variables:\n\n(updated, logdetG, sgndetG, δG, δθ),\n\nwhere updated = true if n_stab was decremented.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tight-Binding-Model","page":"API","title":"Tight-Binding Model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TightBindingModel\nTightBindingParameters\nmeasure_onsite_energy\nmeasure_hopping_energy\nmeasure_bare_hopping_energy\nmeasure_hopping_amplitude\nmeasure_hopping_inversion\nmeasure_hopping_inversion_avg","category":"page"},{"location":"api/","page":"API","title":"API","text":"TightBindingModel\nTightBindingModel(;)\nTightBindingParameters\nTightBindingParameters(;)\nmeasure_onsite_energy\nmeasure_hopping_energy\nmeasure_bare_hopping_energy\nmeasure_hopping_amplitude\nmeasure_hopping_inversion\nmeasure_hopping_inversion_avg","category":"page"},{"location":"api/#SmoQyDQMC.TightBindingModel","page":"API","title":"SmoQyDQMC.TightBindingModel","text":"TightBindingModel{T<:Number, E<:AbstractFloat, D}\n\nDefines a tight binding model in D dimensions. Note that spin = 1 (spin = 2) corresponds to spin-up (spin-down), and spin = 0 corresponds to both spin-up and spin-down.\n\nFields\n\nμ::E: Chemical potential.\nϵ_mean::Vector{E}: Mean on-site energy for each orbital in the unit cell. \nϵ_std::Vector{E}: Standard deviation of on-site energy for each orbital in the unit cell.\nt_bond_ids::Vector{Int}: The bond ID for each bond/hopping definition.\nt_bonds::Vector{Bond{D}}: Bond definition for each type of hopping in the tight binding model.\nt_mean::Vector{T}: Mean hopping energy for each type of hopping.\nt_std::Vector{E}: Standard deviation of hopping energy for each type of hopping.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.TightBindingModel-Tuple{}","page":"API","title":"SmoQyDQMC.TightBindingModel","text":"TightBindingModel(;\n    model_geometry::ModelGeometry{D,E,N},\n    μ::E,\n    ϵ_mean::Vector{E},\n    ϵ_std::Vector{E} = zeros(eltype(ϵ_mean), length(ϵ_mean)),\n    t_bonds::Vector{Bond{D}} = Bond{ndims(model_geometry.unit_cell)}[],\n    t_mean::Vector{T} = eltype(ϵ_mean)[],\n    t_std::Vector{E} = zeros(eltype(ϵ_mean), length(t_mean))\n) where {T<:Number, E<:AbstractFloat, D, N}\n\nInitialize and return an instance of TightBindingModel, also adding/recording the bond defintions t_bonds to the ModelGeometry instance model_geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.TightBindingParameters","page":"API","title":"SmoQyDQMC.TightBindingParameters","text":"TightBindingParameters{T<:Number, E<:AbstractFloat}\n\nA mutable struct containing all the parameters needed to characterize a finite tight-binding Hamiltonian for a single spin species sigma on a finite lattice with periodic boundary conditions of the form\n\nhatH_0sigma=-sum_langle ijrangle(t_ij hatc_sigmai^daggerhatc_sigmaj+textrmhc)+sum_i(epsilon_i-mu)hatn_sigmai\n\nwhere hatc_sigmai^dagger is the fermion creation operator for an electron with spin sigma on orbital i t_ij are the hopping energies, epsilon_i are the on-site energies for each orbital in the lattice, and mu is the chemical potential.\n\nFields\n\nμ::E: The chemical potential mu\nconst ϵ::Vector{E}: A vector containing the on-site energy epsilon_i for each orbital in the lattice.\nconst t::Vector{T}: The hopping energy t_ij associated with each pair of neighboring orbitals connected by a bond in the lattice.\nconst neighbor_table::Matrix{Int}: Neighbor table containing all pairs of orbitals in the lattices connected by a bond, with a non-zero hopping energy between them.\nconst bond_ids::Vector{Int}: The bond ID definitions that define the types of hopping in the lattice.\nconst bond_slices::Vector{UnitRange{Int}}: Slices of neighbor_table corresponding to given bond ID i.e. the neighbors neighbor_table[:,bond_slices[1]] corresponds the bond_ids[1] bond defintion.\nconst norbital::Int: Number of orbitals per unit cell.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.TightBindingParameters-Tuple{}","page":"API","title":"SmoQyDQMC.TightBindingParameters","text":"TightBindingParameters(;\n    tight_binding_model::TightBindingModel{T,E,D},\n    model_geometry::ModelGeometry{D,E},\n    rng::AbstractRNG\n) where {T,E,D}\n\nInitialize and return an instance of TightBindingParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.measure_onsite_energy","page":"API","title":"SmoQyDQMC.measure_onsite_energy","text":"measure_onsite_energy(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    G::Matrix{T}, orbital_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nMeasure and return the on-site energy epsilon_textrmon-site = (epsilon - mu)langle hatn_sigma rangle for the orbital_id in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_hopping_energy","page":"API","title":"SmoQyDQMC.measure_hopping_energy","text":"measure_hopping_energy(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{T,E},\n    G::Matrix{T}, bond_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average hopping energy epsilon_rm hopping = -langle t_llangle ij rangle hatc^dagger_sigmai hatc_sigmaj + rm hc rangle for the hopping defined by the bond corresponding to bond_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_bare_hopping_energy","page":"API","title":"SmoQyDQMC.measure_bare_hopping_energy","text":"measure_bare_hopping_energy(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    G::Matrix{T}, bond_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average bare hopping energy epsilon_rm hopping = -langle t_langle ij rangle hatc^dagger_sigmai hatc_sigmaj + rm hc rangle for the hopping defined by the bond corresponding to bond_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_hopping_amplitude","page":"API","title":"SmoQyDQMC.measure_hopping_amplitude","text":"measure_hopping_amplitude(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{T,E},\n    bond_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average hopping amplitude for the hopping defined by the bond corresponding to bond_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_hopping_inversion","page":"API","title":"SmoQyDQMC.measure_hopping_inversion","text":"measure_hopping_inversion(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{T,E},\n    bond_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nMeasure the fraction of time the sign of the instaneous modulated hopping ampltiude t_l(mathbfinu)(mathbfjgamma) is inverted relative to the bare hopping amplitude t_(mathbfinu)(mathbfjgamma), where l is the imaginary time-slice index.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_hopping_inversion_avg","page":"API","title":"SmoQyDQMC.measure_hopping_inversion_avg","text":"measure_hopping_inversion_avg(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{T,E},\n    bond_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nMeasure the fraction of time the sign of the imaginary-time averaged modulated hopping ampltiude bart_(mathbfinu)(mathbfjgamma) is inverted relative to the bare hopping amplitude t_(mathbfinu)(mathbfjgamma).\n\n\n\n\n\n","category":"function"},{"location":"api/#Hubbard-Model","page":"API","title":"Hubbard Model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HubbardModel\nHubbardParameters\ninitialize!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Hubbard Model Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"measure_hubbard_energy","category":"page"},{"location":"api/","page":"API","title":"API","text":"Hubbard Ising Hubbard-Stratonovich Transformation Types and Methods","category":"page"},{"location":"api/","page":"API","title":"API","text":"HubbardIsingHSParameters\ninitialize!\nlocal_updates!\nreflection_update!\nswap_update!","category":"page"},{"location":"api/","page":"API","title":"API","text":"HubbardModel\nHubbardModel(;)\nHubbardParameters\nHubbardParameters(;)\ninitialize!(::FermionPathIntegral{T,E}, ::FermionPathIntegral{T,E}, ::HubbardParameters{E}) where {T,E}","category":"page"},{"location":"api/#SmoQyDQMC.HubbardModel","page":"API","title":"SmoQyDQMC.HubbardModel","text":"HubbardModel{T<:AbstractFloat}\n\nIf shifted = true, then a Hubbard interaction of the form\n\nhatH_U=sum_mathbfinuU_numathbfihatn_uparrownumathbfihatn_downarrownumathbfi\n\nis assumed, where mathbfi specifies the unit cell, and nu denotes the orbital in the unit cell. For a bipartite lattice with only nearest neighbor hopping, the on-site energy corresponding to half-filling and particle-hole symmetry is epsilon_numathbfi = -U_numathbfi2\n\nIf shifted = false, then a Hubbard interaction of the form\n\nhatH_U=sum_mathbfinuU_numathbfi(hatn_uparrownumathbfi-tfrac12)(hatn_downarrownumathbfi-tfrac12)\n\nis assumed. In this case, for a bipartite lattice with only nearest neighbor hopping, the on-site energy corresponding to half-filling and particle-hole symmetry is epsilon_numathbfi = 0\n\nFields\n\nshifted::Bool: Determines which form for Hubbard interaction is used, and whether the on-site energies need to be shifted.\nU_orbital::Vector{Int}: Orbital species in unit cell with finite Hubbard interaction.\nU_mean::Vector{T}: Average Hubbard U_nu for a given orbital species in the lattice.\nU_std::Vector{T}: Standard deviation of Hubbard U_nu for a given orbital species in the lattice.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardModel-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardModel","text":"HubbardModel(;\n    shifted::Bool,\n    U_orbital::AbstractVector{Int},\n    U_mean::AbstractVector{T},\n    U_std::AbstractVector{T} = zero(U_mean)\n) where {T<:AbstractFloat}\n\nInitialize and return an instance of the type HubbardModel.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.HubbardParameters","page":"API","title":"SmoQyDQMC.HubbardParameters","text":"HubbardParameters{T<:AbstractFloat}\n\nHubbard parameters for finite lattice.\n\nFields\n\nU::Vector{T}: On-site Hubbard interaction for each site with finite Hubbard interaction.\nsites::Vector{Int}: Site index associated with each finite Hubbard U interaction.\norbitals::Vector{Int}: Orbital species in unit cell with finite Hubbard interaction.\nshifted::Bool: Convention used for Hubbard interaction, refer to HubbardModel for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardParameters-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardParameters","text":"HubbardParameters(;\n    hubbard_model::HubbardModel{T},\n    model_geometry::ModelGeometry{D,T},\n    rng::AbstractRNG\n) where {D, T<:AbstractFloat}\n\nInitialize an instance of HubbardParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, HubbardParameters{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    hubbard_parameters::HubbardParameters{E}\n) where {T,E}\n\ninitialize!(\n    fermion_path_integral::FermionPathIntegral{T,E},\n    hubbard_parameters::HubbardParameters{E}\n) where {T,E}\n\nInitialize the contribution from the Hubbard interaction to a FermionPathIntegral instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hubbard-Model-Measurements","page":"API","title":"Hubbard Model Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"measure_hubbard_energy","category":"page"},{"location":"api/#SmoQyDQMC.measure_hubbard_energy","page":"API","title":"SmoQyDQMC.measure_hubbard_energy","text":"measure_hubbard_energy(\n    hubbard_parameters::HubbardParameters{E},\n    Gup::Matrix{T}, Gdn::Matrix{T},\n    orbital_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average Hubbard energy U langle hatn_uparrow hatn_downarrow rangle if shifted = true and U langle (hatn_uparrow - tfrac12)(hatn_downarrow - tfrac12)rangle if shifted = false for the orbital corresponding orbital_id in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#Hubbard-Ising-Hubbard-Stratonovich-Transformation-Types-and-Methods","page":"API","title":"Hubbard Ising Hubbard-Stratonovich Transformation Types and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HubbardIsingHSParameters\nHubbardIsingHSParameters(;)\ninitialize!(::FermionPathIntegral{T,E}, ::FermionPathIntegral{T,E}, ::HubbardIsingHSParameters{E}) where {T,E}\ninitialize!(::FermionPathIntegral{T,E}, ::HubbardIsingHSParameters{E}) where {T,E}\nlocal_updates!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E})  where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nlocal_updates!(::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E})  where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nreflection_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nreflection_update!(::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nswap_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nswap_update!(::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}","category":"page"},{"location":"api/#SmoQyDQMC.HubbardIsingHSParameters","page":"API","title":"SmoQyDQMC.HubbardIsingHSParameters","text":"HubbardIsingHSParameters{T<:AbstractFloat}\n\nParameters associated with decoupling the Hubbard interaction using the standard Ising Hubbard-Stratonovich (HS) transformation.\n\nFields\n\nβ::T: Inverse temperature.\nΔτ::T: Discretization in imaginary time.\nLτ::Int: Length of imaginary time axis.\nN::Int: Number of orbitals in the lattice.\nU::Vector{T}: Each hubbard interaction.\nα::Vector{T}: The constant given by cosh(alpha_i) = e^Deltatau vert U_i vert2\nsites::Vector{Int}: Site index associated with each finite Hubbard U interaction.\ns::Matrix{Int}: Ising Hubbard-Stratonovich fields.\nupdate_perm::Vector{Int}: Order in which to iterate over HS fields in time slice when performing local updates.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardIsingHSParameters-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardIsingHSParameters","text":"HubbardIsingHSParameters(; β::E, Δτ::E,\n                         hubbard_parameters::HubbardParameters{E},\n                         rng::AbstractRNG) where {E<:AbstractFloat}\n\nInitialize and return an instance of the HubbardIsingHSParameters type. Note that on-site energies fpi.V are shifted by -U_i2 if hmshifted = true.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, HubbardIsingHSParameters{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(fermion_path_integral_up::FermionPathIntegral{T,E},\n            fermion_path_integral_dn::FermionPathIntegral{T,E},\n            hubbard_ising_parameters::HubbardIsingHSParameters{E}) where {T,E}\n\nInitialize the contribution from the Hubbard interaction to the FermionPathIntegral instance fermion_path_integral_up for spin up and fermion_path_integral_dn spin down.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, HubbardIsingHSParameters{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(fermion_path_integral::FermionPathIntegral{T,E},\n            hubbard_ising_parameters::HubbardIsingHSParameters{E}) where {T,E}\n\nInitialize the contribution from an attractive Hubbard interaction to the FermionPathIntegral instance fermion_path_integral.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.local_updates!","text":"local_updates!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n               Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n               hubbard_ising_parameters::HubbardIsingHSParameters{E};\n               fermion_path_integral_up::FermionPathIntegral{T,E},\n               fermion_path_integral_dn::FermionPathIntegral{T,E},\n               fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n               fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n               Bup::Vector{P}, Bdn::Vector{P},\n               δG_max::E, δG::E, δθ::E,  rng::AbstractRNG,\n               update_stabilization_frequency::Bool=true) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nSweep through every imaginary time slice and orbital in the lattice, peforming local updates to every Ising Hubbard-Stratonovich (HS) field.\n\nThis method returns the a tuple containing (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ).\n\nArguments\n\nGup::Matrix{T}: Spin-up equal-time Green's function matrix.\nlogdetGup::E: The log of the absolute value of the determinant of the spin-up equal-time Green's function matrix, log vert det G_uparrow(tautau) vert\nsgndetGup::T: The sign/phase of the determinant of the spin-up equal-time Green's function matrix, det G_uparrow(tautau)  vert det G_uparrow(tautau) vert\nGdn::Matrix{T}: Spin-down equal-time Green's function matrix.\nlogdetGdn::E: The log of the absolute value of the determinant of the spin-down equal-time Green's function matrix, log vert det G_downarrow(tautau) vert\nsgndetGdn::T: The sign/phase of the determinant of the spin-down equal-time Green's function matrix, det G_downarrow(tautau)  vert det G_downarrow(tautau) vert\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of the FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of the FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: An instance of the FermionGreensCalculator type for the spin-up electrons.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: An instance of the FermionGreensCalculator type for the spin-down electrons.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-dn propagators for each imaginary time slice.\nδG_max::E: Maximum allowed error corrected by numerical stabilization.\nδG::E: Previously recorded maximum error in the Green's function corrected by numerical stabilization.\nδθ::T: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green's function matrix corrected by numerical stabilization.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nupdate_stabilization_frequency::Bool=true: If true, allows the stabilization frequency n_stab to be dynamically adjusted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.local_updates!","text":"local_updates!(G::Matrix{T}, logdetG::E, sgndetG::T,\n               hubbard_ising_parameters::HubbardIsingHSParameters{E};\n               fermion_path_integral::FermionPathIntegral{T,E},\n               fermion_greens_calculator::FermionGreensCalculator{T,E},\n               B::Vector{P}, δG_max::E, δG::E, δθ::E, rng::AbstractRNG,\n               update_stabilization_frequency::Bool=true) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nSweep through every imaginary time slice and orbital in the lattice, performing local updates to every Ising Hubbard-Stratonovich (HS) field, assuming strictly attractive Hubbard interactions and perfect spin symmetry.\n\nThis method returns the a tuple containing (acceptance_rate, logdetG, sgndetG, δG, δθ).\n\nArguments\n\nG::Matrix{T}: Equal-time Green's function matrix.\nlogdetG::E: The log of the absolute value of the determinant of theequal-time Green's function matrix, log vert det G_uparrow(tautau) vert\nsgndetG::T: The sign/phase of the determinant of the equal-time Green's function matrix, det G_uparrow(tautau)  vert det G_uparrow(tautau) vert\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of the FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: An instance of the FermionGreensCalculator type.\nB::Vector{P}: Propagators for each imaginary time slice.\nδG_max::E: Maximum allowed error corrected by numerical stabilization.\nδG::E: Previously recorded maximum error in the Green's function corrected by numerical stabilization.\nδθ::T: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green's function matrix corrected by numerical stabilization.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nupdate_stabilization_frequency::Bool=true:  If true, allows the stabilization frequency n_stab to be dynamically adjusted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n                   Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n                   hubbard_ising_parameters::HubbardIsingHSParameters{E};\n                   fermion_path_integral_up::FermionPathIntegral{T,E},\n                   fermion_path_integral_dn::FermionPathIntegral{T,E},\n                   fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n                   Bup::Vector{P}, Bdn::Vector{P},\n                   rng::AbstractRNG) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform a reflection update where the sign of every Ising Hubbard-Stratonovich field on a randomly chosen orbital in the lattice is changed. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n                   hubbard_ising_parameters::HubbardIsingHSParameters{E};\n                   fermion_path_integral::FermionPathIntegral{T,E},\n                   fermion_greens_calculator::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n                   B::Vector{P},\n                   rng::AbstractRNG) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform a reflection update where the sign of every Ising Hubbard-Stratonovich field on a randomly chosen orbital in the lattice is changed. This function returns (accepted, logdetG, sgndetG). This method assumes strictly attractive Hubbard interactions.\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n             Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n             hubbard_ising_parameters::HubbardIsingHSParameters{E};\n             fermion_path_integral_up::FermionPathIntegral{T,E},\n             fermion_path_integral_dn::FermionPathIntegral{T,E},\n             fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n             Bup::Vector{P}, Bdn::Vector{P},\n             rng::AbstractRNG) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform a swap update where the HS fields associated with two randomly chosen sites in the lattice are exchanged. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n             hubbard_ising_parameters::HubbardIsingHSParameters{E};\n             fermion_path_integral::FermionPathIntegral{T,E},\n             fermion_greens_calculator::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n             B::Vector{P}, rng::AbstractRNG) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nFor strictly attractive Hubbard interactions, perform a swap update where the HS fields associated with two randomly chosen sites in the lattice are exchanged. This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#Electron-Phonon-Model","page":"API","title":"Electron-Phonon Model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Model Types and Method","category":"page"},{"location":"api/","page":"API","title":"API","text":"ElectronPhononModel\nPhononMode\nHolsteinCoupling\nSSHCoupling\nPhononDispersion\nadd_phonon_mode!\nadd_holstein_coupling!\nadd_ssh_coupling!\nadd_phonon_dispersion!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Parameter Types and Methods","category":"page"},{"location":"api/","page":"API","title":"API","text":"ElectronPhononParameters\nSmoQyDQMC.PhononParameters\nSmoQyDQMC.HolsteinParameters\nSmoQyDQMC.SSHParameters\nSmoQyDQMC.DispersionParameters\ninitialize!\nupdate!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"measure_phonon_kinetic_energy\nmeasure_phonon_potential_energy\nmeasure_phonon_position_moment\nmeasure_holstein_energy\nmeasure_ssh_energy\nmeasure_ssh_sgn_switch\nmeasure_dispersion_energy","category":"page"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Updates","category":"page"},{"location":"api/","page":"API","title":"API","text":"HMCUpdater\nEFAHMCUpdater\nhmc_update!\nSmoQyDQMC.FourierMassMatrix\nreflection_update!\nswap_update!","category":"page"},{"location":"api/#Electron-Phonon-Model-Types-and-Method","page":"API","title":"Electron-Phonon Model Types and Method","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ElectronPhononModel\nElectronPhononModel(;)\nPhononMode\nPhononMode(;)\nHolsteinCoupling\nHolsteinCoupling(;)\nSSHCoupling\nSSHCoupling(;)\nPhononDispersion\nPhononDispersion(;)\nadd_phonon_mode!\nadd_holstein_coupling!\nadd_ssh_coupling!\nadd_phonon_dispersion!","category":"page"},{"location":"api/#SmoQyDQMC.ElectronPhononModel","page":"API","title":"SmoQyDQMC.ElectronPhononModel","text":"ElectronPhononModel{T<:Number, E<:AbstractFloat, D}\n\nDefines an electron-phonon model.\n\nFields\n\nphonon_modes::Vector{PhononModes{E}}: A vector of PhononMode definitions.\nphonon_dispersions::Vector{PhononDispersion{E,D}}: A vector of PhononDispersion defintions.\nholstein_couplings_up::Vector{HolsteinCoupling{E,D}}: A vector of HolsteinCoupling definitions for spin-up.\nholstein_couplings_dn::Vector{HolsteinCoupling{E,D}}: A vector of HolsteinCoupling definitions for spin-down.\nssh_couplings_up::Vector{SSHCoupling{T,E,D}}: A vector of SSHCoupling defintions for spin-up.\nssh_couplings_dn::Vector{SSHCoupling{T,E,D}}: A vector of SSHCoupling defintions for spin-down.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ElectronPhononModel-Tuple{}","page":"API","title":"SmoQyDQMC.ElectronPhononModel","text":"ElectronPhononModel(;\n    model_geometry::ModelGeometry{D,E},\n    tight_binding_model::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    tight_binding_model_up::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    tight_binding_model_dn::Union{TightBindingModel{T,E,D}, Nothing} = nothing\n) where {T<:Number, E<:AbstractFloat, D}\n\nInitialize and return a null (empty) instance of ElectronPhononModel. Note that either tight_binding_model or tight_binding_model_up and tight_binding_model_dn needs to be specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononMode","page":"API","title":"SmoQyDQMC.PhononMode","text":"PhononMode{E<:AbstractFloat}\n\nDefines a phonon mode on the orbital species orbital in the unit cell. Specifically, it defines the phonon Hamiltonian terms\n\nhatH_rm ph = sum_mathbfi\n  left\n      frac12 M_mathbfinuOmega_mathbfinu^2hatX_mathbfinu^2\n    + frac112M_mathbfinuOmega_4mathbfinu^2hatX_mathbfinu^4\n    + frac12M_mathbfinuhatP_mathbfinu^2\n  right\n\nwhere the sum runs over unit cell mathbfi, nu denotes the orbital species orbital in the unit cell, M_mathbfinu is the phonon mass M, Omega_mathbfinu is the phonon frequency that is distributed according to a normal distribution with mean Ω_mean and standard deviation Ω_std. Lastly, Omega_4mathbfinu is the anhmaronic coefficient, and is distributed according to a normal distribution with mean Ω4_mean and standard deviation Ω4_std.\n\nFields\n\norbital::Int: Orbital species nu in the unit cell.\nM::E:: The phonon mass M_mathbfinu\nΩ_mean::E: Mean of normal distribution the phonon frequency Omega_mathbfinu is sampled from.\nΩ_std::E: Standard deviation of normal distribution the phonon frequency Omega_mathbfinu is sampled from.\nΩ4_mean::E: Mean of normal distribution the anharmonic coefficient Omega_4mathbfinu is sampled from.\nΩ4_std::E: Standard deviation of normal distribution the anharmonic coefficient Omega_4mathbfinu is sampled from.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.PhononMode-Tuple{}","page":"API","title":"SmoQyDQMC.PhononMode","text":"PhononMode(;\n    orbital::Int, Ω_mean::E, Ω_std::E = 0.,\n    M::E = 1., Ω4_mean::E = 0.0, Ω4_std::E = 0.0\n) where {E<:AbstractFloat}\n\nInitialize and return a instance of PhononMode.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.HolsteinCoupling","page":"API","title":"SmoQyDQMC.HolsteinCoupling","text":"HolsteinCoupling{E<:AbstractFloat, D}\n\nDefines a Holstein coupling between a specified phonon mode and orbital density. Specifically, if shifted = true a Holstein interaction term is given by\n\nbeginalign*\nH = sum_mathbfi Big \n         (alpha_mathbfi(mathbfrkappanu) hatX_mathbfinu\n        + alpha_3mathbfi(mathbfrkappanu) hatX^3_mathbfinu)  (hatn_sigmamathbfi+mathbfrkappa-tfrac12)\n         + (alpha_2mathbfi(mathbfrkappanu) hatX^2_mathbfinu\n        + alpha_4mathbfi(mathbfrkappanu) hatX^4_mathbfinu)  hatn_sigmamathbfi+mathbfrkappa \nBig\nendalign*\n\nwhereas if shifted = false then it is given by\n\nbeginalign*\nH = sum_mathbfi Big \n         (alpha_mathbfi(mathbfrkappanu) hatX_mathbfinu\n        + alpha_3mathbfi(mathbfrkappanu) hatX^3_mathbfinu)  hatn_sigmamathbfi+mathbfrkappa\n         + (alpha_2mathbfi(mathbfrkappanu) hatX^2_mathbfinu\n        + alpha_4mathbfi(mathbfrkappanu) hatX^4_mathbfinu)  hatn_sigmamathbfi+mathbfrkappa \nBig\nendalign*\n\nIn the above, sigma specifies the sum, and the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa specify orbital species in the unit cell, and mathbfr is a static displacement in unit cells.\n\nFields\n\nshifted::Bool: If the odd powered interaction terms are shifted to render them particle-hole symmetric in the atomic limit.\nphonon_mode::Int: The phonon mode getting coupled to.\nbond::Bond{D}: Static displacement from hatX_mathbfinu to hatn_sigmamathbfi+mathbfrkappa\nbond_id::Int: Bond ID associtated with bond field.\nα_mean::E: Mean of the linear Holstein coupling coefficient alpha_1mathbfi(mathbfrkappanu)\nα_std::E: Standard deviation of the linear Holstein coupling coefficient alpha_1mathbfi(mathbfrkappanu)\nα2_mean::E: Mean of the squared Holstein coupling coefficient alpha_2mathbfi(mathbfrkappanu)\nα2_std::E: Standard deviation of the squared Holstein coupling coefficient alpha_2mathbfi(mathbfrkappanu)\nα3_mean::E: Mean of the cubic Holstein coupling coefficient alpha_3mathbfi(mathbfrkappanu)\nα3_std::E: Standard deviation of the cubic Holstein coupling coefficient alpha_3mathbfi(mathbfrkappanu)\nα4_mean::E: Mean of the quartic Holstein coupling coefficient alpha_4mathbfi(mathbfrkappanu)\nα4_std::E: Standard deviation of the quartic Holstein coupling coefficient alpha_4mathbfi(mathbfrkappanu)\n\nComment\n\nNote that the initial orbital bond.orbital[1] must match the orbital species associated with phonon mode PhononMode getting coupled to.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HolsteinCoupling-Tuple{}","page":"API","title":"SmoQyDQMC.HolsteinCoupling","text":"HolsteinCoupling(;\n    model_geometry::ModelGeometry{D,E},\n    phonon_mode::Int,\n    bond::Bond{D},\n    α_mean::E,        α_std::E  = 0.0,\n    α2_mean::E = 0.0, α2_std::E = 0.0,\n    α3_mean::E = 0.0, α3_std::E = 0.0,\n    α4_mean::E = 0.0, α4_std::E = 0.0,\n    shifted::Bool = true\n) where {D, E<:AbstractFloat}\n\nInitialize and return a instance of HolsteinCoupling.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.SSHCoupling","page":"API","title":"SmoQyDQMC.SSHCoupling","text":"SSHCoupling{T<:Number, E<:AbstractFloat, D}\n\nDefines a Su-Schrieffer-Heeger (SSH) coupling between a pair of phonon modes. Specifically, it defines the SSH interaction term\n\nhatH_rm ssh = -sum_sigmamathbfi\n    left t_mathbfi(mathbfrkappanu) - left( sum_n=1^4alpha_nmathbfi(mathbfrkappanu)\n    left( hatX_mathbfi+mathbfrkappa - hatX_mathbfinuright)^nright) right\n    left( hatc_sigmamathbfi+mathbfrkappa^daggerhatc_sigmamathbfinu+rm hc right)\n\nwhere sigma specifies the sum, and the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa specify orbital species in the unit cell, and mathbfr is a static displacement in unit cells. In that above expression t_mathbfi(mathbfrkappanu) is the bare hopping amplitude, which is not specified here.\n\nFields\n\nphonon_modes::NTuple{2,Int}: Pair of phonon modes getting coupled together.\nbond::Bond{D}: Static displacement seperating the two phonon modes getting coupled.\nbond_id::Int: Bond ID associated with the bond field.\nα_mean::T: Mean of the linear SSH coupling constant alpha_1mathbfi(mathbfrkappanu)\nα_std::T: Standard deviation of the linear SSH coupling constant alpha_1mathbfi(mathbfrkappanu)\nα2_mean::T: Mean of the quadratic SSH coupling constant alpha_2mathbfi(mathbfrkappanu)\nα2_std::T: Standard deviation of the quadratic SSH coupling constant alpha_2mathbfi(mathbfrkappanu)\nα3_mean::T: Mean of the cubic SSH coupling constant alpha_3mathbfi(mathbfrkappanu)\nα3_std::T: Standard deviation of the cubic SSH coupling constant alpha_3mathbfi(mathbfrkappanu)\nα4_mean::T: Mean of the quartic SSH coupling constant alpha_4mathbfi(mathbfrkappanu)\nα4_std::T: Standard deviation of the quartic SSH coupling constant alpha_4mathbfi(mathbfrkappanu)\n\nComment\n\nThe pair of orbitals appearing in bond.orbitals must correspond to the orbital species associated with the two coupling phonon modes specified by phonon_modes.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SSHCoupling-Tuple{}","page":"API","title":"SmoQyDQMC.SSHCoupling","text":"SSHCoupling(;\n    model_geometry::ModelGeometry{D,E},\n    tight_binding_model::TightBindingModel{T,E,D},\n    phonon_modes::NTuple{2,Int},\n    bond::Bond{D},\n    α_mean::Union{T,E},        α_std::E  = 0.0,\n    α2_mean::Union{T,E} = 0.0, α2_std::E = 0.0,\n    α3_mean::Union{T,E} = 0.0, α3_std::E = 0.0,\n    α4_mean::Union{T,E} = 0.0, α4_std::E = 0.0\n) where {D, T<:Number, E<:AbstractFloat}\n\nInitialize and return a instance of SSHCoupling.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononDispersion","page":"API","title":"SmoQyDQMC.PhononDispersion","text":"PhononDispersion{E<:AbstractFloat, D}\n\nDefines a dispersive phonon coupling between phonon modes. Specifically, it defines the dispersive phonon term\n\nhatH_rm disp = sum_mathbfi\n    left(\n        fracM_mathbfi+mathbfrkappaM_mathbfinuM_mathbfi+mathbfrkappa+M_mathbfinu\n    right)\n    bigg\n                    Omega_mathbfi(mathbfrkappanu)^2Big(hatX_mathbfi+mathbfrkappa-hatX_mathbfinuBig)^2\n       +frac112Omega_4mathbfi(mathbfrkappanu)^2Big(hatX_mathbfi+mathbfrkappa-hatX_mathbfinuBig)^4\n    bigg\n\nwhere the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa specify orbital species in the unit cell, and mathbfr is a static displacement in unit cells.\n\nFields\n\nphonon_modes::NTuple{2,Int}: Pair of phonon modes getting coupled together.\nbond::Bond{D}: Static displacement seperating the two phonon modes getting coupled.\nbond_id::Int: Bond ID associated with the bond field.\nΩ_mean::E: Mean dispersive phonon frequency Omega_mathbfi(mathbfrkappanu)\nΩ_std::E: Standard deviation of dispersive phonon frequency Omega_mathbfi(mathbfrkappanu)\nΩ4_mean::E: Mean quartic dispersive phonon coefficient Omega_4mathbfi(mathbfrkappanu)\nΩ4_std::E: Standard deviation of quartic dispersive phonon coefficient Omega_4mathbfi(mathbfrkappanu)\n\nComment\n\nThe pair of orbitals appearing in bond.orbitals must correspond to the orbital species associated with the two coupling phonon modes specified by phonon_modes.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.PhononDispersion-Tuple{}","page":"API","title":"SmoQyDQMC.PhononDispersion","text":"PhononDispersion(;\n    model_geometry::ModelGeometry{D,E},\n    phonon_modes::NTuple{2,Int},\n    bond::Bond{D},\n    Ω_mean::E, Ω_std::E=0.0,\n    Ω4_mean::E=0.0, Ω4_std::E=0.0\n) where {E<:AbstractFloat, D}\n\nInitialize and return a instance of PhononDispersion.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.add_phonon_mode!","page":"API","title":"SmoQyDQMC.add_phonon_mode!","text":"add_phonon_mode!(;\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    phonon_mode::PhononMode{E}\n) where {T<:Number, E<:AbstractFloat, D}\n\nAdd a PhononMode to an ElectronPhononModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_holstein_coupling!","page":"API","title":"SmoQyDQMC.add_holstein_coupling!","text":"add_holstein_coupling!(;\n    model_geometry::ModelGeometry{D,E},\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    holstein_coupling::Union{HolsteinCoupling{E,D}, Nothing} = nothing,\n    holstein_coupling_up::Union{HolsteinCoupling{E,D}, Nothing} = nothing,\n    holstein_coupling_dn::Union{HolsteinCoupling{E,D}, Nothing} = nothing\n) where {T,E,D}\n\nAdd the HolsteinCoupling to an ElectronPhononModel. Note that either holstein_coupling or holstein_coupling_up and holstein_coupling_dn must be specified.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_ssh_coupling!","page":"API","title":"SmoQyDQMC.add_ssh_coupling!","text":"add_ssh_coupling!(;\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    tight_binding_model::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    ssh_coupling::Union{SSHCoupling{T,E,D}, Nothing} = nothing,\n    tight_binding_model_up::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    tight_binding_model_dn::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    ssh_coupling_up::Union{SSHCoupling{T,E,D}, Nothing} = nothing,\n    ssh_coupling_dn::Union{SSHCoupling{T,E,D}, Nothing} = nothing\n) where {T,E,D}\n\nAdd a SSHCoupling to an ElectronPhononModel. Note that either ssh_coupling and tight_binding_model or ssh_coupling_up, ssh_coupling_dn, tight_binding_model_up and tight_binding_model_dn need to be specified.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_phonon_dispersion!","page":"API","title":"SmoQyDQMC.add_phonon_dispersion!","text":"add_phonon_dispersion!(;\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    phonon_dispersion::PhononDispersion{E,D},\n    model_geometry::ModelGeometry{D,E}\n) where {T,E,D}\n\nAdd a PhononDispersion to an ElectronPhononModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#Electron-Phonon-Parameter-Types-and-Methods","page":"API","title":"Electron-Phonon Parameter Types and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ElectronPhononParameters\nElectronPhononParameters(;)\nSmoQyDQMC.PhononParameters\nSmoQyDQMC.HolsteinParameters\nSmoQyDQMC.SSHParameters\nSmoQyDQMC.DispersionParameters\ninitialize!(::FermionPathIntegral{T,E}, ::FermionPathIntegral{T,E}, ::ElectronPhononParameters{T,E}) where {T,E}\ninitialize!(::FermionPathIntegral{T,E}, ::ElectronPhononParameters{T,E}) where {T,E}\nupdate!(::FermionPathIntegral{T,E}, ::FermionPathIntegral{T,E}, ::ElectronPhononParameters{T,E}, ::Matrix{E}, ::Matrix{E}) where {T,E}\nupdate!(::FermionPathIntegral{T,E}, ::ElectronPhononParameters{T,E}, ::Matrix{E}, ::Matrix{E}) where {T,E}\nupdate!(::FermionPathIntegral{T,E}, ::ElectronPhononParameters{T,E}, ::Matrix{E}, ::Int) where {T,E}","category":"page"},{"location":"api/#SmoQyDQMC.ElectronPhononParameters","page":"API","title":"SmoQyDQMC.ElectronPhononParameters","text":"ElectronPhononParameters{T<:Number, E<:AbstractFloat}\n\nDescribes all parameters in the electron-phonon model.\n\nFields\n\nβ::E: Inverse temperature.\nΔτ::E: Discretization in imaginary time.\nLτ::Int: Length of imaginary time axis.\nx::Matrix{E}: Phonon fields, where each column represents the phonon fields for a given imaginary time slice.\nphonon_parameters::PhononParameters{E}: Refer to PhononParameters.\nholstein_parameters_up::HolsteinParameters{E}: Spin up HolsteinParameters.\nholstein_parameters_dn::HolsteinParameters{E}: Spin down HolsteinParameters.\nssh_parameters_up::SSHParameters{T}: Spin up SSHParameters.\nssh_parameters_dn::SSHParameters{T}: Spin down SSHParameters.\ndispersion_parameters::DispersionParameters{E}: Refer to DispersionParameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ElectronPhononParameters-Tuple{}","page":"API","title":"SmoQyDQMC.ElectronPhononParameters","text":"ElectronPhononParameters(;\n    β::E, Δτ::E,\n    model_geometry::ModelGeometry{D,E},\n    tight_binding_parameters::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    tight_binding_parameters_up::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    tight_binding_parameters_dn::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    rng::AbstractRNG\n) where {T,E,D}\n\nInitialize and return an instance of ElectronPhononParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononParameters","page":"API","title":"SmoQyDQMC.PhononParameters","text":"PhononParameters{E<:AbstractFloat}\n\nDefines the parameters for each phonon in the lattice, includes the phonon field configuration.\n\nFields\n\nnphonon::Int: Number of type of phonon modes.\nNphonon::Int: Total number of phonon modes in finite lattice.\nM::Int: Mass of each phonon mode.\nΩ::Int: Frequency of each phonon mode.\nΩ4::Int: Quartic phonon coefficient for each phonon mode.\nphonon_to_site::Vector{Int}: Map each phonon to the site it lives on in the lattice.\nsite_to_phonons::Vector{Vector{Int}}: Maps the site to the phonon modes on it, allowing for multiple modes to reside on a single site.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HolsteinParameters","page":"API","title":"SmoQyDQMC.HolsteinParameters","text":"HolsteinParameters{E<:AbstractFloat}\n\nDefines the Holstein coupling parameters in lattice.\n\nFields\n\nnholstein::Int: The number of type of holstein couplings.\nNholstein::Int: Total number of Holstein couplings in lattice.\nα::Vector{T}: Linear Holstein coupling.\nα2::Vector{T}: Quadratic Holstein coupling.\nα3::Vector{T}: Cubic Holstein coupling.\nα4::Vector{T}: Quartic Holstein coupling.\nshifted::Vector{Bool}: If the density multiplying the odd powered interaction terms is shifted.\nneighbor_table::Matrix{Int}: Neighbor table where the first row specifies the site where the phonon mode is located, and the second row specifies the site corresponds to the density getting coupled to.\ncoupling_to_phonon::Vector{Int}: Maps each Holstein coupling in the lattice to the corresponding phonon mode.\nphonon_to_coupling::Vector{Vector{Int}}: Maps each phonon model to correspond Holstein couplings.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SSHParameters","page":"API","title":"SmoQyDQMC.SSHParameters","text":"SSHParameters{T<:Number}\n\nDefines the SSH coupling parameters in lattice.\n\nFields\n\nnssh::Int: Number of types of SSH couplings.\nNssh::Int: Number of SSH couplings in lattice.\nα::Vector{T}: Linear SSH coupling.\nα2::Vector{T}: Quadratic SSH coupling.\nα3::Vector{T}: Cubic SSH coupling.\nα4::Vector{T}: Quartic SSH coupling.`\nneighbor_table::Matrix{Int}: Neighbor table to SSH coupling.\ncoupling_to_phonon::Matrix{Int}: Maps each SSH coupling onto that pair of coupled phonons.\ninit_phonon_to_coupling::Vector{Vector{Int}}: Maps initial phonon mode to corresponding SSH coupling(s).\nfinal_phonon_to_coupling::Vector{Vector{Int}}: Maps final phonon mode to corresponding SSH coupling(s).\nhopping_to_couplings::Vector{Vector{Int}}: Maps hopping in the tight-binding model onto SSH couplings.\ncoupling_to_hopping::Vector{Int}: Maps each SSH coupling onto the corresponding hopping in the tight-binding model.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.DispersionParameters","page":"API","title":"SmoQyDQMC.DispersionParameters","text":"DispersionParameters{E<:AbstractFloat}\n\nDefines the dispersive phonon coupling parameters in the lattice.\n\nFields\n\nndispersion::Int: Number of types of dispersive couplings.\nNdispersion::Int: Number of dispersive couplings in the lattice.\nΩ::Vector{E}: Frequency of dispersive phonon coupling.\nΩ4::Vector{E}: Quartic coefficient for the phonon dispersion.\ndispersion_to_phonon::Matrix{Int}: Pair of phonon modes in lattice coupled by dispersive coupling.\ninit_phonon_to_coupling::Vector{Vector{Int}}: Maps initial phonon mode to corresponding dispersive phonon coupling.\nfinal_phonon_to_coupling::Vector{Vector{Int}}: Maps final phonon mode to corresponding dispersive phonon coupling.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, ElectronPhononParameters{T, E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    electron_phonon_parameters::ElectronPhononParameters{T,E}\n) where {T,E}\n\nInitialize the contribution of an ElectronPhononParameters to a FermionPathIntegral.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, ElectronPhononParameters{T, E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(\n    fermion_path_integral::FermionPathIntegral{T,E},\n    electron_phonon_parameters::ElectronPhononParameters{T,E};\n    spin::Int = +1,\n) where {T,E}\n\nInitialize the contribution of an ElectronPhononParameters to a FermionPathIntegral.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.update!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, ElectronPhononParameters{T, E}, Matrix{E}, Matrix{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.update!","text":"update!(\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    x′::Matrix{E},\n    x::Matrix{E}\n) where {T,E}\n\nUpdate a FermionPathIntegral to reflect a change in the phonon configuration from x to x′.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.update!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, ElectronPhononParameters{T, E}, Matrix{E}, Matrix{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.update!","text":"update!(\n    fermion_path_integral::FermionPathIntegral{T,E},\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    x′::Matrix{E},\n    x::Matrix{E};\n    spin::Int = +1\n) where {T,E}\n\nUpdate a FermionPathIntegral to reflect a change in the phonon configuration from x to x′.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.update!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, ElectronPhononParameters{T, E}, Matrix{E}, Int64}} where {T, E}","page":"API","title":"SmoQyDQMC.update!","text":"update!(fermion_path_integral::FermionPathIntegral{T,E},\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    x::Matrix{E},\n    sgn::Int;\n    spin::Int = +1\n) where {T,E}\n\nUpdate a FermionPathIntegral according to sgn * x.\n\n\n\n\n\n","category":"method"},{"location":"api/#Electron-Phonon-Measurements","page":"API","title":"Electron-Phonon Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"measure_phonon_kinetic_energy\nmeasure_phonon_potential_energy\nmeasure_phonon_position_moment\nmeasure_holstein_energy\nmeasure_ssh_energy\nmeasure_ssh_sgn_switch\nmeasure_dispersion_energy","category":"page"},{"location":"api/#SmoQyDQMC.measure_phonon_kinetic_energy","page":"API","title":"SmoQyDQMC.measure_phonon_kinetic_energy","text":"measure_phonon_kinetic_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                              n::Int) where {T<:Number, E<:AbstractFloat}\n\nEvaluate the average phonon kinetic energy for phonon mode n. The measurement is made using the expression\n\nlangle K rangle = frac12Deltatau - fracM2bigglanglefrac(x_l+1-x_l)^2Deltatau^2biggrangle \n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_phonon_potential_energy","page":"API","title":"SmoQyDQMC.measure_phonon_potential_energy","text":"measure_phonon_potential_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                                n::Int) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average phonon potential energy, given by\n\nU = frac12 M Omega^2 langle hatX^2 rangle + frac124 M Omega_4^2 langle hatX^4 rangle\n\nfor phonon mode n in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_phonon_position_moment","page":"API","title":"SmoQyDQMC.measure_phonon_position_moment","text":"measure_phonon_position_moment(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                               n::Int, m::Int) where {T<:Number, E<:AbstractFloat}\n\nMeasure langle X^m rangle for phonon mode n in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_holstein_energy","page":"API","title":"SmoQyDQMC.measure_holstein_energy","text":"measure_holstein_energy(\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    Gup::Matrix{T}, Gdn::Matrix{T},\n    holstein_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate and return both the spin-resolved Holstein interaction energy\n\nepsilon_rm holsigma = \n                            leftlangle\n                                \n                                    alpha   hatX   + alpha_2 hatX^2\n                                  + alpha_3 hatX^3 + alpha_4 hatX^4\n                                \n                                left(\n                                    hatn_sigma - frac12\n                                right)\n                            rightrangle\n\nand the total Holstein interaction energy coupling definition corresponding to holstein_id. The method returns (ϵ_hol, ϵ_hol_up, ϵ_hol_dn) where ϵ_hol = ϵ_hol_up + ϵ_hol_dn.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_ssh_energy","page":"API","title":"SmoQyDQMC.measure_ssh_energy","text":"measure_ssh_energy(\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    Gup::Matrix{T}, Gdn::Matrix{T},\n    ssh_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the return the SSH interaction energy\n\nepsilon_rm ssh = sum_sigma leftlangle alpha hatX     + alpha_2 hatX^2\n                                               alpha_3 hatX^3 + alpha_4 hatX^4\n                                              (hatc^dagger_sigmai hatc_sigmaj + rm hc) rightrangle\n\nfor coupling definition specified by ssh_id.\n\n\n\n\n\nmeasure_ssh_energy(\n    ssh_parameters::SSHParameters{T},\n    G::Matrix{T}, x::Matrix{E}, ssh_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the return the SSH interaction energy\n\nepsilon_rm ssh = leftlangle alpha hatX     + alpha_2 hatX^2\n                                   alpha_3 hatX^3 + alpha_4 hatX^4\n                        (hatc^dagger_sigmai hatc_sigmaj + rm hc) rightrangle\n\nfor coupling definition specified by ssh_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_ssh_sgn_switch","page":"API","title":"SmoQyDQMC.measure_ssh_sgn_switch","text":"measure_ssh_sgn_switch(\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    tight_binding_parameters::TightBindingParameters{T,E},\n    ssh_id::Int;\n    spin::Int = +1\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the fraction of the time the sign of the hopping is changed as a result of the SSH coupling associated with ssh_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_dispersion_energy","page":"API","title":"SmoQyDQMC.measure_dispersion_energy","text":"measure_dispersion_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                       dispersion_id::Int) where {T<:Number, E<:AbstractFloat}\n\nEvaluate the average dispersion energy\n\nepsilon_rm disp = frac12 M_rm red Omega^2 langle(hatX_i - hatX_j)^2rangle\n                    + frac124 Mrm red Omega_4^2 langle(hatX_i - hatX_j)^4rangle\n\nwhere M_rm red = fracM_i M_jM_i + M_j is the reduced mass, for the dispersive coupling definition specified by dispersion_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#Electron-Phonon-Updates","page":"API","title":"Electron-Phonon Updates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HMCUpdater\nHMCUpdater(;)\nEFAHMCUpdater\nEFAHMCUpdater(;)\nhmc_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}, ::HMCUpdater{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nhmc_update!(::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}, ::HMCUpdater{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nhmc_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}, ::EFAHMCUpdater{T,E}) where {T, E, P<:AbstractPropagator{T,E}}\nhmc_update!(::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}, ::EFAHMCUpdater{T,E}) where {T, E, P<:AbstractPropagator{T,E}}\nSmoQyDQMC.FourierMassMatrix\nreflection_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nreflection_update!(::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nswap_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nswap_update!(::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}","category":"page"},{"location":"api/#SmoQyDQMC.HMCUpdater","page":"API","title":"SmoQyDQMC.HMCUpdater","text":"HMCUpdater{T<:Number, E<:AbstractFloat, PFFT, PIFFT}\n\nDefines a hybrid/hamiltonian monte carlo (HMC) update for the phonon degrees of freedom.\n\nFields\n\nNt::Int: Mean trajectory length in terms of the number of fermionic time-steps.\nΔt::E: Average fermionic time-step size used in HMC update.\nnt::Int: Number of bosonic time-steps per fermionic time-step using a bosonic time-step Δt′=Δt/nt.\nδ::E: Time-step used in HMC update is jittered by an amount Δt = Δt * (1 + δ*(2*rand(rng)-1)).\nM::FourierMassMatrix{E,PFFT,PIFFT}: Defines the FourierMassMatrix.\ndSdx::Matrix{E}: Array to contain derivative of fermionic and bosonic action during HMC trajectory.\ndSfdx0::Matrix{E}: Initial derivative of fermionic action associated with the initial phonon configuration.\nGup′::Matrix{T}: Matrix to contain itermediate spin-up Green's function matrices.\nGdn′::Matrix{T}: Matrix to contain itermediate spin-down Green's function matrices.\nx′::Matrix{E}: Array to record intermediate phonon configurations.\nx0::Matrix{E}: Array to record initial phonon configuration.\nv::Matrix{E}: Conjugate momentum to phonon fields in HMC trajectory.\nfirst_update::Bool: A flag indicating whether the next update will be the first update\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HMCUpdater-Tuple{}","page":"API","title":"SmoQyDQMC.HMCUpdater","text":"HMCUpdater(;\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    G::Matrix{T},\n    Nt::Int,\n    Δt::E,\n    nt::Int,\n    reg::E\n) where {T,E}\n\nInitialize and return an instance of HMCUpdater.\n\nArguments\n\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Defines electron phonon model.\nG::Matrix{T}: Template Green's function matrix.\nNt::Int: Number of fermionic timesteps in HMC trajectory.\nΔt::E: Fermionic time-step.\nnt::Int: Number of bosonic time-steps per fermionic time-step.\nreg::E: Regularization parameter for defining an instance of FourierMassMatrix.\nδ::E = 0.05: Proportion by which the HMC time-step is jittered befored each update.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.EFAHMCUpdater","page":"API","title":"SmoQyDQMC.EFAHMCUpdater","text":"EFAHMCUpdater{T<:Number, E<:AbstractFloat, PFFT, PIFFT}\n\nDefines an Exact Fourier Acceleration Hamiltonian/Hybrid Monte Carlo (EFA-HMC) update for the phonon degrees of freedom.\n\nFields\n\nNt::Int: Number of time-steps in HMC trajectory.\nΔt::E: Average time-step size used in HMC update.\nreg::E: Mass regularization.\nδ::E: Time-step used in EFA-HMC update is jittered by an amount Δt = Δt * (1 + δ*(2*rand(rng)-1)).\nω::Matrix{E}: Harmonic frequency associated fourier mode in the non-interacting quantum Harmonic oscillator action.\nm::Matrix{E}: Mass associated with quantum Harmonic oscillator fourier mode equations of motion.\nx::Matrix{E}: Records initial phonon configuration in position space.\np::Matrix{E}: Conjugate momentum in HMC dynamics.\nx̃::Matrix{Complex{E}}: Phonon configuration in frequency space.\np̃::Matrix{Complex{E}}: Momentum in frequency space.\nu::Matrix{Complex{E}}: Temporary storage array.\ndSdx::Matrix{E}: Stores the derivative of the action.\nGup′::Matrix{T}: Intermediate spin-up Green's function matrix during HMC trajectory.\nGdn′::Matrix{T}: Intermediate spin-down Green's function matrix during HMC trajectory.\npfft::PFFT: FFT plan to transform form imaginary time to frequency space.\npifft::PIFFT: Inverse FFT plan to trasform from frequency space back to imaginary time.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.EFAHMCUpdater-Tuple{}","page":"API","title":"SmoQyDQMC.EFAHMCUpdater","text":"EFAHMCUpdater(;\n    # Keyword Arguments Start Here\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    G::Matrix{T},\n    Nt::Int,\n    Δt::E,\n    reg::E = 0.0,\n    δ::E = 0.05\n) where {T<:Number, E<:AbstractFloat}\n\nArguments\n\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Defines electron-phonon model.\nG::Matrix{T}: Sample Green's function matrix.\nNt::Int: Number of time-steps used in EFA-HMC update.\nΔt::E: Average step size used for HMC update.\nreg::E = Inf: Regularization used for mass in equations of motion.\nδ::E = 0.05: Amount of jitter added to time-step used in EFA-HMC update.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}, HMCUpdater{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(\n    Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n    Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    hmc_updater::HMCUpdater{T,E};\n    # Keyword Arguments Start Here\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P},\n    δG_max::E, δG::E, δθ::E, rng::AbstractRNG,\n    update_stabilization_frequency::Bool = true,\n    initialize_force::Bool = true,\n    δG_reject::E = 1e-2,\n    recenter!::Function = identity,\n    Nt::Int = hmc_updater.Nt,\n    nt::Int = hmc_updater.nt,\n    Δt::E = hmc_updater.Δt,\n    δ::E = hmc_updater.δ\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform HMC update to the phonon degrees of freedom. This method returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ), where accepted is a boolean field indicating whether the proposed HMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}, HMCUpdater{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(\n    G::Matrix{T}, logdetG::E, sgndetG::T,\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    hmc_updater::HMCUpdater{T,E};\n    # Keyword Arguments Start Here\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n    B::Vector{P}, δG_max::E, δG::E, δθ::E, rng::AbstractRNG,\n    update_stabilization_frequency::Bool = true,\n    initialize_force::Bool = true,\n    δG_reject::E = 1e-2,\n    recenter!::Function = identity,\n    Nt::Int = hmc_updater.Nt,\n    nt::Int = hmc_updater.nt,\n    Δt::E = hmc_updater.Δt,\n    δ::E = hmc_updater.δ\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform HMC update to the phonon degrees of freedom assuming the spin-up and spin-down sectors are equivalent. This method returns (accepted, logdetG, sgndetG, δG, δθ), where accepted is a boolean field indicating whether the proposed HMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}, EFAHMCUpdater{T, E}}} where {T, E, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(\n    Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n    Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    hmc_updater::EFAHMCUpdater{T,E};\n    # Keyword Arguments Start Here\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P},\n    δG_max::E, δG::E, δθ::E, rng::AbstractRNG,\n    update_stabilization_frequency::Bool = true,\n    δG_reject::E = 1e-2,\n    recenter!::Function = identity,\n    Nt::Int = hmc_updater.Nt,\n    Δt::E = hmc_updater.Δt,\n    δ::E = hmc_updater.δ\n) where {T, E, P<:AbstractPropagator{T,E}}\n\nPerform EFA-HMC update to the phonon degrees of freedom. This method returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ), where accepted is a boolean field indicating whether the proposed HMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}, EFAHMCUpdater{T, E}}} where {T, E, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(\n    G::Matrix{T}, logdetG::E, sgndetG::T,\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    hmc_updater::EFAHMCUpdater{T,E};\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n    B::Vector{P},\n    δG_max::E, δG::E, δθ::E, rng::AbstractRNG,\n    update_stabilization_frequency::Bool = true,\n    δG_reject::E = 1e-2,\n    recenter!::Function = identity,\n    Nt::Int = hmc_updater.Nt,\n    Δt::E = hmc_updater.Δt,\n    δ::E = hmc_updater.δ\n) where {T, E, P<:AbstractPropagator{T,E}}\n\nPerform EFA-HMC update to the phonon degrees of freedom. This method returns (accepted, logdetG, sgndetG, δG, δθ), where accepted is a boolean field indicating whether the proposed HMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.FourierMassMatrix","page":"API","title":"SmoQyDQMC.FourierMassMatrix","text":"FourierMassMatrix{E<:AbstractFloat, PFFT, PIFFT}\n\nDefines the mass matrix that implements fourier acceleration when performing either hybrid/hamiltonian monte carlo or langevin monte carlo updates to the phonon fields.\n\nFields\n\nM̃::Matrix{E}: Matrix elements of fourier mass matrix in frequency space.\nv′::Matrix{Complex{E}}: Temporary storage array to contain velocities as complex numbers to avoid dynamic memory allocations.\nṽ::Matrix{Complex{E}}: Temporary storage to avoid some dynamic memory allocations when performing fourier transforms.\npfft::PFFT: Forward FFT plan to perform transformation from imaginary time to frequency space without allocations.\npifft::PIFFT: Inverse FFT plan to perform transformation from frequency to imaginary time space without allocations.\nis_scalar::Bool: If the mass matrix is equivalent to a simple scalar.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n                   Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n                   electron_phonon_parameters::ElectronPhononParameters{T,E};\n                   fermion_path_integral_up::FermionPathIntegral{T,E},\n                   fermion_path_integral_dn::FermionPathIntegral{T,E},\n                   fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n                   Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,\n                   phonon_types = nothing) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a phonon mode in the lattice, and propose an update that reflects all the phonon fields associated with that phonon mode x rightarrow -x This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_types = nothing: Collection of phonon types in the unit cell to randomly sample a phonon mode from. If nothing then all phonon modes in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n                   electron_phonon_parameters::ElectronPhononParameters{T,E};\n                   fermion_path_integral::FermionPathIntegral{T,E},\n                   fermion_greens_calculator::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n                   B::Vector{P}, rng::AbstractRNG,\n                   phonon_types = nothing) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a phonon mode in the lattice, and propose an update that reflects all the phonon fields associated with that phonon mode x rightarrow -x This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_types = nothing: Collection of phonon types in the unit cell to randomly sample a phonon mode from. If nothing then all phonon modes in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n             Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n             electron_phonon_parameters::ElectronPhononParameters{T,E};\n             fermion_path_integral_up::FermionPathIntegral{T,E},\n             fermion_path_integral_dn::FermionPathIntegral{T,E},\n             fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n             Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,\n             phonon_type_pairs = nothing) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a pairs of phonon modes and exchange the phonon fields associated with the pair of phonon modes. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_type_pairs = nothing: Collection of phonon type pairs in the unit cell to randomly sample a phonon modes from. If nothing then all phonon mode pairs in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n             electron_phonon_parameters::ElectronPhononParameters{T,E};\n             fermion_path_integral::FermionPathIntegral{T,E},\n             fermion_greens_calculator::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n             B::Vector{P}, rng::AbstractRNG,\n             phonon_type_pairs = nothing) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a pairs of phonon modes and exchange the phonon fields associated with the pair of phonon modes. This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_type_pairs = nothing: Collection of phonon type pairs in the unit cell to randomly sample a phonon modes from. If nothing then all phonon mode pairs in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#Density-and-Chemical-Potential-Tuning","page":"API","title":"Density and Chemical Potential Tuning","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"update_chemical_potential!\nsave_density_tuning_profile","category":"page"},{"location":"api/","page":"API","title":"API","text":"update_chemical_potential!\nsave_density_tuning_profile","category":"page"},{"location":"api/#SmoQyDQMC.update_chemical_potential!","page":"API","title":"SmoQyDQMC.update_chemical_potential!","text":"update_chemical_potential!(\n    Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n    Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T;\n    chemical_potential_tuner::MuTunerLogger{E,T},\n    tight_binding_parameters::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    tight_binding_parameters_up::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    tight_binding_parameters_dn::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P}\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nUpdate the chemical potential mu in the simulation to approach the target density/filling. This method returns the new values for (logdetGup, sgndetGup, logdetGup, sgndetGup). Note that either the keywork tight_binding_parameters needs to be specified, or tight_binding_parameters_up and tight_binding_parameters_dn both need to be specified.\n\n\n\n\n\nupdate_chemical_potential!(\n    G::Matrix{T}, logdetG::E, sgndetG::T;\n    chemical_potential_tuner::MuTunerLogger{E,T},\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    B::Vector{P}\n) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nUpdate the chemical potential mu in the simulation to approach the target density/filling. This method returns the new values for (logdetG, sgndetG).\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.save_density_tuning_profile","page":"API","title":"SmoQyDQMC.save_density_tuning_profile","text":"save_density_tuning_profile(simulation_info::SimulationInfo,\n                            chemical_potential_tuner::MuTunerLogger{E,T}) where {E,T}\n\nWrite the full density tuning history to a CSV file, typically done at the end of a simulation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Measurement-Methods","page":"API","title":"Measurement Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"GLOBAL_MEASUREMENTS\nLOCAL_MEASUREMENTS\nCORRELATION_FUNCTIONS","category":"page"},{"location":"api/","page":"API","title":"API","text":"Initialize Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"initialize_measurement_container\ninitialize_measurements!\ninitialize_correlation_measurements!\ninitialize_measurement_directories","category":"page"},{"location":"api/","page":"API","title":"API","text":"Make Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"make_measurements!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Write Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"write_measurements!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Process Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"save_simulation_info\nprocess_measurements\nprocess_correlation_measurement\ncomposite_correlation_stat\nglobal_measurement_bins_to_csv\nlocal_measurement_bins_to_csv\ncorrelation_bins_to_csv","category":"page"},{"location":"api/","page":"API","title":"API","text":"GLOBAL_MEASUREMENTS\nLOCAL_MEASUREMENTS\nCORRELATION_FUNCTIONS","category":"page"},{"location":"api/#SmoQyDQMC.GLOBAL_MEASUREMENTS","page":"API","title":"SmoQyDQMC.GLOBAL_MEASUREMENTS","text":"const GLOBAL_MEASUREMENTS = (\n    \"logdetGup\",\n    \"logdetGdn\",\n    \"sgndetGup\",\n    \"sgndetGdn\",\n    \"sgn\",\n    \"action_total\",\n    \"action_bosonic\",\n    \"action_fermionic\",\n    \"density\",\n    \"density_up\",\n    \"density_dn\",\n    \"double_occ\",\n    \"Nsqrd\"\n)\n\nList of all the global measurements that are made.\n\n\n\n\n\n","category":"constant"},{"location":"api/#SmoQyDQMC.LOCAL_MEASUREMENTS","page":"API","title":"SmoQyDQMC.LOCAL_MEASUREMENTS","text":"const LOCAL_MEASUREMENTS = Base.ImmutableDict(\n    \"density\"                  => \"ORBITAL_ID\",\n    \"density_up\"               => \"ORBITAL_ID\",\n    \"density_dn\"               => \"ORBITAL_ID\",\n    \"double_occ\"               => \"ORBITAL_ID\",\n    \"onsite_energy\"            => \"ORBITAL_ID\",\n    \"onsite_energy_up\"         => \"ORBITAL_ID\",\n    \"onsite_energy_dn\"         => \"ORBITAL_ID\",\n    \"bare_hopping_energy\"      => \"HOPPING_ID\",\n    \"bare_hopping_energy_up\"   => \"HOPPING_ID\",\n    \"bare_hopping_energy_dn\"   => \"HOPPING_ID\",\n    \"hopping_energy\"           => \"HOPPING_ID\",\n    \"hopping_energy_up\"        => \"HOPPING_ID\",\n    \"hopping_energy_dn\"        => \"HOPPING_ID\",\n    \"hopping_amplitude_up\"     => \"HOPPING_ID\",\n    \"hopping_amplitude_dn\"     => \"HOPPING_ID\",\n    \"hopping_amplitude\"        => \"HOPPING_ID\",\n    \"hopping_inversion_avg_up\" => \"HOPPING_ID\",\n    \"hopping_inversion_avg_dn\" => \"HOPPING_ID\",\n    \"hopping_inversion_avg\"    => \"HOPPING_ID\",\n    \"hopping_inversion_up\"     => \"HOPPING_ID\",\n    \"hopping_inversion_dn\"     => \"HOPPING_ID\",\n    \"hopping_inversion\"        => \"HOPPING_ID\",\n    \"hubbard_energy\"           => \"ORBITAL_ID\",\n    \"phonon_kin_energy\"        => \"PHONON_ID\",\n    \"phonon_pot_energy\"        => \"PHONON_ID\",\n    \"X\"                        => \"PHONON_ID\",\n    \"X2\"                       => \"PHONON_ID\",\n    \"X3\"                       => \"PHONON_ID\",\n    \"X4\"                       => \"PHONON_ID\",\n    \"holstein_energy\"          => \"HOLSTEIN_ID\",\n    \"holstein_energy_up\"       => \"HOLSTEIN_ID\",\n    \"holstein_energy_dn\"       => \"HOLSTEIN_ID\",\n    \"ssh_energy\"               => \"SSH_ID\",\n    \"ssh_energy_up\"            => \"SSH_ID\",\n    \"ssh_energy_dn\"            => \"SSH_ID\",\n    \"dispersion_energy\"        => \"DISPERSION_ID\"\n)\n\nList of all the local measurements than can be made, with a mapping to the corresponding type of ID each measurement is reported in terms of.\n\n\n\n\n\n","category":"constant"},{"location":"api/#SmoQyDQMC.CORRELATION_FUNCTIONS","page":"API","title":"SmoQyDQMC.CORRELATION_FUNCTIONS","text":"CORRELATION_FUNCTIONS = Base.ImmutableDict(\n    \"greens\"           => \"ORBITAL_ID\",\n    \"greens_up\"        => \"ORBITAL_ID\",\n    \"greens_dn\"        => \"ORBITAL_ID\",\n    \"greens_tautau\"    => \"ORBITAL_ID\",\n    \"greens_tautau_up\" => \"ORBITAL_ID\",\n    \"greens_tautau_dn\" => \"ORBITAL_ID\",\n    \"density\"          => \"ORBITAL_ID\",\n    \"density_upup\"     => \"ORBITAL_ID\",\n    \"density_dndn\"     => \"ORBITAL_ID\",\n    \"density_updn\"     => \"ORBITAL_ID\",\n    \"density_dnup\"     => \"ORBITAL_ID\",\n    \"spin_x\"           => \"ORBITAL_ID\",\n    \"spin_z\"           => \"ORBITAL_ID\",\n    \"pair\"             => \"BOND_ID\",\n    \"bond\"             => \"BOND_ID\",\n    \"bond_upup\"        => \"BOND_ID\",\n    \"bond_dndn\"        => \"BOND_ID\",\n    \"bond_updn\"        => \"BOND_ID\",\n    \"bond_dnup\"        => \"BOND_ID\",\n    \"current\"          => \"HOPPING_ID\",\n    \"current_upup\"     => \"HOPPING_ID\",\n    \"current_dndn\"     => \"HOPPING_ID\",\n    \"current_updn\"     => \"HOPPING_ID\",\n    \"current_dnup\"     => \"HOPPING_ID\",\n    \"phonon_greens\"    => \"PHONON_ID\"\n)\n\nList of all the correlation functions that can be measured, along with the corresponding type of ID the correlation measurement is reported in terms of. Correlation functions are well defined in both position and momentum space.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Initialize-Measurements","page":"API","title":"Initialize Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"initialize_measurement_container\ninitialize_measurements!\ninitialize_correlation_measurements!\ninitialize_measurement_directories","category":"page"},{"location":"api/#SmoQyDQMC.initialize_measurement_container","page":"API","title":"SmoQyDQMC.initialize_measurement_container","text":"initialize_measurement_container(\n    model_geometry::ModelGeometry{D,T,N},\n    β::T, Δτ::T\n) where {T<:AbstractFloat, D, N}\n\nInitialize and return a measurement container of type NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_measurements!","page":"API","title":"SmoQyDQMC.initialize_measurements!","text":"initialize_measurements!(\n    measurement_container::NamedTuple,\n    tight_binding_model_up::TightBindingModel{T,E},\n    tight_binding_model_dn::TightBindingModel{T,E},\n) where {T<:Number, E<:AbstractFloat}\n\ninitialize_measurements!(\n    measurement_container::NamedTuple,\n    tight_binding_model::TightBindingModel{T,E}\n) where {T<:Number, E<:AbstractFloat}\n\nInitialize tight-binding model related measurements.\n\nInitialized Measurements\n\nonsite_energy: Refer to measure_onsite_energy.\nonsite_energy_up: Refer to measure_onsite_energy.\nonsite_energy_dn: Refer to measure_onsite_energy.\nhopping_energy: Refer to measure_hopping_energy.\nhopping_energy_up: Refer to measure_hopping_energy.\nhopping_energy_dn: Refer to measure_hopping_energy.\n\n\n\n\n\ninitialize_measurements!(\n    measurement_container::NamedTuple,\n    hubbard_model::HubbardModel{T}\n) where {T<:AbstractFloat}\n\nInitialize Hubbard model related measurements.\n\nInitialized Measurements:\n\nhubbard_energy: Refer to measure_hopping_energy.\n\n\n\n\n\ninitialize_measurements!(\n    measurement_container::NamedTuple,\n    electron_phonon_model::ElectronPhononModel{T, E, D}\n) where {T<:Number, E<:AbstractFloat, D}\n\nInitialize electron-phonon model related measurements.\n\nInitialized Measurements:\n\nphonon_kinetic_energy: Refer to measure_phonon_kinetic_energy.\nphonon_potential_energy: Refer to measure_phonon_potential_energy.\nX: Measure langle hatX rangle, refer to measure_phonon_position_moment.\nX2: Measure langle hatX^2 rangle, refer to measure_phonon_position_moment.\nX3: Measure langle hatX^3 rangle, refer to measure_phonon_position_moment.\nX4: Measure langle hatX^4 rangle, refer to measure_phonon_position_moment.\nholstein_energy: Refer to measure_holstein_energy.\nholstein_energy_up: Refer to measure_holstein_energy.\nholstein_energy_dn: Refer to measure_holstein_energy.\nssh_energy: Refer to measure_ssh_energy.\nssh_energy_up: Refer to measure_ssh_energy.\nssh_energy_dn: Refer to measure_ssh_energy.\nssh_sgn_switch_up: Refer to measure_ssh_sgn_switch.\nssh_sgn_switch_dn: Refer to measure_ssh_sgn_switch.\ndispersion_energy: Refer to measure_dispersion_energy.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_correlation_measurements!","page":"API","title":"SmoQyDQMC.initialize_correlation_measurements!","text":"initialize_correlation_measurements!(;\n    measurement_container::NamedTuple,\n    model_geometry::ModelGeometry{D,T,N},\n    correlation::String, pairs::AbstractVector{NTuple{2,Int}},\n    time_displaced::Bool,\n    integrated::Bool = false\n)  where {T<:AbstractFloat, D, N}\n\nInitialize measurements of correlation for all pairs of bond ID's in pairs. The name correlation must appear in CORRELATION_FUNCTIONS. If time_displaced = true then time-displaced and integrated correlation measurements are made. If time_displaced = false and integrated = false, then just equal-time correlation measurements are made. If time_displaced = false and integrated = true, then both equal-time and integrated correlation measurements are made.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_measurement_directories","page":"API","title":"SmoQyDQMC.initialize_measurement_directories","text":"initialize_measurement_directories(;\n    simulation_info::SimulationInfo,\n    measurement_container::NamedTuple\n)\n\nInitialize the measurement directories for simulation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Make-Measreuments","page":"API","title":"Make Measreuments","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"make_measurements!","category":"page"},{"location":"api/#SmoQyDQMC.make_measurements!","page":"API","title":"SmoQyDQMC.make_measurements!","text":"make_measurements!(\n    measurement_container::NamedTuple,\n    logdetGup::E, sgndetGup::T, Gup::AbstractMatrix{T},\n    Gup_ττ::AbstractMatrix{T}, Gup_τ0::AbstractMatrix{T}, Gup_0τ::AbstractMatrix{T},\n    logdetGdn::E, sgndetGdn::T, Gdn::AbstractMatrix{T},\n    Gdn_ττ::AbstractMatrix{T}, Gdn_τ0::AbstractMatrix{T}, Gdn_0τ::AbstractMatrix{T};\n    # Keyword Arguments Start Here\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P}, δG_max::E, δG::E, δθ::E,\n    model_geometry::ModelGeometry{D,E,N},\n    tight_binding_parameters::Union{Nothing, TightBindingParameters{T,E}} = nothing,\n    tight_binding_parameters_up::Union{Nothing, TightBindingParameters{T,E}} = nothing,\n    tight_binding_parameters_dn::Union{Nothing, TightBindingParameters{T,E}} = nothing,\n    coupling_parameters::Tuple\n) where {T<:Number, E<:AbstractFloat, D, N, P<:AbstractPropagator{T,E}}\n\nMake measurements, including time-displaced correlation and zero Matsubara frequency measurements. This method also returns (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ). Note that either the keywork tight_binding_parameters needs to be specified, or tight_binding_parameters_up and tight_binding_parameters_dn both need to be specified.\n\n\n\n\n\nmake_measurements!(\n    measurement_container::NamedTuple,\n    logdetG::E, sgndetG::T, G::AbstractMatrix{T},\n    G_ττ::AbstractMatrix{T}, G_τ0::AbstractMatrix{T}, G_0τ::AbstractMatrix{T};\n    # Keyword Arguments Start Here\n    fermion_path_integral::FermionPathIntegral{T,E},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    B::Vector{P}, δG_max::E, δG::E, δθ::E,\n    model_geometry::ModelGeometry{D,E,N},\n    tight_binding_parameters::TightBindingParameters{T,E},\n    coupling_parameters::Tuple\n) where {T<:Number, E<:AbstractFloat, D, N, P<:AbstractPropagator{T,E}}\n\nMake measurements, including time-displaced correlation and zero Matsubara frequency measurements. This method also returns (logdetG, sgndetG, δG, δθ).\n\n\n\n\n\n","category":"function"},{"location":"api/#Write-Measreuments","page":"API","title":"Write Measreuments","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"write_measurements!","category":"page"},{"location":"api/#SmoQyDQMC.write_measurements!","page":"API","title":"SmoQyDQMC.write_measurements!","text":"write_measurements!(; measurement_container::NamedTuple,\n                    simulation_info::SimulationInfo,\n                    model_geometry::ModelGeometry{D, E, N},\n                    bin::Int, bin_size::Int) where {E<:AbstractFloat, D, N}\n\nWrite the measurements contained in measurement_container to file. Measurements are written to file in a binary format using the JLD2.jl package.\n\nThis funciton also does a few other things:\n\nNormalizes all the measurements by the bin_size i.e. the number of measurements that were accumlated into the measurement container.\nTake position space correlation function measurements and fourier transform them to momentum space.\nIntegrate relevant time-displaced correlation function measurements over imaginary time to get the corresponding zero matsubara frequency correlation function.\nReset all the measurements in measurement_container to zero after the measurements are written to file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Process-Measurements","page":"API","title":"Process Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"save_simulation_info\nprocess_measurements\nprocess_global_measurements\nprocess_local_measurements\nprocess_correlation_measurements\nprocess_correlation_measurement\ncomposite_correlation_stat\nglobal_measurement_bins_to_csv\nlocal_measurement_bins_to_csv\ncorrelation_bins_to_csv","category":"page"},{"location":"api/#SmoQyDQMC.save_simulation_info","page":"API","title":"SmoQyDQMC.save_simulation_info","text":"save_simulation_info(sim_info::SimulationInfo, additional_info = nothing)\n\nSave the contents sim_info to a TOML file, and add an optional additional table to the output file based on the contents of a dictionary additional_info.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.process_measurements","page":"API","title":"SmoQyDQMC.process_measurements","text":"process_measurements(\n    folder::String,\n    N_bins::Int,\n    pIDs::Union{Vector{Int},Int} = Int[];\n    time_displaced::Bool = false\n)\n\nprocess_measurements(\n    comm::MPI.Comm,\n    folder::String,\n    N_bins::Int,\n    pIDs::Union{Vector{Int},Int} = Int[];\n    time_displaced::Bool = false\n)\n\nProcess the measurements recorded in the simulation directory folder, where N_bins is the number of bins the data is grouped into for calculating error bars. Note that this method will over-write an existing correlation stats file if there already is one. The boolean flag time_displaced determines whether or not to calculate error bars for time-displaced correlation measurements, as this can take a non-negligible amount of time for large system, especially when many simulations were run in parallel. Note that using pIDs argument you can filter which MPI walker to use when calculting the statistics.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.process_global_measurements","page":"API","title":"SmoQyDQMC.process_global_measurements","text":"process_global_measurements(\n    folder::String,\n    N_bins::Int,\n    pIDs::Union{Vector{Int},Int} = Int[]\n)\n\nprocess_global_measurements(\n    comm::MPI.Comm,\n    folder::String,\n    N_bins::Int,\n    pIDs::Vector{Int} = Int[]\n)\n\nProcess global measurents for the specified process IDs, calculating the average and error for all global measurements and writing the result to CSV file. If pIDs is not specified, then results for all MPI walkers are averaged over.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.process_local_measurements","page":"API","title":"SmoQyDQMC.process_local_measurements","text":"process_local_measurements(\n    folder::String,\n    N_bins::Int,\n    pIDs::Union{Vector{Int},Int} = Int[]\n)\n\nprocess_local_measurements(\n    comm::MPI.Comm,\n    folder::String,\n    N_bins::Int,\n    pIDs::Vector{Int} = Int[]\n)\n\nProcess local measurents for the specified process IDs, calculating the average and error for all local measurements and writing the result to CSV file. If pIDs is not specified, then the statistics are calculated using all MPI walker results.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.process_correlation_measurements","page":"API","title":"SmoQyDQMC.process_correlation_measurements","text":"process_correlation_measurements(\n    folder::String,\n    N_bins::Int,\n    pIDs::Union{Vector{Int},Int} = Int[],\n    types::Vector{String} = [\"equal-time\", \"time-displaced\", \"integrated\"],\n    spaces::Vector{String} = [\"position\", \"momentum\"]\n)\n\nfunction process_correlation_measurements(\n    comm::MPI.Comm,\n    N_bins::Int,\n    pIDs::Vector{Int} = Int[],\n    types::Vector{String} = [\"equal-time\", \"time-displaced\", \"integrated\"],\n    spaces::Vector{String} = [\"position\", \"momentum\"]\n)\n\nProcess correlation measurements, calculating the average and errors and writing the result to CSV file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.process_correlation_measurement","page":"API","title":"SmoQyDQMC.process_correlation_measurement","text":"process_correlation_measurement(\n    folder::String,\n    correlation::String,\n    type::String,\n    space::String,\n    N_bins::Int,\n    pIDs::Union{Vector{Int}, Int} = Int[]\n)\n\nProcess results for the specified correlation function, calculating the associated average and error statistics for it and writing the result to CSV file. If pIDs is not specified, then the calculated statistics are arrived at by averaging over the results for all MPI walkers.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.composite_correlation_stat","page":"API","title":"SmoQyDQMC.composite_correlation_stat","text":"composite_correlation_stat(;\n    folder::String,\n    correlations::Vector{String},\n    spaces::Vector{String},\n    types::Vector{String},\n    ids::Vector{NTuple{2,Int}},\n    locs::Vector{NTuple{D,Int}},\n    Δls::Vector{Int} = Int[],\n    num_bins::Int = 0,\n    pIDs::Vector{Int} = Int[],\n    f::Function = identity\n) where {D}\n\nfunction composite_correlation_stat(\n    comm::MPI.COMM;\n    # Keyword Arguments Below\n    folder::String,\n    correlations::Vector{String},\n    spaces::Vector{String},\n    types::Vector{String},\n    ids::Vector{NTuple{2,Int}},\n    locs::Vector{NTuple{D,Int}},\n    Δls::Vector{Int} = Int[],\n    num_bins::Int = 0,\n    pIDs::Vector{Int} = Int[],\n    f::Function = identity\n) where {D}\n\nCalaculate the mean and error for a composite correlation measurement based on the function f. Note that D indicates the spatial dimension of the system.\n\nKeywords\n\nfolder::String: The directory all the simulation results were written to.\ncorrelations::Vector{String}: Vector specifying the correlation types.\nspaces::Vector{String}: Space of each correlation measurement \"position\" or \"momentum\".\ntypes::Vector{String}: The type of each correlation measurement \"equal-time\", \"time-displaced\" or \"integrated\".\nids::Vector{NTuple{2,Int}}: Vector of ID pairs to read for each correlation.\nlocs::Vector{NTuple{D,Int}}: Species displacement vector for position space, or k-point for momentum space.\nΔls::Vector{Int} = Int[]: Displacement in imaginary time for time-displaced correlation measurements. Igonored otherwise.\nnum_bins::Int = 0: Number of bins used to calcuate error for each MPI walker, defaults to the number of JLD2 binary data files.\npIDs::Vector{Int} = Int[]: MPI walkers to average over when calculating states, defaults to using all MPI walkers if not specified.\nf::Function = identity: Function evaluated to calculate the composite correlation that is measured.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.global_measurement_bins_to_csv","page":"API","title":"SmoQyDQMC.global_measurement_bins_to_csv","text":"global_measurement_bins_to_csv(folder::String)\n\nWrite the binned global measurements to file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.local_measurement_bins_to_csv","page":"API","title":"SmoQyDQMC.local_measurement_bins_to_csv","text":"local_measurement_bins_to_csv(folder::String, measurement::String)\n\nWrite the binned values for the local measurement measurement to a CSV file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.correlation_bins_to_csv","page":"API","title":"SmoQyDQMC.correlation_bins_to_csv","text":"correlation_bins_to_csv(;\n    folder::String,\n    correlation::String,\n    type::String,\n    space::String,\n    write_index_key::Bool = true\n)\n\nWrite binned correlation data for correlation to a CSV file. The field type must be set equal to \"equal-time\", \"time-displaced\" or \"integrated\", and the field space but bet set to either \"position\" or \"momentum\".\n\n\n\n\n\n","category":"function"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"EditURL = \"../../../examples/hubbard_chain.jl\"","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/hubbard_chain/#Hubbard-Chain","page":"Hubbard Chain","title":"Hubbard Chain","text":"","category":"section"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"In this first example we will work through simulating the repulsive Hubbard model on a 1D chain at half-filling. The Hubbard Hamiltonian for a 1D chain is given by","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"hatH = -t sum_sigmai (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n+ U sum_i (hatn_uparrowi-tfrac12)(hatn_downarrowi-tfrac12)\n- mu sum_sigmai hatn_sigmai","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. In the above Hamiltonian t is the nearest neighbor hopping integral and U  0 controls the strength of the on-site Hubbard repulsion. Lastly, we consider the case that the system is half-filled and particle-hole symmetric, which occurs when when the chemical potential is zero, mu = 00.","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"Suppose we want to simulate a half-filled Hubbard chain (mu = 00) of length L=16 with U=80 at an inverse temperature of beta = 80. This is accomplished by running the script associated with this example using the command","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"> julia hubbard_chain.jl 1 6.0 0.0 8.0 16 2000 10000 50","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"with the resulting data being written to a local directory hubbard_chain_U6.00_mu0.00_L16_b8.00-1 that will be created. The first command line argument is the simulation ID (sID = 1), and reuslts in the directory name ending in -1. The second, third, fourth and fifth command line arguments correspond to U, mu, beta and L respectively. The sixth command line argument specifies the number thermalization/burnin sweeps (N_burnin = 2000) that are performed, where an update to each Hubbard-Stratonovich field is attempted. The seventh command line argument specifies the subsequent number of sweeps through the lattice (N_udpates = 10000), after each of which measurements are performed. Finally, the eighth command line argument specifies the number of times during the simulation data is written to file (N_bins = 50). Note that this example only runs for a few minutes on most systems and can be easily run on most personal computers.","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"However, it should be stressed that this structure for the simulation is not enforced by the SmoQyDQMC.jl package itself, but rather is simply a function of how the example_scripts/hubbard_chain.jl script is structured.","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"Below you will find a more heavily commented version of the example_scripts/hubbard_chain.jl script that includes additional exposition on what each part of the code is doing.","category":"page"},{"location":"examples/hubbard_chain/","page":"Hubbard Chain","title":"Hubbard Chain","text":"# First we import the required packages, including all of the required SmoQyDQMC submodules.\n\nusing LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# To start, we define a top-level function for running the DQMC simulation.\n# Note that the arguments to this function correspond to the command line arguments\n# used to run this script.\nfunction run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    # Note that the simulation ID `sID`` will be appended to this foldername as `*-sID`\n    datafolder_prefix = @sprintf \"hubbard_chain_U%.2f_mu%.2f_L%d_b%.2f\" U μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    # This type helps keep track of where data will be written to, and also what versions of\n    # SmoQyDQMC and Julia were used to run the script.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    # For convenience, we seed this function with a randomly sampled number for the\n    # global random number generator.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    # The function  dqmcf.eval_length_imaginary_axis() simply ensures\n    # that Lτ can be appropriately defined as an integer.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    # The bin size is the number of measurements that are averaged over each time data is written\n    # to file during the simulation.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    # Thinks of this as a simulation notebook where you can store any parameters you would like to record\n    # about how the DQMC simulation was run. For instance, it may be good to record the seed\n    # used to initialize the random number generator for reproducibility reasons. This dictionary\n    # will be appended as a table to the simulation information TOML file generated at the end of\n    # the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    # This struct defines the UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    # The struct describes the size of the finite periodic lattice to be simulated.\n    # Note that curretly periodic boundary condition must be used.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    # This type helps keep track of all the relevant features of the lattice\n    # geometry being simulated, including the defintion of the unit cell,\n    # the size of the finite periodic lattice, and all the relevant\n    # bond defintions that may arise in the model.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted = false, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n        U_orbital = [1],\n        U_mean = [U],\n    )\n\n    # Write the model summary to file.\n    # The model summary file, \"model_summary.toml\", is a very important file.\n    # It fully describes the model and system being simulated. It also defines all the\n    # various tID definitions (ORBITAL_ID, BOND_ID, HOPPING_ID, PHONON_ID)\n    # that measurements are reported in terms of. Therefore, this file is useful\n    # for understanding out the interpret and process the output data files.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n    # Above we defined the both the model and lattice size. Next, we initialize\n    # the actual system parameters. This is different because in general any\n    # parameter appearing in the model can support disorder. For instance, you\n    # can in simulate a system with random disorder in the on-site energy.\n    # Therefore, we need to initialize the parameters for the model on the lattice\n    # size we actually want to simulate.\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Here we initialize/define all the measurements we plan on making during the simulation.\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    # Because `time_displaced = true`, the time-displaced Greens function will be measured.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize density correlation function measurement.\n    # Because `time_displaced = false` and `integrated = true` the equal-time\n    # density correlation function, and the charge susceptibility will\n    # be measured. Note that the charge susceptibilty can be understood as the\n    # integral of the time-displaced density correlation function over\n    # the imaginary-time axis from τ=0 to τ=β.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    # Measure the local s-wave equal-time pair correlation function (`time-displaced = false`),\n    # and the corresponding pair susceptibility (`integrated = true`).\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # The code appearing in this section of the code is relatively boiler plate.\n    # While it may change in some small ways from system to system, the overall\n    # structure should remain relatively static.\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters, hubbard_ising_parameters)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    # This simulation summary file records the version number of SmoQyDQMC and Julia\n    # used to perform the simulation. The dictionary `additional_info` is appended\n    # as a table to the end of the simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n   # Note that everyting appearing in this section of the code is considered post-processing,\n   # and can be re-run so long as the data folder generated by the DQMC simulation persists\n   # and none of the binned data has been deleted from it.\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    μ = parse(Float64, ARGS[3])\n    β = parse(Float64, ARGS[4])\n    L = parse(Int, ARGS[5])\n    N_burnin = parse(Int, ARGS[6])\n    N_updates = parse(Int, ARGS[7])\n    N_bins = parse(Int, ARGS[8])\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"EditURL = \"../../../examples/holstein_zeeman_square.jl\"","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/holstein_zeeman_square/#Square-Holstein-Model-with-Zeeman-Splitting","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"","category":"section"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"In this example we write a script to simulate the Holstein model on a square lattice in an external applied magentic field perpendicular to the lattice, manifesting as a Zeeman splitting in the on-site energies between the spin up and down electrons. More generally, this examples demonstrates how to simulate models with explicit spin-dependence appearing in the Hamiltonian. The Hamiltonian is given by","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"beginalign*\nhatH =  -t sum_sigmalangle i j rangle (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n            + sum_sigmai(epsilon_sigma - mu) hatn_sigmai\n           + alpha sum_sigmai hatX_i (hatn_sigmai - tfrac12) \n           + sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)\nendalign*","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. The nearest-neighbor hopping amplitude is t and mu is the chemical potential. The Zeeman splitting is reflected in the on-site energies taking on spin-resolved values epsilon_pm = pm Deltaepsilon2. The strength of the repulsive Hubbard interaction is controlled by U0. hatX_i  (hatP_i) is the phonon position (momentum) operator for a dispersionless mode placed on site i with phonon frequency Omega and corresponding ion mass M. The stength of the Holstein electron-phonon is controlled by the parameter alpha.","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"> julia hubbard_holstein_square.jl 0 1.0 0.1 0.1 0.0 4.0 4 1000 5000 50","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"which simulates the Holstein model on a L = 4 square lattice, with Deltaepsilon = 10, Omega = 01, alpha = 01 and mu = 00 at an inverse temperature of beta = 40. In this simulation the Hubbard-Stranonovich and phonon fields are thermalized with N_burnin = 1000 rounds of updates, followed by N_udpates = 5000 rounds of updates with measurements being made. Bin averaged measurements are written to file N_bins = 50 during the simulation.","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing. Additionally, this script demonstrates how to calculate the extended s-wave and d-wave pair susceptibilities.","category":"page"},{"location":"examples/holstein_zeeman_square/","page":"Square Holstein Model with Zeeman Splitting","title":"Square Holstein Model with Zeeman Splitting","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running DQMC simulation\nfunction run_holstein_zeeman_square_simulation(sID, Δϵ, Ω, α, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_zeeman_square_ez%.2f_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Δϵ Ω α μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    bin_size = div(N_updates, N_bins)\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 4\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(Nt*Ω)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"reflection_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n        \"Nt\" => Nt,\n        \"dt\" => Δt,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0, 0.0],\n                                            [0.0, 1.0]],\n                            basis_vecs   = [[0.0, 0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Get the number of orbitals in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond in the +x direction.\n    bond_px = lu.Bond(orbitals = (1,1), displacement = [1,0])\n\n    # Add nearest-neighbor bond in the +x direction.\n    bond_px_id = add_bond!(model_geometry, bond_px)\n\n    # Define the nearest-neighbor bond in the +y direction.\n    bond_py = lu.Bond(orbitals = (1,1), displacement = [0,1])\n\n    # Add the nearest-neighbor bond in the +y direction.\n    bond_py_id = add_bond!(model_geometry, bond_py)\n\n    # Here we define bonds to points in the negative x and y directions respectively.\n    # We do this in order to be able to measure all the pairing channels we need\n    # in order to reconstruct the extended s-wave and d-wave pair susceptibilities.\n\n    # Define the nearest-neighbor bond in the -x direction.\n    bond_nx = lu.Bond(orbitals = (1,1), displacement = [-1,0])\n\n    # Add nearest-neighbor bond in the -x direction.\n    bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n    # Define the nearest-neighbor bond in the -y direction.\n    bond_ny = lu.Bond(orbitals = (1,1), displacement = [0,-1])\n\n    # Add the nearest-neighbor bond in the -y direction.\n    bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n    # Next we define the various Hamiltonian parameters for spin-up and spin-down seperately.\n    # Here, only the on-site energy will be different between the two spin species, but in\n    # general any other parameter appearing in the tight-binding model could as well, including\n    # including the mircoscropic interaction constants.\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the spin-up tight-binding model\n    tight_binding_model_up = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_px, bond_py],\n        t_mean = [t, t],\n        μ = μ,\n        ϵ_mean = [+Δϵ]\n    )\n\n    # Define the spin-down tight-binding model\n    tight_binding_model_dn = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_px, bond_py],\n        t_mean = [t, t],\n        μ = μ,\n        ϵ_mean = [-Δϵ]\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model_up = tight_binding_model_up,\n        tight_binding_model_dn = tight_binding_model_up\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon\n    )\n\n    # Define a spin-up on-site Holstein coupling between the electron and the local dispersionless phonon mode.\n    holstein_coupling_up = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_id,\n    \tbond = lu.Bond(orbitals = (1,1), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Define a spin-down on-site Holstein coupling between the electron and the local dispersionless phonon mode.\n    holstein_coupling_dn = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_id,\n    \tbond = lu.Bond(orbitals = (1,1), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model.\n    holstein_coupling_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling_up = holstein_coupling_up,\n        holstein_coupling_dn = holstein_coupling_dn,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Write the model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model_up = tight_binding_model_up,\n        tight_binding_model_dn = tight_binding_model_dn,\n        interactions = (electron_phonon_model,)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n    # Initialize spin-up tight-binding parameters.\n    tight_binding_parameters_up = TightBindingParameters(\n        tight_binding_model = tight_binding_model_up,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize spin-down tight-binding parameters.\n    tight_binding_parameters_dn = TightBindingParameters(\n        tight_binding_model = tight_binding_model_dn,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters_up = tight_binding_parameters_up,\n        tight_binding_parameters_dn = tight_binding_parameters_dn,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model_up, tight_binding_model_up)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Now we define the various correlation function measurements we would like to make.\n    # Note that relative to the other examples, we include spin-resolved correlation\n    # measurements as the underlying model being simulated is spin-dependent.\n\n    # Initialize the single-particle spin-up electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens_up\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the single-particle spin-down electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens_dn\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize total density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize spin-up density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density_upup\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize spin-down density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density_dndn\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize mixed-spin density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density_updn\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the total current correlation function measurement\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"current\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), # hopping ID pair for x-direction hopping\n                 (2, 2)] # hopping ID pair for y-direction hopping\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters_up, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters_dn, β = β, Δτ = Δτ)\n\n    # Initialize the fermion path integral type with respect to electron-phonon interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, electron_phonon_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_up_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_up)\n    fermion_greens_calculator_dn_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_dn)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = Gup, Nt = Nt, Δt = Δt\n    )\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a reflection update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, rng = rng, phonon_types = (phonon_id,)\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = hmc_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters,\n            hmc_updater,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn,\n            δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a reflection update.\n            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn,\n                electron_phonon_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n                Bup = Bup, Bdn = Bdn, rng = rng, phonon_types = (phonon_id,)\n            )\n\n            # Record whether the reflection update was accepted or rejected.\n            additional_info[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = hmc_update!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn,\n                electron_phonon_parameters,\n                hmc_updater,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n                Bup = Bup, Bdn = Bdn,\n                δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry,\n                tight_binding_parameters_up = tight_binding_parameters_up,\n                tight_binding_parameters_dn = tight_binding_parameters_dn,\n                coupling_parameters = (electron_phonon_parameters,)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rates.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n    additional_info[\"reflection_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    return nothing\nend\n\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Δϵ = parse(Float64, ARGS[2])\n    Ω = parse(Float64, ARGS[3])\n    α = parse(Float64, ARGS[4])\n    μ = parse(Float64, ARGS[5])\n    β = parse(Float64, ARGS[6])\n    L = parse(Int, ARGS[7])\n    N_burnin = parse(Int, ARGS[8])\n    N_updates = parse(Int, ARGS[9])\n    N_bins = parse(Int, ARGS[10])\n\n    # Run the simulation.\n    run_holstein_zeeman_square_simulation(sID, Δϵ, Ω, α, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"EditURL = \"../../../examples/hubbard_honeycomb.jl\"","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/hubbard_honeycomb/#Honeycomb-Hubbard-model","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"","category":"section"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"In this script we simulate the Hubbard model on a Honeycomb lattice, with a Hamiltonian given by","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"beginalign*\nhatH =  -t sum_sigmalangle i j rangle (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n            -mu sum_sigmaihatn_sigmai\n           + U sum_i (hatn_uparrowi-tfrac12)(hatn_downarrowi-tfrac12)\nendalign*","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. The nearest-neighbor hopping amplitude is t and mu is the chemical potential. The strength of the repulsive Hubbard interaction is controlled by U0.","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"> julia hubbard_honeycomb.jl 0 6.0 0.0 4.0 3 2000 10000 50","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"This simulates a half-filled (mu = 00) Hubabrd model on a 3 times 3 unit cell honeycomb lattice, with a Hubbard interaction of U = 60, at inverse temperature beta = 40.","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Honeycomb Hubbard model","title":"Honeycomb Hubbard model","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running DQMC simulation.\nfunction run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_honeycomb_U%.2f_mu%.2f_L%d_b%.2f\" U μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[3/2,√3/2],\n                        [3/2,-√3/2]],\n        basis_vecs   = [[0.,0.],\n                        [1.,0.]]\n    )\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the first nearest-neighbor bond in a honeycomb lattice.\n    bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n    # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_1_id = add_bond!(model_geometry, bond_1)\n\n    # Define the second nearest-neighbor bond in a honeycomb lattice.\n    bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n    # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_2_id = add_bond!(model_geometry, bond_2)\n\n    # Define the third nearest-neighbor bond in a honeycomb lattice.\n    bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n    # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_3_id = add_bond!(model_geometry, bond_3)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds        = [bond_1, bond_2, bond_3], # defines hopping\n        t_mean         = [t, t, t], # defines corresponding hopping amplitude\n        μ              = μ, # set chemical potential\n        ϵ_mean         = [0.0, 0.0] # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted   = false, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n        U_orbital = [1, 2],\n        U_mean    = [U, U],\n    )\n\n    # Write the model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1), (2, 2), (1, 2)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (1, 2)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (1, 2)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (1, 2)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters, hubbard_ising_parameters)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    μ = parse(Float64, ARGS[3])\n    β = parse(Float64, ARGS[4])\n    L = parse(Int, ARGS[5])\n    N_burnin = parse(Int, ARGS[6])\n    N_updates = parse(Int, ARGS[7])\n    N_bins = parse(Int, ARGS[8])\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Hubbard Chain with Checkpointing","title":"Hubbard Chain with Checkpointing","text":"EditURL = \"../../../examples/hubbard_chain_checkpoint.jl\"","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Hubbard Chain with Checkpointing","title":"Hubbard Chain with Checkpointing","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/hubbard_chain_checkpoint/#Hubbard-Chain-with-Checkpointing","page":"Hubbard Chain with Checkpointing","title":"Hubbard Chain with Checkpointing","text":"","category":"section"},{"location":"examples/hubbard_chain_checkpoint/","page":"Hubbard Chain with Checkpointing","title":"Hubbard Chain with Checkpointing","text":"In this script we take the script from the previous example and introduce checkpointing, so that if the simulation is killed at some point it can resumed from the previous checkpoint. It is important to note that how checkpointing is introduced in this script is not unique, and other checkpointing schemes could be implemented in a script. For instance, in this script the checkpointing is implemented such that the number of checkpoints written to file during the simulation is a fixed number at the start of the simulation. It is possible, though slightly more involved, to implement a checkpointing scheme that instead writes checkpoints to file based on the wall clock and the amount of time that has passed since the previous checkpoint was written to file.","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Hubbard Chain with Checkpointing","title":"Hubbard Chain with Checkpointing","text":"To write the checkpoints we use the package JLD2, which allows the checkpoint files to be written to file as binary files that are HDF5 compatible. In this script, following the thermalziation/burnin updates, a checkpoint is written to file whenever measurements are written to file, so a total of N_bins checkpoints are written following the initial thermalization/burnin period of the simulation. During the thermalization/burnin updates, checkpoints are written with the same frequency as they are going to be once measurements start getting made.","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Hubbard Chain with Checkpointing","title":"Hubbard Chain with Checkpointing","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Hubbard Chain with Checkpointing","title":"Hubbard Chain with Checkpointing","text":"using LinearAlgebra\nusing Random\nusing Printf\nusing MPI\n\n# Import JLD2 package for write checkpoints during the simulation\n# to file as a binary file.\nusing JLD2\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# initialize MPI\nMPI.Init()\n\n# Define top-level function for running DQMC simulation\nfunction run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_chain_U%.2f_mu%.2f_L%d_b%.2f\" U μ L β\n\n    # Get the MPI comm rank, which fixes the process ID (pID).\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID,\n        pID = pID\n    )\n\n    # Define checkpoint filename.\n    # We implement three checkpoint files, an old, current and new one,\n    # that get cycled through to ensure a checkpoint file always exists in the off\n    # chance that the simulation is killed while a checkpoint is getting written to file.\n    # Additionally, each simulation that is running in parallel with MPI will have their own\n    # checkpoints written to file.\n    datafolder = simulation_info.datafolder\n    sID        = simulation_info.sID\n    pID        = simulation_info.pID\n    checkpoint_name_old          = @sprintf \"checkpoint_sID%d_pID%d_old.jld2\" sID pID\n    checkpoint_filename_old      = joinpath(datafolder, checkpoint_name_old)\n    checkpoint_name_current      = @sprintf \"checkpoint_sID%d_pID%d_current.jld2\" sID pID\n    checkpoint_filename_current  = joinpath(datafolder, checkpoint_name_current)\n    checkpoint_name_new          = @sprintf \"checkpoint_sID%d_pID%d_new.jld2\" sID pID\n    checkpoint_filename_new      = joinpath(datafolder, checkpoint_name_new)\n\n    ######################################################\n    ### DEFINE SOME RELEVANT DQMC SIMULATION PARAMETERS ##\n    ######################################################\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = 0.0\n    δθ = 0.0\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted = false, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n        U_orbital = [1],\n        U_mean = [U],\n    )\n\n    #######################################################\n    ### BRANCHING BEHAVIOR BASED ON WHETHER STARTING NEW ##\n    ### SIMULAIOTN OR RESUMING PREVIOUS SIMULATION.      ##\n    #######################################################\n\n    # Synchronize all the MPI processes.\n    MPI.Barrier(comm)\n\n    # If starting a new simulation.\n    if !simulation_info.resuming\n\n        # Initialize a random number generator that will be used throughout the simulation.\n        seed = abs(rand(Int))\n        rng = Xoshiro(seed)\n\n        # Initialize the directory the data will be written to.\n        initialize_datafolder(simulation_info)\n\n        # Write the model summary to file.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (hubbard_model,)\n        )\n\n        # Calculate the bins size.\n        bin_size = div(N_updates, N_bins)\n\n        # Initialize a dictionary to store additional information about the simulation.\n        additional_info = Dict(\n            \"dG_max\" => δG_max,\n            \"N_burnin\" => N_burnin,\n            \"N_updates\" => N_updates,\n            \"N_bins\" => N_bins,\n            \"bin_size\" => bin_size,\n            \"local_acceptance_rate\" => 0.0,\n            \"reflection_acceptance_rate\" => 0.0,\n            \"n_stab_init\" => n_stab,\n            \"symmetric\" => symmetric,\n            \"checkerboard\" => checkerboard,\n            \"seed\" => seed,\n        )\n\n        #########################################\n        ### INITIALIZE FINITE MODEL PARAMETERS ##\n        #########################################\n\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize Hubbard interaction parameters.\n        hubbard_parameters = HubbardParameters(\n            model_geometry = model_geometry,\n            hubbard_model = hubbard_model,\n            rng = rng\n        )\n\n        # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n        # corresponding HS fields that will be sampled in DQMC simulation.\n        hubbard_ising_parameters = HubbardIsingHSParameters(\n            β = β, Δτ = Δτ,\n            hubbard_parameters = hubbard_parameters,\n            rng = rng\n        )\n\n        ##############################\n        ### INITIALIZE MEASUREMENTS ##\n        ##############################\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the Hubbard interaction related measurements.\n        initialize_measurements!(measurement_container, hubbard_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the sub-directories to which the various measurements will be written.\n        initialize_measurement_directories(\n            simulation_info = simulation_info,\n            measurement_container = measurement_container\n        )\n\n        #############################\n        ### WRITE FIRST CHECKPOINT ##\n        #############################\n\n        # Calculate the bin size.\n        bin_size = div(N_updates, N_bins)\n\n        # Calculate the number of thermalization/burnin bins.\n        # This determines the number times the simulations checkpoints\n        # during the initial thermalziation/burnin period.\n        N_bins_burnin = div(N_burnin, bin_size)\n\n        # Initialize variable to keep track of the current burnin bin.\n        n_bin_burnin = 1\n\n        # Initialize variable to keep track of the current bin.\n        n_bin = 1\n\n        # Write an initial checkpoint to file.\n        JLD2.jldsave(\n            checkpoint_filename_current;\n            rng, additional_info,\n            N_burnin, N_updates, N_bins,\n            bin_size, N_bins_burnin, n_bin_burnin, n_bin,\n            measurement_container,\n            model_geometry,\n            tight_binding_parameters,\n            hubbard_parameters,\n            dG = δG, dtheta = δθ, n_stab = n_stab\n        )\n\n    # If resuming simulation from previous checkpoint.\n    else\n\n        # Initialize checkpoint to nothing before it is loaded.\n        checkpoint = nothing\n\n        # Try loading in the new checkpoint.\n        if isfile(checkpoint_filename_new)\n            try\n                # Load the new checkpoint.\n                checkpoint = JLD2.load(checkpoint_filename_new)\n            catch\n                nothing\n            end\n        end\n\n        # Try loading in the current checkpoint.\n        if isfile(checkpoint_filename_current) && isnothing(checkpoint)\n            try\n                # Load the current checkpoint.\n                checkpoint = JLD2.load(checkpoint_filename_current)\n            catch\n                nothing\n            end\n        end\n\n        # Try loading in the current checkpoint.\n        if isfile(checkpoint_filename_old) && isnothing(checkpoint)\n            try\n                # Load the old checkpoint.\n                checkpoint = JLD2.load(checkpoint_filename_old)\n            catch\n                nothing\n            end\n        end\n\n        # Throw an error if no checkpoint was succesfully loaded.\n        if isnothing(checkpoint)\n            error(\"Failed to load checkpoint successfully!\")\n        end\n\n        # Unpack the contents of the checkpoint.\n        rng                      = checkpoint[\"rng\"]\n        additional_info          = checkpoint[\"additional_info\"]\n        N_burnin                 = checkpoint[\"N_burnin\"]\n        N_updates                = checkpoint[\"N_updates\"]\n        N_bins                   = checkpoint[\"N_bins\"]\n        bin_size                 = checkpoint[\"bin_size\"]\n        N_bins_burnin            = checkpoint[\"N_bins_burnin\"]\n        n_bin_burnin             = checkpoint[\"n_bin_burnin\"]\n        n_bin                    = checkpoint[\"n_bin\"]\n        model_geometry           = checkpoint[\"model_geometry\"]\n        measurement_container    = checkpoint[\"measurement_container\"]\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        hubbard_parameters       = checkpoint[\"hubbard_parameters\"]\n        hubbard_ising_parameters = checkpoint[\"hubbard_ising_parameters\"]\n        δG                       = checkpoint[\"dG\"]\n        δθ                       = checkpoint[\"dtheta\"]\n        n_stab                   = checkpoint[\"n_stab\"]\n    end\n\n    # Synchronize all the MPI processes.\n    MPI.Barrier(comm)\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization bins.\n    for bin in n_bin_burnin:N_bins_burnin\n\n        # Iterate over updates in current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n        end\n\n        # Write the new checkpoint to file.\n        JLD2.jldsave(\n            checkpoint_filename_new;\n            rng, additional_info,\n            N_burnin, N_updates, N_bins,\n            bin_size, N_bins_burnin,\n            n_bin_burnin = bin + 1,\n            n_bin = 1,\n            measurement_container,\n            model_geometry,\n            tight_binding_parameters,\n            hubbard_parameters,\n            hubbard_ising_parameters,\n            dG = δG, dtheta = δθ, n_stab = n_stab\n        )\n        # Make the current checkpoint the old checkpoint.\n        mv(checkpoint_filename_current, checkpoint_filename_old, force = true)\n        # Make the new checkpoint the current checkpoint.\n        mv(checkpoint_filename_new, checkpoint_filename_current, force = true)\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in n_bin:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters, hubbard_ising_parameters)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write the new checkpoint to file.\n        JLD2.jldsave(\n            checkpoint_filename_new;\n            rng, additional_info,\n            N_burnin, N_updates, N_bins,\n            bin_size, N_bins_burnin,\n            n_bin_burnin = N_bins_burnin+1,\n            n_bin = bin + 1,\n            measurement_container,\n            model_geometry,\n            tight_binding_parameters,\n            hubbard_parameters,\n            hubbard_ising_parameters,\n            dG = δG, dtheta = δθ, n_stab = n_stab\n        )\n        # Make the current checkpoint the old checkpoint.\n        mv(checkpoint_filename_current, checkpoint_filename_old, force = true)\n        # Make the new checkpoint the current checkpoint.\n        mv(checkpoint_filename_new, checkpoint_filename_current, force = true)\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Synchronize all the MPI processes.\n    MPI.Barrier(comm)\n\n    # Have the primary MPI process calculate the final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    if iszero(simulation_info.pID)\n        process_measurements(simulation_info.datafolder, N_bins)\n    end\n\n    return nothing\nend\n\n\n# Only excute if script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    μ = parse(Float64, ARGS[3])\n    β = parse(Float64, ARGS[4])\n    L = parse(Int, ARGS[5])\n    N_burnin = parse(Int, ARGS[6])\n    N_updates = parse(Int, ARGS[7])\n    N_bins = parse(Int, ARGS[8])\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins)\n\n    # Finalize MPI (not strictly required).\n    MPI.Finalize()\nend","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"EditURL = \"../../../examples/ossh_chain.jl\"","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/ossh_chain/#Optical-Su-Schrieffer-Heeger-Chain","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"","category":"section"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"In this example we simulate the optical Su-Schrieffer-Heeger (OSSH) model on a 1D chain, with a Hamiltonian given by","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"beginalign*\nhatH = sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)\n          - sum_sigmai t-alpha(hatX_i+1-hatX_i) (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n          - mu sum_sigmai hatn_sigmai\nendalign*","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"in which the fluctuations in the position of dispersionless phonon modes placed on each site in the lattice modulate the hopping amplitude between neighboring sites. In the above expression hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creation (annihilation) operator a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on site i is given by hatX_i  (hatP_i), where Omega and M are the phonon frequency and associated ion mass respectively. Lastly, the strength of the electron-phonon coupling is controlled by the parameter alpha.","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"> julia ossh_chain.jl 0 1.0 0.5 0.0 4.0 16 1000 5000 20","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"which simulates an L=16 chain with Omega = 10, alpha = 05 at half-filling (mu = 00) and an inverse temperature of beta = 40. In this example N_burnin = 1000 HMC thermalization updates are performed, followed an additional N_updates = 5000 HMC updates, after each of which measurements are made. Bin averaged measurements are then written to file N_bins = 20 during the simulation.","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/ossh_chain/","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running the DQMC simulation.\nfunction run_ossh_chain_simulation(sID, Ω, α, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"ossh_chain_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.05\n\n    # For performance reasons it is important that we represent the exponentiated hopping\n    # matrix with the checkerboard approximation when simulating an SSH model, where the\n    # phonons modulate the hopping amplitudes. Without the checkerboard approximation,\n    # each time a phonon field is updated the kinetic energy matrix would need to be diagonalized\n    # to calculate its exponential, which is very computationally expensive.\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = true\n\n    # As we are using the checkboard approximation, using a symmetric definition for the propagator\n    # matrices is important as it significantly improves the accuracy of approximation.\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = true\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bin size.\n    bin_size = div(N_updates, N_bins)\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 4\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(Nt*Ω)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"swap_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"Nt\" => Nt,\n        \"dt\" => Δt,\n        \"seed\" => seed,\n    )\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Get the number of sites in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add optical ssh phonon to electron-phonon model.\n    phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon\n    )\n\n    # Define optical SSH coupling.\n    # Defines total effective hopping amplitude given by t_eff = t-α⋅(Xᵢ₊₁-Xᵢ).\n    ossh_coupling = SSHCoupling(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        phonon_modes = (phonon_id, phonon_id),\n        bond = bond,\n        α_mean = α\n    )\n\n    # Add optical SSH coupling to the electron-phonon model.\n    ossh_coupling_id = add_ssh_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        ssh_coupling = ossh_coupling,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Write a model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )\n\n    #################################################\n    ### INITIALIZE FINITE LATTICE MODEL PARAMETERS ##\n    #################################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the measurement container.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the measurements associated with the tight-binding model.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the measurements associated with the electron-phonon model.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize time-displaced Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize time-displaced phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(phonon_id, phonon_id)]\n    )\n\n    # Initialize the density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurements.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (bond_id, bond_id)]\n    )\n\n    # Initialize the bond correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"bond\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(bond_id, bond_id)]\n    )\n\n    # Initialize current-current correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"current\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)] # Hopping ID pair.\n    )\n\n    # Initialize the sub-directories the various measurements will be written to.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Allocate and initialize propagators for each imaginary time slice.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize fermion greens calculator.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize equal-time Green's function matrix\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt\n    )\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a swap update.\n        # In a swap update, to phonon modes are randomly selected in the lattice\n        # and their phonon fields are exchanged for all imaginary time slices.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng, phonon_type_pairs = ((phonon_id, phonon_id),)\n        )\n\n        # Record whether the swap update was accepted or rejected.\n        additional_info[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a swap update..\n            (accepted, logdetG, sgndetG) = swap_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, rng = rng, phonon_type_pairs = ((phonon_id, phonon_id),)\n            )\n\n            # Record whether the swap update was accepted or rejected.\n            additional_info[\"swap_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Make measurements.\n            (logdetG, sgndetG, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (electron_phonon_parameters,)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate HMC acceptance rate.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Calculate swap update acceptance rate.\n    additional_info[\"swap_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ω = parse(Float64, ARGS[2])\n    α = parse(Float64, ARGS[3])\n    μ = parse(Float64, ARGS[4])\n    β = parse(Float64, ARGS[5])\n    L = parse(Int, ARGS[6])\n    N_burnin = parse(Int, ARGS[7])\n    N_updates = parse(Int, ARGS[8])\n    N_bins = parse(Int, ARGS[9])\n\n    # Run the simulation.\n    run_ossh_chain_simulation(sID, Ω, α, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"EditURL = \"../../../examples/hubbard_holstein_square.jl\"","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/hubbard_holstein_square/#Square-Hubbard-Holstein-Model","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"","category":"section"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"In this example we write a script to simulate the Hubbard-Holstein model on a square lattice, with a Hamiltonian given by","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"beginalign*\nhatH =  -t sum_sigmalangle i j rangle (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n            -mu sum_sigmaihatn_sigmai\n           + U sum_i (hatn_uparrowi-tfrac12)(hatn_downarrowi-tfrac12)\n            + alpha sum_sigmai hatX_i (hatn_sigmai - tfrac12) \n           + sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)\nendalign*","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. The nearest-neighbor hopping amplitude is t and mu is the chemical potential. The strength of the repulsive Hubbard interaction is controlled by U0. hatX_i  (hatP_i) is the phonon position (momentum) operator for a dispersionless mode placed on site i with phonon frequency Omega and corresponding ion mass M. The stength of the Holstein electron-phonon is controlled by the parameter alpha.","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"> julia hubbard_holstein_square.jl 0 6.0 0.1 0.1 0.0 4.0 4 1000 5000 50","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"which simulates the Hubbard-Holstein model on a L = 4 square lattice, with U = 60, Omega = 01, alpha = 01 and mu = 00 at an inverse temperature of beta = 40. In this simulation the Hubbard-Stranonovich and phonon fields are thermalized with N_burnin = 1000 rounds of updates, followed by N_udpates = 5000 rounds of updates with measurements being made. Bin averaged measurements are written to file N_bins = 50 during the simulation.","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing. Additionally, this script demonstrates how to calculate the extended s-wave and d-wave pair susceptibilities.","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Square Hubbard-Holstein Model","title":"Square Hubbard-Holstein Model","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running DQMC simulation\nfunction run_hubbard_holstein_square_simulation(sID, U, Ω, α, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_holstein_square_U%.2f_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" U Ω α μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    bin_size = div(N_updates, N_bins)\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 4\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(Nt*Ω)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"reflection_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n        \"Nt\" => Nt,\n        \"dt\" => Δt,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0, 0.0],\n                                            [0.0, 1.0]],\n                            basis_vecs   = [[0.0, 0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Get the number of orbitals in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond in the +x direction.\n    bond_px = lu.Bond(orbitals = (1,1), displacement = [1,0])\n\n    # Add nearest-neighbor bond in the +x direction.\n    bond_px_id = add_bond!(model_geometry, bond_px)\n\n    # Define the nearest-neighbor bond in the +y direction.\n    bond_py = lu.Bond(orbitals = (1,1), displacement = [0,1])\n\n    # Add the nearest-neighbor bond in the +y direction.\n    bond_py_id = add_bond!(model_geometry, bond_py)\n\n    # Here we define bonds to points in the negative x and y directions respectively.\n    # We do this in order to be able to measure all the pairing channels we need\n    # in order to reconstruct the extended s-wave and d-wave pair susceptibilities.\n\n    # Define the nearest-neighbor bond in the -x direction.\n    bond_nx = lu.Bond(orbitals = (1,1), displacement = [-1,0])\n\n    # Add nearest-neighbor bond in the -x direction.\n    bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n    # Define the nearest-neighbor bond in the -y direction.\n    bond_ny = lu.Bond(orbitals = (1,1), displacement = [0,-1])\n\n    # Add the nearest-neighbor bond in the -y direction.\n    bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_px, bond_py], # defines hopping\n        t_mean = [t, t],            # defines corresponding hopping amplitude\n        μ = μ,                      # set chemical potential\n        ϵ_mean = [0.]               # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted = false,\n        U_orbital = [1],\n        U_mean = [U],\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon\n    )\n\n    # Define a on-site Holstein coupling between the electron and the local dispersionless phonon mode.\n    holstein_coupling = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_id,\n    \tbond = lu.Bond(orbitals = (1,1), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model.\n    holstein_coupling_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Write the model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model, electron_phonon_model)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # measure equal-times green's function for all τ\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens_tautau\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Measure all possible combinations of bond pairing channels\n    # for the bonds we have defined. We will need each of these\n    # pairs channels measured in order to reconstruct the extended\n    # s-wave and d-wave pair susceptibilities.\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1),\n                 (bond_px_id, bond_px_id), (bond_px_id, bond_nx_id),\n                 (bond_nx_id, bond_px_id), (bond_nx_id, bond_nx_id),\n                 (bond_py_id, bond_py_id), (bond_py_id, bond_ny_id),\n                 (bond_ny_id, bond_py_id), (bond_ny_id, bond_ny_id),\n                 (bond_px_id, bond_py_id), (bond_px_id, bond_ny_id),\n                 (bond_nx_id, bond_py_id), (bond_nx_id, bond_ny_id),\n                 (bond_py_id, bond_px_id), (bond_py_id, bond_nx_id),\n                 (bond_ny_id, bond_px_id), (bond_ny_id, bond_nx_id)]\n    )\n\n    # Initialize the current correlation function measurement\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"current\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), # hopping ID pair for x-direction hopping\n                 (2, 2)] # hopping ID pair for y-direction hopping\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the fermion path integral type with respect to electron-phonon interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, electron_phonon_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_up_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_up)\n    fermion_greens_calculator_dn_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_dn)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = Gup, Nt = Nt, Δt = Δt\n    )\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a reflection update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, rng = rng, phonon_types = (phonon_id,)\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = hmc_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters,\n            hmc_updater,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn,\n            δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a reflection update.\n            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn,\n                electron_phonon_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n                Bup = Bup, Bdn = Bdn, rng = rng, phonon_types = (phonon_id,)\n            )\n\n            # Record whether the reflection update was accepted or rejected.\n            additional_info[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = hmc_update!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn,\n                electron_phonon_parameters,\n                hmc_updater,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n                Bup = Bup, Bdn = Bdn,\n                δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (\n                    hubbard_parameters,\n                    hubbard_ising_parameters,\n                    electron_phonon_parameters\n                )\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rates.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n    additional_info[\"reflection_acceptance_rate\"] /= (N_updates + N_burnin)\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    # Here we use the `composite_correlation_stats` to reconstruct the extended\n    # s-wave and d-wave pair susceptibilities. We also subract off the background\n    # signal associated with the zero-momentum transfer charge susceptibility.\n    # Behind the scenes, uses the binning\n    # method to calculate the error bars by calculating both susceptibilities for\n    # each bin of data that was written to file.\n\n    # Measure the extended s-wave pair susceptibility.\n    Pes, ΔPes = composite_correlation_stat(\n        folder = simulation_info.datafolder,\n        correlations = [\"pair\", \"pair\", \"pair\", \"pair\",\n                        \"pair\", \"pair\", \"pair\", \"pair\",\n                        \"pair\", \"pair\", \"pair\", \"pair\",\n                        \"pair\", \"pair\", \"pair\", \"pair\"],\n        spaces = [\"momentum\", \"momentum\", \"momentum\", \"momentum\",\n                  \"momentum\", \"momentum\", \"momentum\", \"momentum\",\n                  \"momentum\", \"momentum\", \"momentum\", \"momentum\",\n                  \"momentum\", \"momentum\", \"momentum\", \"momentum\"],\n        types = [\"integrated\", \"integrated\", \"integrated\", \"integrated\",\n                 \"integrated\", \"integrated\", \"integrated\", \"integrated\",\n                 \"integrated\", \"integrated\", \"integrated\", \"integrated\",\n                 \"integrated\", \"integrated\", \"integrated\", \"integrated\"],\n        ids = [(bond_px_id, bond_px_id), (bond_nx_id, bond_nx_id), (bond_px_id, bond_nx_id), (bond_nx_id, bond_px_id),\n               (bond_py_id, bond_py_id), (bond_ny_id, bond_ny_id), (bond_py_id, bond_ny_id), (bond_ny_id, bond_py_id),\n               (bond_px_id, bond_py_id), (bond_nx_id, bond_ny_id), (bond_px_id, bond_ny_id), (bond_nx_id, bond_py_id),\n               (bond_py_id, bond_px_id), (bond_ny_id, bond_nx_id), (bond_py_id, bond_nx_id), (bond_ny_id, bond_px_id)],\n        locs = [(0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0)],\n        num_bins = N_bins,\n        f = (P_px_px, P_nx_nx, P_px_nx, P_nx_px,\n             P_py_py, P_ny_ny, P_py_ny, P_ny_py,\n             P_px_py, P_nx_ny, P_px_ny, P_nx_py,\n             P_py_px, P_ny_nx, P_py_nx, P_ny_px) -> (P_px_px + P_nx_nx + P_px_nx + P_nx_px +\n                                                     P_py_py + P_ny_ny + P_py_ny + P_ny_py +\n                                                     P_px_py + P_nx_ny + P_px_ny + P_nx_py +\n                                                     P_py_px + P_ny_nx + P_py_nx + P_ny_px)/4\n    )\n    additional_info[\"P_ext-s_avg\"] = Pes\n    additional_info[\"P_ext-s_err\"] = ΔPes\n\n    # Measure the d-wave pair susceptibility.\n    Pd, ΔPd = composite_correlation_stat(\n        folder = simulation_info.datafolder,\n        correlations = [\"pair\", \"pair\", \"pair\", \"pair\",\n                        \"pair\", \"pair\", \"pair\", \"pair\",\n                        \"pair\", \"pair\", \"pair\", \"pair\",\n                        \"pair\", \"pair\", \"pair\", \"pair\"],\n        spaces = [\"momentum\", \"momentum\", \"momentum\", \"momentum\",\n                  \"momentum\", \"momentum\", \"momentum\", \"momentum\",\n                  \"momentum\", \"momentum\", \"momentum\", \"momentum\",\n                  \"momentum\", \"momentum\", \"momentum\", \"momentum\"],\n        types = [\"integrated\", \"integrated\", \"integrated\", \"integrated\",\n                 \"integrated\", \"integrated\", \"integrated\", \"integrated\",\n                 \"integrated\", \"integrated\", \"integrated\", \"integrated\",\n                 \"integrated\", \"integrated\", \"integrated\", \"integrated\"],\n        ids = [(bond_px_id, bond_px_id), (bond_nx_id, bond_nx_id), (bond_px_id, bond_nx_id), (bond_nx_id, bond_px_id),\n               (bond_py_id, bond_py_id), (bond_ny_id, bond_ny_id), (bond_py_id, bond_ny_id), (bond_ny_id, bond_py_id),\n               (bond_px_id, bond_py_id), (bond_nx_id, bond_ny_id), (bond_px_id, bond_ny_id), (bond_nx_id, bond_py_id),\n               (bond_py_id, bond_px_id), (bond_ny_id, bond_nx_id), (bond_py_id, bond_nx_id), (bond_ny_id, bond_px_id)],\n        locs = [(0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0)],\n        num_bins = N_bins,\n        f = (P_px_px, P_nx_nx, P_px_nx, P_nx_px,\n             P_py_py, P_ny_ny, P_py_ny, P_ny_py,\n             P_px_py, P_nx_ny, P_px_ny, P_nx_py,\n             P_py_px, P_ny_nx, P_py_nx, P_ny_px) -> (P_px_px + P_nx_nx + P_px_nx + P_nx_px +\n                                                     P_py_py + P_ny_ny + P_py_ny + P_ny_py -\n                                                     P_px_py - P_nx_ny - P_px_ny - P_nx_py -\n                                                     P_py_px - P_ny_nx - P_py_nx - P_ny_px)/4\n    )\n    additional_info[\"P_d_avg\"] = Pd\n    additional_info[\"P_d_err\"] = ΔPd\n\n    # Calculate the charge susceptibility for zero momentum transfer (q=0)\n    # with the net charge background signal subtracted off.\n\n    # Calculate the Cu-Cu charge susceptibility at q=0 with the background signal removed.\n    C0, ΔC0 = composite_correlation_stat(\n        folder = simulation_info.datafolder,\n        correlations = [\"density\", \"greens_tautau\", \"greens\"],\n        spaces = [\"momentum\", \"position\", \"position\"],\n        types = [\"integrated\", \"integrated\", \"time-displaced\"],\n        ids = [(1,1), (1,1), (1,1)],\n        locs = [(0,0), (0,0), (0,0)],\n        Δls = [0, 0, 0],\n        num_bins = N_bins,\n        f = (x, y, z) -> x - (L^2)*4*(β-y)*(1-z)\n    )\n    additional_info[\"Chi_C_q0_avg\"] = C0\n    additional_info[\"Chi_C_q0_err\"] = ΔC0\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    return nothing\nend\n\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    Ω = parse(Float64, ARGS[3])\n    α = parse(Float64, ARGS[4])\n    μ = parse(Float64, ARGS[5])\n    β = parse(Float64, ARGS[6])\n    L = parse(Int, ARGS[7])\n    N_burnin = parse(Int, ARGS[8])\n    N_updates = parse(Int, ARGS[9])\n    N_bins = parse(Int, ARGS[10])\n\n    # Run the simulation.\n    run_hubbard_holstein_square_simulation(sID, U, Ω, α, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"hamiltonian/#Supported-Hamiltonians","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"","category":"section"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"This section describes the class of Hamiltonians SmoQyDQMC.jl currently supports, and how the various terms appearing in the Hamiltonian are parameterized within the code. We start by partitioning the full Hamiltonian as ","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalH = hatmathcalU + hatmathcalK + hatmathcalV\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"where hatmathcalU is the bare lattice energy, hatmathcalK the total electron kinetic energy, and hatmathcalV the total electron potential energy. In the discussion that follows we apply the normalization hbar = 1 throughout.","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"The bare lattice term is further decomposed into","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalU = hatmathcalU_rm ph + hatmathcalU_rm disp\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"where","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalU_rm ph = sum_mathbfinusum_n_mathbfinu\n        left\n            frac12M_n_mathbfinuhatP_n_mathbfinu\n            + frac12M_n_mathbfinuOmega_0n_mathbfinu^2hatX_n_mathbfinu^2\n            + frac124M_n_mathbfinuOmega_an_mathbfinu^2hatX_n_mathbfinu^4\n        right\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"describes the placement of local dispersionless phonon (LDP) modes in the lattice, i.e. an Einstein solid, and","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalU_rm disp = sum_substackmathbfinu  mathbfjgammasum_substackn_mathbfinu  n_mathbfjgamma\n        fracM_n_mathbfialphaM_n_mathbfjgammaM_n_mathbfialpha+M_n_mathbfjgammaleft\n            tildeOmega^2_0n_mathbfialphan_mathbfjgamma(hatX_n_mathbfinu-hatX_n_mathbfjgamma)^2\n            + frac112tildeOmega^2_an_mathbfialphan_mathbfjgamma(hatX_n_mathbfinu-hatX_n_mathbfjgamma)^4\n        right\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"introduces dispersion between the LDP modes. The sums over mathbfi  (mathbfj) and nu  (gamma) run over unit cells in the lattice and orbitals within each unit cell respectively. A sum over n_mathbfinu  (n_mathbfjgamma) then runs over the LDP modes placed on a given orbital in the lattice.","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"The position and momentum operators for each LPD mode are given by hatX_n_mathbfinu and hatP_n_mathbfinu respectively, with corresponding phonon mass M_n_mathbfinu. The spring constant is K_n_mathbfinu = M_n_mathbfinu Omega_0n_n_mathbfinu^2, with Omega_0n_n_mathbfinu specifying the phonon frequency. The U_rm ph also supports an anharmonic hatX_n_mathbfinu^4 contribution to the LDP potential energy that is controlled by the parameter Omega_an_n_mathbfinu. Similary, tildeOmega_0n_mathbfialphan_mathbfjgamma  (tildeOmega_an_mathbfialphan_mathbfjgamma) is the coefficient controlling harmonic (anhmaronic) dispersion between LDP modes.","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"Next we trace out the phonon degrees of freedom ","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"The electron kinetic energy is decomposed as","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalK = sum_sigma=uparrowdownarrow left hatmathcalK_sigma0 + hatmathcalK_sigmarm ssh right\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"where","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalK_sigma0 = -sum_substackmathbfinu  mathbfjgamma\n        left\n            t_sigma(mathbfinu)(mathbfjgamma) hatc^dagger_sigmamathbfinuhatc_sigmamathbfjgamma + rm hc\n        right\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"is the non-interacting spin-sigma electron kinetic energy, and","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalK_sigmarm ssh = sum_substackmathbfinu  mathbfjgammasum_substackn_mathbfinu  n_mathbfjgammasum_m=1^4\n        (hatX_n_mathbfinu-hatX_n_mathbfjgamma)^mleft\n            alpha_sigmamn_mathbfinun_mathbfjgamma hatc^dagger_sigmamathbfinuhatc_sigmamathbfjgamma + rm hc\n        right\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"is describes the interaction between the lattice degrees of freedom and the spin-sigma electron kinetic energy via a Su-Schrieffer-Heeger (SSH)-like coupling mechanism. The hopping integral between from orbital gamma in unit cell mathbfj to orbital nu in unit cell mathbfi is given by t_(mathbfinu)(mathbfjgamma), and may in general be complex. The modulations to this hopping integral are controlled by the parameters alpha_m(mathbfinu)(mathbfjgamma), where min 14 specifies the order of the difference in the phonon positions that modulates the hopping integral.","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"Lastly, the electron potential energy is broken down into the three terms","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalV = sum_sigma=uparrowdownarrow left hatmathcalV_sigma0 + hatmathcalV_sigmarm hol right + hatmathcalV_rm hub\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"where","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalV_sigma0 = sum_mathbfinu\n        left\n            (epsilon_sigmamathbfinu - mu) hatn_sigmamathbfinu\n        right\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"is the non-interacting spin-sigma electron potential energy,","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalV_sigmarm hol =\n    begincases\n        sum_mathbfinu summathbfjgamma sum_n_mathbfinu leftsum_m=13tildealpha_sigmamn_mathbfinu(mathbfjgamma)  hatX^m_n_mathbfinu(hatn_sigmamathbfjgamma - tfrac12) + sum_m=24tildealpha_sigmamn_mathbfinu(mathbfjgamma)  hatX^m_n_mathbfinuhatn_sigmamathbfjgammaright \n        sum_mathbfinu summathbfjgamma sum_n_mathbfinu sum_m=1^4 tildealpha_sigmamn_mathbfinu(mathbfjgamma)  hatX^m_n_mathbfinu hatn_sigmamathbfjgamma\n    endcases\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"is the contribution to the spin-sigma electron potential energy that results from a Holstein-like coupling to the lattice degrees of freedom, and","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"beginalign*\n    hatmathcalV_rm hub=\n    begincases\n        sum_mathbfinuU_mathbfinubig(hatn_uparrowmathbfinu-tfrac12big)big(hatn_downarrowmathbfinu-tfrac12big)\n        sum_mathbfinuU_mathbfinuhatn_uparrowmathbfinuhatn_downarrowmathbfinu\n    endcases\nendalign*","category":"page"},{"location":"hamiltonian/","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"is the on-site Hubbard interaction contribution to the electron potential energy. In hatmathcalV_0 the chemical potential is given by mu, and epsilon_mathbfinu is the on-site energy, the parameter tildealpha_mn_mathbfinu(mathbfjgamma) controls the strength of the Holstein-like coupling in hatmathcalV_rm ph, and U_mathbfinu is the on-site Hubbard interaction strength in hatmathcalV_rm hub. Note that either functional form for hatmathcalV_rm hub and hatmathcalV_sigma rm hub can be used in the code. Note that the two possible parameterizations for hatmathcalV_sigma rm hub are inequivalent! ","category":"page"},{"location":"simulation_output/#Simulation-Output-Overview","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"In this section we define and provide an overview of the output generated by a DQMC simulation performed using the SmoQyDQMC.jl package.","category":"page"},{"location":"simulation_output/#Output-Data-Folder-Structure","page":"Simulation Output Overview","title":"Output Data Folder Structure","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"Each simulation performed with SmoQyDQMC.jl will generate a directory with a user defined name that all the output of the simulation will be written to. Here we will simply refer to this top-level directory as the datafolder, but again, the user may call it whatever they like. Inside the datafolder a set of files and folders resembling the structure outlined below will be found:","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"[datafolder]: \nmodel_summary.toml: A TOML file that describes the Hamiltonian that was simulated, and defines the various types of IDs that measurements are reported in terms of.\nsimulation_info_pID*_sID*.toml: A TOML file reporting basic information about the simulation, including the version of Julia and SmoQyDQMC.jl that was used to run the simulation. An [additional_info] table contains the contents of a user defined dictionary as well. One such file is generated for each pID MPI rank if multiple simulations are being performed in parallel using MPI.\nglobal_stats.csv: CSV file containing final average and error for all global measurements.\nlocal_stats.csv: CSV file containing final average and error for all local measurements.\n[global]: Directory contained binned global measurements written as binary JDL2 files.\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[local]: Directory contained binned local measurements written as binary JDL2 files.\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[equal-time]: Top-level directory containing all equal-time correlation function measurement results.\n[density]: As an example, directory containing equal-time density-density correlations.\ndensity_momentum_equal-time_stats.csv: CSV file containing average and error for density-density correlation in momentum space.\ndensity_position_equal-time_stats.csv: CSV file containing average and error for density-density correlation in position space.\n[momentum]: Directory containing binned momentum space density-density correlation data as binary JLD2 files.\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[position]: Directory containing binned position space density-density correlation data as binary JLD2 files.\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[...]\n[time-displaced]: Top-level directory containing all time-displaced correlation function measurement results.\n[greens]\ngreens_momentum_equal-time_stats.csv\ngreens_position_equal-time_stats.csv\n[momentum]\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[position]\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[...]\n[integrated]: Top-level directory containing all integrated correlation function measurement results.\n[density]\ndensity_momentum_integrated_stats.csv\ndensity_position_integrated_stats.csv\n[momentum]\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[position]\nbin-1_pID-0.jld2\nbin-2_pID-0.jld2\n...\n[...]","category":"page"},{"location":"simulation_output/#Model-Summary","page":"Simulation Output Overview","title":"Model Summary","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"The function model_summary is used to a TOML file named model_summary.toml that full describes and parameterizes the Hamiltonian simulated in a DQMC simulation using SmoQyDQMC.jl. Significantly, this method also defines the types of IDs (ORBITAL_ID, BOND_ID, HOPPING_ID, PHONON_ID, HOLSTEIN_ID, SSH_ID, DISPERSION_ID) that the various measurements are reported in terms of. The type of ID used to report correlation and local measurements are recorded in the exported dictionaries CORRELATION_FUNCTIONS and LOCAL_MEASUREMENTS.","category":"page"},{"location":"simulation_output/#Uncertainty-Reporting-Conventions","page":"Simulation Output Overview","title":"Uncertainty Reporting Conventions","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"The average value barC for any measured expectation value langle C rangle is reported as a complex number in all  *_stats.csv files, even if it is known formally to be a strictly real quantity. On the other hand, the error, or standard deviation, associated with each measurement is reported as a strictly positive real number such that the error associated with the complex expectation value langle C rangle is given by Delta C = sqrtDelta C_rm Re^2 + Delta C_rm Im^2.","category":"page"},{"location":"simulation_output/#Global-Measurements","page":"Simulation Output Overview","title":"Global Measurements","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"At the end of a simulation once the measurements are processed using the process_measurements method, a file global_stats.csv file is created that contains the final estimates and errors for all \"global\" measurements. The corresponding binned global data is stored as binary JLD2 files in the directory global inside the simulation directory. We define each global measurement below.","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"sgn: The average sign mathcalS = langle rm sign( det G_uparrow cdot det G_downarrow ) rangle.\nsgndetGup: The average spin-up sign mathcalS_uparrow = langle rm sign(det G_uparrow) rangle.\nsgndetGdn: The average spin-up sign mathcalS_downarrow = langle rm sign(det G_downarrow) rangle.\ndensity: Average global total charge density langle n rangle = langle n_uparrow rangle + langle n_downarrow rangle.\ndensity_up: Average global spin-up charge density langle n_uparrow rangle.\ndensity_dn: Average global spin-down charge density langle n_downarrow rangle.\ndouble_occ: Average global double occupancy langle n_uparrow n_downarrow rangle.\nNsqrd: Expectation value for total electron number squared langle N^2 rangle, where hatN = sum_sigmamathbfinu hatn_sigma mathbfi nu.\nchemical_potential: The measured chemical potential mu.\ncompressibility: The measured compressibility kappa = fracd langle n rangled mu = fracbetamathcalNleft( langle N^2 rangle - langle N rangle^2 right).","category":"page"},{"location":"simulation_output/#Local-Measurement","page":"Simulation Output Overview","title":"Local Measurement","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"At the end of a simulation once the measurements are processed using the process_measurements method, a file local_stats.csv file is created that contains the final estimates and errors for all \"local\" measurements. The corresponding binned local data is stored as binary JLD2 files in the directory local inside the simulation directory. All \"local\" measurements are reported in terms of an ID type, defined in the model_summary.toml file generated by the model_summary function. The definition for each local measurement that may be reported, including the type of ID it is reported in terms of, is defined below.","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"density: (ORBITAL_ID) The charge density langle n_nu rangle = langle n_uparrownu rangle + langle n_downarrownu rangle for orbital nu in the unit cell.\ndensity_up: (ORBITAL_ID) The spin-up charge density langle n_uparrownu rangle for orbital nu in the unit cell.\ndensity_dn: (ORBITAL_ID) The spin-down charge density langle n_downarrownu rangle for orbital nu in the unit cell.\ndouble_occ: (ORBITAL_ID) The double-occupance langle n_uparrownu n_downarrownu rangle for orbital nu in the unit cell.","category":"page"},{"location":"simulation_output/#Local-Tight-Binding-Measurements","page":"Simulation Output Overview","title":"Local Tight-Binding Measurements","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"onsite_energy: (ORBITAL_ID) The total on-site energy sum_sigma (epsilon_sigmanu - mu) langle n_sigmanu rangle for orbital nu in the unit cell.\nonsite_energy_up: (ORBITAL_ID) The spin-up on-site energy (epsilon_uparrownu - mu) langle n_uparrownu rangle for orbital nu in the unit cell.\nonsite_energy_dn: (ORBITAL_ID) The spin-down on-site energy (epsilon_downarrownu - mu) langle n_downarrownu rangle for orbital nu in the unit cell.\nbare_hopping_energy: (HOPPING_ID) The bare hopping energy -sum_sigma langle t_sigma(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_sigmamathbfi+mathbfrnu c^phantomdagger_sigmamathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_(mathbfi+mathbfrnu)(mathbfigamma) is the bare hopping amplitude.\nbare_hopping_energy_up: (HOPPING_ID) The bare spin-up hopping energy -langle t_uparrow(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_uparrowmathbfi+mathbfrnu c^phantomdagger_uparrowmathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_sigma(mathbfi+mathbfrnu)(mathbfigamma) is the bare hopping amplitude.\nbare_hopping_energy_dn: (HOPPING_ID) The bare spin-up hopping energy -langle t_downarrow(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_downarrowmathbfi+mathbfrnu c^phantomdagger_downarrowmathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_downarrow(mathbfi+mathbfrnu)(mathbfigamma) is the bare hopping amplitude.\nhopping_energy: (HOPPING_ID) The total hopping energy -sum_sigma langle t_lsigma(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_sigmamathbfi+mathbfrnu c^phantomdagger_sigmamathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_l(mathbfi+mathbfrnu)(mathbfigamma) is the modulated hopping amplitude.\nhopping_energy_up: (HOPPING_ID) The spin-up hopping energy -langle t_luparrow(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_uparrowmathbfi+mathbfrnu c^phantomdagger_uparrowmathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_lsigma(mathbfi+mathbfrnu)(mathbfigamma) is the modulated hopping amplitude.\nhopping_energy_dn: (HOPPING_ID) The spin-up hopping energy -langle t_ldownarrow(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_downarrowmathbfi+mathbfrnu c^phantomdagger_downarrowmathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_ldownarrow(mathbfi+mathbfrnu)(mathbfigamma) is the modulated hopping amplitude.\nhopping_amplitude: (HOPPING_ID) The average hopping amplitude frac12 N sum_sigmamathbfi langle t_sigma(mathbfi+mathbfrnu)(mathbfigamma)rangle.\nhopping_amplitude_up: (HOPPING_ID) The average spin-up hopping amplitude frac1N sum_mathbfi langle t_uparrow(mathbfi+mathbfrnu)(mathbfigamma)rangle.\nhopping_amplitude_dn: (HOPPING_ID) The average spin-down hopping amplitude frac1N sum_mathbfi langle t_downarrow(mathbfi+mathbfrnu)(mathbfigamma)rangle.\nhopping_inversion: (HOPPING_ID) Fraction of the time the overall sign of the total hopping amplitude is inverted as a result of interactions, without first averaging the hopping amplitude over imaginary time.\nhopping_inversion_up: (HOPPING_ID) Fraction of the time the overall sign of the spin-up hopping amplitude is inverted as a result of interactions, without first averaging the hopping amplitude over imaginary time.\nhopping_inversion_dn: (HOPPING_ID) Fraction of the time the overall sign of the spin-down hopping amplitude is inverted as a result of interactions, without first averaging the hopping amplitude over imaginary time.\nhopping_inversion_avg: (HOPPING_ID) Fraction of the time the overall sign of the total hopping amplitude is inverted as a result of interactions, as calculated after first averaging the hopping amplitude over imaginary time.\nhopping_inversion_avg_up: (HOPPING_ID) Fraction of the time the overall sign of the spin-up hopping amplitude is inverted as a result of interactions, as calculated after first averaging the hopping amplitude over imaginary time.\nhopping_inversion_avg_dn: (HOPPING_ID) Fraction of the time the overall sign of the spin-down hopping amplitude is inverted as a result of interactions,as calculated after first averaging the hopping amplitude over imaginary time.","category":"page"},{"location":"simulation_output/#Local-Hubbard-Measurements","page":"Simulation Output Overview","title":"Local Hubbard Measurements","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"hubbard_energy: (ORBITAL_ID) The Hubbard interaction energy U_nu langle n_uparrownu n_downarrownu rangle for orbital nu in the unit cell.","category":"page"},{"location":"simulation_output/#Local-Phonon-Measurements","page":"Simulation Output Overview","title":"Local Phonon Measurements","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"phonon_kin_energy: (PHONON_ID) The phonon kinetic energy frac12 M_n_nu langle P_n_nu^2 rangle for phonon mode n_nu in unit cell.\nphonon_pot_energy: (PHONON_ID) The phonon potential energy frac12M_n_nuOmega_0n_nu^2langle X_n_nu^2 rangle + frac124M_n_nuOmega_an_nu^2langle X_n_nu^4 rangle for phonon mode n_nu in unit cell.\nX: (PHONON_ID): The expecation values langle X_n_nu rangle for phonon mode n_nu in unit cell.\nX2: (PHONON_ID): The expecation values langle X_n_nu^2 rangle for phonon mode n_nu in unit cell.\nX3: (PHONON_ID): The expecation values langle X_n_nu^3 rangle for phonon mode n_nu in unit cell.\nX4: (PHONON_ID): The expecation values langle X_n_nu^4 rangle for phonon mode n_nu in unit cell.\ndispersion_energy: (DISPERSION_ID) The dispersion energy langle mathcalU_rm disp (mathbfr n_nu n_gamma) rangle between the two phonon models n_nu and n_gamma displaced mathbfr unit cells from eachother.","category":"page"},{"location":"simulation_output/#Local-Electron-Phonon-Interaction-Measurements","page":"Simulation Output Overview","title":"Local Electron-Phonon Interaction Measurements","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"holstein_energy: (HOLSTEIN_ID) The total Holstein interaction energy langle hatmathcalV_rm hol n_mathbfinu (mathbfi+mathbfrgamma) rangle between a phonon mode n_mathbfinu and total charge density on orbital gamma displaced mathbfr unit cells away.\nholstein_energy_up: (HOLSTEIN_ID) The spin-up Holstein interaction energy langle hatmathcalV_rm hol uparrow n_mathbfinu (mathbfi+mathbfrgamma) rangle between a phonon mode n_mathbfinu and the spin-uparrow density on orbital gamma displaced mathbfr unit cells away.\nholstein_energy_dn: (HOLSTEIN_ID) The spin-down Holstein interaction energy langle hatmathcalV_rm hol downarrow n_mathbfinu (mathbfi+mathbfrgamma) rangle between a phonon mode n_mathbfinu and the spin-downarrow on orbital gamma displaced mathbfr unit cells away.\nssh_energy: (SSH_ID) The total SSH interaction enery langle mathcalK_rm ssh(n_mathbfinun_mathbfi+mathbfrgamma)rangle between phonon modes n_nu and n_gamma displaced mathbfr unit cells from eachother.\nssh_energy_up: (SSH_ID) The spin-up SSH interaction enery langle mathcalK_rm sshuparrow(n_mathbfinun_mathbfi+mathbfrgamma)rangle between phonon modes n_nu and n_gamma displaced mathbfr unit cells from eachother.\nssh_energy_dn: (SSH_ID) The spin-down SSH interaction enery langle mathcalK_rm sshdownarrow(n_mathbfinun_mathbfi+mathbfrgamma)rangle between phonon modes n_nu and n_gamma displaced mathbfr unit cells from eachother.","category":"page"},{"location":"simulation_output/#Correlation-Function-Measurements","page":"Simulation Output Overview","title":"Correlation Function Measurements","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"Three types of correlation functions are reported by SmoQyDQMC.jl package. Let hatO_mathbfinu represent some operator associated with unit cell mathbfi and ID index nu. For instance, in the case of a density-density correlation, nu corresponds to an ORBITAL_ID index. The first type of correlation that may be reported are equal-time correlation function of the form","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"C_nugamma(mathbfr) = frac1N sum_mathbfi langle O_mathbfi+mathbfrnu O_mathbfigamma rangle","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"in position space, where the sum over mathbfi runs over all unit cells, and mathbfr represents a displacement in unit cells. The corresponding equal-time correlation function in momentum space is given by","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"C_nugamma(mathbfq) = sum_mathbfr e^-rm imathbfqcdot(mathbfr+mathbfr_nu-mathbfr_gamma) C_nugamma(mathbfr)","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"where mathbfr_nu and mathbfr_gamma are static displacement vector associated with the operators hatO_mathbfinu and hatO_mathbfigamma. For instance, in the case of the density-density correlation, mathbfr_nu is the location of the orbital nu in the unit cell.","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"The second type of correlation function is the time-displaced correlation function in position space is given by","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"C_nugamma(mathbfrtau) = frac1N sum_mathbfi langle O_mathbfi+mathbfrnu(tau) O_mathbfigamma(0) rangle","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"and in momentum space by","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"C_nugamma(mathbfqtau) = sum_mathbfr e^-rm imathbfqcdot(mathbfr+mathbfr_nu-mathbfr_gamma) C_nugamma(mathbfrtau)","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"The last type is the integrated correlation functions in position space, given by","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"chi_nugamma(mathbfr) = int_0^beta dtau  C_nugamma(mathbfrtau)","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"and in momentum space by","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"chi_nugamma(mathbfq) = int_0^beta dtau  C_nugamma(mathbfqtau)","category":"page"},{"location":"simulation_output/#Displacement-Vector-and-Momentum-Reporting-Conventions","page":"Simulation Output Overview","title":"Displacement Vector and Momentum Reporting Conventions","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"Consider a D dimensional finite periodic lattice, where mathbfa_d and mathbfb_d denote the corresponding lattice vectors and reciprocal lattice vectors, where d in 1D. The extent of the lattice in unit cells in the direction of each of the lattice vectors is denoted by L_d. Given these definitions, the displacement vectors are parametetized as","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"mathbfr = sum_d=1^D left( fracmathttR_dL_d right) mathbfa_d","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"and then reported in terms of the set of integers mathttR_d in 0 L_d). Similarly, the set of mathbfk-points associated with the finite lattice are given by","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"mathbfk = sum_d=1^D left( fracmathttK_dL_d right) mathbfb_d","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"and then reported in term of the set of integers mathttK_d in 0 L_d).","category":"page"},{"location":"simulation_output/#Correlation-Function-Reporting-Conventions","page":"Simulation Output Overview","title":"Correlation Function Reporting Conventions","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"In addition to reporting the set of integers mathttR_d  (mathttK_d) used to define correlation functions in position (momentum) space, they are also identified by an ID pair (mathtt*_ID_2 mathtt*_ID_1) specifying the subscripts nu and gamma. Lastly, time-displaced correlation functions also report the displacement in imaginary time, given as an integer mathttTAU in 0 L_tau such that tau = Deltatau cdot mathttTAU where beta = Deltatau cdot L_tau.","category":"page"},{"location":"simulation_output/#Defined-Correlation-Functions","page":"Simulation Output Overview","title":"Defined Correlation Functions","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"In this section we review the various correlation measurements that the SmoQyDQMC.jl package currently supports.","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"greens: (ORBITAL_ID) Measures spin averaged single-particle electron Green's functions.\ngreens_up: (ORBITAL_ID) Measures spin-up single-particle electron Green's functions..\ngreens_dn: (ORBITAL_ID) Measures spin-down single-particle electron Green's functions..\ndensity: (ORBITAL_ID) Measures total density correlation functions.\nspin_z: (ORBITAL_ID) Measures spin-z correlation functions.\nspin_x: (ORBITAL_ID) Measures spin-z correlation functions.\npair: (BOND_ID) Measures pair correlation functions.\nbond: (BOND_ID) Measures bond correlation functions.\ncurrent: (HOPPING_ID) Measures current correlation functions.\nphonon_greens: (PHONON_ID) Measures phonon Green's functions, parameterized as the phonon position correlation function. The position space definition is given below, with n_alpha and n_gamma specifying phonon modes associated with orbitals alpha and gamma in the unit cell respectively.","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"mathcalD_mathbfr^n_alpha n_gamma(tau) = frac1N sum_mathbfi langle hatX_n_alphamathbfi+mathbfr(tau) hatX_n_gammamathbfi(0) rangle","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"EditURL = \"../../../examples/holstein_kagome.jl\"","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/holstein_kagome/#Kagome-Holstein-Model-with-Density-Tuning","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"","category":"section"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"In this script we simulate the Holstein model on the Kagome lattice, with a Hamiltonian given by","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"beginalign*\nhatH =  -t sum_sigmalangle i j rangle (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n            -mu sum_sigmaihatn_sigmai + alpha sum_sigmai hatX_i (hatn_sigmai - tfrac12)\n           + sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)\nendalign*","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. The nearest-neighbor hopping amplitude is t and mu is the chemical potential. The phonon position (momentum) operators hatX_i  (hatP_i) describe a dispersionless mode placed on site i with phonon frequency Omega and corresponding ion mass M. The stength of the Holstein electron-phonon is controlled by the parameter alpha.","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"A short test simulation using the script associated with this example can be run as","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"> julia holstein_chain.jl 0 0.1 0.1 0.667 0.0 4.0 3 2000 10000 50","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"Here the Holstein model on a 3 times 3 unit cell Kagome lattice is simulated with Omega = 01, alpha = 01 and inverse temperature beta = 40. The chemical potential is initialized to mu = 00, and then tuned to achieve are target electron density of langle n rangle = 0667. In this example N_burnin = 2000 thermalizatoin HMC and refleciton updates are performed, followed by an additional N_updates = 10000 such updates, during which time an equivalent number of measurements are made. Bin averaged measurements are written to file N_bins = 50 during the simulation.","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"Below you will find the source code from the julia script linked at the top of this page, but with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/holstein_kagome/","page":"Kagome Holstein Model with Density Tuning","title":"Kagome Holstein Model with Density Tuning","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n# Import the MuTuner module that implements the chemical potential tuning algorithm.\nimport SmoQyDQMC.MuTuner           as mt\n\n# Define top-level function for running the DQMC simulation.\nfunction run_holstein_chain_simulation(sID, Ω, α, n, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_kagome_w%.2f_a%.2f_n%.2f_L%d_b%.2f\" Ω α n L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.05\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bin size.\n    bin_size = div(N_updates, N_bins)\n\n    # To update the phonon degrees of freedom in this code we primarily perform\n    # hybrid/hamiltonian Monte Carlo (HMC) updates. Below we specify some of the\n    # parameters associated with these HMC updates.\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 4\n\n    # Fermionic time-step used in HMC update.\n    Δt = π/(Nt*Ω)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"reflection_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"Nt\" => Nt,\n        \"dt\" => Δt,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[1.0,0.0],\n                        [1/2,√3/2]],\n        basis_vecs   = [[0.0,0.0],\n                        [1/2,0.0],\n                        [1/4,√3/4]]\n    )\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Get the number of sites in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond.\n    bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n    # Add nearest neighbor bond to the model.\n    bond_1_id = add_bond!(model_geometry, bond_1)\n\n    # Define the nearest-neighbor bond.\n    bond_2 = lu.Bond(orbitals = (1,3), displacement = [0,0])\n\n    # Add nearest neighbor bond to the model.\n    bond_2_id = add_bond!(model_geometry, bond_2)\n\n    # Define the nearest-neighbor bond.\n    bond_3 = lu.Bond(orbitals = (2,3), displacement = [0,0])\n\n    # Add nearest neighbor bond to the model.\n    bond_3_id = add_bond!(model_geometry, bond_3)\n\n    # Define the nearest-neighbor bond.\n    bond_4 = lu.Bond(orbitals = (2,1), displacement = [1,0])\n\n    # Add nearest neighbor bond to the model.\n    bond_4_id = add_bond!(model_geometry, bond_4)\n\n    # Define the nearest-neighbor bond.\n    bond_5 = lu.Bond(orbitals = (3,1), displacement = [0,1])\n\n    # Add nearest neighbor bond to the model.\n    bond_5_id = add_bond!(model_geometry, bond_5)\n\n    # Define the nearest-neighbor bond.\n    bond_6 = lu.Bond(orbitals = (3,2), displacement = [-1,1])\n\n    # Add nearest neighbor bond to the model.\n    bond_6_id = add_bond!(model_geometry, bond_6)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_1, bond_2, bond_3, bond_4, bond_5, bond_6], # defines hopping\n        t_mean  = [t, t, t, t, t, t],     # defines corresponding hopping amplitude\n        μ       = μ,            # set chemical potential\n        ϵ_mean  = [0.0, 0.0, 0.0]     # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live the first sub-lattice.\n    phonon_1 = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_1_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_1\n    )\n\n    # Define a dispersionless electron-phonon mode to live the second sub-lattice.\n    phonon_2 = PhononMode(orbital = 2, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_2_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_2\n    )\n\n    # Define a dispersionless electron-phonon mode to live the third sub-lattice.\n    phonon_3 = PhononMode(orbital = 3, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_3_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_3\n    )\n\n    # Define a on-site Holstein coupling for first sub-lattice.\n    holstein_coupling_1 = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_1_id,\n    \tbond = lu.Bond(orbitals = (1,1), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model for first sub-lattice.\n    holstein_coupling_1_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling_1,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Define a on-site Holstein coupling for second sub-lattice.\n    holstein_coupling_2 = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_2_id,\n    \tbond = lu.Bond(orbitals = (2,2), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model for first sub-lattice.\n    holstein_coupling_2_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling_2,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Define a on-site Holstein coupling for first sub-lattice.\n    holstein_coupling_3 = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_3_id,\n    \tbond = lu.Bond(orbitals = (3,3), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model for first sub-lattice.\n    holstein_coupling_3_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling_3,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Write a model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )\n\n    #################################################\n    ### INITIALIZE FINITE LATTICE MODEL PARAMETERS ##\n    #################################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1), (2, 2), (3, 3),\n                 (1, 2), (1, 3), (2, 3)]\n    )\n\n    # Initialize time-displaced phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(1, 1), (2, 2), (3, 3),\n                 (1, 2), (1, 3), (2, 3)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (3, 3),\n                 (1, 2), (1, 3), (2, 3)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (3, 3)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (3, 3),\n                 (1, 2), (1, 3), (2, 3)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Note that the spin-up and spin-down electron sectors are equivalent in the Holstein model\n    # without Hubbard interaction. Therefore, there is only a single Fermion determinant\n    # that needs to be calculated. This fact is reflected in the code below.\n\n    # Allocate fermion path integral type.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the fermion path integral type with respect to electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Allocate and initialize propagators for each imaginary time slice.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize fermion greens calculator.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize equal-time Green's function matrix\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = HMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt, nt = nt, reg = reg\n    )\n\n    # Initialize the density/chemical potential tuner.\n    # This type facilitates the tuning of the chemical potential to achieve\n    # at target electron density.\n    chemical_potential_tuner = mt.MuTunerLogger(n₀ = n, β = β, V = N, u₀ = 1.0, μ₀ = μ, c = 0.5)\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a reflection update.\n        # This update randomly selects a phonon mode in the lattice and reflects\n        # all the associated phonon about the origin, (xᵢ → -xᵢ).\n        # This updates all the phonon fields to cross the on-site energy barrier\n        # associated with bipolaron formation, helping reduce autocorrelation times.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng, phonon_types = (phonon_1_id, phonon_2_id, phonon_3_id)\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n\n        # Update the chemical potential.\n        logdetG, sgndetG = update_chemical_potential!(\n            G, logdetG, sgndetG,\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B\n        )\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a reflection update.\n            (accepted, logdetG, sgndetG) = reflection_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, rng = rng, phonon_types = (phonon_1_id, phonon_2_id, phonon_3_id)\n            )\n\n            # Record whether the reflection update was accepted or rejected.\n            additional_info[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Make measurements.\n            (logdetG, sgndetG, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (electron_phonon_parameters,)\n            )\n\n            # Update the chemical potential.\n            logdetG, sgndetG = update_chemical_potential!(\n                G, logdetG, sgndetG,\n                chemical_potential_tuner = chemical_potential_tuner,\n                tight_binding_parameters = tight_binding_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate HMC acceptance rate.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Calculate reflection update acceptance rate.\n    additional_info[\"reflection_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Save the density tuning profile.\n    save_density_tuning_profile(simulation_info, chemical_potential_tuner)\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ω = parse(Float64, ARGS[2])\n    α = parse(Float64, ARGS[3])\n    n = parse(Float64, ARGS[4]) # target electorn density\n    μ = parse(Float64, ARGS[5]) # intial chemical potential\n    β = parse(Float64, ARGS[6])\n    L = parse(Int, ARGS[7])\n    N_burnin = parse(Int, ARGS[8])\n    N_updates = parse(Int, ARGS[9])\n    N_bins = parse(Int, ARGS[10])\n\n    # Run the simulation.\n    run_holstein_chain_simulation(sID, Ω, α, n, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SmoQyDQMC","category":"page"},{"location":"#SmoQyDQMC","page":"Home","title":"SmoQyDQMC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SmoQyDQMC.jl. This package implements the determinant quantum Monte Carlo (DQMC) method for Hubbard, and electron-phonon interactions, including both Holstein and Su-Schrieffer-Heeger (SSH) style electron-phonon coupling.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This code is currently in the experimental phase of development.","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The development of this code was supported by the U.S. Department of Energy, Office of Science, Basic Energy Sciences, under Award Number DE-SC0022311.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the SmoQyDQMC.jl, simply open the Julia REPL and run the commands","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add SmoQyDQMC","category":"page"},{"location":"","page":"Home","title":"Home","text":"or equivalently via Pkg do","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"SmoQyDQMC\")","category":"page"},{"location":"#Publication-List","page":"Home","title":"Publication List","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This sections lists of some of the publications that report results generated using the SmoQyDQMC.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A. Tanjaroon Ly, B. Cohen-Stead, S. Malkaruge Costa and S. Johnston. Comparative study of the superconductivity in the Holstein and optical Su-Schrieffer-Heeger models. Phys. Rev. B 108, 184501 (2023).\n\n\n\nS. Malkaruge Costa, B. Cohen-Stead, A. T. Ly, J. Neuhaus and S. Johnston. Comparative determinant quantum Monte Carlo study of the acoustic and optical variants of the Su-Schrieffer-Heeger model. Phys. Rev. B 108, 165138 (2023).\n\n\n\n","category":"page"},{"location":"#Notable-Package-Dependencies","page":"Home","title":"Notable Package Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This section reviews some notable package dependencies.","category":"page"},{"location":"#Re-exported-Packages","page":"Home","title":"Re-exported Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SmoQyDQMC.jl re-exports certain packages using the Reexport.jl package in order to simplify the installation process.","category":"page"},{"location":"","page":"Home","title":"Home","text":"LatticeUtilties.jl: Used to represent arbitrary lattice geometries.\nJDQMCFramework.jl: Implements and exports the basic framework for running a DQMC simulation.\nJDQMCMeasurements.jl: Implements various global, local and correlation measurements for a DQMC simulation.\nMuTuner.jl: Impelments and exports an algorithm for tuning the chemical potential to achieve a target density in grand canonical Monte Carlo simulations.","category":"page"},{"location":"#External-Dependencies","page":"Home","title":"External Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StableLinearAlgebra.jl: Implements optimized numerical stabilizaiton methods required by DQMC simulations.\nCheckerboard.jl: Implements and exports the checkerboard method for approximating exponentiated hopping matrices by a sparse matrix.\nJLD2.jl: Package used to write data to binary files in an HDF5 compatible format. It is also recommended this package be used at the scripting level to implement checkpointing in a simulation.\nBinningAnalysis.jl: Export method impelementing the jackknife algorithm for calculating error bars.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you found this library to be useful in the course of academic work, please consider citing us:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{SmoQyDQMC,\n      title={SmoQyDQMC.jl: A flexible implementation of determinant quantum Monte Carlo for Hubbard and electron-phonon interactions}, \n      author={Benjamin Cohen-Stead and Sohan Malkaruge Costa and James Neuhaus and Andy Tanjaroon Ly and Yutan Zhang and Richard Scalettar and Kipton Barros and Steven Johnston},\n      year={2023},\n      eprint={2311.09395},\n      archivePrefix={arXiv},\n      primaryClass={cond-mat.str-el},\n      url={https://arxiv.org/abs/2311.09395}\n}","category":"page"},{"location":"#Contact-Us","page":"Home","title":"Contact Us","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For question and comments regarding this package, please email either Dr. Benjamin Cohen-Stead at bcohenst@utk.edu or Professor Steven Johnston at sjohn145@utk.edu.","category":"page"}]
}
