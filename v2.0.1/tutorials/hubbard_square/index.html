<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1a) Square Hubbard Model · SmoQyDQMC.jl</title><meta name="title" content="1a) Square Hubbard Model · SmoQyDQMC.jl"/><meta property="og:title" content="1a) Square Hubbard Model · SmoQyDQMC.jl"/><meta property="twitter:title" content="1a) Square Hubbard Model · SmoQyDQMC.jl"/><meta name="description" content="Documentation for SmoQyDQMC.jl."/><meta property="og:description" content="Documentation for SmoQyDQMC.jl."/><meta property="twitter:description" content="Documentation for SmoQyDQMC.jl."/><meta property="og:url" content="https://smoqysuite.github.io/SmoQyDQMC.jl/stable/tutorials/hubbard_square/"/><meta property="twitter:url" content="https://smoqysuite.github.io/SmoQyDQMC.jl/stable/tutorials/hubbard_square/"/><link rel="canonical" href="https://smoqysuite.github.io/SmoQyDQMC.jl/stable/tutorials/hubbard_square/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SmoQyDQMC.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../hamiltonian/">Supported Hamiltonians</a></li><li><a class="tocitem" href="../../simulation_output/">Simulation Output Overview</a></li><li><a class="tocitem" href="../../api/">API</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>1a) Square Hubbard Model</a><ul class="internal"><li><a class="tocitem" href="#hubbard_square_import_packages"><span>Import packages</span></a></li><li><a class="tocitem" href="#Specify-simulation-parameters"><span>Specify simulation parameters</span></a></li><li><a class="tocitem" href="#hubbard_square_initialize_simulation"><span>Initialize simulation</span></a></li><li><a class="tocitem" href="#Initialize-simulation-metadata"><span>Initialize simulation metadata</span></a></li><li><a class="tocitem" href="#Initialize-model"><span>Initialize model</span></a></li><li><a class="tocitem" href="#Initialize-model-parameters"><span>Initialize model parameters</span></a></li><li><a class="tocitem" href="#hubbard_square_initialize_measurements"><span>Initialize measurement</span></a></li><li><a class="tocitem" href="#hubbard_square_setup_dqmc"><span>Setup DQMC simulation</span></a></li><li><a class="tocitem" href="#Thermalize-system"><span>Thermalize system</span></a></li><li><a class="tocitem" href="#hubbard_square_make_measurements"><span>Make measurements</span></a></li><li><a class="tocitem" href="#Merge-binned-data"><span>Merge binned data</span></a></li><li><a class="tocitem" href="#Record-simulation-metadata"><span>Record simulation metadata</span></a></li><li><a class="tocitem" href="#hubbard_square_process_results"><span>Post-process results</span></a></li><li><a class="tocitem" href="#Execute-script"><span>Execute script</span></a></li></ul></li><li><a class="tocitem" href="../hubbard_square_mpi/">1b) Square Hubbard Model with MPI Parallelization</a></li><li><a class="tocitem" href="../hubbard_square_checkpoint/">1c) Square Hubbard Model with Checkpointing</a></li><li><a class="tocitem" href="../hubbard_square_density_tuning/">1d) Square Hubbard Model with Density Tuning</a></li><li><a class="tocitem" href="../holstein_honeycomb/">2a) Honeycomb Holstein Model</a></li><li><a class="tocitem" href="../holstein_honeycomb_mpi/">2b) Honeycomb Holstein Model with MPI Parallelization</a></li><li><a class="tocitem" href="../holstein_honeycomb_checkpoint/">2c) Honeycomb Holstein Model with Checkpointing</a></li><li><a class="tocitem" href="../holstein_honeycomb_density_tuning/">2d) Honeycomb Holstein Model with Density Tuning</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/ossh_chain/">Optical Su-Schrieffer-Heeger Chain</a></li><li><a class="tocitem" href="../../examples/ossh_square/">Square Optical Su-Schrieffer-Heeger Model</a></li><li><a class="tocitem" href="../../examples/bssh_chain/">Bond Su-Schrieffer-Heeger Chain</a></li><li><a class="tocitem" href="../../examples/bssh_square/">Bond Su-Schrieffer-Heeger Square</a></li><li><a class="tocitem" href="../../examples/hubbard_ossh_square/">Square Optical Su-Schrieffer-Heeger-Hubbard Model</a></li><li><a class="tocitem" href="../../examples/hubbard_holstein_square/">Square Holstein-Hubbard Model</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>1a) Square Hubbard Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>1a) Square Hubbard Model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/main/tutorials/hubbard_square.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="1a)-Square-Hubbard-Model"><a class="docs-heading-anchor" href="#1a)-Square-Hubbard-Model">1a) Square Hubbard Model</a><a id="1a)-Square-Hubbard-Model-1"></a><a class="docs-heading-anchor-permalink" href="#1a)-Square-Hubbard-Model" title="Permalink"></a></h1><p>Download this example as a <a href="../../assets/scripts/tutorials/hubbard_square.jl">Julia script</a>.</p><p>In this example we will work through simulating the repulsive Hubbard model on a square lattice. The Hubbard Hamiltonian for a square lattice given by</p><p class="math-container">\[\begin{align}
\hat{H} = &amp;
-t \sum_{\langle i, j \rangle, \sigma} (\hat{c}^{\dagger}_{\sigma,i}, \hat{c}^{\phantom \dagger}_{\sigma,j} + {\rm h.c.})
-t^{\prime} \sum_{\langle\langle i, j \rangle\rangle, \sigma} (\hat{c}^{\dagger}_{\sigma,i}, \hat{c}^{\phantom \dagger}_{\sigma,j} + {\rm h.c.}) \\
&amp; + U \sum_i (\hat{n}_{\uparrow,i}-\tfrac{1}{2})(\hat{n}_{\downarrow,i}-\tfrac{1}{2})
- \mu \sum_{i,\sigma} \hat{n}_{\sigma,i},
\end{align}\]</p><p>where <span>$\hat{c}^\dagger_{\sigma,i} \ (\hat{c}^{\phantom \dagger}_{\sigma,i})$</span> creates (annihilates) a spin <span>$\sigma$</span> electron on site <span>$i$</span> in the lattice, and <span>$\hat{n}_{\sigma,i} = \hat{c}^\dagger_{\sigma,i} \hat{c}^{\phantom \dagger}_{\sigma,i}$</span> is the spin-<span>$\sigma$</span> electron number operator for site <span>$i$</span>. In the above Hamiltonian <span>$(t^{\prime}) \ t$</span> is the (next-) nearest-neighbor hopping amplitude and <span>$U &gt; 0$</span> controls the strength of the on-site Hubbard repulsion. Lastly, we note the system is half-filled and particle-hole symmetric when the next-nearest-neighbor hopping amplitude and the chemical potential is zero <span>$(t^{\prime} = \mu = 0.0),$</span> in which case there is no sign problem.</p><h2 id="hubbard_square_import_packages"><a class="docs-heading-anchor" href="#hubbard_square_import_packages">Import packages</a><a id="hubbard_square_import_packages-1"></a><a class="docs-heading-anchor-permalink" href="#hubbard_square_import_packages" title="Permalink"></a></h2><p>Let us begin by importing <a href="https://github.com/SmoQySuite/SmoQyDQMC.jl.git">SmoQyDQMC.jl</a>, and its relevant submodules.</p><pre><code class="language-julia hljs">using SmoQyDQMC
import SmoQyDQMC.LatticeUtilities as lu
import SmoQyDQMC.JDQMCFramework as dqmcf</code></pre><p>The <a href="https://github.com/SmoQySuite/SmoQyDQMC.jl.git">SmoQyDQMC</a> package re-exports several other packages that we will make use of in this tutorial. The first one is <a href="https://github.com/SmoQySuite/LatticeUtilities.jl.git">LatticeUtilities</a>, which we will use to define the lattice geometry for our model. The second submodule is the <a href="https://github.com/SmoQySuite/JDQMCFramework.jl.git">JDQMCFramework</a> package, which exports useful types and methods for writing a determinant quantum Monte Carlo (DQMC) code, taking care of things like numerical stabilization. We will see how to leverage both these packages in this tutorial.</p><p>We will also  use the Standard Library packages <a href="https://docs.julialang.org/en/v1/stdlib/Random/">Random</a> and <a href="https://docs.julialang.org/en/v1/stdlib/Printf/">Printf</a> for random number generation and C-style string formatting, respectively.</p><pre><code class="language-julia hljs">using Random
using Printf</code></pre><h2 id="Specify-simulation-parameters"><a class="docs-heading-anchor" href="#Specify-simulation-parameters">Specify simulation parameters</a><a id="Specify-simulation-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Specify-simulation-parameters" title="Permalink"></a></h2><p>The entire main body of the simulation we will wrapped in a top-level function named <code>run_simulation</code> that will take as keyword arguments various model and simulation parameters that we may want to change. The function arguments with default values are ones that are typically left unchanged between simulations. The specific meaning of each argument will be discussed in more detail in later sections of the tutorial.</p><pre><code class="language-julia hljs"># Top-level function to run simulation.
function run_simulation(;
    # KEYWORD ARGUMENTS
    sID, # Simulation ID.
    U, # Hubbard interaction.
    t′, # Next-nearest-neighbor hopping amplitude.
    μ, # Chemical potential.
    L, # System size.
    β, # Inverse temperature.
    N_therm, # Number of thermalization updates.
    N_measurements, # Total number of measurements.
    N_bins, # Number of measurement bins.
    N_updates, # Number of updates per measurement.
    Δτ = 0.05, # Discretization in imaginary time.
    n_stab = 10, # Numerical stabilization period in imaginary-time slices.
    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.
    symmetric = false, # Whether symmetric propagator definition is used.
    checkerboard = false, # Whether checkerboard approximation is used.
    seed = abs(rand(Int)), # Seed for random number generator.
    filepath = &quot;.&quot; # Filepath to where data folder will be created.
)</code></pre><h2 id="hubbard_square_initialize_simulation"><a class="docs-heading-anchor" href="#hubbard_square_initialize_simulation">Initialize simulation</a><a id="hubbard_square_initialize_simulation-1"></a><a class="docs-heading-anchor-permalink" href="#hubbard_square_initialize_simulation" title="Permalink"></a></h2><p>In this first part of the script we name and initialize our simulation, creating the data folder our simulation results will be written to. This is done by initializing an instances of the <a href="../../api/#SmoQyDQMC.SimulationInfo"><code>SimulationInfo</code></a> type, and then calling the <a href="../../api/#SmoQyDQMC.initialize_datafolder"><code>initialize_datafolder</code></a> function.</p><p>Note that the <code>write_bins_concurrent</code> keyword arguments controls whether or not binned simulation measurement data is written to HDF5 file during the simulation, or held in memory and only written to file once the simulation is complete. Here we decide how to set <code>write_bins_concurrent</code> based on the system size being simulated. This is because when performing simulations of small systems that do not take very long, writing data to file too frequently can sometimes cause network latency problems on clusters and HPC systems. However, for larger systems that take longer to simulate, you are not limited by file IO frequency but rather by available memory, so writing data to file more frequently is preferred in these cases.</p><pre><code class="language-julia hljs">    # Construct the foldername the data will be written to.
    datafolder_prefix = @sprintf &quot;hubbard_square_U%.2f_tp%.2f_mu%.2f_L%d_b%.2f&quot; U t′ μ L β

    # Initialize simulation info.
    simulation_info = SimulationInfo(
        filepath = filepath,
        datafolder_prefix = datafolder_prefix,
        write_bins_concurrent = (L &gt; 10),
        sID = sID
    )

    # Initialize the directory the data will be written to.
    initialize_datafolder(simulation_info)</code></pre><h2 id="Initialize-simulation-metadata"><a class="docs-heading-anchor" href="#Initialize-simulation-metadata">Initialize simulation metadata</a><a id="Initialize-simulation-metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-simulation-metadata" title="Permalink"></a></h2><p>In this section of the code we record important metadata about the simulation, including initializing the random number generator that will be used throughout the simulation. The important metadata within the simulation will be recorded in the <code>metadata</code> dictionary.</p><pre><code class="language-julia hljs">    # Initialize random number generator
    rng = Xoshiro(seed)

    # Initialize metadata dictionary
    metadata = Dict()

    # Record simulation parameters.
    metadata[&quot;N_therm&quot;] = N_therm
    metadata[&quot;N_measurements&quot;] = N_measurements
    metadata[&quot;N_updates&quot;] = N_updates
    metadata[&quot;N_bins&quot;] = N_bins
    metadata[&quot;n_stab_init&quot;] = n_stab
    metadata[&quot;dG_max&quot;] = δG_max
    metadata[&quot;symmetric&quot;] = symmetric
    metadata[&quot;checkerboard&quot;] = checkerboard
    metadata[&quot;seed&quot;] = seed
    metadata[&quot;local_acceptance_rate&quot;] = 0.0
    metadata[&quot;reflection_acceptance_rate&quot;] = 0.0</code></pre><p>In the above, <code>sID</code> stands for simulation ID, which is used to distinguish simulations that would otherwise be identical i.e. to distinguish simulations that use the same parameters and are only different in the random seed used to initialize the simulation. A valid <code>sID</code> is any positive integer greater than zero, and is used when naming the data folder the simulation results will be written to. Specifically, the actual data folder created above will be <code>&quot;$(filepath)/$(datafolder_prefix)-$(sID)&quot;</code>. Note that if you set <code>sID = 0</code>, then it will instead be assigned smallest previously unused integer value. For instance, suppose the directory <code>&quot;$(filepath)/$(datafolder_prefix)-1&quot;</code> already exits. Then if you pass <code>sID = 0</code> to <a href="../../api/#SmoQyDQMC.SimulationInfo"><code>SimulationInfo</code></a>, then the simulation ID <code>sID = 2</code> will be used instead, and a directory <code>&quot;$(filepath)/$(datafolder_prefix)-2&quot;</code> will be created.</p><p>Another useful resource in the documentation is the <a href="../../simulation_output/#Simulation-Output-Overview">Simulation Output Overview</a> page, which describes the output written to the data folder generated during a <a href="https://github.com/SmoQySuite/SmoQyDQMC.jl.git">SmoQyDQMC</a> simulation.</p><h2 id="Initialize-model"><a class="docs-heading-anchor" href="#Initialize-model">Initialize model</a><a id="Initialize-model-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-model" title="Permalink"></a></h2><p>The next step is define the model we wish to simulate. In this example the relevant model parameters are the Hubbard interaction strength <span>$U$</span> (<code>U</code>), chemical potential <span>$\mu$</span> (<code>μ</code>), next-nearest-neighbor hopping amplitude <span>$t^\prime$</span> (<code>t′</code>) and lattice size <span>$L$</span> (<code>L</code>).</p><p>First we define the lattice geometry for our model, relying on the <a href="https://github.com/SmoQySuite/LatticeUtilities.jl.git">LatticeUtilities</a> package to do so. We define a the unit cell and size of our finite lattice using the <a href="https://smoqysuite.github.io/LatticeUtilities.jl/stable/api/#LatticeUtilities.UnitCell"><code>UnitCell</code></a> and <a href="https://smoqysuite.github.io/LatticeUtilities.jl/stable/api/#LatticeUtilities.Lattice"><code>Lattice</code></a> types, respectively. Lastly, we define various instances of the <a href="https://smoqysuite.github.io/LatticeUtilities.jl/stable/api/#LatticeUtilities.Bond"><code>Bond</code></a> type to represent the the nearest-neighbor and next-nearest-neighbor bonds. All of this information regarding the lattice geometry is then stored in an instance of the <a href="../../api/#SmoQyDQMC.ModelGeometry"><code>ModelGeometry</code></a> type. Further documentation, with usage examples, for <a href="https://github.com/SmoQySuite/LatticeUtilities.jl.git">LatticeUtilities</a> package can be found <a href="https://smoqysuite.github.io/LatticeUtilities.jl/stable/">here</a>.</p><pre><code class="language-julia hljs">    # Define unit cell.
    unit_cell = lu.UnitCell(
        lattice_vecs = [[1.0, 0.0],
                        [0.0, 1.0]],
        basis_vecs = [[0.0, 0.0]]
    )

    # Define finite lattice with periodic boundary conditions.
    lattice = lu.Lattice(
        L = [L, L],
        periodic = [true, true]
    )

    # Initialize model geometry.
    model_geometry = ModelGeometry(
        unit_cell, lattice
    )

    # Define the nearest-neighbor bond in +x direction.
    bond_px = lu.Bond(
        orbitals = (1,1),
        displacement = [1, 0]
    )

    # Add this bond definition to the model, by adding it the model_geometry.
    bond_px_id = add_bond!(model_geometry, bond_px)

    # Define the nearest-neighbor bond in +y direction.
    bond_py = lu.Bond(
        orbitals = (1,1),
        displacement = [0, 1]
    )

    # Add this bond definition to the model, by adding it the model_geometry.
    bond_py_id = add_bond!(model_geometry, bond_py)

    # Define the next-nearest-neighbor bond in +x+y direction.
    bond_pxpy = lu.Bond(
        orbitals = (1,1),
        displacement = [1, 1]
    )

    # Define the nearest-neighbor bond in -x direction.
    # Will be used to make measurements later in this tutorial.
    bond_nx = lu.Bond(
        orbitals = (1,1),
        displacement = [-1, 0]
    )

    # Add this bond definition to the model, by adding it the model_geometry.
    bond_nx_id = add_bond!(model_geometry, bond_nx)

    # Define the nearest-neighbor bond in -y direction.
    # Will be used to make measurements later in this tutorial.
    bond_ny = lu.Bond(
        orbitals = (1,1),
        displacement = [0, -1]
    )

    # Add this bond definition to the model, by adding it the model_geometry.
    bond_ny_id = add_bond!(model_geometry, bond_ny)

    # Define the next-nearest-neighbor bond in +x+y direction.
    bond_pxpy = lu.Bond(
        orbitals = (1,1),
        displacement = [1, 1]
    )

    # Add this bond definition to the model, by adding it the model_geometry.
    bond_pxpy_id = add_bond!(model_geometry, bond_pxpy)

    # Define the next-nearest-neighbor bond in +x-y direction.
    bond_pxny = lu.Bond(
        orbitals = (1,1),
        displacement = [1, -1]
    )

    # Add this bond definition to the model, by adding it the model_geometry.
    bond_pxny_id = add_bond!(model_geometry, bond_pxny)</code></pre><p>Next we specify the non-interacting tight-binding term in our Hamiltonian with the <a href="../../api/#SmoQyDQMC.TightBindingModel"><code>TightBindingModel</code></a> type.</p><pre><code class="language-julia hljs">    # Set nearest-neighbor hopping amplitude to unity,
    # setting the energy scale in the model.
    t = 1.0

    # Define the non-interacting tight-binding model.
    tight_binding_model = TightBindingModel(
        model_geometry = model_geometry,
        t_bonds = [bond_px, bond_py, bond_pxpy, bond_pxny], # defines hopping
        t_mean = [t, t, t′, t′], # defines corresponding mean hopping amplitude
        t_std = [0., 0., 0., 0.], # defines corresponding standard deviation in hopping amplitude
        ϵ_mean = [0.], # set mean on-site energy for each orbital in unit cell
        ϵ_std = [0.], # set standard deviation of on-site energy or each orbital in unit cell
        μ  = μ # set chemical potential
    )</code></pre><p>Finally, we define the Hubbard interaction with the <a href="../../api/#SmoQyDQMC.HubbardModel"><code>HubbardModel</code></a> type. Here the boolean <code>ph_sym_form</code> keyword argument determines whether the particle-hole symmetric form (<code>ph_sym_form = true</code>) for the Hubbard interaction <span>$U(\hat{n}_{\uparrow,i}-\tfrac{1}{2})(\hat{n}_{\downarrow,i}-\tfrac{1}{2})$</span> is used, or the form <span>$U\hat{n}_{\uparrow,i}\hat{n}_{\downarrow,i}$</span> is used (<code>ph_sym_form = false</code>) instead.</p><pre><code class="language-julia hljs">    # Define the Hubbard interaction in the model.
    hubbard_model = HubbardModel(
        ph_sym_form = true, # if particle-hole symmetric form for Hubbard interaction is used.
        U_orbital = [1], # orbitals in unit cell with Hubbard interaction.
        U_mean = [U], # mean Hubbard interaction strength for corresponding orbital species in unit cell.
        U_std = [0.], # standard deviation of Hubbard interaction strength for corresponding orbital species in unit cell.
    )</code></pre><p>Note that most terms in our model can support random disorder. However, we have suppressed this behavior by setting all relevant standard deviations in model values to zero. If these standard deviations were not specified they would have also defaulted to zero We explicitly set them to zero here to simply highlight the presence of this functionality even though we are not using it.</p><p>Lastly, the <a href="../../api/#SmoQyDQMC.model_summary"><code>model_summary</code></a> function is used to write a <code>model_summary.toml</code> file, completely specifying the Hamiltonian that will be simulated.</p><pre><code class="language-julia hljs">    # Write model summary TOML file specifying Hamiltonian that will be simulated.
    model_summary(
        simulation_info = simulation_info,
        β = β, Δτ = Δτ,
        model_geometry = model_geometry,
        tight_binding_model = tight_binding_model,
        interactions = (hubbard_model,)
    )</code></pre><h2 id="Initialize-model-parameters"><a class="docs-heading-anchor" href="#Initialize-model-parameters">Initialize model parameters</a><a id="Initialize-model-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-model-parameters" title="Permalink"></a></h2><p>The next step is to initialize our model parameters given the size of our finite lattice. To clarify, both the <a href="../../api/#SmoQyDQMC.TightBindingModel"><code>TightBindingModel</code></a> and <a href="../../api/#SmoQyDQMC.HubbardModel"><code>HubbardModel</code></a> types are agnostic to the size of the lattice being simulated, defining the model in a translationally invariant way. As <a href="https://github.com/SmoQySuite/SmoQyDQMC.jl.git">SmoQyDQMC.jl</a> supports random disorder in the terms appearing in the Hamiltonian, it is necessary to initialize separate parameter values for each unit cell in the lattice. For instance, we need to initialize a separate number to represent the on-site energy for each orbital in our finite lattice. To do so we need to initialize an instance of the <a href="../../api/#SmoQyDQMC.TightBindingParameters"><code>TightBindingParameters</code></a> and <a href="../../api/#SmoQyDQMC.HubbardParameters"><code>HubbardParameters</code></a> types.</p><pre><code class="language-julia hljs">    # Initialize tight-binding parameters.
    tight_binding_parameters = TightBindingParameters(
        tight_binding_model = tight_binding_model,
        model_geometry = model_geometry,
        rng = rng
    )

    # Initialize Hubbard interaction parameters.
    hubbard_parameters = HubbardParameters(
        model_geometry = model_geometry,
        hubbard_model = hubbard_model,
        rng = rng
    )</code></pre><p>Having initialized the Hubbard Hamiltonian parameters above, we now need to decouple the interaction by applying a Hubbard-Stratonovich (HS) transformation to decouple the local Hubbard interaction, thereby introducing the HS fields that will be sampled during the simulation. The <a href="https://github.com/SmoQySuite/SmoQyDQMC.jl.git">SmoQyDQMC.jl</a> package implements four types of Hubbard-Stratonovich transformations for decoupling the local Hubbard interaction, represented by the four types <a href="../../api/#SmoQyDQMC.HubbardDensityHirschHST"><code>HubbardDensityHirschHST</code></a>, <a href="../../api/#SmoQyDQMC.HubbardDensityGaussHermiteHST"><code>HubbardDensityGaussHermiteHST</code></a>, <a href="../../api/#SmoQyDQMC.HubbardSpinHirschHST"><code>HubbardSpinHirschHST</code></a> and [<code>HubbardSpinGaussHermiteHST</code>]. In this example we will use the <a href="../../api/#SmoQyDQMC.HubbardSpinHirschHST"><code>HubbardSpinHirschHST</code></a> type to decouple the local Hubbard interactions.</p><pre><code class="language-julia hljs">    # Apply Spin Hirsch Hubbard-Stratonovich (HS) transformation to decouple the Hubbard interaction,
    # and initialize the corresponding HS fields that will be sampled in the DQMC simulation.
    hst_parameters = HubbardSpinHirschHST(
        β = β, Δτ = Δτ,
        hubbard_parameters = hubbard_parameters,
        rng = rng
    )</code></pre><h2 id="hubbard_square_initialize_measurements"><a class="docs-heading-anchor" href="#hubbard_square_initialize_measurements">Initialize measurement</a><a id="hubbard_square_initialize_measurements-1"></a><a class="docs-heading-anchor-permalink" href="#hubbard_square_initialize_measurements" title="Permalink"></a></h2><p>Having initialized both our model and the corresponding model parameters, the next step is to initialize the various measurements we want to make during our DQMC simulation. This includes defining the various types of correlation measurements that will be made, which is primarily done using the <a href="../../api/#SmoQyDQMC.initialize_correlation_measurements!"><code>initialize_correlation_measurements!</code></a> function.</p><p>Here the arguments <code>β</code> and <code>Δτ</code> correspond to the inverse temperature and imaginary-time axis discretization constant, which were passed as arguments to the <code>run_simulation</code> function.</p><pre><code class="language-julia hljs">    # Initialize the container that measurements will be accumulated into.
    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)

    # Initialize the tight-binding model related measurements, like the hopping energy.
    initialize_measurements!(measurement_container, tight_binding_model)

    # Initialize the Hubbard interaction related measurements.
    initialize_measurements!(measurement_container, hubbard_model)

    # Initialize the single-particle electron Green&#39;s function measurement.
    initialize_correlation_measurements!(
        measurement_container = measurement_container,
        model_geometry = model_geometry,
        correlation = &quot;greens&quot;,
        time_displaced = true,
        pairs = [(1, 1)]
    )

    # Initialize density correlation function measurement.
    initialize_correlation_measurements!(
        measurement_container = measurement_container,
        model_geometry = model_geometry,
        correlation = &quot;density&quot;,
        time_displaced = false,
        integrated = true,
        pairs = [(1, 1)]
    )

    # Initialize the pair correlation function measurement.
    initialize_correlation_measurements!(
        measurement_container = measurement_container,
        model_geometry = model_geometry,
        correlation = &quot;pair&quot;,
        time_displaced = false,
        integrated = true,
        pairs = [(1, 1)]
    )

    # Initialize the spin-z correlation function measurement.
    initialize_correlation_measurements!(
        measurement_container = measurement_container,
        model_geometry = model_geometry,
        correlation = &quot;spin_z&quot;,
        time_displaced = false,
        integrated = true,
        pairs = [(1, 1)]
    )</code></pre><p>We also want to define define what we term a composite correlation measurement to measure d-wave pairing tendencies in our Hubbard model. Specifically, we would like to measure the d-wave pair susceptibility</p><p class="math-container">\[\chi_d(\mathbf{q}) = \frac{1}{L^2} \int_0^\beta d\tau \sum_{\mathbf{r}, \mathbf{i}} e^{-\text{i}\mathbf{q}\cdot\mathbf{r}}
\langle \hat{\Delta}^{\phantom\dagger}_{d,\mathbf{i}+\mathbf{r}}(\tau) \hat{\Delta}^{\dagger}_{d,\mathbf{i}}(0) \rangle\]</p><p>for all scattering momentum <span>$\mathbf{q}$</span>, where</p><p class="math-container">\[\hat{\Delta}^{\dagger}_{d,\mathbf{i}}(\tau) = \frac{1}{2}\left[
(
   \hat{c}^\dagger_{\uparrow,\mathbf{i}+\mathbf{x}} + \hat{c}^\dagger_{\uparrow,\mathbf{i}-\mathbf{x}}
 - \hat{c}^\dagger_{\uparrow,\mathbf{i}+\mathbf{y}} - \hat{c}^\dagger_{\uparrow,\mathbf{i}-\mathbf{y}}
)
\hat{c}^\dagger_{\downarrow,\mathbf{i}}
\right]\]</p><p>is the d-wave pair creation operator. We do this using the <a href="../../api/#SmoQyDQMC.initialize_composite_correlation_measurement!"><code>initialize_composite_correlation_measurement!</code></a> function.</p><pre><code class="language-julia hljs">    # Initialize the d-wave pair susceptibility measurement.
    initialize_composite_correlation_measurement!(
        measurement_container = measurement_container,
        model_geometry = model_geometry,
        name = &quot;d-wave&quot;,
        correlation = &quot;pair&quot;,
        ids = [bond_px_id, bond_nx_id, bond_py_id, bond_ny_id],
        coefficients = [0.5, 0.5, -0.5, -0.5],
        time_displaced = false,
        integrated = true
    )</code></pre><h2 id="hubbard_square_setup_dqmc"><a class="docs-heading-anchor" href="#hubbard_square_setup_dqmc">Setup DQMC simulation</a><a id="hubbard_square_setup_dqmc-1"></a><a class="docs-heading-anchor-permalink" href="#hubbard_square_setup_dqmc" title="Permalink"></a></h2><p>This section of the code sets up the DQMC simulation by allocating the initializing the relevant types and arrays we will need in the simulation.</p><p>This portion of code is perhaps the most opaque and difficult to understand, and quite a bit of exposition is included describing it. That said, you do not need to fully comprehend everything that goes on in this section as most of it is fairly boilerplate, and will not need to be changed much once written. This is true even if you want to modify this script to perform a DQMC simulation for a different Hamiltonian.</p><p>To start, two instances of the <a href="../../api/#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type are allocated, one for each electron spin species. Recall that after performing a HS transformation to decouple the Hubbard interaction, the resulting Hamiltonian is quadratic in fermion creation and annihilation operators, but fluctuates in imaginary-time as a result of introducing the HS fields. Therefore, this Hamiltonian may be expressed as</p><p class="math-container">\[\hat{H}_l = \sum_\sigma \hat{\mathbf{c}}_\sigma^\dagger \left[ H_{\sigma,l} \right] \hat{\mathbf{c}}_\sigma
= \sum_\sigma \hat{\mathbf{c}}_\sigma^\dagger \left[ K_{\sigma,l} + V_{\sigma,l} \right] \hat{\mathbf{c}}_\sigma,\]</p><p>at imaginary-time <span>$\tau = \Delta\tau \cdot l$</span>. where <span>$\hat{\mathbf{c}}_\sigma \ (\hat{\mathbf{c}}_\sigma^\dagger)$</span> is a column (row) vector of spin-<span>$\sigma$</span> electron annihilation (creation) operators for each orbital in the lattice. Here <span>$H_{\sigma,l}$</span> is the spin-<span>$\sigma$</span> Hamiltonian matrix for imaginary-time <span>$\tau$</span>, which can be expressed as the sum of the electron kinetic and potential energy matrices <span>$K_{\sigma,l}$</span> and <span>$V_{\sigma,l}$</span>, respectively. The purpose of the <a href="../../api/#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type is to contain the minimal information required to reconstruct each <span>$K_{\sigma,l}$</span> and <span>$V_{\sigma,l}$</span> matrix. Each instance of the <a href="../../api/#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type is first allocated and initialized to just reflect the non-interacting component of the Hamiltonian. Then the two subsequent <code>initialize!</code> calls modify the <a href="../../api/#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type to reflect the contributions from the Hubbard interaction and initial HS field configuration.</p><p>Note that if the keyword arguments <code>forced_complex_potential</code> and <code>forced_complex_kinetic</code> are set to <code>true</code> then the <span>$V_{\sigma,l}$</span> and <span>$K_{\sigma,l}$</span> matrices are forced to be complex matrices, respectively. If instead set to false then their type is inferred from the instance of <code>tight_binding_parameters</code> passed during initialization. This is important, as the Hubbard-Stratonovich transform represented by the <a href="../../api/#SmoQyDQMC.HubbardSpinHirschHST"><code>HubbardSpinHirschHST</code></a> type used in this example is real if <span>$U \ge 0$</span> and complex if <span>$U &lt; 0$</span>. Therefore, we need to set <code>forced_complex_potential = (U &lt; 0)</code> to account for this fact if we want this example to work for both repulsive and attractive Hubbard interactions. The opposite would be true if we had instead used <a href="../../api/#SmoQyDQMC.HubbardDensityHirschHST"><code>HubbardDensityHirschHST</code></a> decoupling scheme instead.</p><pre><code class="language-julia hljs">    # Allocate FermionPathIntegral type for spin-up electrons.
    fermion_path_integral_up = FermionPathIntegral(
        tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ,
        forced_complex_potential = (U &lt; 0),
        forced_complex_kinetic = false
    )

    # Allocate FermionPathIntegral type for spin-down electrons.
    fermion_path_integral_dn = FermionPathIntegral(
        tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ,
        forced_complex_potential = (U &lt; 0),
        forced_complex_kinetic = false
    )

    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for Hubbard interaction.
    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)

    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for the current
    # Hubbard-Stratonovich field configuration.
    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hst_parameters)</code></pre><p>Next, the <a href="../../api/#SmoQyDQMC.initialize_propagators"><code>initialize_propagators</code></a> function allocates and initializes the <span>$B_{\sigma,l}$</span> propagator matrices to reflect the current state of the <span>$K_{\sigma,l}$</span> and <span>$V_{\sigma,l}$</span> matrices as represented by the <a href="../../api/#SmoQyDQMC.FermionPathIntegral"><code>FermionPathIntegral</code></a> type. If <code>symmetric = true</code>, then the propagator matrices take the form</p><p class="math-container">\[B_{\sigma,l} = \left[ e^{-\Delta\tau K_{\sigma,l}/2} \right]^\dagger \cdot e^{-\Delta\tau V_{\sigma,l}} \cdot e^{-\Delta\tau K_{\sigma,l}/2},\]</p><p>whereas if <code>symmetric = false</code> then</p><p class="math-container">\[B_{\sigma,l} = e^{-\Delta\tau V_{\sigma,l}} \cdot e^{-\Delta\tau K_{\sigma,l}}.\]</p><p>If <code>checkerboard = true</code>, then the exponentiated kinetic energy matrices <span>$e^{-\Delta\tau K_{\sigma,l}} \ \left( \text{ or } e^{-\Delta\tau K_{\sigma,l}/2} \right)$</span> are represented using the sparse checkerboard approximation, otherwise they are computed exactly.</p><pre><code class="language-julia hljs">    # Initialize imaginary-time propagators for all imaginary-time slices for spin-up and spin-down electrons.
    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)
    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)</code></pre><p>Next, four instances of the <a href="https://smoqysuite.github.io/JDQMCFramework.jl/stable/api/#JDQMCFramework.FermionGreensCalculator"><code>FermionGreensCalculator</code></a> type are initialized, which are used to take care of numerical stabilization behind the scenes in the DQMC simulation. Here <code>n_stab</code> is the period in imaginary-time with which numerical stabilization is performed, and is typically on the order of <span>$n_{\rm stab} \sim 10.$</span></p><pre><code class="language-julia hljs">    # Initialize FermionGreensCalculator type for spin-up and spin-down electrons.
    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)
    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)

    # Initialize alternate FermionGreensCalculator type for performing reflection updates.
    fermion_greens_calculator_up_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_up)
    fermion_greens_calculator_dn_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_dn)</code></pre><p>Now we allocate and initialize the equal-time Green&#39;s function matrix <span>$G_\sigma(0,0)$</span> for both spin species (<code>Gup</code> and <code>Gdn</code>). The initialization process also returns <span>$\log | \det G_\sigma(0,0) |$</span> (<code>logdetGup</code> and <code>logdetGdn</code>) and <span>${\rm sgn} \det G_\sigma(0,0)$</span> (<code>sgndetGup</code> and <code>sgndetGdn</code>).</p><pre><code class="language-julia hljs">    # Allocate matrices for spin-up and spin-down electron Green&#39;s function matrices.
    Gup = zeros(eltype(Bup[1]), size(Bup[1]))
    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))

    # Initialize the spin-up and spin-down electron Green&#39;s function matrices, also
    # calculating their respective determinants as the same time.
    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)
    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)</code></pre><p>We also need to allocate matrices to represent the equal-time and time-displaced Green&#39;s function matrices <span>$G_\sigma(\tau,\tau)$</span> (<code>Gup_ττ</code> and <code>Gdn_ττ</code>), <span>$G_\sigma(\tau, 0)$</span> (<code>Gup_τ0</code> and <code>Gdn_τ0</code>), and <span>$G_\sigma(0,\tau)$</span> (<code>Gup_0τ</code> and <code>Gdn_0τ</code>) for <span>$\tau \ne 0$</span>. All of these various Green&#39;s function matrices are required if we want to make time-displaced correlation function measurements.</p><pre><code class="language-julia hljs">    # Allocate matrices for various time-displaced Green&#39;s function matrices.
    Gup_ττ = similar(Gup) # Gup(τ,τ)
    Gup_τ0 = similar(Gup) # Gup(τ,0)
    Gup_0τ = similar(Gup) # Gup(0,τ)
    Gdn_ττ = similar(Gdn) # Gdn(τ,τ)
    Gdn_τ0 = similar(Gdn) # Gdn(τ,0)
    Gdn_0τ = similar(Gdn) # Gdn(0,τ)</code></pre><p>Lastly, we initialize two diagnostic parameters <code>δG</code> and <code>δθ</code> to asses numerical stability during the simulation. The <code>δG</code>  parameter is particularly important to keep track of during the simulation, and is defined as</p><p class="math-container">\[\delta G = \max \left( | G^{\rm stab.}_\sigma(0,0) - G^{\rm naive}_\sigma(0,0) | \right),\]</p><p>i.e. the maximum magnitude numerical error corrected by numerical stabilization for any Green&#39;s function matrix element. The <span>$\delta \theta$</span> diagnostic parameter reports the error in the phase of the fermion determinant as it can in general be complex, but this is less important to keep track of in most situations.</p><pre><code class="language-julia hljs">    # Initialize diagnostic parameters to asses numerical stability.
    δG = zero(logdetGup)
    δθ = zero(logdetGup)</code></pre><h2 id="Thermalize-system"><a class="docs-heading-anchor" href="#Thermalize-system">Thermalize system</a><a id="Thermalize-system-1"></a><a class="docs-heading-anchor-permalink" href="#Thermalize-system" title="Permalink"></a></h2><p>The next section of code performs updates to thermalize the system prior to beginning measurements. The structure of this function should be fairly intuitive, mainly consisting of a loop inside of which we perform updates to the Hubbard-Stratonovich fields. In this example we perform two types of updates.</p><p>We use the <a href="../../api/#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, AbstractHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><code>local_updates!</code></a> function to attempt a local update to every HS field. Additionally, if the <a href="../../api/#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, AbstractHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><code>local_updates!</code></a> argument <code>update_stabilization_frequency = true</code>, then the <code>δG_max</code> parameter acts a maximum threshold for <code>δG</code>. If <code>δG</code> exceeds <code>δG_max</code>, then <code>n_stab</code> is decrement by one (the frequency of numerical stabilization is increased) and <code>δG</code> is reset to zero. In the case <code>update_stabilization_frequency = false</code>, then <code>δG_max</code> doesn&#39;t do anything and <code>n_stab</code> remains unchanged during the simulation, with <code>δG</code> is simply reporting the maximum observed numerical error during the simulation.</p><p>We also use the <a href="../../api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, AbstractHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><code>reflection_update!</code></a> function to perform a reflection update on a randomly selected sites in the lattice whereby we flip the HS fields on every imaginary-time slice for that site i.e. propose an update such that <span>$s_{i,l} \rightarrow -s_{i,l}$</span> for all <span>$l \in [1, L_\tau]$</span>. This type of reflection update <a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.44.10502">has been shown</a> to be important for mitigating ergodicity issues in large Hubbard <span>$U$</span> simulations.</p><p>In the block of code below, <code>N_therm</code> is the number of local sweeps and reflection updates performed to thermalize the system.</p><pre><code class="language-julia hljs">    # Iterate over number of thermalization updates to perform.
    for n in 1:N_therm

        # Perform reflection update for HS fields with randomly chosen site.
        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(
            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,
            hst_parameters,
            fermion_path_integral_up = fermion_path_integral_up,
            fermion_path_integral_dn = fermion_path_integral_dn,
            fermion_greens_calculator_up = fermion_greens_calculator_up,
            fermion_greens_calculator_dn = fermion_greens_calculator_dn,
            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,
            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,
            Bup = Bup, Bdn = Bdn, rng = rng
        )

        # Record whether reflection update was accepted or not.
        metadata[&quot;reflection_acceptance_rate&quot;] += accepted

        # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.
        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(
            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,
            hst_parameters,
            fermion_path_integral_up = fermion_path_integral_up,
            fermion_path_integral_dn = fermion_path_integral_dn,
            fermion_greens_calculator_up = fermion_greens_calculator_up,
            fermion_greens_calculator_dn = fermion_greens_calculator_dn,
            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,
            update_stabilization_frequency = false
        )

        # Record acceptance rate for sweep.
        metadata[&quot;local_acceptance_rate&quot;] += acceptance_rate
    end</code></pre><h2 id="hubbard_square_make_measurements"><a class="docs-heading-anchor" href="#hubbard_square_make_measurements">Make measurements</a><a id="hubbard_square_make_measurements-1"></a><a class="docs-heading-anchor-permalink" href="#hubbard_square_make_measurements" title="Permalink"></a></h2><p>In this next section of code we continue to sample the HS fields, but we also begin making measurements as well. Here, <code>N_measurements</code> refers to the number of times measurements are made using the <a href="../../api/#SmoQyDQMC.make_measurements!"><code>make_measurements!</code></a> function, and <code>N_updates</code> refers to the number of times <a href="../../api/#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, AbstractHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><code>local_updates!</code></a> and <a href="../../api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, AbstractHST{T, R}}} where {H&lt;:Number, T&lt;:Number, R&lt;:Real, P&lt;:AbstractPropagator}"><code>reflection_update!</code></a> are called between measurements being made. The parameter <code>N_bins</code> then controls the number of times bin-averaged measurements are stored in an HDF5 that is either stored in memory or written to file, subject to the constraint that <code>(N_measurements % N_bins) == 0</code>. Therefore, the number of measurements that are averaged over per bin is given by <code>bin_size = N_measurements ÷ N_bins</code>. The bin-averaged measurements are written to file once <code>bin_size</code> measurements are accumulated using the <a href="../../api/#SmoQyDQMC.write_measurements!"><code>write_measurements!</code></a> function.</p><pre><code class="language-julia hljs">    # Reset diagnostic parameters used to monitor numerical stability to zero.
    δG = zero(logdetGup)
    δθ = zero(logdetGup)

    # Calculate the bin size.
    bin_size = N_measurements ÷ N_bins

    # Iterate over measurements.
    for measurement in 1:N_measurements

        # Iterate over updates between measurements.
        for update in 1:N_updates

            # Perform reflection update for HS fields with randomly chosen site.
            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(
                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,
                hst_parameters,
                fermion_path_integral_up = fermion_path_integral_up,
                fermion_path_integral_dn = fermion_path_integral_dn,
                fermion_greens_calculator_up = fermion_greens_calculator_up,
                fermion_greens_calculator_dn = fermion_greens_calculator_dn,
                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,
                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,
                Bup = Bup, Bdn = Bdn, rng = rng
            )

            # Record whether reflection update was accepted or not.
            metadata[&quot;reflection_acceptance_rate&quot;] += accepted

            # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.
            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(
                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,
                hst_parameters,
                fermion_path_integral_up = fermion_path_integral_up,
                fermion_path_integral_dn = fermion_path_integral_dn,
                fermion_greens_calculator_up = fermion_greens_calculator_up,
                fermion_greens_calculator_dn = fermion_greens_calculator_dn,
                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,
                update_stabilization_frequency = false
            )

            # Record acceptance rate.
            metadata[&quot;local_acceptance_rate&quot;] += acceptance_rate
        end

        # Make measurements.
        (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(
            measurement_container,
            logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,
            logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,
            fermion_path_integral_up = fermion_path_integral_up,
            fermion_path_integral_dn = fermion_path_integral_dn,
            fermion_greens_calculator_up = fermion_greens_calculator_up,
            fermion_greens_calculator_dn = fermion_greens_calculator_dn,
            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,
            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,
            coupling_parameters = (hubbard_parameters, hst_parameters)
        )

        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.
        write_measurements!(
            measurement_container = measurement_container,
            simulation_info = simulation_info,
            model_geometry = model_geometry,
            measurement = measurement,
            bin_size = bin_size,
            Δτ = Δτ
        )
    end</code></pre><h2 id="Merge-binned-data"><a class="docs-heading-anchor" href="#Merge-binned-data">Merge binned data</a><a id="Merge-binned-data-1"></a><a class="docs-heading-anchor-permalink" href="#Merge-binned-data" title="Permalink"></a></h2><p>At this point the simulation is essentially complete, with all updates and measurements having been performed. However, the binned measurement data resides in many separate HDF5 files currently. Here we will merge these separate HDF5 files into a single file containing all the binned data using the <a href="../../api/#SmoQyDQMC.merge_bins"><code>merge_bins</code></a> function.</p><pre><code class="language-julia hljs">    # Merge binned data into a single HDF5 file.
    merge_bins(simulation_info)</code></pre><h2 id="Record-simulation-metadata"><a class="docs-heading-anchor" href="#Record-simulation-metadata">Record simulation metadata</a><a id="Record-simulation-metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Record-simulation-metadata" title="Permalink"></a></h2><p>At this point we are done sampling and taking measurements. Next, we want to calculate the final acceptance rate for the Monte Carlo updates, as well as write the simulation metadata to file, including the contents of the <code>metadata</code> dictionary. This is done using the <a href="../../api/#SmoQyDQMC.save_simulation_info"><code>save_simulation_info</code></a> function.</p><pre><code class="language-julia hljs">    # Normalize acceptance rate.
    metadata[&quot;local_acceptance_rate&quot;] /=  (N_therm + N_measurements * N_updates)
    metadata[&quot;reflection_acceptance_rate&quot;] /= (N_therm + N_measurements * N_updates)

    # Record final stabilization period used at the end of the simulation.
    metadata[&quot;n_stab_final&quot;] = fermion_greens_calculator_up.n_stab

    # Record largest numerical error.
    metadata[&quot;dG&quot;] = δG

    # Write simulation summary TOML file.
    save_simulation_info(simulation_info, metadata)</code></pre><h2 id="hubbard_square_process_results"><a class="docs-heading-anchor" href="#hubbard_square_process_results">Post-process results</a><a id="hubbard_square_process_results-1"></a><a class="docs-heading-anchor-permalink" href="#hubbard_square_process_results" title="Permalink"></a></h2><p>In this final section of code we post-process the binned data. This includes calculating the final estimates for the mean and error of all measured observables, which will be written to an HDF5 file using the <a href="../../api/#SmoQyDQMC.process_measurements"><code>process_measurements</code></a> function. Inside this function the binned data gets further re-binned into <code>n_bins</code>, where <code>n_bins</code> is any positive integer satisfying the constraints <code>(N_bins ≥ n_bin)</code> and <code>(N_bins % n_bins == 0)</code>. Note that the <a href="../../api/#SmoQyDQMC.process_measurements"><code>process_measurements</code></a> function has many additional keyword arguments that can be used to control the output. For instance, in this example in addition to writing the statistics to an HDF5 file, we also export the statistics to CSV files by setting <code>export_to_csv = true</code>, with additional keyword arguments controlling the formatting of the CSV files. Again, for more information on how to interpret the output refer the <a href="../../simulation_output/#Simulation-Output-Overview">Simulation Output Overview</a> page.</p><pre><code class="language-julia hljs">    # Process the simulation results, calculating final error bars for all measurements.
    # writing final statistics to CSV files.
    process_measurements(
        datafolder = simulation_info.datafolder,
        n_bins = N_bins,
        export_to_csv = true,
        scientific_notation = false,
        decimals = 7,
        delimiter = &quot; &quot;
    )</code></pre><p>A common measurement that needs to be computed at the end of a DQMC simulation is something called the correlation ratio with respect to the ordering wave-vector for a specified type of structure factor measured during the simulation. In the case of the square Hubbard model, we are interested in measuring the correlation ratio</p><p class="math-container">\[R_z(\mathbf{Q}_\text{afm}) = 1 - \frac{1}{4} \sum_{\delta\mathbf{q}} \frac{S_z(\mathbf{Q}_\text{afm} + \delta\mathbf{q})}{S_z(\mathbf{Q}_\text{afm})}\]</p><p>with respect to the equal-time antiferromagnetic (AFM) structure factor <span>$S_z(\mathbf{Q}_\text{afm})$</span>, where <span>$S_z(\mathbf{q})$</span> is the spin-<span>$z$</span> equal-time structure factor and <span>$\mathbf{Q}_\text{afm} = (\pi/a, \pi/a)$</span> is the AFM ordering wave-vector. The sum over <span>$\delta\mathbf{q}$</span> runs over the four wave-vectors that neighboring <span>$\mathbf{Q}_\text{afm}.$</span></p><p>Here we use the <a href="../../api/#SmoQyDQMC.compute_correlation_ratio"><code>compute_correlation_ratio</code></a> function to compute to compute this correlation ratio. Note that the <span>$\mathbf{Q}_\text{afm}$</span> is specified using the <code>q_point</code> keyword argument, and the four neighboring wave-vectors <span>$\mathbf{Q}_\text{afm} + \delta\mathbf{q}$</span> are specified using the <code>q_neighbors</code> keyword argument. These wave-vectors are specified using the convention described <a href="../../simulation_output/#vector_reporting_conventions">here</a> in the <a href="../../simulation_output/#Simulation-Output-Overview">Simulation Output Overview</a> page.</p><pre><code class="language-julia hljs">    # Calculate AFM correlation ratio.
    Rafm, ΔRafm = compute_correlation_ratio(
        datafolder = simulation_info.datafolder,
        correlation = &quot;spin_z&quot;,
        type = &quot;equal-time&quot;,
        id_pairs = [(1, 1)],
        id_pair_coefficients = [1.0],
        q_point = (L÷2, L÷2),
        q_neighbors = [
            (L÷2+1, L÷2), (L÷2-1, L÷2),
            (L÷2, L÷2+1), (L÷2, L÷2-1)
        ]
    )</code></pre><p>Next, we record the measurement in the <code>metadata</code> dictionary, and then write a new version of the simulation summary TOML file that contains this new information using the <a href="../../api/#SmoQyDQMC.save_simulation_info"><code>save_simulation_info</code></a> function.</p><pre><code class="language-julia hljs">    # Record the AFM correlation ratio mean and standard deviation.
    metadata[&quot;Rafm_mean_real&quot;] = real(Rafm)
    metadata[&quot;Rafm_mean_imag&quot;] = imag(Rafm)
    metadata[&quot;Rafm_std&quot;] = ΔRafm

    # Write simulation summary TOML file.
    save_simulation_info(simulation_info, metadata)</code></pre><p>Note that as long as the binned data persists the <a href="../../api/#SmoQyDQMC.process_measurements"><code>process_measurements</code></a> and <a href="../../api/#SmoQyDQMC.compute_correlation_ratio"><code>compute_correlation_ratio</code></a> functions can be rerun to recompute the final statistics for the measurements without needing to rerun the simulation.</p><pre><code class="language-julia hljs">    return nothing
end # end of run_simulation function</code></pre><h2 id="Execute-script"><a class="docs-heading-anchor" href="#Execute-script">Execute script</a><a id="Execute-script-1"></a><a class="docs-heading-anchor-permalink" href="#Execute-script" title="Permalink"></a></h2><p>DQMC simulations are typically run from the command line as jobs on a computing cluster. With this in mind, the following block of code only executes if the Julia script is run from the command line, also reading in additional command line arguments.</p><pre><code class="language-julia hljs"># Only execute if the script is run directly from the command line.
if abspath(PROGRAM_FILE) == @__FILE__

    # Run the simulation, reading in command line arguments.
    run_simulation(;
        sID = parse(Int, ARGS[1]), # Simulation ID.
        U = parse(Float64, ARGS[2]), # Hubbard interaction strength.
        t′ = parse(Float64, ARGS[3]), # Next-nearest-neighbor hopping amplitude.
        μ = parse(Float64, ARGS[4]), # Chemical potential.
        L = parse(Int, ARGS[5]), # Lattice size.
        β = parse(Float64, ARGS[6]), # Inverse temperature.
        N_therm = parse(Int, ARGS[7]), # Number of thermalization sweeps.
        N_measurements = parse(Int, ARGS[8]), # Number of measurement to make.
        N_bins = parse(Int, ARGS[9]), # Number of measurement bins.
        N_updates = parse(Int, ARGS[10]) # Number of updates per measurement.
    )
end</code></pre><p>For instance, the command</p><pre><code class="nohighlight hljs">&gt; julia hubbard_square.jl 1 5.0 -0.25 -2.0 4 4.0 2000 2000 40 5</code></pre><p>runs a DQMC simulation of a <span>$N = 4 \times 4$</span> doped square Hubbard model at inverse temperature <span>$\beta = 4.0$</span> with interaction strength <span>$U = 5.0,$</span> chemical potential <span>$\mu = -2.0$</span> and next-nearest-neighbor hopping amplitude <span>$t^\prime = -0.25$</span>. In the DQMC simulation, <span>$2,000$</span> sweeps through the lattice are be performed to thermalize the system. Then <span>$2,000$</span> measurements are made, each separated by <span>$5$</span> updates to the HS fields. Therefore, a total of <span>$2,000 \times 5 = 10,000$</span> updates are performed during the measurement phase of the simulation. During the simulation, bin-averaged measurements are written to file or stored in memory <span>$40$</span> times, with each bin of data containing the average of <span>$2,000/40 = 50$</span> sequential measurements.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../api/">« API</a><a class="docs-footer-nextpage" href="../hubbard_square_mpi/">1b) Square Hubbard Model with MPI Parallelization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 15 January 2026 21:39">Thursday 15 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
