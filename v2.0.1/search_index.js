var documenterSearchIndex = {"docs":
[{"location":"tutorials/holstein_honeycomb_checkpoint/#2c)-Honeycomb-Holstein-Model-with-Checkpointing","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"2c) Honeycomb Holstein Model with Checkpointing","text":"Download this example as a Julia script.\n\nIn this tutorial we demonstrate how to introduce checkpointing to the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial, allowing for simulations to be resumed if terminated prior to completion.","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Import-packages","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Import packages","text":"No changes need to made to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial.\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf\nusing MPI","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Specify-simulation-parameters","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Specify simulation parameters","text":"Compared to the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial, we have added two new keyword arguments to the run_simulation function:\n\ncheckpoint_freq: When going to write a new checkpoint file, only write one if more than checkpoint_freq hours have passed since the last checkpoint file was written.\nruntime_limit: If after writing a new checkpoint file more than runtime_limit hours have passed since the simulation started, terminate the simulation.\n\nThe runtime_limit = Inf default behavior means there is no runtime limit for the simulation.\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Nt = 8, # Number of time-steps in HMC update.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-simulation","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Initialize simulation","text":"We need to make a few modifications to this portion of the code as compared to the previous tutorial in order for checkpointing to work. First, we record need to record the simulation start time, which we do by initializing a variable start_timestamp = time(). Second, we need to convert the checkpoint_freq and runtime_limit from hours to seconds.\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_honeycomb_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 7),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-simulation-metadata","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Initialize simulation metadata","text":"At this point we need to introduce branching logic to handle whether a new simulation is being started, or a previous simulation is being resumed. We do this by checking the simulation_info.resuming boolean value. If simulation_info.resuming = true, then we are resuming a previous simulation, while simulation_info.resuming = false indicates we are starting a new simulation. Therefore, the section of code immediately below handles the case that we are starting a new simulation.\n\nWe also introduce and initialize two new variables n_therm = 1 and n_measurements = 1 which will keep track of how many rounds of thermalization and measurement updates have been performed. These two variables will needed to be included in the checkpoint files we write later in the simulation, as they will indicate where to resume a previously terminated simulation.\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"Nt\"] = Nt\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_measurements\"] = N_measurements\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"n_stab\"] = n_stab\n        metadata[\"dG_max\"] = δG_max\n        metadata[\"symmetric\"] = symmetric\n        metadata[\"checkerboard\"] = checkerboard\n        metadata[\"seed\"] = seed\n        metadata[\"hmc_acceptance_rate\"] = 0.0\n        metadata[\"reflection_acceptance_rate\"] = 0.0\n        metadata[\"swap_acceptance_rate\"] = 0.0","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-model","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Initialize model","text":"No changes need to made to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial.\n\n        # Define lattice vectors.\n        a1 = [+3/2, +√3/2]\n        a2 = [+3/2, -√3/2]\n\n        # Define basis vectors for two orbitals in the honeycomb unit cell.\n        r1 = [0.0, 0.0] # Location of first orbital in unit cell.\n        r2 = [1.0, 0.0] # Location of second orbital in unit cell.\n\n        # Define the unit cell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [a1, a2],\n            basis_vecs = [r1, r2]\n        )\n\n        # Define finite lattice with periodic boundary conditions.\n        lattice = lu.Lattice(\n            L = [L, L],\n            periodic = [true, true]\n        )\n\n        # Initialize model geometry.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the first nearest-neighbor bond in a honeycomb lattice.\n        bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n        # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_1_id = add_bond!(model_geometry, bond_1)\n\n        # Define the second nearest-neighbor bond in a honeycomb lattice.\n        bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n        # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_2_id = add_bond!(model_geometry, bond_2)\n\n        # Define the third nearest-neighbor bond in a honeycomb lattice.\n        bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n        # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_3_id = add_bond!(model_geometry, bond_3)\n\n        # Set nearest-neighbor hopping amplitude to unity,\n        # setting the energy scale in the model.\n        t = 1.0\n\n        # Define the honeycomb tight-binding model.\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond_1, bond_2, bond_3], # defines hopping\n            t_mean = [t, t, t], # defines corresponding hopping amplitude\n            μ  = μ, # set chemical potential\n            ϵ_mean = [0.0, 0.0] # set the (mean) on-site energy\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n        phonon_1 = PhononMode(\n            basis_vec = r1,\n            Ω_mean = Ω\n        )\n\n        # Add the phonon mode definition to the electron-phonon model.\n        phonon_1_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_1\n        )\n\n        # Define a dispersionless electron-phonon mode to live on the second sublattice.\n        phonon_2 = PhononMode(\n            basis_vec = r2,\n            Ω_mean = Ω\n        )\n\n        # Add the phonon mode definition to the electron-phonon model.\n        phonon_2_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_2\n        )\n\n        # Define first local Holstein coupling for first phonon mode.\n        holstein_coupling_1 = HolsteinCoupling(\n            model_geometry = model_geometry,\n            phonon_id = phonon_1_id,\n            orbital_id = 1,\n            displacement = [0, 0],\n            α_mean = α,\n            ph_sym_form = true,\n        )\n\n        # Add the first local Holstein coupling definition to the model.\n        holstein_coupling_1_id = add_holstein_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            holstein_coupling = holstein_coupling_1,\n            model_geometry = model_geometry\n        )\n\n        # Define second local Holstein coupling for second phonon mode.\n        holstein_coupling_2 = HolsteinCoupling(\n            model_geometry = model_geometry,\n            phonon_id = phonon_2_id,\n            orbital_id = 2,\n            displacement = [0, 0],\n            α_mean = α,\n            ph_sym_form = true,\n        )\n\n        # Add the second local Holstein coupling definition to the model.\n        holstein_coupling_2_id = add_holstein_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            holstein_coupling = holstein_coupling_2,\n            model_geometry = model_geometry\n        )\n\n        # Write model summary TOML file specifying Hamiltonian that will be simulated.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-model-parameters","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Initialize model parameters","text":"No changes need to made to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial.\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Initialize-measurements","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Initialize measurements","text":"No changes need to made to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial.\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1), (2, 2), (1, 2)\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs of modes.\n                (1, 1), (2, 2), (1, 2)\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1), (2, 2),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1), (2, 2)\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1), (2, 2)\n            ]\n        )\n\n        # Initialize measurement of electron Green's function traced\n        # over both orbitals in the unit cell.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"tr_greens\",\n            correlation = \"greens\",\n            id_pairs = [(1,1), (2,2)],\n            coefficients = [1.0, 1.0],\n            time_displaced = true,\n        )\n\n        # Initialize CDW correlation measurement.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"cdw\",\n            correlation = \"density\",\n            ids = [1, 2],\n            coefficients = [1.0, -1.0],\n            time_displaced = false,\n            integrated = true\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Write-first-checkpoint","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Write first checkpoint","text":"This section of code needs to be added so that a first checkpoint file is written before beginning a new simulation. We do this using the write_jld2_checkpoint function. This function all return the epoch timestamp checkpoint_timestamp corresponding to when the checkpoint file was written.\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Load-checkpoint","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Load checkpoint","text":"If we are resuming a simulation that was previously terminated prior to completion, then we need to load the most recent checkpoint file using the read_jld2_checkpoint function. The contents of the checkpoint file are returned as a dictionary checkpoint by the read_jld2_checkpoint function. We then extract the contents of the checkpoint file from the checkpoint dictionary.\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        electron_phonon_parameters = checkpoint[\"electron_phonon_parameters\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Setup-DQMC-simulation","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Setup DQMC simulation","text":"No changes need to made to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial.\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing EFA-HMC, reflection and swap updates below.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time electron Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize electron Green's function matrix, also calculating the matrix determinant as the same time.\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize diagnostic parameters to asses numerical stability.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Setup-EFA-HMC-Updates","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Setup EFA-HMC Updates","text":"No changes need to made to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial.\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = π/(2*Nt)\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Thermalize-system","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Thermalize system","text":"The first change we need to make to this section is to have the for-loop iterate from n_therm:N_therm instead of 1:N_therm. The other change we need to make to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial is to add a call to the write_jld2_checkpoint function at the end of each iteration of the for-loop in which we perform the thermalization updates. When calling this function we need to pass it the timestamp for the previous checkpoint checkpoint_timestamp so that the function can determine if a new checkpoint file needs to be written. If a new checkpoint file is written then the checkpoint_timestamp variable will be updated to reflect this, otherwise it will remain unchanged.\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Make-measurements","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Make measurements","text":"Again, we need to modify the for-loop so that it runs from n_measurements:N_measurements instead of 1:N_measurements. The only other change we need to make to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial is to add a call to the write_jld2_checkpoint function at the end of each iteration of the for-loop in which we perform updates and measurements. Note that we set n_therm = N_therm + 1 when writing the checkpoint file to ensure that when the simulation is resumed the thermalization updates are not repeated.\n\n    # Reset diagnostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for measurement in n_measurements:N_measurements\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Make measurements.\n        (logdetG, sgndetG, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (electron_phonon_parameters,)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm = N_therm + 1,\n            n_measurements = measurement + 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Merge-binned-data","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Merge binned data","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Record-simulation-metadata","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Record simulation metadata","text":"No changes need to made to this section of the code from the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial.\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Record largest numerical error encountered during simulation.\n    metadata[\"dG\"] = δG\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Post-process-results","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Post-process results","text":"From the last 2b) Honeycomb Holstein Model with MPI Parallelization tutorial, we now recommend adding a call to the rename_complete_simulation function once the results are processed. This function renames the data folder to begin with complete_*, making it simple to identify which simulations ran to completion and which ones need to be resumed from the last checkpoint file. This function also deletes the checkpoint files that were written during the simulation.\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm,\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\n    # Calculate CDW correlation ratio.\n    Rcdw, ΔRcdw = compute_composite_correlation_ratio(\n        comm;\n        datafolder = simulation_info.datafolder,\n        name = \"cdw\",\n        type = \"equal-time\",\n        q_point = (0, 0),\n        q_neighbors = [\n            (1,0),   (0,1),   (1,1),\n            (L-1,0), (0,L-1), (L-1,L-1)\n        ]\n    )\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rcdw_mean_real\"] = real(Rcdw)\n    metadata[\"Rcdw_mean_imag\"] = imag(Rcdw)\n    metadata[\"Rcdw_std\"]       = ΔRcdw\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function","category":"section"},{"location":"tutorials/holstein_honeycomb_checkpoint/#Execute-script","page":"2c) Honeycomb Holstein Model with Checkpointing","title":"Execute script","text":"To execute the script, we have added two new command line arguments allowing for the assignment of both the checkpoint_freq and runtime_limit values. Therefore, a simulation can be run with the command\n\nmpiexecjl -n 16 julia holstein_honeycomb_checkpoint.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100 0.5\n\nor\n\nsrun julia holstein_honeycomb_checkpoint.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100 0.5\n\nRefer to the previous 2b) Honeycomb Holstein Model with MPI Parallelization tutorial for more details on how to run the simulation script using MPI.\n\nIn the example calls above the code will write a new checkpoint if more than 30 minutes (0.5 hours) has passed since the last checkpoint file was written. Note that these same commands are used to both begin a new simulation and also resume a previous simulation. This is a useful feature when submitting jobs on a cluster, as it allows the same job file to be used for both starting new simulations and resuming ones that still need to finish.\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins = parse(Int, ARGS[9]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[10]), # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"section"},{"location":"examples/bssh_chain/#Bond-Su-Schrieffer-Heeger-Chain","page":"Bond Su-Schrieffer-Heeger Chain","title":"Bond Su-Schrieffer-Heeger Chain","text":"Download this example as a Julia script.\n\nIn this example we simulate the optical Su-Schrieffer-Heeger (OSSH) model on a 1D chain, with a Hamiltonian given by\n\nbeginalign*\nhatH = sum_i left( frac12MhatP_langle i+1 i rangle^2 + frac12MOmega^2hatX_langle i+1 i rangle^2 right)\n          - sum_sigmai t-alphahatX_langle i+1 i rangle (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n          - mu sum_sigmai hatn_sigmai\nendalign*\n\nin which the fluctuations in the position of dispersionless phonon modes placed on each site in the lattice modulate the hopping amplitude between neighboring sites. In the above expression hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creation (annihilation) operator a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on the bond connecting sites i and i+1 is given by hatX_langle i+1irangle  (hatP_langle i+1irangle), where Omega and M are the phonon frequency and associated ion mass respectively. Lastly, the strength of the electron-phonon coupling is controlled by the parameter alpha.\n\nNote that this example script comes with all the bells and whistles so to speak, including support for MPI parallelization as well as checkpointing.\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf\nusing MPI\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements to make.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Nt = 10, # Number of time-steps in HMC update.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"bssh_chain_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 100),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"Nt\"] = Nt\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_measurements\"] = N_measurements\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"n_stab\"] = n_stab\n        metadata[\"dG_max\"] = δG_max\n        metadata[\"symmetric\"] = symmetric\n        metadata[\"checkerboard\"] = checkerboard\n        metadata[\"seed\"] = seed\n        metadata[\"hmc_acceptance_rate\"] = 0.0\n        metadata[\"reflection_acceptance_rate\"] = 0.0\n        metadata[\"swap_acceptance_rate\"] = 0.0\n\n        # Initialize an instance of the type UnitCell.\n        unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                                basis_vecs   = [[0.0]])\n\n        # Initialize an instance of the type Lattice.\n        lattice = lu.Lattice(\n            L = [L],\n            periodic = [true]\n        )\n\n        # Get the number of sites in the lattice.\n        N = lu.nsites(unit_cell, lattice)\n\n        # Initialize an instance of the ModelGeometry type.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the nearest-neighbor bond for a 1D chain.\n        bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n        # Add this bond to the model, by adding it to the ModelGeometry type.\n        bond_id = add_bond!(model_geometry, bond)\n\n        # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n        t = 1.0\n\n        # Define the tight-binding model\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond], # defines hopping\n            t_mean = [t],     ## defines corresponding hopping amplitude\n            μ = μ,            ## set chemical potential\n            ϵ_mean = [0.]     ## set the (mean) on-site energy\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless electron-phonon mode to live on each bond in the lattice.\n        phonon = PhononMode(\n            basis_vec = [0.5],\n            Ω_mean = Ω\n        )\n\n        # Add bond ssh phonon to electron-phonon model.\n        phonon_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon\n        )\n\n        # Define frozen phonon mode with infinite mass.\n        fphonon = PhononMode(\n            basis_vec = [0.0],\n            Ω_mean = Ω,\n            M = Inf # Set phonon mass to infinity.\n        )\n\n        # Add frozen phonon mode to model.\n        fphonon_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = fphonon\n        )\n\n        # Defines ssh e-ph coupling such that total effective hopping is t_eff = t-α⋅X .\n        bssh_coupling = SSHCoupling(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            phonon_ids = (fphonon_id, phonon_id),\n            bond = bond,\n            α_mean = α\n        )\n\n        # Add bond SSH coupling to the electron-phonon model.\n        bssh_coupling_id = add_ssh_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            ssh_coupling = bssh_coupling,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Write a model summary to file.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs of modes.\n                (1, 1),\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the bond correlation measurement\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"bond\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (bond_id, bond_id),\n            ]\n        )\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        electron_phonon_parameters = checkpoint[\"electron_phonon_parameters\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing EFA-HMC, reflection and swap updates below.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time electron Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize electron Green's function matrix, also calculating the matrix determinant as the same time.\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize diagnostic parameters to asses numerical stability.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = π/(2*Nt)\n    )\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Reset diagnostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for measurement in n_measurements:N_measurements\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Make measurements.\n        (logdetG, sgndetG, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (electron_phonon_parameters,)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_measurements = measurement + 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Record largest numerical error encountered during simulation.\n    metadata[\"dG\"] = δG\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm,\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]), # Total number of measurements.\n        N_bins = parse(Int, ARGS[9]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[10]), # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#1c)-Square-Hubbard-Model-with-Checkpointing","page":"1c) Square Hubbard Model with Checkpointing","title":"1c) Square Hubbard Model with Checkpointing","text":"Download this example as a Julia script.\n\nIn this tutorial we demonstrate how to introduce checkpointing to the previous 1b) Square Hubbard Model with MPI Parallelization tutorial, allowing for simulations to be resumed if terminated prior to completion.","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Import-Packages","page":"1c) Square Hubbard Model with Checkpointing","title":"Import Packages","text":"No changes need to made to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial.\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf\nusing MPI","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Specify-simulation-parameters","page":"1c) Square Hubbard Model with Checkpointing","title":"Specify simulation parameters","text":"Compared to the previous 1b) Square Hubbard Model with MPI Parallelization tutorial, we have added two new keyword arguments to the run_simulation function:\n\ncheckpoint_freq: When going to write a new checkpoint file, only write one if more than checkpoint_freq hours have passed since the last checkpoint file was written.\nruntime_limit = Inf: If after writing a new checkpoint file more than runtime_limit hours have passed since the simulation started, terminate the simulation.\n\nThe runtime_limit = Inf default behavior means there is no runtime limit for the simulation.\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    U, # Hubbard interaction.\n    t′, # Next-nearest-neighbor hopping amplitude.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    N_updates, # Number of updates between measurements.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Initialize-simulation","page":"1c) Square Hubbard Model with Checkpointing","title":"Initialize simulation","text":"We need to make a few modifications to this portion of the code as compared to the previous tutorial in order for checkpointing to work. First, we record need to record the simulation start time, which we do by initializing a variable start_timestamp = time(). Second, we need to convert the checkpoint_freq and runtime_limit from hours to seconds.\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_square_U%.2f_tp%.2f_mu%.2f_L%d_b%.2f\" U t′ μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 10),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to if one does not already exist.\n    initialize_datafolder(comm, simulation_info)","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Initialize-simulation-metadata","page":"1c) Square Hubbard Model with Checkpointing","title":"Initialize simulation metadata","text":"At this point we need to introduce branching logic to handle whether a new simulation is being started, or a previous simulation is being resumed. We do this by checking the simulation_info.resuming boolean value. If simulation_info.resuming = true, then we are resuming a previous simulation, while simulation_info.resuming = false indicates we are starting a new simulation. Therefore, the section of code immediately below handles the case that we are starting a new simulation.\n\nWe also introduce and initialize two new variables n_therm = 1 and n_updates = 1 which will keep track of how many rounds of thermalization and measurement updates have been performed. These two variables will needed to be included in the checkpoint files we write later in the simulation, as they will indicate where to resume a previously terminated simulation.\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurements from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_measurements\"] = N_measurements\n        metadata[\"N_updates\"] = N_updates\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"n_stab_init\"] = n_stab\n        metadata[\"dG_max\"] = δG_max\n        metadata[\"symmetric\"] = symmetric\n        metadata[\"checkerboard\"] = checkerboard\n        metadata[\"seed\"] = seed\n        metadata[\"local_acceptance_rate\"] = 0.0\n        metadata[\"reflection_acceptance_rate\"] = 0.0","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Initialize-Model","page":"1c) Square Hubbard Model with Checkpointing","title":"Initialize Model","text":"No changes need to made to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial.\n\n        # Define unit cell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [[1.0, 0.0],\n                            [0.0, 1.0]],\n            basis_vecs = [[0.0, 0.0]]\n        )\n\n        # Define finite lattice with periodic boundary conditions.\n        lattice = lu.Lattice(\n            L = [L, L],\n            periodic = [true, true]\n        )\n\n        # Initialize model geometry.\n        model_geometry = ModelGeometry(\n            unit_cell, lattice\n        )\n\n        # Define the nearest-neighbor bond in +x direction.\n        bond_px = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, 0]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_px_id = add_bond!(model_geometry, bond_px)\n\n        # Define the nearest-neighbor bond in +y direction.\n        bond_py = lu.Bond(\n            orbitals = (1,1),\n            displacement = [0, 1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_py_id = add_bond!(model_geometry, bond_py)\n\n        # Define the next-nearest-neighbor bond in +x+y direction.\n        bond_pxpy = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, 1]\n        )\n\n        # Define the nearest-neighbor bond in -x direction.\n        # Will be used to make measurements later in this tutorial.\n        bond_nx = lu.Bond(\n            orbitals = (1,1),\n            displacement = [-1, 0]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n        # Define the nearest-neighbor bond in -y direction.\n        # Will be used to make measurements later in this tutorial.\n        bond_ny = lu.Bond(\n            orbitals = (1,1),\n            displacement = [0, -1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n        # Define the next-nearest-neighbor bond in +x+y direction.\n        bond_pxpy = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, 1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_pxpy_id = add_bond!(model_geometry, bond_pxpy)\n\n        # Define the next-nearest-neighbor bond in +x-y direction.\n        bond_pxny = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, -1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_pxny_id = add_bond!(model_geometry, bond_pxny)\n\n        # Set nearest-neighbor hopping amplitude to unity,\n        # setting the energy scale in the model.\n        t = 1.0\n\n        # Define the non-interacting tight-binding model.\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond_px, bond_py, bond_pxpy, bond_pxny], # defines hopping\n            t_mean = [t, t, t′, t′], # defines corresponding mean hopping amplitude\n            t_std = [0., 0., 0., 0.], # defines corresponding standard deviation in hopping amplitude\n            ϵ_mean = [0.], # set mean on-site energy for each orbital in unit cell\n            ϵ_std = [0.], # set standard deviation of on-site energy or each orbital in unit cell\n            μ = μ # set chemical potential\n        )\n\n        # Define the Hubbard interaction in the model.\n        hubbard_model = HubbardModel(\n            ph_sym_form = true, # if particle-hole symmetric form for Hubbard interaction is used.\n            U_orbital = [1], # orbitals in unit cell with Hubbard interaction.\n            U_mean = [U], # mean Hubbard interaction strength for corresponding orbital species in unit cell.\n            U_std = [0.], # standard deviation of Hubbard interaction strength for corresponding orbital species in unit cell.\n        )\n\n        # Write model summary TOML file specifying Hamiltonian that will be simulated.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (hubbard_model,)\n        )","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Initialize-model-parameters","page":"1c) Square Hubbard Model with Checkpointing","title":"Initialize model parameters","text":"No changes need to made to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial.\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize Hubbard interaction parameters.\n        hubbard_parameters = HubbardParameters(\n            model_geometry = model_geometry,\n            hubbard_model = hubbard_model,\n            rng = rng\n        )\n\n        # Apply Hubbard-Stratonovich (HS) transformation to decouple the Hubbard interaction,\n        # and initialize the corresponding HS fields that will be sampled in the DQMC simulation.\n        hst_parameters = HubbardSpinHirschHST(\n            β = β, Δτ = Δτ,\n            hubbard_parameters = hubbard_parameters,\n            rng = rng\n        )","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Initialize-measurements","page":"1c) Square Hubbard Model with Checkpointing","title":"Initialize measurements","text":"No changes need to made to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial.\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the Hubbard interaction related measurements.\n        initialize_measurements!(measurement_container, hubbard_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the d-wave pair susceptibility measurement.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"d-wave\",\n            correlation = \"pair\",\n            ids = [bond_px_id, bond_nx_id, bond_py_id, bond_ny_id],\n            coefficients = [0.5, 0.5, -0.5, -0.5],\n            time_displaced = false,\n            integrated = true\n        )","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Write-first-checkpoint","page":"1c) Square Hubbard Model with Checkpointing","title":"Write first checkpoint","text":"This section of code needs to be added so that a first checkpoint file is written before beginning a new simulation. We do this using the write_jld2_checkpoint function. This function all return the epoch timestamp checkpoint_timestamp corresponding to when the checkpoint file was written.\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, hubbard_parameters, hst_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Load-checkpoint","page":"1c) Square Hubbard Model with Checkpointing","title":"Load checkpoint","text":"If we are resuming a simulation that was previously terminated prior to completion, then we need to load the most recent checkpoint file using the read_jld2_checkpoint function. The contents of the checkpoint file are returned as a dictionary checkpoint by the read_jld2_checkpoint function. We then extract the contents of the checkpoint file from the checkpoint dictionary.\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        hubbard_parameters = checkpoint[\"hubbard_parameters\"]\n        hst_parameters = checkpoint[\"hst_parameters\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Setup-DQMC-simulation","page":"1c) Square Hubbard Model with Checkpointing","title":"Setup DQMC simulation","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for Hubbard interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for the current\n    # Hubbard-Stratonovich field configuration.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hst_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices for spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type for spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Initialize alternate FermionGreensCalculator type for performing reflection updates.\n    fermion_greens_calculator_up_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_up)\n    fermion_greens_calculator_dn_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_dn)\n\n    # Allocate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # Gup(τ,τ)\n    Gup_τ0 = similar(Gup) # Gup(τ,0)\n    Gup_0τ = similar(Gup) # Gup(0,τ)\n    Gdn_ττ = similar(Gdn) # Gdn(τ,τ)\n    Gdn_τ0 = similar(Gdn) # Gdn(τ,0)\n    Gdn_0τ = similar(Gdn) # Gdn(0,τ)\n\n    # Initialize diagnostic parameters to asses numerical stability.\n    δG = zero(logdetGup)\n    δθ = zero(logdetGup)","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Thermalize-system","page":"1c) Square Hubbard Model with Checkpointing","title":"Thermalize system","text":"The first change we need to make to this section is to have the for-loop iterate from n_therm:N_therm instead of 1:N_therm. The other change we need make to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial is to add a call to the write_jld2_checkpoint function at the end of each iteration of the for-loop in which we perform the thermalization updates. When calling this function we need to pass it the timestamp for the previous checkpoint checkpoint_timestamp so that the function can determine if a new checkpoint file needs to be written. If a new checkpoint file is written then the checkpoint_timestamp variable will be updated to reflect this, otherwise it will remain unchanged.\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform reflection update for HS fields with randomly chosen site.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hst_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, rng = rng\n        )\n\n        # Record whether reflection update was accepted or not.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hst_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n            update_stabilization_frequency = true\n        )\n\n        # Record acceptance rate for sweep.\n        metadata[\"local_acceptance_rate\"] += acceptance_rate\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, hubbard_parameters, hst_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Make-measurements","page":"1c) Square Hubbard Model with Checkpointing","title":"Make measurements","text":"Again, we need to modify the for-loop so that it runs from n_updates:N_measurements instead of 1:N_measurements. The only other change we need to make to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial is to add a call to the write_jld2_checkpoint function at the end of each iteration of the for-loop in which we perform updates and measurements. Note that we set n_therm = N_therm + 1 when writing the checkpoint file to ensure that when the simulation is resumed the thermalization updates are not repeated.\n\n    # Reset diagnostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetGup)\n    δθ = zero(logdetGup)\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over measurements.\n    for measurement in n_measurements:N_measurements\n\n        # Iterate over updates between measurements.\n        for update in 1:N_updates\n\n            # Perform reflection update for HS fields with randomly chosen site.\n            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hst_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n                Bup = Bup, Bdn = Bdn, rng = rng\n            )\n\n            # Record whether reflection update was accepted or not.\n            metadata[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hst_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n                update_stabilization_frequency = true\n            )\n\n            # Record acceptance rate.\n            metadata[\"local_acceptance_rate\"] += acceptance_rate\n        end\n\n        # Make measurements.\n        (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n            logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (hubbard_parameters, hst_parameters)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_measurements = measurement + 1,\n            tight_binding_parameters, hubbard_parameters, hst_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Merge-binned-data","page":"1c) Square Hubbard Model with Checkpointing","title":"Merge binned data","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Record-simulation-metadata","page":"1c) Square Hubbard Model with Checkpointing","title":"Record simulation metadata","text":"No changes need to made to this section of the code from the previous 1b) Square Hubbard Model with MPI Parallelization tutorial.\n\n    # Normalize acceptance rate.\n    metadata[\"local_acceptance_rate\"] /=  (N_therm + N_measurements * N_updates)\n    metadata[\"reflection_acceptance_rate\"] /=  (N_therm + N_measurements * N_updates)\n\n    # Record final stabilization frequency used at end of simulation.\n    metadata[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record largest numerical error.\n    metadata[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Post-process-results","page":"1c) Square Hubbard Model with Checkpointing","title":"Post-process results","text":"From the last 1b) Square Hubbard Model with MPI Parallelization tutorial, we now need to add a call to the rename_complete_simulation function once the results are processed. This function renames the data folder to begin with complete_*, making it simple to identify which simulations ran to completion and which ones need to be resumed from the last checkpoint file. This function also deletes the checkpoint files that were written during the simulation.\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm;\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\n    # Calculate AFM correlation ratio.\n    Rafm, ΔRafm = compute_correlation_ratio(\n        comm;\n        datafolder = simulation_info.datafolder,\n        correlation = \"spin_z\",\n        type = \"equal-time\",\n        id_pairs = [(1, 1)],\n        id_pair_coefficients = [1.0],\n        q_point = (L÷2, L÷2),\n        q_neighbors = [\n            (L÷2+1, L÷2), (L÷2-1, L÷2),\n            (L÷2, L÷2+1), (L÷2, L÷2-1)\n        ]\n    )\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rafm_mean_real\"] = real(Rafm)\n    metadata[\"Rafm_mean_imag\"] = imag(Rafm)\n    metadata[\"Rafm_std\"] = ΔRafm\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function","category":"section"},{"location":"tutorials/hubbard_square_checkpoint/#Execute-script","page":"1c) Square Hubbard Model with Checkpointing","title":"Execute script","text":"To execute the script, we have added two new command line arguments allowing for the assignment of both the checkpoint_freq and runtime_limit values. Therefore, a simulation can be run with the command\n\nmpiexecjl -n 16 julia hubbard_square_checkpoint.jl 1 5.0 -0.25 -2.0 4 4.0 2000 2000 40 5 1.0\n\nor\n\nsrun julia hubbard_square_checkpoint.jl 1 5.0 -0.25 -2.0 4 4.0 2000 2000 40 5 1.0\n\nRefer to the previous 1b) Square Hubbard Model with MPI Parallelization tutorial for more details on how to run the simulation script using MPI.\n\nIn the example calls above the code will write a new checkpoint if more than 1 hour has passed since the last checkpoint file was written. Note that these same commands are used to both begin a new simulation and also resume a previous simulation. This is a useful feature when submitting jobs on a cluster, as it allows the same job file to be used for both starting new simulations and resuming ones that still need to finish.\n\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation, reading in command line arguments.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        U = parse(Float64, ARGS[2]), # Hubbard interaction.\n        t′ = parse(Float64, ARGS[3]), # Next-nearest-neighbor hopping amplitude.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins = parse(Int, ARGS[9]), # Number of times bin-averaged measurements are written to file.\n        N_updates = parse(Int, ARGS[10]), # Number of updates between measurements.\n        checkpoint_freq = parse(Float64, ARGS[11]) # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#2d)-Honeycomb-Holstein-Model-with-Density-Tuning","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"2d) Honeycomb Holstein Model with Density Tuning","text":"Download this example as a Julia script.\n\nIn this example we demonstrate how to introduce chemical potential and density tuning to the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial. Specifically, we show how to use the algorithm introduced in Phys. Rev. E 105, 045311 for dynamically adjusting the chemical potential during the simulation in order to achieve a target electron density or filling fraction.","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Import-Packages","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Import Packages","text":"Compared to the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial, we now need to import the MuTuner.jl package, which is reexported by SmoQyDQMC.jl\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\nimport SmoQyDQMC.MuTuner as mt\n\nusing Random\nusing Printf\nusing MPI","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Specify-simulation-parameters","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Specify simulation parameters","text":"Here we introduce the keyword argument n to the run_simulation function which specifies the target electron density we want to achieve in the simulation. Now the μ argument specifies the initial chemical potential we begin the simulation with, but of course it will be adjusted during the simulation to achieve the target density n.\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    n, # Target density.\n    μ, # Initial chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Nt = 10, # Number of time-steps in HMC update.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-simulation","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Initialize simulation","text":"No changes need to made to this section of the code from the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial.\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_honeycomb_w%.2f_a%.2f_n%.2f_L%d_b%.2f\" Ω α n L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 7),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-simulation-metadata","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Initialize simulation metadata","text":"Here it is useful to record the initial chemical potential μ used during the simulation in the metadata dictionary.\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"mu\"] = μ\n        metadata[\"Nt\"] = Nt\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_measurements\"] = N_measurements\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"n_stab\"] = n_stab\n        metadata[\"dG_max\"] = δG_max\n        metadata[\"symmetric\"] = symmetric\n        metadata[\"checkerboard\"] = checkerboard\n        metadata[\"seed\"] = seed\n        metadata[\"hmc_acceptance_rate\"] = 0.0\n        metadata[\"reflection_acceptance_rate\"] = 0.0\n        metadata[\"swap_acceptance_rate\"] = 0.0","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-model","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Initialize model","text":"No changes need to made to this section of the code from the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial.\n\n        # Define lattice vectors.\n        a1 = [+3/2, +√3/2]\n        a2 = [+3/2, -√3/2]\n\n        # Define basis vectors for two orbitals in the honeycomb unit cell.\n        r1 = [0.0, 0.0] # Location of first orbital in unit cell.\n        r2 = [1.0, 0.0] # Location of second orbital in unit cell.\n\n        # Define the unit cell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [a1, a2],\n            basis_vecs = [r1, r2]\n        )\n\n        # Define finite lattice with periodic boundary conditions.\n        lattice = lu.Lattice(\n            L = [L, L],\n            periodic = [true, true]\n        )\n\n        # Initialize model geometry.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the first nearest-neighbor bond in a honeycomb lattice.\n        bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n        # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_1_id = add_bond!(model_geometry, bond_1)\n\n        # Define the second nearest-neighbor bond in a honeycomb lattice.\n        bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n        # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_2_id = add_bond!(model_geometry, bond_2)\n\n        # Define the third nearest-neighbor bond in a honeycomb lattice.\n        bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n        # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n        bond_3_id = add_bond!(model_geometry, bond_3)\n\n        # Set nearest-neighbor hopping amplitude to unity,\n        # setting the energy scale in the model.\n        t = 1.0\n\n        # Define the honeycomb tight-binding model.\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond_1, bond_2, bond_3], # defines hopping\n            t_mean = [t, t, t], # defines corresponding hopping amplitude\n            μ  = μ, # set chemical potential\n            ϵ_mean = [0.0, 0.0] # set the (mean) on-site energy\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n        phonon_1 = PhononMode(\n            basis_vec = r1,\n            Ω_mean = Ω\n        )\n\n        # Add the phonon mode definition to the electron-phonon model.\n        phonon_1_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_1\n        )\n\n        # Define a dispersionless electron-phonon mode to live on the second sublattice.\n        phonon_2 = PhononMode(\n            basis_vec = r2,\n            Ω_mean = Ω\n        )\n\n        # Add the phonon mode definition to the electron-phonon model.\n        phonon_2_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_2\n        )\n\n        # Define first local Holstein coupling for first phonon mode.\n        holstein_coupling_1 = HolsteinCoupling(\n            model_geometry = model_geometry,\n            phonon_id = phonon_1_id,\n            orbital_id = 1,\n            displacement = [0, 0],\n            α_mean = α,\n            ph_sym_form = true,\n        )\n\n        # Add the first local Holstein coupling definition to the model.\n        holstein_coupling_1_id = add_holstein_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            holstein_coupling = holstein_coupling_1,\n            model_geometry = model_geometry\n        )\n\n        # Define second local Holstein coupling for second phonon mode.\n        holstein_coupling_2 = HolsteinCoupling(\n            model_geometry = model_geometry,\n            phonon_id = phonon_2_id,\n            orbital_id = 2,\n            displacement = [0, 0],\n            α_mean = α,\n            ph_sym_form = true,\n        )\n\n        # Add the second local Holstein coupling definition to the model.\n        holstein_coupling_2_id = add_holstein_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            holstein_coupling = holstein_coupling_2,\n            model_geometry = model_geometry\n        )\n\n        # Write model summary TOML file specifying Hamiltonian that will be simulated.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-model-parameters","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Initialize model parameters","text":"In this section we need to make use of the MuTuner.jl package, initializing an instance of the MuTuner.MuTunerLogger type using the MuTuner.init_mutunerlogger function. Note that we use the LatticeUtilities.nsites function to calculate the total number of orbitals in our system.\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize MuTunerLogger type that will be used to dynamically adjust the\n        # chemical potential during the simulation.\n        chemical_potential_tuner = mt.init_mutunerlogger(\n            target_density = n,\n            inverse_temperature = β,\n            system_size = lu.nsites(unit_cell, lattice),\n            initial_chemical_potential = μ,\n            complex_sign_problem = false\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Initialize-measurements","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Initialize measurements","text":"No changes need to made to this section of the code from the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial.\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1), (2, 2), (1, 2)\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs of modes.\n                (1, 1), (2, 2), (1, 2)\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1), (2, 2),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1), (2, 2)\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1), (2, 2)\n            ]\n        )\n\n        # Initialize measurement of electron Green's function traced\n        # over both orbitals in the unit cell.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"tr_greens\",\n            correlation = \"greens\",\n            id_pairs = [(1,1), (2,2)],\n            coefficients = [1.0, 1.0],\n            time_displaced = true,\n        )\n\n        # Initialize CDW correlation measurement.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"cdw\",\n            correlation = \"density\",\n            ids = [1, 2],\n            coefficients = [1.0, -1.0],\n            time_displaced = false,\n            integrated = true\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Write-first-checkpoint","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Write first checkpoint","text":"Here we need to add the MuTuner.MuTunerLogger instance chemical_potential_tuner to the checkpoint file.\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, electron_phonon_parameters, chemical_potential_tuner,\n            measurement_container, model_geometry, metadata, rng\n        )","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Load-checkpoint","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Load checkpoint","text":"Here we need to make sure to load the MuTuner.MuTunerLogger instance chemical_potential_tuner from the checkpoint file.\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters    = checkpoint[\"tight_binding_parameters\"]\n        electron_phonon_parameters  = checkpoint[\"electron_phonon_parameters\"]\n        chemical_potential_tuner    = checkpoint[\"chemical_potential_tuner\"]\n        measurement_container       = checkpoint[\"measurement_container\"]\n        model_geometry              = checkpoint[\"model_geometry\"]\n        metadata                    = checkpoint[\"metadata\"]\n        rng                         = checkpoint[\"rng\"]\n        n_therm                     = checkpoint[\"n_therm\"]\n        n_measurements                   = checkpoint[\"n_measurements\"]\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Setup-DQMC-simulation","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Setup DQMC simulation","text":"No changes need to made to this section of the code from the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial.\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing EFA-HMC, reflection and swap updates below.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time electron Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize electron Green's function matrix, also calculating the matrix determinant as the same time.\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize diagnostic parameters to asses numerical stability.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Setup-EFA-HMC-Updates","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Setup EFA-HMC Updates","text":"No changes need to made to this section of the code from the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial.\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = π/(2*Nt)\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Thermalize-system","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Thermalize system","text":"Here we need to add a call to the update_chemical_potential! function after completing the updates but before writing the checkpoint file is written. And again, we need to make sure the include the chemical_potential_tuner in the checkpoint file.\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Update the chemical potential to achieve the target density.\n        (logdetG, sgndetG) = update_chemical_potential!(\n            G, logdetG, sgndetG;\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, electron_phonon_parameters, chemical_potential_tuner,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Make-measurements","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Make measurements","text":"Here we need to add a call to the update_chemical_potential! function after making and writing measurements but before writing the checkpoint file is written. And again, we need to make sure the include the chemical_potential_tuner in the checkpoint file.\n\n    # Reset diagnostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for measurement in n_measurements:N_measurements\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Make measurements.\n        (logdetG, sgndetG, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (electron_phonon_parameters,)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Update the chemical potential to achieve the target density.\n        (logdetG, sgndetG) = update_chemical_potential!(\n            G, logdetG, sgndetG;\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm = N_therm + 1,\n            n_measurements = measurement + 1,\n            tight_binding_parameters, electron_phonon_parameters, chemical_potential_tuner,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Merge-binned-data","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Merge binned data","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Record-simulation-metadata","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Record simulation metadata","text":"Here we can add a call to the save_density_tuning_profile, which records the full history of the chemical potential and density tuning process.\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Record largest numerical error encountered during simulation.\n    metadata[\"dG\"] = δG\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Save the density tuning profile to file.\n    save_density_tuning_profile(simulation_info, chemical_potential_tuner)","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Post-process-results","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Post-process results","text":"No changes need to made to this section of the code from the previous 2c) Honeycomb Holstein Model with Checkpointing tutorial.\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm,\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\n    # Calculate CDW correlation ratio.\n    Rcdw, ΔRcdw = compute_composite_correlation_ratio(\n        comm;\n        datafolder = simulation_info.datafolder,\n        name = \"cdw\",\n        type = \"equal-time\",\n        q_point = (0, 0),\n        q_neighbors = [\n            (1,0),   (0,1),   (1,1),\n            (L-1,0), (0,L-1), (L-1,L-1)\n        ]\n    )\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rcdw_mean_real\"] = real(Rcdw)\n    metadata[\"Rcdw_mean_imag\"] = imag(Rcdw)\n    metadata[\"Rcdw_std\"]       = ΔRcdw\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function","category":"section"},{"location":"tutorials/holstein_honeycomb_density_tuning/#Execute-script","page":"2d) Honeycomb Holstein Model with Density Tuning","title":"Execute script","text":"Here we add an additional command line argument to specify the target density n we want to achieve in the simulation. Now the μ command line argument specifies the initial chemical potential we begin the simulation with. For instance, a simulation can be run with the command\n\nmpiexecjl -n 16 julia holstein_honeycomb_density_tuning.jl 1 1.0 1.5 0.8 0.0 3 4.0 5000 10000 100 0.5\n\nor\n\nsrun julia holstein_honeycomb_density_tuning.jl 1 1.0 1.5 0.8 0.0 3 4.0 5000 10000 100 0.5\n\nwhere the target density is langle n rangle = 08 and the initial chemical potential is mu = 00.\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Run the simulation.\n    run_simulation(\n        MPI.COMM_WORLD;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        n = parse(Float64, ARGS[4]), # Target density.\n        μ = parse(Float64, ARGS[5]), # Initial chemical potential.\n        L = parse(Int, ARGS[6]), # System size.\n        β = parse(Float64, ARGS[7]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[8]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[9]), # Total number of measurements and measurement updates.\n        N_bins = parse(Int, ARGS[10]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[11]), # Frequency with which checkpoint files are written in hours.\n    )\nend","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#1d)-Square-Hubbard-Model-with-Density-Tuning","page":"1d) Square Hubbard Model with Density Tuning","title":"1d) Square Hubbard Model with Density Tuning","text":"Download this example as a Julia script.\n\nIn this example we demonstrate how to introduce chemical potential and density tuning to the previous 1c) Square Hubbard Model with Checkpointing tutorial. Specifically, we show how to use the algorithm introduced in Phys. Rev. E 105, 045311 for dynamically adjusting the chemical potential during the simulation in order to achieve a target electron density or filling fraction.\n\nNote that when you dope the Hubbard model away from half-filling a sign problem is introduced. As with making measurements, if the sign problem becomes severe the density tuning algorithm will become very inefficient as simply providing an accurate measurement of the density and compressibility (which is used to adjust the chemical potential) will become challenging.","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Import-Packages","page":"1d) Square Hubbard Model with Density Tuning","title":"Import Packages","text":"Compared to the previous 1c) Square Hubbard Model with Checkpointing tutorial, we now need to import the MuTuner.jl package, which is reexported by SmoQyDQMC.jl\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\nimport SmoQyDQMC.MuTuner as mt\n\nusing Random\nusing Printf\nusing MPI","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Specify-simulation-parameters","page":"1d) Square Hubbard Model with Density Tuning","title":"Specify simulation parameters","text":"Here we introduce the keyword argument n to the run_simulation function which specifies the target electron density we want to achieve in the simulation. Now the μ argument specifies the initial chemical potential we begin the simulation with, but of course it will be adjusted during the simulation to achieve the target density n.\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    U, # Hubbard interaction.\n    t′, # Next-nearest-neighbor hopping amplitude.\n    n, # Target density.\n    μ, # Initial chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Number of measurements to make.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    N_updates, # Number of updates between measurements.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Initialize-simulation","page":"1d) Square Hubbard Model with Density Tuning","title":"Initialize simulation","text":"No changes need to made to this section of the code from the previous 1c) Square Hubbard Model with Checkpointing tutorial.\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_square_U%.2f_tp%.2f_n%.2f_L%d_b%.2f\" U t′ n L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 10),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to if one does not already exist.\n    initialize_datafolder(comm, simulation_info)","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Initialize-simulation-metadata","page":"1d) Square Hubbard Model with Density Tuning","title":"Initialize simulation metadata","text":"Here it is useful to record the initial chemical potential μ used during the simulation in the metadata dictionary.\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"mu\"] = μ\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_measurements\"] = N_measurements\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"N_updates\"] = N_updates\n        metadata[\"n_stab_init\"] = n_stab\n        metadata[\"dG_max\"] = δG_max\n        metadata[\"symmetric\"] = symmetric\n        metadata[\"checkerboard\"] = checkerboard\n        metadata[\"seed\"] = seed\n        metadata[\"local_acceptance_rate\"] = 0.0\n        metadata[\"reflection_acceptance_rate\"] = 0.0","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Initialize-Model","page":"1d) Square Hubbard Model with Density Tuning","title":"Initialize Model","text":"No changes need to made to this section of the code from the previous 1c) Square Hubbard Model with Checkpointing tutorial.\n\n        # Define unit cell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [[1.0, 0.0],\n                            [0.0, 1.0]],\n            basis_vecs = [[0.0, 0.0]]\n        )\n\n        # Define finite lattice with periodic boundary conditions.\n        lattice = lu.Lattice(\n            L = [L, L],\n            periodic = [true, true]\n        )\n\n        # Initialize model geometry.\n        model_geometry = ModelGeometry(\n            unit_cell, lattice\n        )\n\n        # Define the nearest-neighbor bond in +x direction.\n        bond_px = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, 0]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_px_id = add_bond!(model_geometry, bond_px)\n\n        # Define the nearest-neighbor bond in +y direction.\n        bond_py = lu.Bond(\n            orbitals = (1,1),\n            displacement = [0, 1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_py_id = add_bond!(model_geometry, bond_py)\n\n        # Define the next-nearest-neighbor bond in +x+y direction.\n        bond_pxpy = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, 1]\n        )\n\n        # Define the nearest-neighbor bond in -x direction.\n        # Will be used to make measurements later in this tutorial.\n        bond_nx = lu.Bond(\n            orbitals = (1,1),\n            displacement = [-1, 0]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n        # Define the nearest-neighbor bond in -y direction.\n        # Will be used to make measurements later in this tutorial.\n        bond_ny = lu.Bond(\n            orbitals = (1,1),\n            displacement = [0, -1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n        # Define the next-nearest-neighbor bond in +x+y direction.\n        bond_pxpy = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, 1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_pxpy_id = add_bond!(model_geometry, bond_pxpy)\n\n        # Define the next-nearest-neighbor bond in +x-y direction.\n        bond_pxny = lu.Bond(\n            orbitals = (1,1),\n            displacement = [1, -1]\n        )\n\n        # Add this bond definition to the model, by adding it the model_geometry.\n        bond_pxny_id = add_bond!(model_geometry, bond_pxny)\n\n        # Set neartest-neighbor hopping amplitude to unity,\n        # setting the energy scale in the model.\n        t = 1.0\n\n        # Define the non-interacting tight-binding model.\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond_px, bond_py, bond_pxpy, bond_pxny], # defines hopping\n            t_mean = [t, t, t′, t′], # defines corresponding mean hopping amplitude\n            t_std = [0., 0., 0., 0.], # defines corresponding standard deviation in hopping amplitude\n            ϵ_mean = [0.], # set mean on-site energy for each orbital in unit cell\n            ϵ_std = [0.], # set standard deviation of on-site energy or each orbital in unit cell\n            μ = μ # set chemical potential\n        )\n\n        # Define the Hubbard interaction in the model.\n        hubbard_model = HubbardModel(\n            ph_sym_form = true, # if particle-hole symmetric form for Hubbard interaction is used.\n            U_orbital = [1], # orbitals in unit cell with Hubbard interaction.\n            U_mean = [U], # mean Hubbard interaction strength for corresponding orbital species in unit cell.\n            U_std = [0.], # standard deviation of Hubbard interaction strength for corresponding orbital species in unit cell.\n        )\n\n        # Write model summary TOML file specifying Hamiltonian that will be simulated.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (hubbard_model,)\n        )","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Initialize-model-parameters","page":"1d) Square Hubbard Model with Density Tuning","title":"Initialize model parameters","text":"In this section we need to make use of the MuTuner.jl package, initializing an instance of the MuTuner.MuTunerLogger type using the MuTuner.init_mutunerlogger function. Note that we use the LatticeUtilities.nsites function to calculate the total number of orbitals in our system.\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize Hubbard interaction parameters.\n        hubbard_params = HubbardParameters(\n            model_geometry = model_geometry,\n            hubbard_model = hubbard_model,\n            rng = rng\n        )\n\n        # Apply Hubbard-Stratonovich (HS) transformation to decouple the Hubbard interaction,\n        # and initialize the corresponding HS fields that will be sampled in the DQMC simulation.\n        hst_parameters = HubbardSpinHirschHST(\n            β = β, Δτ = Δτ,\n            hubbard_parameters = hubbard_params,\n            rng = rng\n        )\n\n        # Initialize MuTunerLogger type that will be used to dynamically adjust the\n        # chemical potential during the simulation.\n        chemical_potential_tuner = mt.init_mutunerlogger(\n            target_density = n,\n            inverse_temperature = β,\n            system_size = lu.nsites(unit_cell, lattice),\n            initial_chemical_potential = μ,\n            complex_sign_problem = false\n        )","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Initialize-measurements","page":"1d) Square Hubbard Model with Density Tuning","title":"Initialize measurements","text":"No changes need to made to this section of the code from the previous 1c) Square Hubbard Model with Checkpointing tutorial.\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the Hubbard interaction related measurements.\n        initialize_measurements!(measurement_container, hubbard_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the d-wave pair susceptibility measurement.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"d-wave\",\n            correlation = \"pair\",\n            ids = [bond_px_id, bond_nx_id, bond_py_id, bond_ny_id],\n            coefficients = [0.5, 0.5, -0.5, -0.5],\n            time_displaced = false,\n            integrated = true\n        )","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Write-first-checkpoint","page":"1d) Square Hubbard Model with Density Tuning","title":"Write first checkpoint","text":"Here we need to add the MuTuner.MuTunerLogger instance chemical_potential_tuner to the checkpoint file.\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, hubbard_params, hst_parameters,\n            chemical_potential_tuner, measurement_container, model_geometry, metadata, rng\n        )","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Load-checkpoint","page":"1d) Square Hubbard Model with Density Tuning","title":"Load checkpoint","text":"Here we need to make sure to load the MuTuner.MuTunerLogger instance chemical_potential_tuner from the checkpoint file.\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        hubbard_params = checkpoint[\"hubbard_params\"]\n        hst_parameters = checkpoint[\"hst_parameters\"]\n        chemical_potential_tuner = checkpoint[\"chemical_potential_tuner\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Setup-DQMC-simulation","page":"1d) Square Hubbard Model with Density Tuning","title":"Setup DQMC simulation","text":"No changes need to made to this section of the code from the previous 1c) Square Hubbard Model with Checkpointing tutorial.\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for Hubbard interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_params)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for the current\n    # Hubbard-Stratonovich field configuration.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hst_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices for spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type for spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Initialize alternate FermionGreensCalculator type for performing reflection updates.\n    fermion_greens_calculator_up_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_up)\n    fermion_greens_calculator_dn_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_dn)\n\n    # Allocate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # Gup(τ,τ)\n    Gup_τ0 = similar(Gup) # Gup(τ,0)\n    Gup_0τ = similar(Gup) # Gup(0,τ)\n    Gdn_ττ = similar(Gdn) # Gdn(τ,τ)\n    Gdn_τ0 = similar(Gdn) # Gdn(τ,0)\n    Gdn_0τ = similar(Gdn) # Gdn(0,τ)\n\n    # Initialize diagnostic parameters to asses numerical stability.\n    δG = zero(logdetGup)\n    δθ = zero(logdetGup)","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Thermalize-system","page":"1d) Square Hubbard Model with Density Tuning","title":"Thermalize system","text":"Here we need to add a call to the update_chemical_potential! function after completing the updates but before writing the checkpoint file is written. And again, we need to make sure the include the chemical_potential_tuner in the checkpoint file.\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Update the chemical potential to achieve the target density.\n        (logdetGup, sgndetGup, logdetGdn, sgndetGdn) = update_chemical_potential!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn;\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn\n        )\n\n        # Perform reflection update for HS fields with randomly chosen site.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hst_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, rng = rng\n        )\n\n        # Record whether reflection update was accepted or not.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hst_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n            update_stabilization_frequency = true\n        )\n\n        # Record acceptance rate for sweep.\n        metadata[\"local_acceptance_rate\"] += acceptance_rate\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, hubbard_params, hst_parameters,\n            chemical_potential_tuner, measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Make-measurements","page":"1d) Square Hubbard Model with Density Tuning","title":"Make measurements","text":"Here we need to add a call to the update_chemical_potential! function after making and writing measurements but before writing the checkpoint file is written. And again, we need to make sure the include the chemical_potential_tuner in the checkpoint file.\n\n    # Reset diagnostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetGup)\n    δθ = zero(logdetGup)\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over measurements.\n    for measurement in n_measurements:N_measurements\n\n        # Iterate over number of updates between measurements.\n        for update in 1:N_updates\n\n            # Update the chemical potential to achieve the target density.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn) = update_chemical_potential!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn;\n                chemical_potential_tuner = chemical_potential_tuner,\n                tight_binding_parameters = tight_binding_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn\n            )\n\n            # Perform reflection update for HS fields with randomly chosen site.\n            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hst_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n                Bup = Bup, Bdn = Bdn, rng = rng\n            )\n\n            # Record whether reflection update was accepted or not.\n            metadata[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hst_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n                update_stabilization_frequency = true\n            )\n\n            # Record acceptance rate.\n            metadata[\"local_acceptance_rate\"] += acceptance_rate\n        end\n\n        # Make measurements.\n        (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n            logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (hubbard_params, hst_parameters)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_measurements = measurement + 1,\n            tight_binding_parameters, hubbard_params, hst_parameters,\n            chemical_potential_tuner, measurement_container, model_geometry, metadata, rng\n        )\n    end","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Merge-binned-data","page":"1d) Square Hubbard Model with Density Tuning","title":"Merge binned data","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Record-simulation-metadata","page":"1d) Square Hubbard Model with Density Tuning","title":"Record simulation metadata","text":"Here we can add a call to the save_density_tuning_profile, which records the full history of the chemical potential and density tuning process.\n\n    # Normalize acceptance rate.\n    metadata[\"local_acceptance_rate\"] /=  (N_therm + N_measurements * N_updates)\n    metadata[\"reflection_acceptance_rate\"] /=  (N_therm + N_measurements * N_updates)\n\n    # Record final stabilization frequency used at end of simulation.\n    metadata[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record largest numerical error.\n    metadata[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Save the density tuning profile to file.\n    save_density_tuning_profile(\n        simulation_info, chemical_potential_tuner,\n        export_to_h5 = true,\n        export_to_csv = false\n    )","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Post-process-results","page":"1d) Square Hubbard Model with Density Tuning","title":"Post-process results","text":"No changes need to made to this section of the code from the previous 1c) Square Hubbard Model with Checkpointing tutorial.\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm;\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\n    # Calculate AFM correlation ratio.\n    Rafm, ΔRafm = compute_correlation_ratio(\n        comm;\n        datafolder = simulation_info.datafolder,\n        correlation = \"spin_z\",\n        type = \"equal-time\",\n        id_pairs = [(1, 1)],\n        id_pair_coefficients = [1.0],\n        q_point = (L÷2, L÷2),\n        q_neighbors = [\n            (L÷2+1, L÷2), (L÷2-1, L÷2),\n            (L÷2, L÷2+1), (L÷2, L÷2-1)\n        ]\n    )\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rafm_mean_real\"] = real(Rafm)\n    metadata[\"Rafm_mean_imag\"] = imag(Rafm)\n    metadata[\"Rafm_std\"] = ΔRafm\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function","category":"section"},{"location":"tutorials/hubbard_square_density_tuning/#Execute-script","page":"1d) Square Hubbard Model with Density Tuning","title":"Execute script","text":"Here we add an additional command line argument to specify the target density n we want to achieve in the simulation. Now the μ command line argument specifies the initial chemical potential we begin the simulation with. For instance, a simulation can be run with the command\n\nmpiexecjl -n 16 julia hubbard_square_density_tuning.jl 1 5.0 -0.25 0.8 0.0 4 4.0 2000 2000 40 5 1.0\n\nor\n\nsrun julia hubbard_square_density_tuning.jl 1 5.0 -0.25 0.8 0.0 4 4.0 2000 2000 40 5 1.0\n\nwhere the target density is langle n rangle = 08 and the initial chemical potential is mu = 00.\n\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation, reading in command line arguments.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        U = parse(Float64, ARGS[2]), # Hubbard interaction.\n        t′ = parse(Float64, ARGS[3]), # Next-nearest-neighbor hopping amplitude.\n        n = parse(Float64, ARGS[4]), # Target density.\n        μ = parse(Float64, ARGS[5]), # Initial chemical potential.\n        L = parse(Int, ARGS[6]), # System size.\n        β = parse(Float64, ARGS[7]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[8]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[9]), # Number of measurements to make.\n        N_bins = parse(Int, ARGS[10]), # Number of times bin-averaged measurements are written to file.\n        N_updates = parse(Int, ARGS[11]), # Number of updates between measurements.\n        checkpoint_freq = parse(Float64, ARGS[12]) # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"section"},{"location":"tutorials/hubbard_square_mpi/#1b)-Square-Hubbard-Model-with-MPI-Parallelization","page":"1b) Square Hubbard Model with MPI Parallelization","title":"1b) Square Hubbard Model with MPI Parallelization","text":"Download this example as a Julia script.\n\nThis tutorial will build on the previous 1a) Square Hubbard Model tutorial, demonstrating how to add parallelization with MPI using the MPI.jl package. By this we mean that each MPI process will act as independent walker, running it's own independent DQMC simulation, with the final reported estimates for measured quantities being the average across all walkers.\n\nThe exposition in this tutorial will focus on the changes that need to be made to the 1a) Square Hubbard Model tutorial to introduce MPI parallelization, omitting a more comprehensive discussion of other parts of the code that were included in the previous tutorial.","category":"section"},{"location":"tutorials/hubbard_square_mpi/#Import-Packages","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Import Packages","text":"We now need to import the MPI.jl package as well.\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf\nusing MPI","category":"section"},{"location":"tutorials/hubbard_square_mpi/#Specify-simulation-parameters","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Specify simulation parameters","text":"Here we have introduced the comm argument to the run_simulation function, which is a type exported by the MPI.jl package to facilitate communication and synchronization between the different MPI processes.\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    U, # Hubbard interaction.\n    t′, # Next-nearest-neighbor hopping amplitude.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements made during simulation.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    N_updates, # Number of updates between measurements.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"section"},{"location":"tutorials/hubbard_square_mpi/#Initialize-simulation","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Initialize simulation","text":"Now when initializing the SimulationInfo type, we also need to include the MPI process ID pID, which can be retrieved using the MPI.Comm_rank function.\n\nWe also the initialize_datafolder function such that it takes the comm as the first argument. This ensures that all the MPI processes remained synchronized, and none try proceeding beyond this point until the data folder has been initialized.\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_square_U%.2f_tp%.2f_mu%.2f_L%d_b%.2f\" U t′ μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 10),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)","category":"section"},{"location":"tutorials/hubbard_square_mpi/#Initialize-simulation-metadata","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Initialize simulation metadata","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.\n\n    # Initialize random number generator\n    rng = Xoshiro(seed)\n\n    # Initialize metadata dictionary\n    metadata = Dict()\n\n    # Record simulation parameters.\n    metadata[\"N_therm\"] = N_therm\n    metadata[\"N_measurements\"] = N_measurements\n    metadata[\"N_updates\"] = N_updates\n    metadata[\"N_bins\"] = N_bins\n    metadata[\"n_stab_init\"] = n_stab\n    metadata[\"dG_max\"] = δG_max\n    metadata[\"symmetric\"] = symmetric\n    metadata[\"checkerboard\"] = checkerboard\n    metadata[\"seed\"] = seed\n    metadata[\"local_acceptance_rate\"] = 0.0\n    metadata[\"reflection_acceptance_rate\"] = 0.0","category":"section"},{"location":"tutorials/hubbard_square_mpi/#Initialize-model","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Initialize model","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.\n\n    # Define unit cell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[1.0, 0.0],\n                        [0.0, 1.0]],\n        basis_vecs = [[0.0, 0.0]]\n    )\n\n    # Define finite lattice with periodic boundary conditions.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize model geometry.\n    model_geometry = ModelGeometry(\n        unit_cell, lattice\n    )\n\n    # Define the nearest-neighbor bond in +x direction.\n    bond_px = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, 0]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_px_id = add_bond!(model_geometry, bond_px)\n\n    # Define the nearest-neighbor bond in +y direction.\n    bond_py = lu.Bond(\n        orbitals = (1,1),\n        displacement = [0, 1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_py_id = add_bond!(model_geometry, bond_py)\n\n    # Define the next-nearest-neighbor bond in +x+y direction.\n    bond_pxpy = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, 1]\n    )\n\n    # Define the nearest-neighbor bond in -x direction.\n    # Will be used to make measurements later in this tutorial.\n    bond_nx = lu.Bond(\n        orbitals = (1,1),\n        displacement = [-1, 0]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n    # Define the nearest-neighbor bond in -y direction.\n    # Will be used to make measurements later in this tutorial.\n    bond_ny = lu.Bond(\n        orbitals = (1,1),\n        displacement = [0, -1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n    # Define the next-nearest-neighbor bond in +x+y direction.\n    bond_pxpy = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, 1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_pxpy_id = add_bond!(model_geometry, bond_pxpy)\n\n    # Define the next-nearest-neighbor bond in +x-y direction.\n    bond_pxny = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, -1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_pxny_id = add_bond!(model_geometry, bond_pxny)\n\n    # Set nearest-neighbor hopping amplitude to unity,\n    # setting the energy scale in the model.\n    t = 1.0\n\n    # Define the non-interacting tight-binding model.\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_px, bond_py, bond_pxpy, bond_pxny], # defines hopping\n        t_mean = [t, t, t′, t′], # defines corresponding mean hopping amplitude\n        t_std = [0., 0., 0., 0.], # defines corresponding standard deviation in hopping amplitude\n        ϵ_mean = [0.], # set mean on-site energy for each orbital in unit cell\n        ϵ_std = [0.], # set standard deviation of on-site energy or each orbital in unit cell\n        μ = μ # set chemical potential\n    )\n\n    # Define the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        ph_sym_form = true, # if particle-hole symmetric form for Hubbard interaction is used.\n        U_orbital = [1], # orbitals in unit cell with Hubbard interaction.\n        U_mean = [U], # mean Hubbard interaction strength for corresponding orbital species in unit cell.\n        U_std = [0.], # standard deviation of Hubbard interaction strength for corresponding orbital species in unit cell.\n    )\n\n    # Write model summary TOML file specifying Hamiltonian that will be simulated.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )","category":"section"},{"location":"tutorials/hubbard_square_mpi/#Initialize-model-parameters","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Initialize model parameters","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Hubbard-Stratonovich (HS) transformation to decouple the Hubbard interaction,\n    # and initialize the corresponding HS fields that will be sampled in the DQMC simulation.\n    hst_parameters = HubbardSpinHirschHST(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )","category":"section"},{"location":"tutorials/hubbard_square_mpi/#Initialize-measurements","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Initialize measurements","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the d-wave pair susceptibility measurement.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"d-wave\",\n        correlation = \"pair\",\n        ids = [bond_px_id, bond_nx_id, bond_py_id, bond_ny_id],\n        coefficients = [0.5, 0.5, -0.5, -0.5],\n        time_displaced = false,\n        integrated = true\n    )","category":"section"},{"location":"tutorials/hubbard_square_mpi/#Setup-DQMC-simulation","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Setup DQMC simulation","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.\n\n    # Allocate FermionPathIntegral type for spin-up electrons.\n    fermion_path_integral_up = FermionPathIntegral(\n        tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ,\n        forced_complex_potential = (U < 0),\n        forced_complex_kinetic = false\n    )\n\n    # Allocate FermionPathIntegral type for spin-down electrons.\n    fermion_path_integral_dn = FermionPathIntegral(\n        tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ,\n        forced_complex_potential = (U < 0),\n        forced_complex_kinetic = false\n    )\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for Hubbard interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for the current\n    # Hubbard-Stratonovich field configuration.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hst_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices for spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type for spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Initialize alternate FermionGreensCalculator type for performing reflection updates.\n    fermion_greens_calculator_up_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_up)\n    fermion_greens_calculator_dn_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_dn)\n\n    # Allocate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # Gup(τ,τ)\n    Gup_τ0 = similar(Gup) # Gup(τ,0)\n    Gup_0τ = similar(Gup) # Gup(0,τ)\n    Gdn_ττ = similar(Gdn) # Gdn(τ,τ)\n    Gdn_τ0 = similar(Gdn) # Gdn(τ,0)\n    Gdn_0τ = similar(Gdn) # Gdn(0,τ)\n\n    # Initialize diagnostic parameters to asses numerical stability.\n    δG = zero(logdetGup)\n    δθ = zero(logdetGup)","category":"section"},{"location":"tutorials/hubbard_square_mpi/#Thermalize-system","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Thermalize system","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.\n\n    # Iterate over number of thermalization updates to perform.\n    for n in 1:N_therm\n\n        # Perform reflection update for HS fields with randomly chosen site.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hst_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, rng = rng\n        )\n\n        # Record whether reflection update was accepted or not.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hst_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n            update_stabilization_frequency = true\n        )\n\n        # Record acceptance rate for sweep.\n        metadata[\"local_acceptance_rate\"] += acceptance_rate\n    end","category":"section"},{"location":"tutorials/hubbard_square_mpi/#Make-measurements","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Make measurements","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.\n\n    # Reset diagnostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetGup)\n    δθ = zero(logdetGup)\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over measurements.\n    for measurement in 1:N_measurements\n\n        # Iterate over number of updates between measurements.\n        for update in 1:N_updates\n\n            # Perform reflection update for HS fields with randomly chosen site.\n            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hst_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n                Bup = Bup, Bdn = Bdn, rng = rng\n            )\n\n            # Record whether reflection update was accepted or not.\n            metadata[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hst_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n                update_stabilization_frequency = true\n            )\n\n            # Record acceptance rate.\n            metadata[\"local_acceptance_rate\"] += acceptance_rate\n        end\n\n        # Make measurements.\n        (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n            logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (hubbard_parameters, hst_parameters)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end","category":"section"},{"location":"tutorials/hubbard_square_mpi/#Merge-binned-data","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Merge binned data","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)","category":"section"},{"location":"tutorials/hubbard_square_mpi/#Record-simulation-metadata","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Record simulation metadata","text":"No changes need to made to this section of the code from the previous 1a) Square Hubbard Model tutorial.\n\n    # Normalize acceptance rate.\n    metadata[\"local_acceptance_rate\"] /= (N_therm + N_measurements * N_updates)\n    metadata[\"reflection_acceptance_rate\"] /= (N_therm + N_measurements * N_updates)\n\n    # Record final stabilization frequency used at end of simulation.\n    metadata[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record largest numerical error.\n    metadata[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)","category":"section"},{"location":"tutorials/hubbard_square_mpi/#Post-process-results","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Post-process results","text":"The main change we need to make from the previous 1a) Square Hubbard Model tutorial is to call the process_measurements and compute_correlation_ratio functions such that the first argument is the comm object, thereby ensuring a parallelized version of each method is called.\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm;\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\n    # Calculate AFM correlation ratio.\n    Rafm, ΔRafm = compute_correlation_ratio(\n        comm;\n        datafolder = simulation_info.datafolder,\n        correlation = \"spin_z\",\n        type = \"equal-time\",\n        id_pairs = [(1, 1)],\n        id_pair_coefficients = [1.0],\n        q_point = (L÷2, L÷2),\n        q_neighbors = [\n            (L÷2+1, L÷2), (L÷2-1, L÷2),\n            (L÷2, L÷2+1), (L÷2, L÷2-1)\n        ]\n    )\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rafm_mean_real\"] = real(Rafm)\n    metadata[\"Rafm_mean_imag\"] = imag(Rafm)\n    metadata[\"Rafm_std\"] = ΔRafm\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    return nothing\nend # end of run_simulation function","category":"section"},{"location":"tutorials/hubbard_square_mpi/#Execute-script","page":"1b) Square Hubbard Model with MPI Parallelization","title":"Execute script","text":"Here we first need to initialize MPI using the MPI.Init command. Then, we need to make sure to pass the comm = MPI.COMM_WORLD to the run_simulation function. At the very end of simulation it is good practice to run the MPI.Finalize() function even though it is typically not strictly required.\n\nOnly execute if the script is run directly from the command line.\n\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation, reading in command line arguments.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        U = parse(Float64, ARGS[2]), # Hubbard interaction.\n        t′ = parse(Float64, ARGS[3]), # Next-nearest-neighbor hopping amplitude.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins = parse(Int, ARGS[9]),  # Number of times bin-averaged measurements are written to file.\n        N_updates = parse(Int, ARGS[10]) # Number of updates between measurements.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend\n\nHere is an example of what the command to run this script might look like:\n\nmpiexecjl -n 16 julia hubbard_square_mpi.jl 1 5.0 -0.25 -2.0 4 4.0 2000 2000 40 5\n\nThis will 16 MPI processes, each running and independent simulation using a different random seed the final results arrived at by averaging over all 16 walkers. Here mpiexecjl is the MPI executable that can be easily install using the directions found here in the MPI.jl documentation. However, you can substitute a different MPI executable here if one is already configured on your system.\n\nAlso, when submitting jobs via SLURM on a High-Performance Computing (HPC) cluster, if a default MPI executable is already configured on the system, as is frequently the case, then the script can likely be run inside the *.sh job file using the srun command:\n\nsrun julia hubbard_square_mpi.jl 1 5.0 -0.25 -2.0 4 4.0 2000 2000 40 5\n\nThe srun command should automatically detect the number of available cores requested by the job and run the script using the MPI executable with the appropriate number of processes.","category":"section"},{"location":"tutorials/hubbard_square/#1a)-Square-Hubbard-Model","page":"1a) Square Hubbard Model","title":"1a) Square Hubbard Model","text":"Download this example as a Julia script.\n\nIn this example we will work through simulating the repulsive Hubbard model on a square lattice. The Hubbard Hamiltonian for a square lattice given by\n\nbeginalign\nhatH = \n-t sum_langle i j rangle sigma (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n-t^prime sum_langlelangle i j ranglerangle sigma (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc) \n + U sum_i (hatn_uparrowi-tfrac12)(hatn_downarrowi-tfrac12)\n- mu sum_isigma hatn_sigmai\nendalign\n\nwhere hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. In the above Hamiltonian (t^prime)  t is the (next-) nearest-neighbor hopping amplitude and U  0 controls the strength of the on-site Hubbard repulsion. Lastly, we note the system is half-filled and particle-hole symmetric when the next-nearest-neighbor hopping amplitude and the chemical potential is zero (t^prime = mu = 00) in which case there is no sign problem.","category":"section"},{"location":"tutorials/hubbard_square/#hubbard_square_import_packages","page":"1a) Square Hubbard Model","title":"Import packages","text":"Let us begin by importing SmoQyDQMC.jl, and its relevant submodules.\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nThe SmoQyDQMC package re-exports several other packages that we will make use of in this tutorial. The first one is LatticeUtilities, which we will use to define the lattice geometry for our model. The second submodule is the JDQMCFramework package, which exports useful types and methods for writing a determinant quantum Monte Carlo (DQMC) code, taking care of things like numerical stabilization. We will see how to leverage both these packages in this tutorial.\n\nWe will also  use the Standard Library packages Random and Printf for random number generation and C-style string formatting, respectively.\n\nusing Random\nusing Printf","category":"section"},{"location":"tutorials/hubbard_square/#Specify-simulation-parameters","page":"1a) Square Hubbard Model","title":"Specify simulation parameters","text":"The entire main body of the simulation we will wrapped in a top-level function named run_simulation that will take as keyword arguments various model and simulation parameters that we may want to change. The function arguments with default values are ones that are typically left unchanged between simulations. The specific meaning of each argument will be discussed in more detail in later sections of the tutorial.\n\n# Top-level function to run simulation.\nfunction run_simulation(;\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    U, # Hubbard interaction.\n    t′, # Next-nearest-neighbor hopping amplitude.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements.\n    N_bins, # Number of measurement bins.\n    N_updates, # Number of updates per measurement.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"section"},{"location":"tutorials/hubbard_square/#hubbard_square_initialize_simulation","page":"1a) Square Hubbard Model","title":"Initialize simulation","text":"In this first part of the script we name and initialize our simulation, creating the data folder our simulation results will be written to. This is done by initializing an instances of the SimulationInfo type, and then calling the initialize_datafolder function.\n\nNote that the write_bins_concurrent keyword arguments controls whether or not binned simulation measurement data is written to HDF5 file during the simulation, or held in memory and only written to file once the simulation is complete. Here we decide how to set write_bins_concurrent based on the system size being simulated. This is because when performing simulations of small systems that do not take very long, writing data to file too frequently can sometimes cause network latency problems on clusters and HPC systems. However, for larger systems that take longer to simulate, you are not limited by file IO frequency but rather by available memory, so writing data to file more frequently is preferred in these cases.\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_square_U%.2f_tp%.2f_mu%.2f_L%d_b%.2f\" U t′ μ L β\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 10),\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)","category":"section"},{"location":"tutorials/hubbard_square/#Initialize-simulation-metadata","page":"1a) Square Hubbard Model","title":"Initialize simulation metadata","text":"In this section of the code we record important metadata about the simulation, including initializing the random number generator that will be used throughout the simulation. The important metadata within the simulation will be recorded in the metadata dictionary.\n\n    # Initialize random number generator\n    rng = Xoshiro(seed)\n\n    # Initialize metadata dictionary\n    metadata = Dict()\n\n    # Record simulation parameters.\n    metadata[\"N_therm\"] = N_therm\n    metadata[\"N_measurements\"] = N_measurements\n    metadata[\"N_updates\"] = N_updates\n    metadata[\"N_bins\"] = N_bins\n    metadata[\"n_stab_init\"] = n_stab\n    metadata[\"dG_max\"] = δG_max\n    metadata[\"symmetric\"] = symmetric\n    metadata[\"checkerboard\"] = checkerboard\n    metadata[\"seed\"] = seed\n    metadata[\"local_acceptance_rate\"] = 0.0\n    metadata[\"reflection_acceptance_rate\"] = 0.0\n\nIn the above, sID stands for simulation ID, which is used to distinguish simulations that would otherwise be identical i.e. to distinguish simulations that use the same parameters and are only different in the random seed used to initialize the simulation. A valid sID is any positive integer greater than zero, and is used when naming the data folder the simulation results will be written to. Specifically, the actual data folder created above will be \"$(filepath)/$(datafolder_prefix)-$(sID)\". Note that if you set sID = 0, then it will instead be assigned smallest previously unused integer value. For instance, suppose the directory \"$(filepath)/$(datafolder_prefix)-1\" already exits. Then if you pass sID = 0 to SimulationInfo, then the simulation ID sID = 2 will be used instead, and a directory \"$(filepath)/$(datafolder_prefix)-2\" will be created.\n\nAnother useful resource in the documentation is the Simulation Output Overview page, which describes the output written to the data folder generated during a SmoQyDQMC simulation.","category":"section"},{"location":"tutorials/hubbard_square/#Initialize-model","page":"1a) Square Hubbard Model","title":"Initialize model","text":"The next step is define the model we wish to simulate. In this example the relevant model parameters are the Hubbard interaction strength U (U), chemical potential mu (μ), next-nearest-neighbor hopping amplitude t^prime (t′) and lattice size L (L).\n\nFirst we define the lattice geometry for our model, relying on the LatticeUtilities package to do so. We define a the unit cell and size of our finite lattice using the UnitCell and Lattice types, respectively. Lastly, we define various instances of the Bond type to represent the the nearest-neighbor and next-nearest-neighbor bonds. All of this information regarding the lattice geometry is then stored in an instance of the ModelGeometry type. Further documentation, with usage examples, for LatticeUtilities package can be found here.\n\n    # Define unit cell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[1.0, 0.0],\n                        [0.0, 1.0]],\n        basis_vecs = [[0.0, 0.0]]\n    )\n\n    # Define finite lattice with periodic boundary conditions.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize model geometry.\n    model_geometry = ModelGeometry(\n        unit_cell, lattice\n    )\n\n    # Define the nearest-neighbor bond in +x direction.\n    bond_px = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, 0]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_px_id = add_bond!(model_geometry, bond_px)\n\n    # Define the nearest-neighbor bond in +y direction.\n    bond_py = lu.Bond(\n        orbitals = (1,1),\n        displacement = [0, 1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_py_id = add_bond!(model_geometry, bond_py)\n\n    # Define the next-nearest-neighbor bond in +x+y direction.\n    bond_pxpy = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, 1]\n    )\n\n    # Define the nearest-neighbor bond in -x direction.\n    # Will be used to make measurements later in this tutorial.\n    bond_nx = lu.Bond(\n        orbitals = (1,1),\n        displacement = [-1, 0]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n    # Define the nearest-neighbor bond in -y direction.\n    # Will be used to make measurements later in this tutorial.\n    bond_ny = lu.Bond(\n        orbitals = (1,1),\n        displacement = [0, -1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n    # Define the next-nearest-neighbor bond in +x+y direction.\n    bond_pxpy = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, 1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_pxpy_id = add_bond!(model_geometry, bond_pxpy)\n\n    # Define the next-nearest-neighbor bond in +x-y direction.\n    bond_pxny = lu.Bond(\n        orbitals = (1,1),\n        displacement = [1, -1]\n    )\n\n    # Add this bond definition to the model, by adding it the model_geometry.\n    bond_pxny_id = add_bond!(model_geometry, bond_pxny)\n\nNext we specify the non-interacting tight-binding term in our Hamiltonian with the TightBindingModel type.\n\n    # Set nearest-neighbor hopping amplitude to unity,\n    # setting the energy scale in the model.\n    t = 1.0\n\n    # Define the non-interacting tight-binding model.\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_px, bond_py, bond_pxpy, bond_pxny], # defines hopping\n        t_mean = [t, t, t′, t′], # defines corresponding mean hopping amplitude\n        t_std = [0., 0., 0., 0.], # defines corresponding standard deviation in hopping amplitude\n        ϵ_mean = [0.], # set mean on-site energy for each orbital in unit cell\n        ϵ_std = [0.], # set standard deviation of on-site energy or each orbital in unit cell\n        μ  = μ # set chemical potential\n    )\n\nFinally, we define the Hubbard interaction with the HubbardModel type. Here the boolean ph_sym_form keyword argument determines whether the particle-hole symmetric form (ph_sym_form = true) for the Hubbard interaction U(hatn_uparrowi-tfrac12)(hatn_downarrowi-tfrac12) is used, or the form Uhatn_uparrowihatn_downarrowi is used (ph_sym_form = false) instead.\n\n    # Define the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        ph_sym_form = true, # if particle-hole symmetric form for Hubbard interaction is used.\n        U_orbital = [1], # orbitals in unit cell with Hubbard interaction.\n        U_mean = [U], # mean Hubbard interaction strength for corresponding orbital species in unit cell.\n        U_std = [0.], # standard deviation of Hubbard interaction strength for corresponding orbital species in unit cell.\n    )\n\nNote that most terms in our model can support random disorder. However, we have suppressed this behavior by setting all relevant standard deviations in model values to zero. If these standard deviations were not specified they would have also defaulted to zero We explicitly set them to zero here to simply highlight the presence of this functionality even though we are not using it.\n\nLastly, the model_summary function is used to write a model_summary.toml file, completely specifying the Hamiltonian that will be simulated.\n\n    # Write model summary TOML file specifying Hamiltonian that will be simulated.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )","category":"section"},{"location":"tutorials/hubbard_square/#Initialize-model-parameters","page":"1a) Square Hubbard Model","title":"Initialize model parameters","text":"The next step is to initialize our model parameters given the size of our finite lattice. To clarify, both the TightBindingModel and HubbardModel types are agnostic to the size of the lattice being simulated, defining the model in a translationally invariant way. As SmoQyDQMC.jl supports random disorder in the terms appearing in the Hamiltonian, it is necessary to initialize separate parameter values for each unit cell in the lattice. For instance, we need to initialize a separate number to represent the on-site energy for each orbital in our finite lattice. To do so we need to initialize an instance of the TightBindingParameters and HubbardParameters types.\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\nHaving initialized the Hubbard Hamiltonian parameters above, we now need to decouple the interaction by applying a Hubbard-Stratonovich (HS) transformation to decouple the local Hubbard interaction, thereby introducing the HS fields that will be sampled during the simulation. The SmoQyDQMC.jl package implements four types of Hubbard-Stratonovich transformations for decoupling the local Hubbard interaction, represented by the four types HubbardDensityHirschHST, HubbardDensityGaussHermiteHST, HubbardSpinHirschHST and [HubbardSpinGaussHermiteHST]. In this example we will use the HubbardSpinHirschHST type to decouple the local Hubbard interactions.\n\n    # Apply Spin Hirsch Hubbard-Stratonovich (HS) transformation to decouple the Hubbard interaction,\n    # and initialize the corresponding HS fields that will be sampled in the DQMC simulation.\n    hst_parameters = HubbardSpinHirschHST(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )","category":"section"},{"location":"tutorials/hubbard_square/#hubbard_square_initialize_measurements","page":"1a) Square Hubbard Model","title":"Initialize measurement","text":"Having initialized both our model and the corresponding model parameters, the next step is to initialize the various measurements we want to make during our DQMC simulation. This includes defining the various types of correlation measurements that will be made, which is primarily done using the initialize_correlation_measurements! function.\n\nHere the arguments β and Δτ correspond to the inverse temperature and imaginary-time axis discretization constant, which were passed as arguments to the run_simulation function.\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\nWe also want to define define what we term a composite correlation measurement to measure d-wave pairing tendencies in our Hubbard model. Specifically, we would like to measure the d-wave pair susceptibility\n\nchi_d(mathbfq) = frac1L^2 int_0^beta dtau sum_mathbfr mathbfi e^-textimathbfqcdotmathbfr\nlangle hatDelta^phantomdagger_dmathbfi+mathbfr(tau) hatDelta^dagger_dmathbfi(0) rangle\n\nfor all scattering momentum mathbfq, where\n\nhatDelta^dagger_dmathbfi(tau) = frac12left\n(\n   hatc^dagger_uparrowmathbfi+mathbfx + hatc^dagger_uparrowmathbfi-mathbfx\n - hatc^dagger_uparrowmathbfi+mathbfy - hatc^dagger_uparrowmathbfi-mathbfy\n)\nhatc^dagger_downarrowmathbfi\nright\n\nis the d-wave pair creation operator. We do this using the initialize_composite_correlation_measurement! function.\n\n    # Initialize the d-wave pair susceptibility measurement.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"d-wave\",\n        correlation = \"pair\",\n        ids = [bond_px_id, bond_nx_id, bond_py_id, bond_ny_id],\n        coefficients = [0.5, 0.5, -0.5, -0.5],\n        time_displaced = false,\n        integrated = true\n    )","category":"section"},{"location":"tutorials/hubbard_square/#hubbard_square_setup_dqmc","page":"1a) Square Hubbard Model","title":"Setup DQMC simulation","text":"This section of the code sets up the DQMC simulation by allocating the initializing the relevant types and arrays we will need in the simulation.\n\nThis portion of code is perhaps the most opaque and difficult to understand, and quite a bit of exposition is included describing it. That said, you do not need to fully comprehend everything that goes on in this section as most of it is fairly boilerplate, and will not need to be changed much once written. This is true even if you want to modify this script to perform a DQMC simulation for a different Hamiltonian.\n\nTo start, two instances of the FermionPathIntegral type are allocated, one for each electron spin species. Recall that after performing a HS transformation to decouple the Hubbard interaction, the resulting Hamiltonian is quadratic in fermion creation and annihilation operators, but fluctuates in imaginary-time as a result of introducing the HS fields. Therefore, this Hamiltonian may be expressed as\n\nhatH_l = sum_sigma hatmathbfc_sigma^dagger left H_sigmal right hatmathbfc_sigma\n= sum_sigma hatmathbfc_sigma^dagger left K_sigmal + V_sigmal right hatmathbfc_sigma\n\nat imaginary-time tau = Deltatau cdot l. where hatmathbfc_sigma  (hatmathbfc_sigma^dagger) is a column (row) vector of spin-sigma electron annihilation (creation) operators for each orbital in the lattice. Here H_sigmal is the spin-sigma Hamiltonian matrix for imaginary-time tau, which can be expressed as the sum of the electron kinetic and potential energy matrices K_sigmal and V_sigmal, respectively. The purpose of the FermionPathIntegral type is to contain the minimal information required to reconstruct each K_sigmal and V_sigmal matrix. Each instance of the FermionPathIntegral type is first allocated and initialized to just reflect the non-interacting component of the Hamiltonian. Then the two subsequent initialize! calls modify the FermionPathIntegral type to reflect the contributions from the Hubbard interaction and initial HS field configuration.\n\nNote that if the keyword arguments forced_complex_potential and forced_complex_kinetic are set to true then the V_sigmal and K_sigmal matrices are forced to be complex matrices, respectively. If instead set to false then their type is inferred from the instance of tight_binding_parameters passed during initialization. This is important, as the Hubbard-Stratonovich transform represented by the HubbardSpinHirschHST type used in this example is real if U ge 0 and complex if U  0. Therefore, we need to set forced_complex_potential = (U < 0) to account for this fact if we want this example to work for both repulsive and attractive Hubbard interactions. The opposite would be true if we had instead used HubbardDensityHirschHST decoupling scheme instead.\n\n    # Allocate FermionPathIntegral type for spin-up electrons.\n    fermion_path_integral_up = FermionPathIntegral(\n        tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ,\n        forced_complex_potential = (U < 0),\n        forced_complex_kinetic = false\n    )\n\n    # Allocate FermionPathIntegral type for spin-down electrons.\n    fermion_path_integral_dn = FermionPathIntegral(\n        tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ,\n        forced_complex_potential = (U < 0),\n        forced_complex_kinetic = false\n    )\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for Hubbard interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for the current\n    # Hubbard-Stratonovich field configuration.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hst_parameters)\n\nNext, the initialize_propagators function allocates and initializes the B_sigmal propagator matrices to reflect the current state of the K_sigmal and V_sigmal matrices as represented by the FermionPathIntegral type. If symmetric = true, then the propagator matrices take the form\n\nB_sigmal = left e^-Deltatau K_sigmal2 right^dagger cdot e^-Deltatau V_sigmal cdot e^-Deltatau K_sigmal2\n\nwhereas if symmetric = false then\n\nB_sigmal = e^-Deltatau V_sigmal cdot e^-Deltatau K_sigmal\n\nIf checkerboard = true, then the exponentiated kinetic energy matrices e^-Deltatau K_sigmal  left( text or  e^-Deltatau K_sigmal2 right) are represented using the sparse checkerboard approximation, otherwise they are computed exactly.\n\n    # Initialize imaginary-time propagators for all imaginary-time slices for spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\nNext, four instances of the FermionGreensCalculator type are initialized, which are used to take care of numerical stabilization behind the scenes in the DQMC simulation. Here n_stab is the period in imaginary-time with which numerical stabilization is performed, and is typically on the order of n_rm stab sim 10\n\n    # Initialize FermionGreensCalculator type for spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Initialize alternate FermionGreensCalculator type for performing reflection updates.\n    fermion_greens_calculator_up_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_up)\n    fermion_greens_calculator_dn_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_dn)\n\nNow we allocate and initialize the equal-time Green's function matrix G_sigma(00) for both spin species (Gup and Gdn). The initialization process also returns log  det G_sigma(00)  (logdetGup and logdetGdn) and rm sgn det G_sigma(00) (sgndetGup and sgndetGdn).\n\n    # Allocate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\nWe also need to allocate matrices to represent the equal-time and time-displaced Green's function matrices G_sigma(tautau) (Gup_ττ and Gdn_ττ), G_sigma(tau 0) (Gup_τ0 and Gdn_τ0), and G_sigma(0tau) (Gup_0τ and Gdn_0τ) for tau ne 0. All of these various Green's function matrices are required if we want to make time-displaced correlation function measurements.\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # Gup(τ,τ)\n    Gup_τ0 = similar(Gup) # Gup(τ,0)\n    Gup_0τ = similar(Gup) # Gup(0,τ)\n    Gdn_ττ = similar(Gdn) # Gdn(τ,τ)\n    Gdn_τ0 = similar(Gdn) # Gdn(τ,0)\n    Gdn_0τ = similar(Gdn) # Gdn(0,τ)\n\nLastly, we initialize two diagnostic parameters δG and δθ to asses numerical stability during the simulation. The δG  parameter is particularly important to keep track of during the simulation, and is defined as\n\ndelta G = max left(  G^rm stab_sigma(00) - G^rm naive_sigma(00)  right)\n\ni.e. the maximum magnitude numerical error corrected by numerical stabilization for any Green's function matrix element. The delta theta diagnostic parameter reports the error in the phase of the fermion determinant as it can in general be complex, but this is less important to keep track of in most situations.\n\n    # Initialize diagnostic parameters to asses numerical stability.\n    δG = zero(logdetGup)\n    δθ = zero(logdetGup)","category":"section"},{"location":"tutorials/hubbard_square/#Thermalize-system","page":"1a) Square Hubbard Model","title":"Thermalize system","text":"The next section of code performs updates to thermalize the system prior to beginning measurements. The structure of this function should be fairly intuitive, mainly consisting of a loop inside of which we perform updates to the Hubbard-Stratonovich fields. In this example we perform two types of updates.\n\nWe use the local_updates! function to attempt a local update to every HS field. Additionally, if the local_updates! argument update_stabilization_frequency = true, then the δG_max parameter acts a maximum threshold for δG. If δG exceeds δG_max, then n_stab is decrement by one (the frequency of numerical stabilization is increased) and δG is reset to zero. In the case update_stabilization_frequency = false, then δG_max doesn't do anything and n_stab remains unchanged during the simulation, with δG is simply reporting the maximum observed numerical error during the simulation.\n\nWe also use the reflection_update! function to perform a reflection update on a randomly selected sites in the lattice whereby we flip the HS fields on every imaginary-time slice for that site i.e. propose an update such that s_il rightarrow -s_il for all l in 1 L_tau. This type of reflection update has been shown to be important for mitigating ergodicity issues in large Hubbard U simulations.\n\nIn the block of code below, N_therm is the number of local sweeps and reflection updates performed to thermalize the system.\n\n    # Iterate over number of thermalization updates to perform.\n    for n in 1:N_therm\n\n        # Perform reflection update for HS fields with randomly chosen site.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hst_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, rng = rng\n        )\n\n        # Record whether reflection update was accepted or not.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hst_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n            update_stabilization_frequency = false\n        )\n\n        # Record acceptance rate for sweep.\n        metadata[\"local_acceptance_rate\"] += acceptance_rate\n    end","category":"section"},{"location":"tutorials/hubbard_square/#hubbard_square_make_measurements","page":"1a) Square Hubbard Model","title":"Make measurements","text":"In this next section of code we continue to sample the HS fields, but we also begin making measurements as well. Here, N_measurements refers to the number of times measurements are made using the make_measurements! function, and N_updates refers to the number of times local_updates! and reflection_update! are called between measurements being made. The parameter N_bins then controls the number of times bin-averaged measurements are stored in an HDF5 that is either stored in memory or written to file, subject to the constraint that (N_measurements % N_bins) == 0. Therefore, the number of measurements that are averaged over per bin is given by bin_size = N_measurements ÷ N_bins. The bin-averaged measurements are written to file once bin_size measurements are accumulated using the write_measurements! function.\n\n    # Reset diagnostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetGup)\n    δθ = zero(logdetGup)\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over measurements.\n    for measurement in 1:N_measurements\n\n        # Iterate over updates between measurements.\n        for update in 1:N_updates\n\n            # Perform reflection update for HS fields with randomly chosen site.\n            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hst_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n                Bup = Bup, Bdn = Bdn, rng = rng\n            )\n\n            # Record whether reflection update was accepted or not.\n            metadata[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform sweep all imaginary-time slice and orbitals, attempting an update to every HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hst_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n                update_stabilization_frequency = false\n            )\n\n            # Record acceptance rate.\n            metadata[\"local_acceptance_rate\"] += acceptance_rate\n        end\n\n        # Make measurements.\n        (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n            logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (hubbard_parameters, hst_parameters)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end","category":"section"},{"location":"tutorials/hubbard_square/#Merge-binned-data","page":"1a) Square Hubbard Model","title":"Merge binned data","text":"At this point the simulation is essentially complete, with all updates and measurements having been performed. However, the binned measurement data resides in many separate HDF5 files currently. Here we will merge these separate HDF5 files into a single file containing all the binned data using the merge_bins function.\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)","category":"section"},{"location":"tutorials/hubbard_square/#Record-simulation-metadata","page":"1a) Square Hubbard Model","title":"Record simulation metadata","text":"At this point we are done sampling and taking measurements. Next, we want to calculate the final acceptance rate for the Monte Carlo updates, as well as write the simulation metadata to file, including the contents of the metadata dictionary. This is done using the save_simulation_info function.\n\n    # Normalize acceptance rate.\n    metadata[\"local_acceptance_rate\"] /=  (N_therm + N_measurements * N_updates)\n    metadata[\"reflection_acceptance_rate\"] /= (N_therm + N_measurements * N_updates)\n\n    # Record final stabilization period used at the end of the simulation.\n    metadata[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record largest numerical error.\n    metadata[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)","category":"section"},{"location":"tutorials/hubbard_square/#hubbard_square_process_results","page":"1a) Square Hubbard Model","title":"Post-process results","text":"In this final section of code we post-process the binned data. This includes calculating the final estimates for the mean and error of all measured observables, which will be written to an HDF5 file using the process_measurements function. Inside this function the binned data gets further re-binned into n_bins, where n_bins is any positive integer satisfying the constraints (N_bins ≥ n_bin) and (N_bins % n_bins == 0). Note that the process_measurements function has many additional keyword arguments that can be used to control the output. For instance, in this example in addition to writing the statistics to an HDF5 file, we also export the statistics to CSV files by setting export_to_csv = true, with additional keyword arguments controlling the formatting of the CSV files. Again, for more information on how to interpret the output refer the Simulation Output Overview page.\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\nA common measurement that needs to be computed at the end of a DQMC simulation is something called the correlation ratio with respect to the ordering wave-vector for a specified type of structure factor measured during the simulation. In the case of the square Hubbard model, we are interested in measuring the correlation ratio\n\nR_z(mathbfQ_textafm) = 1 - frac14 sum_deltamathbfq fracS_z(mathbfQ_textafm + deltamathbfq)S_z(mathbfQ_textafm)\n\nwith respect to the equal-time antiferromagnetic (AFM) structure factor S_z(mathbfQ_textafm), where S_z(mathbfq) is the spin-z equal-time structure factor and mathbfQ_textafm = (pia pia) is the AFM ordering wave-vector. The sum over deltamathbfq runs over the four wave-vectors that neighboring mathbfQ_textafm\n\nHere we use the compute_correlation_ratio function to compute to compute this correlation ratio. Note that the mathbfQ_textafm is specified using the q_point keyword argument, and the four neighboring wave-vectors mathbfQ_textafm + deltamathbfq are specified using the q_neighbors keyword argument. These wave-vectors are specified using the convention described here in the Simulation Output Overview page.\n\n    # Calculate AFM correlation ratio.\n    Rafm, ΔRafm = compute_correlation_ratio(\n        datafolder = simulation_info.datafolder,\n        correlation = \"spin_z\",\n        type = \"equal-time\",\n        id_pairs = [(1, 1)],\n        id_pair_coefficients = [1.0],\n        q_point = (L÷2, L÷2),\n        q_neighbors = [\n            (L÷2+1, L÷2), (L÷2-1, L÷2),\n            (L÷2, L÷2+1), (L÷2, L÷2-1)\n        ]\n    )\n\nNext, we record the measurement in the metadata dictionary, and then write a new version of the simulation summary TOML file that contains this new information using the save_simulation_info function.\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rafm_mean_real\"] = real(Rafm)\n    metadata[\"Rafm_mean_imag\"] = imag(Rafm)\n    metadata[\"Rafm_std\"] = ΔRafm\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\nNote that as long as the binned data persists the process_measurements and compute_correlation_ratio functions can be rerun to recompute the final statistics for the measurements without needing to rerun the simulation.\n\n    return nothing\nend # end of run_simulation function","category":"section"},{"location":"tutorials/hubbard_square/#Execute-script","page":"1a) Square Hubbard Model","title":"Execute script","text":"DQMC simulations are typically run from the command line as jobs on a computing cluster. With this in mind, the following block of code only executes if the Julia script is run from the command line, also reading in additional command line arguments.\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Run the simulation, reading in command line arguments.\n    run_simulation(;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        U = parse(Float64, ARGS[2]), # Hubbard interaction strength.\n        t′ = parse(Float64, ARGS[3]), # Next-nearest-neighbor hopping amplitude.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # Lattice size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization sweeps.\n        N_measurements = parse(Int, ARGS[8]), # Number of measurement to make.\n        N_bins = parse(Int, ARGS[9]), # Number of measurement bins.\n        N_updates = parse(Int, ARGS[10]) # Number of updates per measurement.\n    )\nend\n\nFor instance, the command\n\n> julia hubbard_square.jl 1 5.0 -0.25 -2.0 4 4.0 2000 2000 40 5\n\nruns a DQMC simulation of a N = 4 times 4 doped square Hubbard model at inverse temperature beta = 40 with interaction strength U = 50 chemical potential mu = -20 and next-nearest-neighbor hopping amplitude t^prime = -025. In the DQMC simulation, 2000 sweeps through the lattice are be performed to thermalize the system. Then 2000 measurements are made, each separated by 5 updates to the HS fields. Therefore, a total of 2000 times 5 = 10000 updates are performed during the measurement phase of the simulation. During the simulation, bin-averaged measurements are written to file or stored in memory 40 times, with each bin of data containing the average of 200040 = 50 sequential measurements.","category":"section"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Simulation-Information-Type-and-Methods","page":"API","title":"Simulation Information Type and Methods","text":"","category":"section"},{"location":"api/#Model-Geometry-Type-and-Methods","page":"API","title":"Model Geometry Type and Methods","text":"","category":"section"},{"location":"api/#Fermion-Path-Integral-Type-and-Methods","page":"API","title":"Fermion Path Integral Type and Methods","text":"","category":"section"},{"location":"api/#Update-Numerical-Stabilization-Frequency","page":"API","title":"Update Numerical Stabilization Frequency","text":"","category":"section"},{"location":"api/#Tight-Binding-Model","page":"API","title":"Tight-Binding Model","text":"","category":"section"},{"location":"api/#Hubbard-Model","page":"API","title":"Hubbard Model","text":"","category":"section"},{"location":"api/#Hubbard-Model-Measurements","page":"API","title":"Hubbard Model Measurements","text":"","category":"section"},{"location":"api/#Extended-Hubbard-Model","page":"API","title":"Extended Hubbard Model","text":"","category":"section"},{"location":"api/#Extended-Hubbard-Model-Measurements","page":"API","title":"Extended Hubbard Model Measurements","text":"","category":"section"},{"location":"api/#Hubbard-Stratonovich-Transformations","page":"API","title":"Hubbard-Stratonovich Transformations","text":"Below are the abstract types used to represent generic Hubbard-Stratonovich transformations.\n\nBelow is the shared API for the AbstractHST type.","category":"section"},{"location":"api/#Hubbard-Model-Hubbard-Stratonovich-Transformations","page":"API","title":"Hubbard Model Hubbard-Stratonovich Transformations","text":"","category":"section"},{"location":"api/#Extended-Hubbard-Model-Hubbard-Stratonovich-Transformations","page":"API","title":"Extended Hubbard Model Hubbard-Stratonovich Transformations","text":"","category":"section"},{"location":"api/#Electron-Phonon-Model","page":"API","title":"Electron-Phonon Model","text":"Electron-Phonon Model Types and Method\nElectron-Phonon Parameter Types and Methods\nElectron-Phonon Measurements\nElectron-Phonon Updates","category":"section"},{"location":"api/#Electron-Phonon-Model-Types-and-Method","page":"API","title":"Electron-Phonon Model Types and Method","text":"","category":"section"},{"location":"api/#Electron-Phonon-Parameter-Types-and-Methods","page":"API","title":"Electron-Phonon Parameter Types and Methods","text":"","category":"section"},{"location":"api/#Electron-Phonon-Measurements","page":"API","title":"Electron-Phonon Measurements","text":"","category":"section"},{"location":"api/#Electron-Phonon-Updates","page":"API","title":"Electron-Phonon Updates","text":"","category":"section"},{"location":"api/#Density-and-Chemical-Potential-Tuning","page":"API","title":"Density and Chemical Potential Tuning","text":"","category":"section"},{"location":"api/#Measurement-Methods","page":"API","title":"Measurement Methods","text":"Measurement Names\nInitialize Measurements\nMake Measurements\nWrite Measurements\nCheckpointing Utilities\nProcess Measurements\nExport Measurements","category":"section"},{"location":"api/#Measurement-Names","page":"API","title":"Measurement Names","text":"","category":"section"},{"location":"api/#Initialize-Measurements","page":"API","title":"Initialize Measurements","text":"","category":"section"},{"location":"api/#Make-Measurements","page":"API","title":"Make Measurements","text":"","category":"section"},{"location":"api/#Write-Measurements","page":"API","title":"Write Measurements","text":"","category":"section"},{"location":"api/#Checkpointing-Utilities","page":"API","title":"Checkpointing Utilities","text":"","category":"section"},{"location":"api/#Process-Measurements","page":"API","title":"Process Measurements","text":"","category":"section"},{"location":"api/#Export-Measurements","page":"API","title":"Export Measurements","text":"","category":"section"},{"location":"api/#SmoQyDQMC.SimulationInfo","page":"API","title":"SmoQyDQMC.SimulationInfo","text":"SimulationInfo\n\nContains identification information about simulation, including the location data is written to, the simulation ID, and MPI process ID, and whether this simulation started a new simulation or resumed a previous simulation.\n\nFields\n\nfilepath::String: File path to where data folder lives.\ndatafolder_prefix: Prefix for the data folder name.\ndatafolder_name::String: The data folder name, given by $(datafolder_prefix)_$(sID).\ndatafolder::String: The data folder, including filepath, given by joinpath(filepath, datafolder_name).\npID::Int: MPI process ID, defaults to 0 if MPI not being used.\nsID::Int: Simulation ID.\nwrite_bins_concurrent::Bool: Whether binned data will be written to HDF5 during the simulation or held in memory until the end of the simulation.\nbin_files::Vector{Vector{UInt8}}: Represents the HDF5 files containing the binned data.\nresuming::Bool: Whether current simulation is resuming a previous simulation (true) or starting a new one (false).\nsmoqy_version::VersionNumber: Version of SmoQyDQMC.jl used in simulation.\n\nNotes\n\nIf write_bins_concurrent = true, then the elements of bin_files correspond to the HDF5 bin filenames, assuming the vector elements are converted to strings. If write_bins_concurrent = false, then the elements of the bin_files correspond to a byte vector representation of a HDF5 file containing the binned data. For small simulations that run very fast setting write_bins_concurrent = false can make sense, as it significantly reduces the frequency of file IO during the simulation. This can cause issues on some clusters with respect to overtaxing the cluster network if data is being written to file too frequently during the simulation. However, for most larger simulations it is advisable to set write_bins_concurrent = true as this significantly reduces the memory footprint of the simulation, particularly when making time-displaced correlation measurements. Also, setting write_bins_concurrent = false dramatically increases the size of the checkpoint files if checkpointing is occurring during the simulation, as the checkpoint files now need to contain all the binned data collected during the simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SimulationInfo-Tuple{}","page":"API","title":"SmoQyDQMC.SimulationInfo","text":"SimulationInfo(;\n    # KEYWORD ARGUMENTS\n    datafolder_prefix::String,\n    filepath::String = \".\",\n    write_bins_concurrent::Bool = true,\n    sID::Int=0,\n    pID::Int=0\n)\n\nInitialize and return in instance of the type SimulationInfo.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize_datafolder","page":"API","title":"SmoQyDQMC.initialize_datafolder","text":"initialize_datafolder(comm::MPI.Comm, sim_info::SimulationInfo)\n\ninitialize_datafolder(sim_info::SimulationInfo)\n\nInitialize sim_info.datafolder directory if it does not already exist. If comm::MPI.Comm is passed as the first argument, this this function will synchronize all the MPI processes, ensuring that none proceed beyond this function call until the data folder that results will be written to is successfully initialized.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.model_summary","page":"API","title":"SmoQyDQMC.model_summary","text":"model_summary(;\n    simulation_info::SimulationInfo,\n    β::T, Δτ::T, model_geometry::ModelGeometry,\n    tight_binding_model::Union{TightBindingModel,Nothing} = nothing,\n    tight_binding_model_up::Union{TightBindingModel,Nothing} = nothing,\n    tight_binding_model_dn::Union{TightBindingModel,Nothing} = nothing,\n    interactions::Union{Tuple,Nothing} = nothing\n) where {T<:AbstractFloat}\n\nWrite model to summary to file. Note that either tight_binding_model or tight_binding_model_up and tight_binding_model_dn need to be specified.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.ModelGeometry","page":"API","title":"SmoQyDQMC.ModelGeometry","text":"ModelGeometry{D, T<:AbstractFloat, N}\n\nContains all the information defining the lattice geometry for the model in D spatial dimensions.\n\nComment\n\nThe bond ID associated with a bond::Bond{D} corresponds to the index associated with it into the bonds vector field.\n\nFields\n\nunit_cell::UnitCell{D,T,N}: Defines unit cell.\nlattice::Lattice{D}: Defines finite lattice extent.\nbonds::Vector{Bond{D}}: All available bond definitions in simulation, with vector indices giving the bond ID.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ModelGeometry-Union{Tuple{D}, Tuple{UnitCell{D}, Lattice{D}}} where D","page":"API","title":"SmoQyDQMC.ModelGeometry","text":"ModelGeometry(unit_cell::UnitCell, lattice::Lattice)\n\nInitialize and return a ModelGeometry instance. Defines a \"trivial\" bond definition for each orbital in the unit cell that connects an orbital to itself.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.add_bond!","page":"API","title":"SmoQyDQMC.add_bond!","text":"addbond!(modelgeometry::ModelGeometry{D,T}, bond::Bond{D}) where {D, T}   \n\nAdd bond definition to model_geometry, returning the bond ID i.e. the index to bond in the vector model_geometry.bonds. This method first checks that bond is not already defined. If it is this method simply returns the corresponding bond ID. If bond is not already defined, then it is appended to the vector model_geometry.bonds.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.get_bond_id","page":"API","title":"SmoQyDQMC.get_bond_id","text":"get_bond_id(model_geometry::ModelGeometry{D,T}, bond::Bond{D}) where {D, T}\n\nReturn the bond ID associated with the bond defintion bond, returning bond_id=0 if the it is not a recorded bond.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.FermionPathIntegral","page":"API","title":"SmoQyDQMC.FermionPathIntegral","text":"FermionPathIntegral{H<:Number, T<:Number, U<:Number, R<:AbstractFloat}\n\nA type (mutable struct) to represent a fermion path integral. In particular, this type contains the information required to reconstruct the diagonal on-site energy matrices V_l and hopping matrices K_l for each imaginary time slice l in 1 L_tau where tau = Deltatau cdot l and beta = Deltatau cdot L_tau\n\nTypes\n\nH<:Number: H_l = (K_l + V_l) Hamiltonian matrix element type.\nT<:Number: K_l kinetic energy matrix element type.\nU<:Number: V_l potential energy matrix element type.\nR<:AbstractFloat: Real number type.\n\nFields\n\nβ::R: Inverse temperature.\nΔτ::R: Discretization in imaginary time.\nLτ::Int: Length of the imaginary time axis.\nN::Int: Number of orbitals in the lattice.\nneighbor_table::Matrix{Int}: Neighbor table for each pair of orbitals in the lattice connected by a hopping.\nt::Matrix{T}: Hopping amplitudes for imaginary-time slice l are stored in t[:,l].\nV::Matrix{U}: The diagonal on-site energy matrices V_l for imaginary-time slice l are stored in V[:,l].\nK::Matrix{T}: Used to construct hopping matrix to calculate exponentiated hopping matrix if checkerboard approximation is not being used.\nSb::H: Keeps track of total bosonic action associated with fermionic path integral.\neigen_ws::HermitianEigenWs{T,Matrix{T},R}: For calculating eigenvalues and eigenvectors of K while avoiding dynamic memory allocations.\nu::Matrix{H}: Temporary matrix to avoid dynamic allocation when performing local updates.\nv::Matrix{H}: Temporary matrix to avoid dynamic allocation when performing local updates.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.FermionPathIntegral-Tuple{}","page":"API","title":"SmoQyDQMC.FermionPathIntegral","text":"FermionPathIntegral(;\n    # KEYWORD ARGUMENTS\n    tight_binding_parameters::TightBindingParameters{T,R},\n    β::R, Δτ::R,\n    forced_complex_kinetic::Bool = false,\n    forced_complex_potential::Bool = false\n) where {T<:Number, R<:AbstractFloat}\n\nInitialize an instance of FermionPathIntegral an instance of TightBindingParameters.\n\nIf forced_complex_kinetic = true, then the off-diagonal kinetic energy matrices K_l are assumed to be complex, otherwise the matrix element type is inferred.\n\nIf forced_complex_potential = true, then the diagonal potential energy matrices V_l are assumed to be complex, otherwise the matrix element type is inferred.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize_propagators","page":"API","title":"SmoQyDQMC.initialize_propagators","text":"initialize_propagators(\n    # ARGUMENTS\n    fermion_path_integral::FermionPathIntegral;\n    # KEYWORD ARGUMENTS\n    symmetric::Bool,\n    checkerboard::Bool\n)\n\nInitialize a propagator for each imaginary time slice, returning a vector of type Vector{<:AbstractPropagators{T,E}}.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.calculate_propagators!","page":"API","title":"SmoQyDQMC.calculate_propagators!","text":"calculate_propagators!(\n    # ARGUMENTS\n    B::Vector{P},\n    fpi::FermionPathIntegral;\n    # KEYWORD ARGUMENTS\n    calculate_exp_V::Bool,\n    calculate_exp_K::Bool\n) where {P<:AbstractPropagator}\n\nCalculate the propagator matrices B_l, given by B[l], for all imaginary time slice tau = Deltatau cdot l If calculate_exp_V = true, then calculate the diagonal exponentiated on-site energy matrices. If calculate_exp_K = true, then calculate the exponentiated hopping matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.calculate_propagator!","page":"API","title":"SmoQyDQMC.calculate_propagator!","text":"calculate_propagator!(\n    # ARGUMENTS\n    B::P,\n    fpi::FermionPathIntegral{H,T,U},\n    l::Int;\n    # KEYWORD ARGUMENTS\n    calculate_exp_V::Bool,\n    calculate_exp_K::Bool\n) where {H<:Number, T<:Number, U<:Number, P<:AbstractPropagator{T,U}}\n\nCalculate the propagator matrix B_l for imaginary time slice tau = Deltatau cdot l If calculate_exp_V = true, then calculate the diagonal exponentiated on-site energy matrix. If calculate_exp_K = true, then calculate the exponentiated hopping matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.update_stabilization_frequency!","page":"API","title":"SmoQyDQMC.update_stabilization_frequency!","text":"update_stabilization_frequency!(\n    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,\n    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H;\n    fermion_greens_calculator_up::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_dn::FermionGreensCalculator{H,R},\n    Bup::Vector{P}, Bdn::Vector{P}, δG::R, δθ::R, δG_max::R\n) where {H<:Number, R<:Real, P<:AbstractPropagator}\n\nIf the corrected error in the Green's function matrix is too large, δG > δG_max, then increase the frequency of numerical stabilization by decrementing n_stab such that it is updated to n_stab = max(n_stab - 1, 1), and update the equal-time Green's function matrices and all related variables and types. If the frequency of stabilization is udpated, then δG and δθ are reset to zero. This method returns a tuple of the following variables:\n\n(logdetGup, sgndetGdn, logdetGup, sgndetGdn, δG, δθ),\n\nwhere updated = true if n_stab was decremented.\n\n\n\n\n\nupdate_stabilization_frequency!(\n    G::Matrix{H}, logdetG::R, sgndetG::H;\n    fermion_greens_calculator::FermionGreensCalculator{H,R},\n    B::Vector{P}, δG::R, δθ::R, δG_max::R\n) where {H<:Number, R<:Real, P<:AbstractPropagator}\n\nIf the corrected error in the Green's function matrix is too large, δG > δG_max, then increase the frequency of numerical stabilization by decrementing n_stab such that it is updated to n_stab = max(n_stab - 1, 1), and update the equal-time Green's function matrices and all related variables and types. If the frequency of stabilization is udpated, then δG and δθ are reset to zero. This method returns a tuple of the following variables:\n\n(updated, logdetG, sgndetG, δG, δθ),\n\nwhere updated = true if n_stab was decremented.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.TightBindingModel","page":"API","title":"SmoQyDQMC.TightBindingModel","text":"TightBindingModel{T<:Number, E<:AbstractFloat, D}\n\nDefines a tight binding model in D dimensions. Note that spin = 1 (spin = 2) corresponds to spin-up (spin-down), and spin = 0 corresponds to both spin-up and spin-down.\n\nTypes\n\nT<:Number: The type of the hopping energy, which can be a real or complex number.\nE<:AbstractFloat: The type of the chemical potential and on-site energy, which must be real.\nD: The number of spatial dimensions the model lives in.\n\nFields\n\nμ::E: Chemical potential.\nϵ_mean::Vector{E}: Mean on-site energy for each orbital in the unit cell. \nϵ_std::Vector{E}: Standard deviation of on-site energy for each orbital in the unit cell.\nt_bond_ids::Vector{Int}: The bond ID for each bond/hopping definition.\nt_bonds::Vector{Bond{D}}: Bond definition for each type of hopping in the tight binding model.\nt_mean::Vector{T}: Mean hopping energy for each type of hopping.\nt_std::Vector{E}: Standard deviation of hopping energy for each type of hopping.\nη::Vector{E}: Relative twist angle for each lattice vector direction d in 1 D such that eta_d in 0 1)\nexpniϕ::Vector{T}: Twist angle phase exp(i n_d phi_d) for each hopping.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.TightBindingModel-Tuple{}","page":"API","title":"SmoQyDQMC.TightBindingModel","text":"TightBindingModel(;\n    # KEYWORD ARGUMENTS\n    model_geometry::ModelGeometry{D,E,N},\n    μ::E,\n    ϵ_mean::Vector{E},\n    ϵ_std::Vector{E} = zeros(eltype(ϵ_mean), length(ϵ_mean)),\n    t_bonds::Vector{Bond{D}} = Bond{ndims(model_geometry.unit_cell)}[],\n    t_mean::Vector{T} = eltype(ϵ_mean)[],\n    t_std::Vector{E} = zeros(eltype(ϵ_mean), length(t_mean)),\n    η::Union{Vector{E},Nothing} = nothing\n) where {T<:Number, E<:AbstractFloat, D, N}\n\nInitialize and return an instance of TightBindingModel, also adding/recording the bond defintions t_bonds to the ModelGeometry instance model_geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.TightBindingParameters","page":"API","title":"SmoQyDQMC.TightBindingParameters","text":"TightBindingParameters{T<:Number, E<:AbstractFloat}\n\nA mutable struct containing all the parameters needed to characterize a finite tight-binding Hamiltonian for a single spin species sigma on a finite lattice with periodic boundary conditions of the form\n\nhatH_0sigma=-sum_langle ijrangle(t_ij hatc_sigmai^daggerhatc_sigmaj+textrmhc)+sum_i(epsilon_i-mu)hatn_sigmai\n\nwhere hatc_sigmai^dagger is the fermion creation operator for an electron with spin sigma on orbital i t_ij are the hopping energies, epsilon_i are the on-site energies for each orbital in the lattice, and mu is the chemical potential.\n\nFields\n\nμ::E: The chemical potential mu\nconst ϵ::Vector{E}: A vector containing the on-site energy epsilon_i for each orbital in the lattice.\nconst t::Vector{T}: The hopping energy t_ij associated with each pair of neighboring orbitals connected by a bond in the lattice.\nconst neighbor_table::Matrix{Int}: Neighbor table containing all pairs of orbitals in the lattices connected by a bond, with a non-zero hopping energy between them.\nconst bond_ids::Vector{Int}: The bond ID definitions that define the types of hopping in the lattice.\nconst bond_slices::Vector{UnitRange{Int}}: Slices of neighbor_table corresponding to given bond ID i.e. the neighbors neighbor_table[:,bond_slices[i]] corresponds the bond_ids[i] bond defintion.\nconst norbital::Int: Number of orbitals per unit cell.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.TightBindingParameters-Tuple{}","page":"API","title":"SmoQyDQMC.TightBindingParameters","text":"TightBindingParameters(;\n    tight_binding_model::TightBindingModel{T,E,D},\n    model_geometry::ModelGeometry{D,E},\n    rng::AbstractRNG\n) where {T,E,D}\n\nInitialize and return an instance of TightBindingParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.measure_onsite_energy","page":"API","title":"SmoQyDQMC.measure_onsite_energy","text":"measure_onsite_energy(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    G::Matrix{H}, orbital_id::Int\n) where {H<:Number, T<:Number, E<:AbstractFloat}\n\nMeasure and return the on-site energy epsilon_textrmon-site = (epsilon - mu)langle hatn_sigma rangle for the orbital_id in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_hopping_energy","page":"API","title":"SmoQyDQMC.measure_hopping_energy","text":"measure_hopping_energy(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{H},\n    G::Matrix{H}, hopping_id::Int\n) where {H<:Number, T<:Number, E<:AbstractFloat}\n\nCalculate the average hopping energy epsilon_rm hopping = -langle t_llangle ij rangle hatc^dagger_sigmai hatc_sigmaj + rm hc rangle for the hopping defined by the the hopping_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_bare_hopping_energy","page":"API","title":"SmoQyDQMC.measure_bare_hopping_energy","text":"measure_bare_hopping_energy(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    G::Matrix{H}, hopping_id::Int\n) where {H<:Number, T<:Number, E<:AbstractFloat}\n\nCalculate the average bare hopping energy epsilon_rm hopping = -langle t_langle ij rangle hatc^dagger_sigmai hatc_sigmaj + rm hc rangle for the hopping defined by the hopping_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_hopping_amplitude","page":"API","title":"SmoQyDQMC.measure_hopping_amplitude","text":"measure_hopping_amplitude(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{H},\n    hopping_id::Int\n) where {H<:Number, T<:Number, E<:AbstractFloat}\n\nCalculate the average hopping amplitude for the hopping defined by the hopping_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_hopping_inversion","page":"API","title":"SmoQyDQMC.measure_hopping_inversion","text":"measure_hopping_inversion(\n    tight_binding_parameters::TightBindingParameters{T,E},\n    fermion_path_integral::FermionPathIntegral{H},\n    hopping_id::Int\n) where {H<:Number, T<:Number, E<:AbstractFloat}\n\nMeasure the fraction of time the sign of the instantaneous modulated hopping amplitude t_l(mathbfinu)(mathbfjgamma) is inverted relative to the bare hopping amplitude t_(mathbfinu)(mathbfjgamma), where l is the imaginary time-slice index.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.HubbardModel","page":"API","title":"SmoQyDQMC.HubbardModel","text":"HubbardModel{T<:AbstractFloat}\n\nA type to represent a, in general, multi-orbital Hubbard model.\n\nIf the type field ph_sym_form = false, then the particle-hole asymmetric form for the Hubbard interaction\n\nhatH_U=sum_mathbfinuU_numathbfihatn_uparrownumathbfihatn_downarrownumathbfi\n\nis used, where mathbfi specifies the unit cell, and nu denotes the orbital in the unit cell. In the case of a bipartite lattice with only nearest neighbor hopping, this convention results in an on-site energy corresponding to half-filling and particle-hole symmetry given by epsilon_numathbfi = -U_numathbfi2\n\nIf ph_sym_form = true, then the particle-hole symmetric form for the Hubbard interaction\n\nhatH_U=sum_mathbfinuU_numathbfi(hatn_uparrownumathbfi-tfrac12)(hatn_downarrownumathbfi-tfrac12)\n\nis used instead. In this case, for a bipartite lattice with only nearest neighbor hopping, the on-site energy corresponding to half-filling and particle-hole symmetry is epsilon_numathbfi = 0\n\nFields\n\nph_sym_form::Bool: Determines whether the particle-hole symmetric form of the Hubbard interaction is used.\nU_orbital_ids::Vector{Int}: Orbital species/IDs in unit cell with finite Hubbard interaction.\nU_mean::Vector{T}: Average Hubbard interaction strength U_nu for a given orbital species in the lattice.\nU_std::Vector{T}: Standard deviation of Hubbard interaction strength U_nu for a given orbital species in the lattice.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardModel-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardModel","text":"HubbardModel(;\n    # KEYWORD ARGUMENTS\n    ph_sym_form::Bool,\n    U_orbital::AbstractVector{Int},\n    U_mean::AbstractVector{T},\n    U_std::AbstractVector{T} = zero(U_mean)\n) where {T<:AbstractFloat}\n\nInitialize and return an instance of the type HubbardModel.\n\nKeyword Arguments\n\nph_sym_form::Bool: Determines whether the particle-hole symmetric form of the Hubbard interaction is used.\nU_orbital::Vector{Int}: Orbital species/IDs in unit cell with finite Hubbard interaction.\nU_mean::Vector{T}: Average Hubbard interaction strength U_nu for a given orbital species in the lattice.\nU_std::Vector{T}: Standard deviation of Hubbard interaction strength U_nu for a given orbital species in the lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.HubbardParameters","page":"API","title":"SmoQyDQMC.HubbardParameters","text":"HubbardParameters{T<:AbstractFloat}\n\nHubbard parameters for finite lattice.\n\nFields\n\nU::Vector{T}: On-site Hubbard interaction for each site with finite Hubbard interaction.\nsites::Vector{Int}: Site index associated with each finite Hubbard U interaction.\norbital_ids::Vector{Int}: Orbital ID/species in unit cell with finite Hubbard interaction.\nph_sym_form::Bool: Convention used for Hubbard interaction, refer to HubbardModel for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardParameters-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardParameters","text":"HubbardParameters(;\n    hubbard_model::HubbardModel{T},\n    model_geometry::ModelGeometry{D,T},\n    rng::AbstractRNG\n) where {D, T<:AbstractFloat}\n\nInitialize an instance of HubbardParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Tuple{FermionPathIntegral, FermionPathIntegral, HubbardParameters}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(\n    fermion_path_integral_up::FermionPathIntegral,\n    fermion_path_integral_dn::FermionPathIntegral,\n    hubbard_parameters::HubbardParameters\n)\n\ninitialize!(\n    fermion_path_integral::FermionPathIntegral,\n    hubbard_parameters::HubbardParameters\n)\n\nInitialize the contribution from the Hubbard interaction to a FermionPathIntegral instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.measure_hubbard_energy","page":"API","title":"SmoQyDQMC.measure_hubbard_energy","text":"measure_hubbard_energy(\n    hubbard_parameters::HubbardParameters{E},\n    Gup::Matrix{T}, Gdn::Matrix{T},\n    hubbard_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average Hubbard energy U langle hatn_uparrow hatn_downarrow rangle if ph_sym_form = false and U langle (hatn_uparrow - tfrac12)(hatn_downarrow - tfrac12)rangle if ph_sym_form = true for the orbital corresponding orbital_id in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.ExtendedHubbardModel","page":"API","title":"SmoQyDQMC.ExtendedHubbardModel","text":"ExtendedHubbardModel{T<:AbstractFloat}\n\nA type to represent extended Hubbard interactions.\n\nIf the type field ph_sym_form = false then the particle-hole asymmetric form of the extended Hubbard interaction\n\nbeginalign*\nhatH_V = sum_mathbfjmathbfrnuetaV_(mathbfj+mathbfrnu)(mathbfjeta)  hatn_mathbfj+mathbfrnuhatn_mathbfjeta \n    = sum_mathbfjmathbfrnuetaV_(mathbfj+mathbfrnu)(mathbfjeta)  biggtfrac12(hatn_mathbfj+mathbfrnu+hatn_mathbfjeta-2)^2-1 \n     -hatn_mathbfj+mathbfrnuuparrowhatn_mathbfj+mathbfrnudownarrow-hatn_mathbfjetauparrowhatn_mathbfjetadownarrow+tfrac32hatn_mathbfj+mathbfrnu+tfrac32hatn_mathbfjetabigg\nendalign*\n\nis used, where mathbfj specifies a unit cell in the lattice, mathbfr is a displacement in units, and nu and eta specify the orbital in a given unit cell. Here, hatn_mathbfjeta = (hatn_uparrowmathbfjeta + hatn_downarrowmathbfjeta) is the electron number operator for orbital eta in unit cell mathbfj in the lattice. Therefore, V_(mathbfj+mathbfrnu)(mathbfjeta) controls the strength of the extended Hubbard interaction between orbital eta in unit cell mathbfj and orbital nu in unit cell mathbfj+mathbfr.\n\nIf the type field ph_sym_form = true, then the particle-hole symmetric for the extended Hubbard interaction\n\nbeginalign*\nhatH_V=sum_mathbfjmathbfrnuetaV_(mathbfj+mathbfrnu)(mathbfjeta)(hatn_mathbfj+mathbfrnu-1)(hatn_mathbfjeta-1) \n    = sum_mathbfjmathbfrnuetaV_(mathbfj+mathbfrnu)(mathbfjeta)biggtfrac12(hatn_mathbfj+mathbfrnu+hatn_mathbfjeta-2)^2+tfrac12 \n     -(hatn_mathbfj+mathbfrnuuparrow-tfrac12)(hatn_mathbfj+mathbfrnudownarrow-tfrac12)-(hatn_mathbfjetauparrow-tfrac12)(hatn_mathbfjetadownarrow-tfrac12)bigg\nendalign*\n\nis used instead.\n\nFields\n\nph_sym_form::Bool: Whether the particle-hole symmetric form of the extended Hubbard interaction is used.\nV_bond_ids::Vector{Int}: Bond IDs specifying bond definition that separates a pair of orbitals with an extended Hubbard interaction between them.\nV_mean::Vector{T}: Average extended Hubbard interaction strength V_(mathbfj+mathbfrnu)(mathbfjeta) associated with bond definition.\nV_mean::Vector{T}: Standard deviation of extended Hubbard interaction strength V_(mathbfj+mathbfrnu)(mathbfjeta) associated with bond definition.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ExtendedHubbardModel-Tuple{}","page":"API","title":"SmoQyDQMC.ExtendedHubbardModel","text":"ExtendedHubbardModel(;\n    # KEYWORD ARGUMENTS\n    model_geometry::ModelGeometry{D,T},\n    ph_sym_form::Bool,\n    V_bond::Vector{Bond{D}},\n    V_mean::Vector{T},\n    V_std::Vector{T} = zero(V_mean)\n) where {T<:AbstractFloat, D}\n\nInitialize and return an instance of the type ExtendedHubbardModel.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.ExtendedHubbardParameters","page":"API","title":"SmoQyDQMC.ExtendedHubbardParameters","text":"ExtendedHubbardParameters{T<:AbstractFloat}\n\nExtended Hubbard interaction parameters for finite lattice.\n\nFields\n\nV::Vector{T}: Extended Hubbard interaction strength for each pair neighbors in the lattice.\nneighbor_table::Matrix{Int}: Neighbor table for extended Hubbard interactions on lattice.\nbond_ids::Vector{Int}: Bond IDs used to define extended Hubbard interactions.\nph_sym_form::Bool: Whether particle-hole symmetric form of extended Hubbard interaction was used.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ExtendedHubbardParameters-Tuple{}","page":"API","title":"SmoQyDQMC.ExtendedHubbardParameters","text":"ExtendedHubbardParameters(;\n    # KEYWORD ARGUMENTS\n    extended_hubbard_model::ExtendedHubbardModel{T},\n    model_geometry::ModelGeometry{D,T},\n    rng::AbstractRNG\n) where {D, T<:AbstractFloat}\n\nInitialize an instance of the ExtendedHubbardParameters type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Tuple{FermionPathIntegral, FermionPathIntegral, ExtendedHubbardParameters}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(\n    fermion_path_integral_up::FermionPathIntegral,\n    fermion_path_integral_dn::FermionPathIntegral,\n    extended_hubbard_parameters::ExtendedHubbardParameters\n)\n\ninitialize!(\n    fermion_path_integral::FermionPathIntegral,\n    extended_hubbard_parameters::ExtendedHubbardParameters\n)\n\nInitialize the contribution from the Hubbard interaction to a FermionPathIntegral instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.measure_ext_hub_energy","page":"API","title":"SmoQyDQMC.measure_ext_hub_energy","text":"measure_ext_hub_energy(\n    ext_hub_params::ExtendedHubbardParameters{E},\n    Gup::Matrix{T}, Gdn::Matrix{T},\n    ext_hub_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nMeasure the extended Hubbard interaction energy\n\nV (hatn_i-1)(hatn_j-1)\n\nif ph_sym_form = true and\n\nV hatn_i hatn_j\n\nif ph_sym_form = false for the specified EXT_HUB_ID.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.AbstractHST","page":"API","title":"SmoQyDQMC.AbstractHST","text":"abstract type AbstractHST{T<:Number, R<:AbstractFloat} end\n\nAbstract type to represent a Hubbard-Stratonovich transformation. Here T is the effective Hubbard-Stratonovich field type, specifying whether the Hubbard-Stratonovich transformation is real or complex.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.AbstractSymHST","page":"API","title":"SmoQyDQMC.AbstractSymHST","text":"abstract type AbstractSymHST{T, R} <: AbstractHST{T, R} end\n\nAbstract type to represent a Hubbard-Stratonovich transformation that couples to each spin species symmetrically. Here T is the effective Hubbard-Stratonovich field type, specifying whether the Hubbard-Stratonovich transformation is real or complex.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.AbstractAsymHST","page":"API","title":"SmoQyDQMC.AbstractAsymHST","text":"abstract type AbstractAsymHST{T, R} <: AbstractHST{T, R} end\n\nAbstract type to represent a Hubbard-Stratonovich transformation that couples to each spin species asymmetrically. Here T is the effective Hubbard-Stratonovich field type, specifying whether the Hubbard-Stratonovich transformation is real or complex.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H}, FermionPathIntegral{H}, AbstractHST{T}}} where {H<:Number, T<:Number}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(\n    fermion_path_integral_up::FermionPathIntegral{H},\n    fermion_path_integral_dn::FermionPathIntegral{H},\n    hst_parameters::AbstractHST{T}\n) where {H<:Number, T<:Number}\n\ninitialize!(\n    fermion_path_integral_up::FermionPathIntegral{H},\n    fermion_path_integral_dn::FermionPathIntegral{H},\n    hst_parameters::Tuple{Vararg{HST} where HST<:AbstractHST{T}}\n) where {H<:Number, T<:Number}\n\ninitialize!(\n    fermion_path_integral::FermionPathIntegral{H},\n    hst_parameters::AbstractSymHST{T}\n) where {H<:Number, T<:Number}\n\ninitialize!(\n    fermion_path_integral::FermionPathIntegral{H},\n    hst_parameters::Tuple{Vararg{HST} where HST<:AbstractSymHST{T}}\n) where {H<:Number, T<:Number}\n\nInitialize a FermionPathIntegral integral type to reflect the the current Hubbard-Stratonovich transformation type represented by hst_parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, AbstractHST{T, R}}} where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator}","page":"API","title":"SmoQyDQMC.local_updates!","text":"local_updates!(\n    # ARGUMENTS\n    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,\n    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,\n    hst_parameters::AbstractHST{T,R};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral_up::FermionPathIntegral{H},\n    fermion_path_integral_dn::FermionPathIntegral{H},\n    fermion_greens_calculator_up::FermionGreensCalculator{H},\n    fermion_greens_calculator_dn::FermionGreensCalculator{H},\n    Bup::Vector{P}, Bdn::Vector{P},\n    δG::R, δθ::R,  rng::AbstractRNG,\n    δG_max::R = 1e-6,\n    update_stabilization_frequency::Bool = true\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator}\n\nPerform local updates to Hubbard-Stratonovich fields stored in hst_parameters. This method returns a tuple containing (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ).\n\nArguments\n\nGup::Matrix{H}: Spin-up equal-time Green's function matrix.\nlogdetGup::R: The log of the absolute value of the determinant of the spin-up equal-time Green's function matrix, log vert det G_uparrow(tautau) vert\nsgndetGup::H: The sign/phase of the determinant of the spin-up equal-time Green's function matrix, det G_uparrow(tautau)  vert det G_uparrow(tautau) vert\nGdn::Matrix{H}: Spin-down equal-time Green's function matrix.\nlogdetGdn::R: The log of the absolute value of the determinant of the spin-down equal-time Green's function matrix, log vert det G_downarrow(tautau) vert\nsgndetGdn::H: The sign/phase of the determinant of the spin-down equal-time Green's function matrix, det G_downarrow(tautau)  vert det G_downarrow(tautau) vert\nhst_parameters::AbstractHST{T,R}: Type representing Hubbard-Stratonovich transformation.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{H}: An instance of the FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{H}: An instance of the FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{H}: An instance of the FermionGreensCalculator type for the spin-up electrons.\nfermion_greens_calculator_dn::FermionGreensCalculator{H}: An instance of the FermionGreensCalculator type for the spin-down electrons.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-dn propagators for each imaginary time slice.\nδG_max::R: Maximum allowed error corrected by numerical stabilization.\nδG::R: Previously recorded maximum error in the Green's function corrected by numerical stabilization.\nδθ::R: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green's function matrix corrected by numerical stabilization.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nupdate_stabilization_frequency::Bool = true: If true, allows the stabilization frequency n_stab to be dynamically adjusted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.local_updates!-Union{Tuple{N}, Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, NTuple{N, AbstractHST{T, R}}}} where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator, N}","page":"API","title":"SmoQyDQMC.local_updates!","text":"local_updates!(\n    # ARGUMENTS\n    Gup::Matrix{H}, logdet,Gup::R, sgndetGup::H,\n    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,\n    hst_parameters::Tuple{Vararg{HST,N} where HST<:AbstractHST{T,R}};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral_up::FermionPathIntegral{H},\n    fermion_path_integral_dn::FermionPathIntegral{H},\n    fermion_greens_calculator_up::FermionGreensCalculator{H},\n    fermion_greens_calculator_dn::FermionGreensCalculator{H},\n    Bup::Vector{P}, Bdn::Vector{P},\n    δG::R, δθ::R,  rng::AbstractRNG,\n    δG_max::R = 1e-6,\n    update_stabilization_frequency::Bool = true\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator, N}\n\nPerform local updates to Hubbard-Stratonovich fields for N different types of Hubbard-Stratonovich transformations. This method returns a tuple containing (acceptance_rates, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ). Note that acceptance_rates is a tuple returning the acceptance rate for local updates of each type of Hubbard-Stratonovich field that was sampled.\n\nArguments\n\nGup::Matrix{H}: Spin-up equal-time Green's function matrix.\nlogdetGup::R: The log of the absolute value of the determinant of the spin-up equal-time Green's function matrix, log vert det G_uparrow(tautau) vert\nsgndetGup::H: The sign/phase of the determinant of the spin-up equal-time Green's function matrix, det G_uparrow(tautau)  vert det G_uparrow(tautau) vert\nGdn::Matrix{H}: Spin-down equal-time Green's function matrix.\nlogdetGdn::R: The log of the absolute value of the determinant of the spin-down equal-time Green's function matrix, log vert det G_downarrow(tautau) vert\nsgndetGdn::H: The sign/phase of the determinant of the spin-down equal-time Green's function matrix, det G_downarrow(tautau)  vert det G_downarrow(tautau) vert\nhst_parameters::Tuple{Vararg{HST,N} where HST<:AbstractHST{T,R}}: Tuple of parameters for multiple different Hubbard-Stratonovich transformation fields that will be sampled.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{H}: An instance of the FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{H}: An instance of the FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{H}: An instance of the FermionGreensCalculator type for the spin-up electrons.\nfermion_greens_calculator_dn::FermionGreensCalculator{H}: An instance of the FermionGreensCalculator type for the spin-down electrons.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-dn propagators for each imaginary time slice.\nδG_max::R: Maximum allowed error corrected by numerical stabilization.\nδG::R: Previously recorded maximum error in the Green's function corrected by numerical stabilization.\nδθ::R: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green's function matrix corrected by numerical stabilization.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nupdate_stabilization_frequency::Bool = true: If true, allows the stabilization frequency n_stab to be dynamically adjusted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, AbstractSymHST{T, R}}} where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator}","page":"API","title":"SmoQyDQMC.local_updates!","text":"local_updates!(\n    # ARGUMENTS\n    G::Matrix{H}, logdetG::R, sgndetG::H,\n    hst_parameters::AbstractSymHST{T,R};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{H},\n    fermion_greens_calculator::FermionGreensCalculator{H},\n    B::Vector{P},\n    δG::R, δθ::R,  rng::AbstractRNG,\n    δG_max::R = 1e-6,\n    update_stabilization_frequency::Bool = true\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator}\n\nPerform local updates to Hubbard-Stratonovich fields for a spin-symmetric (density channel) Hubbard-Stratonovich transformation. This method returns a tuple containing (acceptance_rate, logdetG, sgndetG, δG, δθ).\n\nArguments\n\nG::Matrix{H}: Equal-time Green's function matrix.\nlogdetG::R: The log of the absolute value of the determinant of the equal-time Green's function matrix, log vert det G(tautau) vert\nsgndetG::H: The sign/phase of the determinant of the equal-time Green's function matrix, det G(tautau)  vert det G(tautau) vert\nhst_parameters::AbstractSymHST{T,R}: Type representing spin-symmetric Hubbard-Stratonovich transformation.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{H}: An instance of the FermionPathIntegral.\nfermion_greens_calculator::FermionGreensCalculator{H}: An instance of the FermionGreensCalculator type.\nB::Vector{P}: Propagators for each imaginary time slice.\nδG_max::R: Maximum allowed error corrected by numerical stabilization.\nδG::R: Previously recorded maximum error in the Green's function corrected by numerical stabilization.\nδθ::R: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green's function matrix corrected by numerical stabilization.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nupdate_stabilization_frequency::Bool = true: If true, allows the stabilization frequency n_stab to be dynamically adjusted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.local_updates!-Union{Tuple{N}, Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, NTuple{N, AbstractSymHST{T, R}}}} where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator, N}","page":"API","title":"SmoQyDQMC.local_updates!","text":"local_updates!(\n    # ARGUMENTS\n    G::Matrix{H}, logdetG::R, sgndetG::H,\n    hst_parameters::Tuple{Vararg{HST,N} where HST<:AbstractSymHST{T,R}};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{H},\n    fermion_greens_calculator::FermionGreensCalculator{H},\n    B::Vector{P},\n    δG::R, δθ::R,  rng::AbstractRNG,\n    δG_max::R = 1e-6,\n    update_stabilization_frequency::Bool = true\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator, N}\n\nPerform local updates to multiple types Hubbard-Stratonovich fields for a spin-symmetric (density channel) Hubbard-Stratonovich transformation. This method returns a tuple containing (acceptance_rate, logdetG, sgndetG, δG, δθ).\n\nArguments\n\nG::Matrix{H}: Equal-time Green's function matrix.\nlogdetG::R: The log of the absolute value of the determinant of the equal-time Green's function matrix, log vert det G(tautau) vert\nsgndetG::H: The sign/phase of the determinant of the equal-time Green's function matrix, det G(tautau)  vert det G(tautau) vert\nhst_parameters::Tuple{Vararg{HST,N} where HST<:AbstractSymHST{T,R}}: Tuple of parameters for multiple different spin-symmetric Hubbard-Stratonovich transformation fields that will be sampled.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{H}: An instance of the FermionPathIntegral.\nfermion_greens_calculator::FermionGreensCalculator{H}: An instance of the FermionGreensCalculator type.\nB::Vector{P}: Propagators for each imaginary time slice.\nδG_max::R: Maximum allowed error corrected by numerical stabilization.\nδG::R: Previously recorded maximum error in the Green's function corrected by numerical stabilization.\nδθ::R: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green's function matrix corrected by numerical stabilization.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nupdate_stabilization_frequency::Bool = true: If true, allows the stabilization frequency n_stab to be dynamically adjusted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, AbstractHST{T, R}}} where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(\n    # ARGUMENTS\n    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,\n    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,\n    hst_parameters::AbstractHST{T,R};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral_up::FermionPathIntegral{H},\n    fermion_path_integral_dn::FermionPathIntegral{H},\n    fermion_greens_calculator_up::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_dn::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R},\n    Bup::Vector{P}, Bdn::Vector{P},\n    rng::AbstractRNG\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator}\n\nPerform a reflection update for a Hubbard-Stratonovich field on a randomly chosen location in the lattice for all imaginary-time slices. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{H}: Spin-up equal-time Greens function matrix.\nlogdetGup::R: Log of the determinant of the spin-up equal-time Greens function matrix.\nsgndetGup::H: Sign/phase of the determinant of the spin-up equal-time Greens function matrix.\nGdn::Matrix{H}: Spin-down equal-time Greens function matrix.\nlogdetGdn::R: Log of the determinant of the spin-down equal-time Greens function matrix.\nsgndetGdn::H: Sign/phase of the determinant of the spin-down equal-time Greens function matrix.\nhst_parameters::AbstractHST{T,R}: Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{H}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{H}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{H,R}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{H,R}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed spin-down sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, AbstractSymHST{T, R}}} where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(\n    # ARGUMENTS\n    G::Matrix{H}, logdetG::R, sgndetG::H,\n    hst_parameters::AbstractSymHST{T,R};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{H},\n    fermion_greens_calculator::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_alt::FermionGreensCalculator{H,R},\n    B::Vector{P},\n    rng::AbstractRNG\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator}\n\nPerform a reflection update for a spin-symmetric (density channel) Hubbard-Stratonovich field on a randomly chosen location in the lattice for all imaginary-time slices. This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{H}: The current Hubbard-Stratonovich field matrix.\nlogdetG::R: Log of the determinant of the Hubbard-Stratonovich field matrix.\nsgndetG::H: Sign/phase of the determinant of the Hubbard-Stratonovich field matrix.\nhst_parameters::AbstractSymHST{T,R}: Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{H}: An instance of FermionPathIntegral.\nfermion_greens_calculator::FermionGreensCalculator{H,R}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, AbstractHST{T, R}}} where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(\n    # ARGUMENTS\n    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,\n    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,\n    hst_parameters::AbstractHST{T,R};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral_up::FermionPathIntegral{H},\n    fermion_path_integral_dn::FermionPathIntegral{H},\n    fermion_greens_calculator_up::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_dn::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R},\n    Bup::Vector{P}, Bdn::Vector{P},\n    rng::AbstractRNG\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator}\n\nPerform a swap update for a Hubbard-Stratonovich field between a pair of randomly chosen locations in the lattice for all imaginary-time slices. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{H}: Spin-up equal-time Greens function matrix.\nlogdetGup::R: Log of the determinant of the spin-up equal-time Greens function matrix.\nsgndetGup::H: Sign/phase of the determinant of the spin-up equal-time Greens function matrix.\nGdn::Matrix{H}: Spin-down equal-time Greens function matrix.\nlogdetGdn::R: Log of the determinant of the spin-down equal-time Greens function matrix.\nsgndetGdn::H: Sign/phase of the determinant of the spin-down equal-time Greens function matrix.\nhst_parameters::AbstractHST{T,R}: Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{H}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{H}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{H,R}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{H,R}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed spin-down sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, AbstractSymHST{T, R}}} where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(\n    # ARGUMENTS\n    G::Matrix{H}, logdetG::R, sgndetG::H,\n    hst_parameters::AbstractSymHST{T,R};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{H},\n    fermion_greens_calculator::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_alt::FermionGreensCalculator{H,R},\n    B::Vector{P},\n    rng::AbstractRNG\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator}\n\nPerform a swap update for a spin-symmetric (density channel) Hubbard-Stratonovich field between a pair of randomly chosen locations in the lattice for all imaginary-time slices. This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{H}: The current Hubbard-Stratonovich field matrix.\nlogdetG::R: Log of the determinant of the Hubbard-Stratonovich field\nsgndetG::H: Sign of the determinant of the Hubbard-Stratonovich field matrix.\nhst_parameters::AbstractSymHST{T,R}: Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{H}: An instance of FermionPathIntegral.\nfermion_greens_calculator::FermionGreensCalculator{H,R}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.HubbardSpinHirschHST","page":"API","title":"SmoQyDQMC.HubbardSpinHirschHST","text":"HubbardSpinHirschHST{T,R} <: AbstractAsymHST{T,R}\n\nThis type represents a Hubbard-Stratonovich (HS) transformation for decoupling the local Hubbard interaction in the spin channel, where the introduced HS fields take on the two discrete values s = pm 1. Specifically, the Hubbard interaction is decoupled as\n\ne^-Deltatau Uleft(n_uparrow-tfrac12right)left(n_downarrow-tfrac12right)\n = gammasum_s=pm1e^-Deltataualpha(n_uparrow-n_downarrow)s\n\nwhere\n\ngamma=frac12e^-Deltatau U4\n\nand\n\nalpha = frac1Deltataucosh^-1left(e^Deltatau U2right)\n\nNote that when U ge 0 then alpha is real, whereas if U0 then alpha is purely imaginary.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardSpinHirschHST-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardSpinHirschHST","text":"HubbardSpinHirschHST(;\n    # KEYWORD ARGUMENTS\n    hubbard_parameters::HubbardParameters{R},\n    β::R, Δτ::R, rng::AbstractRNG\n) where {R<:AbstractFloat}\n\nInitialize an instance of the HubbardSpinHirschHST type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.HubbardSpinGaussHermiteHST","page":"API","title":"SmoQyDQMC.HubbardSpinGaussHermiteHST","text":"HubbardSpinGaussHermiteHST{T,R} <: AbstractAsymHST{T,R}\n\nThis type represents a Hubbard-Stratonovich (HS) transformation for decoupling the local Hubbard interaction in the spin channel, where the introduced HS fields take on the four discrete values s in  -2 -1 +1 +2  Note that the Hubbard interaction can be written in the spin channel as\n\nU(hatn_uparrow-tfrac12)(hatn_downarrow-tfrac12)=-tfracU2(hatn_uparrow-hatn_downarrow)^2+tfracU4\n\ndifferent only by a constant energy offset U4 which does not matter. Therefore, we can perform a Gauss-Hermite Hubbard-Statonovich transformation in the spin channel as\n\ne^-Deltatauleft-fracU2right(hatn_uparrow-hatn_downarrow)^2\n    = frac14sum_s=pm1pm2e^-S_textGH(s)-DeltatauhatV(s)+mathcalOleft((Deltatau U)^4right)\n\nwhere hatV(s)=alphaeta(s)(hatn_uparrow-hatn_downarrow) and alpha = sqrtU(2Deltatau). In the above expression,\n\nS_textGH(s)=-logleft(1+sqrt6left(1-tfrac23sright)right)\n\nand\n\neta(s)=fracsssqrt6(1-sqrt6)+4sqrt6s\n\nNote that alpha is strictly real when U ge 0 and strictly imaginary when U  0.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardSpinGaussHermiteHST-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardSpinGaussHermiteHST","text":"HubbardSpinGaussHermiteHST(;\n    # KEYWORD ARGUMENTS\n    hubbard_parameters::HubbardParameters{E},\n    β::E, Δτ::E, rng::AbstractRNG\n) where {E<:AbstractFloat}\n\nInitialize an instance of the HubbardSpinGaussHermiteHST type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.HubbardDensityHirschHST","page":"API","title":"SmoQyDQMC.HubbardDensityHirschHST","text":"HubbardDensityHirschHST{T,R} <: AbstractSymHST{T,R}\n\nThis type represents a Hubbard-Stratonovich (HS) transformation for decoupling the local Hubbard interaction in the density channel, where the introduced HS fields take on the two discrete values s = pm 1. Specifically, the Hubbard interaction is decoupled as\n\ne^-Deltatau Uleft(n_uparrow-tfrac12right)left(n_downarrow-tfrac12right) =\ngammasum_s=pm1e^-Deltataualpha(n_uparrow+n_downarrow-1)s\n\nwhere\n\ngamma = frac12e^Deltatau U4\n\nand\n\nalpha = frac1Deltataucoshleft(e^-Deltatau U2right)\n\nNote that when U le 0 then alpha is real, whereas if U  0 then alpha is purely imaginary.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardDensityHirschHST-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardDensityHirschHST","text":"HubbardDensityHirschHST(;\n    # KEYWORD ARGUMENTS\n    hubbard_parameters::HubbardParameters{E},\n    β::E, Δτ::E, rng::AbstractRNG\n) where {E<:AbstractFloat}\n\nInitialize an instance of the HubbardDensityHirschHST type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.HubbardDensityGaussHermiteHST","page":"API","title":"SmoQyDQMC.HubbardDensityGaussHermiteHST","text":"HubbardDensityGaussHermiteHST{T,R} <: AbstractSymHST{T,R}\n\nThis type represents a Hubbard-Stratonovich (HS) transformation for decoupling the local Hubbard interaction in the density channel, where the introduced HS fields take on the four discrete values s in  -2 -1 +1 +2  Note that the Hubbard interaction can be written in the density channel as\n\nU(hatn_uparrow-tfrac12)(hatn_downarrow-tfrac12)=-tfracU2(hatn_uparrow+hatn_downarrow-1)^2-tfracU4\n\ndifferent only by a constant energy offset -U4 which does not matter. Therefore, we can perform a Gauss-Hermite Hubbard-Statonovich transformation in the density channel as\n\ne^-DeltatauleftfracU2right(hatn_uparrow+hatn_downarrow-1)^2\n = frac14sum_s=pm1pm2e^-S_textGF(s)-DeltatauhatV(s)+mathcalOleft((Deltatau U)^4right)\n\nwhere hatV(s)=alphaeta(s)(hatn_uparrow+hatn_downarrow-1) and alpha = sqrt-U(2Deltatau). In the above expression,\n\nS_textGH(s)=-logleft(1+sqrt6left(1-tfrac23sright)right)\n\nand\n\neta(s)=fracsssqrt6(1-sqrt6)+4sqrt6s\n\nNote that alpha is strictly real when U le 0 and strictly imaginary when U  0.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardDensityGaussHermiteHST-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardDensityGaussHermiteHST","text":"HubbardDensityGaussHermiteHST(;\n    # KEYWORD ARGUMENTS\n    hubbard_parameters::HubbardParameters{E},\n    β::E, Δτ::E, rng::AbstractRNG\n) where {E<:AbstractFloat}\n\nInitialize an instance of the HubbardDensityGaussHermiteHST type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.ExtHubSpinHirschHST","page":"API","title":"SmoQyDQMC.ExtHubSpinHirschHST","text":"ExtHubSpinHirschHST{T,R} <: AbstractAsymHST{T,R}\n\nThis type represent a Hirsch style Hubbard-Stratonovich (HS) transformation used to decouple an extended Hubbard interaction, where the introduced HS fields can take on the values s = pm 1. The decomposition is done using the spin-channel. Here the extended Hubbard interaction is expressed as\n\nV(hatn_i-1)(hatn_j) = Vsum_sigmasigma (hatn_sigmai-frac12)hatn_sigmaj-frac12)\n\nThen each of the four terms on the right is decouple using a HS transformation of the form\n\ne^-Deltatau Vleft(n_sigma-tfrac12right)left(n_sigma-tfrac12right)\n = gammasum_s=pm1e^-Deltataualpha(n_sigma-n_sigma)s\n\nwhere\n\ngamma=frac12e^-Deltatau V4\n\nand\n\nalpha = frac1Deltataucosh^-1left(e^Deltatau V2right)\n\nNote that when V ge 0 then alpha is real, whereas if V0 then alpha is purely imaginary.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ExtHubSpinHirschHST-Tuple{}","page":"API","title":"SmoQyDQMC.ExtHubSpinHirschHST","text":"ExtHubSpinHirschHST(;\n    # KEYWORD ARGUMENTS\n    extended_hubbard_parameters::ExtendedHubbardParameters{R},\n    β::R, Δτ::R, rng::AbstractRNG\n) where {R<:AbstractFloat}\n\nInitialize an instance of the ExtHubSpinHirschHST type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.ExtHubDensityGaussHermiteHST","page":"API","title":"SmoQyDQMC.ExtHubDensityGaussHermiteHST","text":"ExtHubDensityGaussHermiteHST{T,R} <: AbstractSymHST{T,R}\n\nThis type represents a Hubbard-Stratonovich (HS) transformation for decoupling the extended Hubbard interaction, where the introduced HS fields take on the four discrete values s in  -2 -1 +1 +2 \n\nSpecifically, we perform the Gauss-Hermite Hubbard-Stratonovich transformation\n\ne^-DeltataulefttfracV2right(hatn_mathbfi+hatn_mathbfj-2)^2 =\n= frac14sum_s=pm1pm2e^-S_textGH(s)-DeltatauhatV(s)+mathcalOleft(lefttfracDeltatau V2right^4right)\n\nwhere hatV(s) = alphaeta(s)(hatn_mathbfi+hatn_mathbfj-2) and alpha=sqrtfrac-V2Deltatau. In the above expression,\n\nS_textGH(s)=-logleft(1+sqrt6left(1-tfrac23sright)right)\n\nand\n\neta(s)=fracsssqrt6(1-sqrt6)+4sqrt6s\n\nNote that alpha is strictly real when V le 0 and strictly imaginary when V  0.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ExtHubDensityGaussHermiteHST-Tuple{}","page":"API","title":"SmoQyDQMC.ExtHubDensityGaussHermiteHST","text":"ExtHubDensityGaussHermiteHST(;\n    # KEYWORD ARGUMENTS\n    extended_hubbard_parameters::ExtendedHubbardParameters{R},\n    β::R, Δτ::R, rng::AbstractRNG\n) where {R<:AbstractFloat}\n\nInitialize an instance of the ExtHubDensityGaussHermiteHST type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.init_renormalized_hubbard_parameters-Tuple{}","page":"API","title":"SmoQyDQMC.init_renormalized_hubbard_parameters","text":"init_renormalized_hubbard_parameters(;\n    # KEYWORD ARGUMENTS\n    hubbard_parameters::HubbardParameters{E},\n    hst_parameters::ExtHubDensityGaussHermiteHST{T,E},\n    model_geometry::ModelGeometry{D,E}\n) where {D, T<:Number, E<:AbstractFloat}\n\nReturns a new instance of the HubbardParameters type with the Hubbard interactions renormalized based on the ExtHubDensityGaussHermiteHST definition. Refer to the definition of the ExtendedHubbardModel to see where this renormalization of the local Hubbard interaction comes from.\n\nNote that either both the local and extended Hubbard interactions need to be initialized using the particle-hole symmetric or asymmetric form for the interaction (as specified by ph_sym_form keyword argument), and cannot use opposite conventions. Additionally, the HubbardModel definition used to create the hubbard_parameters instance of the HubbardParameters passed to this function must initialize a Hubbard interaction on each type of orbital species/ID appearing in an extended Hubbard interaction, even if this means initializing the local Hubbard interaction to U = 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.ElectronPhononModel","page":"API","title":"SmoQyDQMC.ElectronPhononModel","text":"ElectronPhononModel{T<:Number, E<:AbstractFloat, D}\n\nDefines an electron-phonon model.\n\nFields\n\nphonon_modes::Vector{PhononModes{E,D}}: A vector of PhononMode definitions.\nphonon_dispersions::Vector{PhononDispersion{E,D}}: A vector of PhononDispersion definitions.\nholstein_couplings_up::Vector{HolsteinCoupling{E,D}}: A vector of HolsteinCoupling definitions for spin-up.\nholstein_couplings_dn::Vector{HolsteinCoupling{E,D}}: A vector of HolsteinCoupling definitions for spin-down.\nssh_couplings_up::Vector{SSHCoupling{T,E,D}}: A vector of SSHCoupling definitions for spin-up.\nssh_couplings_dn::Vector{SSHCoupling{T,E,D}}: A vector of SSHCoupling definitions for spin-down.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ElectronPhononModel-Tuple{}","page":"API","title":"SmoQyDQMC.ElectronPhononModel","text":"ElectronPhononModel(;\n    # KEYWORD ARGUMENTS\n    model_geometry::ModelGeometry{D,E},\n    tight_binding_model::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    tight_binding_model_up::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    tight_binding_model_dn::Union{TightBindingModel{T,E,D}, Nothing} = nothing\n) where {T<:Number, E<:AbstractFloat, D}\n\nInitialize and return a null (empty) instance of ElectronPhononModel. Note that either tight_binding_model or tight_binding_model_up and tight_binding_model_dn needs to be specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononMode","page":"API","title":"SmoQyDQMC.PhononMode","text":"PhononMode{E<:AbstractFloat}\n\nDefines a phonon mode nu at location \\mathbf{r}_\\nu in the unit cell. Specifically, it defines the phonon Hamiltonian terms\n\nhatH_rm ph = sum_mathbfi\n  left\n      frac12 M_mathbfinuOmega_mathbfinu^2hatX_mathbfinu^2\n    + frac112M_mathbfinuOmega_4mathbfinu^2hatX_mathbfinu^4\n    + frac12M_mathbfinuhatP_mathbfinu^2\n  right\n\nwhere the sum runs over unit cell mathbfi, mathbfr_nu denotes the location of the phonon mode in the unit cell, M_mathbfinu is the phonon mass M, Omega_mathbfinu is the phonon frequency that is distributed according to a normal distribution with mean Ω_mean and standard deviation Ω_std. Lastly, Omega_4mathbfinu is the anharmonic coefficient, and is distributed according to a normal distribution with mean Ω4_mean and standard deviation Ω4_std.\n\nFields\n\nbasis_vec::SVector{D,E}: Location mathbfr_nu of phonon mode in unit cell.\nM::E:: The phonon mass M_mathbfinu\nΩ_mean::E: Mean of normal distribution the phonon frequency Omega_mathbfinu is sampled from.\nΩ_std::E: Standard deviation of normal distribution the phonon frequency Omega_mathbfinu is sampled from.\nΩ4_mean::E: Mean of normal distribution the anharmonic coefficient Omega_4mathbfinu is sampled from.\nΩ4_std::E: Standard deviation of normal distribution the anharmonic coefficient Omega_4mathbfinu is sampled from.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.PhononMode-Tuple{}","page":"API","title":"SmoQyDQMC.PhononMode","text":"PhononMode(;\n    # KEYWORD ARGUMENTS\n    basis_vec::AbstractVector{E},\n    Ω_mean::E,\n    Ω_std::E = 0.,\n    M::E = 1.,\n    Ω4_mean::E = 0.0,\n    Ω4_std::E = 0.0,\n) where {E<:AbstractFloat}\n\nInitialize and return a instance of PhononMode.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.HolsteinCoupling","page":"API","title":"SmoQyDQMC.HolsteinCoupling","text":"HolsteinCoupling{E<:AbstractFloat, D}\n\nDefines a Holstein coupling between a specified phonon mode and orbital density. Specifically, if ph_sym_form = true then a the particle-hole symmetric form of the Holstein coupling given by\n\nbeginalign*\nH = sum_mathbfi Big \n         (alpha_mathbfi(mathbfrkappanu) hatX_mathbfinu\n        + alpha_3mathbfi(mathbfrkappanu) hatX^3_mathbfinu)  (hatn_sigmamathbfi+mathbfrkappa-tfrac12)\n         + (alpha_2mathbfi(mathbfrkappanu) hatX^2_mathbfinu\n        + alpha_4mathbfi(mathbfrkappanu) hatX^4_mathbfinu)  hatn_sigmamathbfi+mathbfrkappa \nBig\nendalign*\n\nis used, whereas if ph_sym_form = false Holstein coupling is given by\n\nbeginalign*\nH = sum_mathbfi Big \n         (alpha_mathbfi(mathbfrkappanu) hatX_mathbfinu\n        + alpha_3mathbfi(mathbfrkappanu) hatX^3_mathbfinu)  hatn_sigmamathbfi+mathbfrkappa\n         + (alpha_2mathbfi(mathbfrkappanu) hatX^2_mathbfinu\n        + alpha_4mathbfi(mathbfrkappanu) hatX^4_mathbfinu)  hatn_sigmamathbfi+mathbfrkappa \nBig\nendalign*\n\nIn the above, sigma specifies the sum, and the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa specify the phonon mode orbital species IDs respectively, and mathbfr is a static displacement in unit cells.\n\nFields\n\nph_sym_form::Bool: If particle-hole symmetric form is used for Holstein coupling.\nphonon_id::Int: The ID nu specifying phonon mode getting coupled to.\norbital_id::Int: The ID kappa specifying orbital species the phonon mode getting coupled to.\ndisplacement::SVector{D,Int}: Static displacement r in unit cells in the direction of each lattice vector.\nα_mean::E: Mean of the linear Holstein coupling coefficient alpha_1mathbfi(mathbfrkappanu)\nα_std::E: Standard deviation of the linear Holstein coupling coefficient alpha_1mathbfi(mathbfrkappanu)\nα2_mean::E: Mean of the squared Holstein coupling coefficient alpha_2mathbfi(mathbfrkappanu)\nα2_std::E: Standard deviation of the squared Holstein coupling coefficient alpha_2mathbfi(mathbfrkappanu)\nα3_mean::E: Mean of the cubic Holstein coupling coefficient alpha_3mathbfi(mathbfrkappanu)\nα3_std::E: Standard deviation of the cubic Holstein coupling coefficient alpha_3mathbfi(mathbfrkappanu)\nα4_mean::E: Mean of the quartic Holstein coupling coefficient alpha_4mathbfi(mathbfrkappanu)\nα4_std::E: Standard deviation of the quartic Holstein coupling coefficient alpha_4mathbfi(mathbfrkappanu)\n\nComment\n\nNote that the initial orbital bond.orbital[1] must match the orbital species associated with phonon mode PhononMode getting coupled to.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HolsteinCoupling-Tuple{}","page":"API","title":"SmoQyDQMC.HolsteinCoupling","text":"HolsteinCoupling(;\n    # KEYWORD ARGUMENTS\n    model_geometry::ModelGeometry{D,E},\n    phonon_id::Int,\n    orbital_id::Int,\n    displacement::AbstractVector{Int},\n    α_mean::E,\n    α_std::E  = 0.0,\n    α2_mean::E = 0.0,\n    α2_std::E = 0.0,\n    α3_mean::E = 0.0,\n    α3_std::E = 0.0,\n    α4_mean::E = 0.0,\n    α4_std::E = 0.0,\n    ph_sym_form::Bool = true\n) where {D, E<:AbstractFloat}\n\nInitialize and return a instance of HolsteinCoupling.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.SSHCoupling","page":"API","title":"SmoQyDQMC.SSHCoupling","text":"SSHCoupling{T<:Number, E<:AbstractFloat, D}\n\nDefines a Su-Schrieffer-Heeger (SSH) coupling between a pair of phonon modes. Specifically, it defines the SSH interaction term\n\nhatH_rm ssh = -sum_sigmamathbfi\n    left t_mathbfi(mathbfrkappanu) - left( sum_n=1^4alpha_nmathbfi(mathbfrkappanu)\n    left( hatX_mathbfi+mathbfrkappa - hatX_mathbfinuright)^nright) right\n    left( hatc_sigmamathbfi+mathbfrkappa^daggerhatc_sigmamathbfinu+rm hc right)\n\nwhere sigma specifies the sum, and the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa IDs specify orbital species in the unit cell, and kappa and nu IDs specify the phonon modes getting coupled to. Finally, mathbfr is a static displacement in unit cells in the direction of each lattice vector. In that above expression t_mathbfi(mathbfrkappanu) is the bare hopping amplitude, which is not specified here.\n\nFields\n\nphonon_ids::NTuple{2,Int}: Pair of phonon modes getting coupled together.\nbond::Bond{D}: Bond separating the two orbitals getting coupled to, which are separated by mathbfr + (mathbfr_kappa - mathbfr_nu).\nbond_id::Int: Bond ID associated with the bond field.\nα_mean::T: Mean of the linear SSH coupling constant alpha_1mathbfi(mathbfrkappanu)\nα_std::T: Standard deviation of the linear SSH coupling constant alpha_1mathbfi(mathbfrkappanu)\nα2_mean::T: Mean of the quadratic SSH coupling constant alpha_2mathbfi(mathbfrkappanu)\nα2_std::T: Standard deviation of the quadratic SSH coupling constant alpha_2mathbfi(mathbfrkappanu)\nα3_mean::T: Mean of the cubic SSH coupling constant alpha_3mathbfi(mathbfrkappanu)\nα3_std::T: Standard deviation of the cubic SSH coupling constant alpha_3mathbfi(mathbfrkappanu)\nα4_mean::T: Mean of the quartic SSH coupling constant alpha_4mathbfi(mathbfrkappanu)\nα4_std::T: Standard deviation of the quartic SSH coupling constant alpha_4mathbfi(mathbfrkappanu)\nexpniϕ::T: Twisted boundary conditions phase factor.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SSHCoupling-Tuple{}","page":"API","title":"SmoQyDQMC.SSHCoupling","text":"SSHCoupling(;\n    # KEYWORD ARGUMENTS\n    model_geometry::ModelGeometry{D,E},\n    tight_binding_model::TightBindingModel{T,E,D},\n    phonon_ids::NTuple{2,Int},\n    bond::Bond{D},\n    α_mean::Union{T,E},\n    α_std::E  = 0.0,\n    α2_mean::Union{T,E} = 0.0,\n    α2_std::E = 0.0,\n    α3_mean::Union{T,E} = 0.0,\n    α3_std::E = 0.0,\n    α4_mean::Union{T,E} = 0.0,\n    α4_std::E = 0.0\n) where {D, T<:Number, E<:AbstractFloat}\n\nInitialize and return a instance of SSHCoupling.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononDispersion","page":"API","title":"SmoQyDQMC.PhononDispersion","text":"PhononDispersion{E<:AbstractFloat, D}\n\nDefines a dispersive phonon coupling between phonon modes. Specifically, it defines the dispersive phonon term\n\nhatH_rm disp = sum_mathbfi\n    left(\n        fracM_mathbfi+mathbfrkappaM_mathbfinuM_mathbfi+mathbfrkappa+M_mathbfinu\n    right)\n    bigg\n                    Omega_mathbfi(mathbfrkappanu)^2Big(hatX_mathbfi+mathbfrkappa-hatX_mathbfinuBig)^2\n       +frac112Omega_4mathbfi(mathbfrkappanu)^2Big(hatX_mathbfi+mathbfrkappa-hatX_mathbfinuBig)^4\n    bigg\n\nwhere the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa IDs specify the phonon modes in the unit cell, and mathbfr is a static displacement in unit cells.\n\nFields\n\nphonon_ids::NTuple{2,Int}: ID's for pair of phonon modes getting coupled together.\ndisplacement::SVector{D,Int}: Static displacement mathbfr in unit cells separating the two phonon modes getting coupled.\nΩ_mean::E: Mean dispersive phonon frequency Omega_mathbfi(mathbfrkappanu)\nΩ_std::E: Standard deviation of dispersive phonon frequency Omega_mathbfi(mathbfrkappanu)\nΩ4_mean::E: Mean quartic dispersive phonon coefficient Omega_4mathbfi(mathbfrkappanu)\nΩ4_std::E: Standard deviation of quartic dispersive phonon coefficient Omega_4mathbfi(mathbfrkappanu)\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.PhononDispersion-Tuple{}","page":"API","title":"SmoQyDQMC.PhononDispersion","text":"PhononDispersion(;\n    # KEYWORD ARGUMENTS\n    model_geometry::ModelGeometry{D,E},\n    phonon_ids::NTuple{2,Int},\n    displacement::AbstractVector{Int},\n    Ω_mean::E,\n    Ω_std::E=0.0,\n    Ω4_mean::E=0.0,\n    Ω4_std::E=0.0\n) where {E<:AbstractFloat, D}\n\nInitialize and return a instance of PhononDispersion.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.add_phonon_mode!","page":"API","title":"SmoQyDQMC.add_phonon_mode!","text":"add_phonon_mode!(;\n    # KEYWORD ARGUMENTS\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    phonon_mode::PhononMode{E,D}\n) where {T<:Number, E<:AbstractFloat, D}\n\nAdd a PhononMode to an ElectronPhononModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_holstein_coupling!","page":"API","title":"SmoQyDQMC.add_holstein_coupling!","text":"add_holstein_coupling!(;\n    # KEYWORD ARGUMENTS\n    model_geometry::ModelGeometry{D,E},\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    holstein_coupling::Union{HolsteinCoupling{E,D}, Nothing} = nothing,\n    holstein_coupling_up::Union{HolsteinCoupling{E,D}, Nothing} = nothing,\n    holstein_coupling_dn::Union{HolsteinCoupling{E,D}, Nothing} = nothing\n) where {T,E,D}\n\nAdd the HolsteinCoupling to an ElectronPhononModel. Note that either holstein_coupling or holstein_coupling_up and holstein_coupling_dn must be specified.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_ssh_coupling!","page":"API","title":"SmoQyDQMC.add_ssh_coupling!","text":"add_ssh_coupling!(;\n    # KEYWORD ARGUMENTS\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    tight_binding_model::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    ssh_coupling::Union{SSHCoupling{T,E,D}, Nothing} = nothing,\n    tight_binding_model_up::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    tight_binding_model_dn::Union{TightBindingModel{T,E,D}, Nothing} = nothing,\n    ssh_coupling_up::Union{SSHCoupling{T,E,D}, Nothing} = nothing,\n    ssh_coupling_dn::Union{SSHCoupling{T,E,D}, Nothing} = nothing\n) where {T,E,D}\n\nAdd a SSHCoupling to an ElectronPhononModel. Note that either ssh_coupling and tight_binding_model or ssh_coupling_up, ssh_coupling_dn, tight_binding_model_up and tight_binding_model_dn need to be specified.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_phonon_dispersion!","page":"API","title":"SmoQyDQMC.add_phonon_dispersion!","text":"add_phonon_dispersion!(;\n    # KEYWORD ARGUMENTS\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    phonon_dispersion::PhononDispersion{E,D},\n    model_geometry::ModelGeometry{D,E}\n) where {T,E,D}\n\nAdd a PhononDispersion to an ElectronPhononModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.ElectronPhononParameters","page":"API","title":"SmoQyDQMC.ElectronPhononParameters","text":"ElectronPhononParameters{T<:Number, E<:AbstractFloat}\n\nDescribes all parameters in the electron-phonon model.\n\nFields\n\nβ::E: Inverse temperature.\nΔτ::E: Discretization in imaginary time.\nLτ::Int: Length of imaginary time axis.\nx::Matrix{E}: Phonon fields, where each column represents the phonon fields for a given imaginary time slice.\nphonon_parameters::PhononParameters{E,D}: Refer to PhononParameters.\nholstein_parameters_up::HolsteinParameters{E}: Spin up HolsteinParameters.\nholstein_parameters_dn::HolsteinParameters{E}: Spin down HolsteinParameters.\nssh_parameters_up::SSHParameters{T}: Spin up SSHParameters.\nssh_parameters_dn::SSHParameters{T}: Spin down SSHParameters.\ndispersion_parameters::DispersionParameters{E}: Refer to DispersionParameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ElectronPhononParameters-Tuple{}","page":"API","title":"SmoQyDQMC.ElectronPhononParameters","text":"ElectronPhononParameters(;\n    β::E, Δτ::E,\n    model_geometry::ModelGeometry{D,E},\n    tight_binding_parameters::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    tight_binding_parameters_up::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    tight_binding_parameters_dn::Union{TightBindingParameters{T,E}, Nothing} = nothing,\n    electron_phonon_model::ElectronPhononModel{T,E,D},\n    rng::AbstractRNG\n) where {T,E,D}\n\nInitialize and return an instance of ElectronPhononParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononParameters","page":"API","title":"SmoQyDQMC.PhononParameters","text":"PhononParameters{E<:AbstractFloat}\n\nDefines the parameters for each phonon in the lattice, includes the phonon field configuration.\n\nFields\n\nnphonon::Int: Number of type of phonon modes.\nNphonon::Int: Total number of phonon modes in finite lattice.\nM::Int: Mass of each phonon mode.\nΩ::Int: Frequency of each phonon mode.\nΩ4::Int: Quartic phonon coefficient for each phonon mode.\nbasis_vecs::Vector{Vector{E}}: Basis vector for each of the nphonon types of phonon mode.`\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HolsteinParameters","page":"API","title":"SmoQyDQMC.HolsteinParameters","text":"HolsteinParameters{E<:AbstractFloat}\n\nDefines the Holstein coupling parameters in lattice.\n\nFields\n\nnholstein::Int: The number of type of holstein couplings.\nNholstein::Int: Total number of Holstein couplings in lattice.\nα::Vector{T}: Linear Holstein coupling.\nα2::Vector{T}: Quadratic Holstein coupling.\nα3::Vector{T}: Cubic Holstein coupling.\nα4::Vector{T}: Quartic Holstein coupling.\nph_sym_form::Vector{Bool}: If particle-hole symmetric form is used for Holstein coupling.\ncoupling_to_site::Vector{Int}: Maps each Holstein coupling in the lattice to the corresponding site in the lattice.\ncoupling_to_phonon::Vector{Int}: Maps each Holstein coupling in the lattice to the corresponding phonon mode.\nphonon_to_coupling::Vector{Vector{Int}}: Maps each phonon model to correspond Holstein couplings.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SSHParameters","page":"API","title":"SmoQyDQMC.SSHParameters","text":"SSHParameters{T<:Number}\n\nDefines the SSH coupling parameters in lattice.\n\nFields\n\nnssh::Int: Number of types of SSH couplings.\nNssh::Int: Number of SSH couplings in lattice.\nα::Vector{T}: Linear SSH coupling.\nα2::Vector{T}: Quadratic SSH coupling.\nα3::Vector{T}: Cubic SSH coupling.\nα4::Vector{T}: Quartic SSH coupling.`\nneighbor_table::Matrix{Int}: Neighbor table to SSH coupling.\ncoupling_to_phonon::Matrix{Int}: Maps each SSH coupling onto that pair of coupled phonons.\ninit_phonon_to_coupling::Vector{Vector{Int}}: Maps initial phonon mode to corresponding SSH coupling(s).\nfinal_phonon_to_coupling::Vector{Vector{Int}}: Maps final phonon mode to corresponding SSH coupling(s).\nhopping_to_couplings::Vector{Vector{Int}}: Maps hopping in the tight-binding model onto SSH couplings.\ncoupling_to_hopping::Vector{Int}: Maps each SSH coupling onto the corresponding hopping in the tight-binding model.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.DispersionParameters","page":"API","title":"SmoQyDQMC.DispersionParameters","text":"DispersionParameters{E<:AbstractFloat}\n\nDefines the dispersive phonon coupling parameters in the lattice.\n\nFields\n\nndispersion::Int: Number of types of dispersive couplings.\nNdispersion::Int: Number of dispersive couplings in the lattice.\nΩ::Vector{E}: Frequency of dispersive phonon coupling.\nΩ4::Vector{E}: Quartic coefficient for the phonon dispersion.\ndispersion_to_phonon::Matrix{Int}: Pair of phonon modes in lattice coupled by dispersive coupling.\ninit_phonon_to_coupling::Vector{Vector{Int}}: Maps initial phonon mode to corresponding dispersive phonon coupling.\nfinal_phonon_to_coupling::Vector{Vector{Int}}: Maps final phonon mode to corresponding dispersive phonon coupling.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}}} where {H<:Number, T<:Number, R<:AbstractFloat}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(\n    fermion_path_integral_up::FermionPathIntegral{H,T},\n    fermion_path_integral_dn::FermionPathIntegral{H,T},\n    electron_phonon_parameters::ElectronPhononParameters{T,R}\n) where {H<:Number, T<:Number, R<:AbstractFloat}\n\nInitialize the contribution of an ElectronPhononParameters to a FermionPathIntegral.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}}} where {H<:Number, T<:Number, R<:AbstractFloat}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(\n    # ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{H,T},\n    electron_phonon_parameters::ElectronPhononParameters{T,R};\n    # KEYWORD ARGUMENTS\n    spin::Int = +1\n) where {H<:Number, T<:Number, R<:AbstractFloat}\n\nInitialize the contribution of an ElectronPhononParameters to a FermionPathIntegral.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.update!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}, Matrix{R}, Matrix{R}}} where {H<:Number, T<:Number, R<:AbstractFloat}","page":"API","title":"SmoQyDQMC.update!","text":"update!(\n    fermion_path_integral_up::FermionPathIntegral{H,T},\n    fermion_path_integral_dn::FermionPathIntegral{H,T},\n    electron_phonon_parameters::ElectronPhononParameters{T,R},\n    x′::Matrix{R},\n    x::Matrix{R}\n) where {H<:Number, T<:Number, R<:AbstractFloat}\n\nUpdate a FermionPathIntegral to reflect a change in the phonon configuration from x to x′.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.update!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}, Matrix{R}, Matrix{R}}} where {H<:Number, T<:Number, R<:AbstractFloat}","page":"API","title":"SmoQyDQMC.update!","text":"update!(\n    # ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{H,T},\n    electron_phonon_parameters::ElectronPhononParameters{T,R},\n    x′::Matrix{R},\n    x::Matrix{R};\n    # KEYWORD ARGUMENTS\n    spin::Int = +1\n) where {H<:Number, T<:Number, R<:AbstractFloat}\n\nUpdate a FermionPathIntegral to reflect a change in the phonon configuration from x to x′.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.update!-Union{Tuple{R}, Tuple{T}, Tuple{H}, Tuple{FermionPathIntegral{H, T}, ElectronPhononParameters{T, R}, Matrix{R}, Int64}} where {H<:Number, T<:Number, R<:AbstractFloat}","page":"API","title":"SmoQyDQMC.update!","text":"update!(\n    # ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{H,T},\n    electron_phonon_parameters::ElectronPhononParameters{T,R},\n    x::Matrix{R},\n    sgn::Int;\n    # KEYWORD ARGUMENTS\n    spin::Int = +1\n) where {H<:Number, T<:Number, R<:AbstractFloat}\n\nUpdate a FermionPathIntegral according to sgn * x.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.measure_phonon_kinetic_energy","page":"API","title":"SmoQyDQMC.measure_phonon_kinetic_energy","text":"measure_phonon_kinetic_energy(\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    n::Int\n) where {T<:Number, E<:AbstractFloat}\n\nEvaluate the average phonon kinetic energy for phonon mode n. The measurement is made using the expression\n\nlangle K rangle = frac12Deltatau - fracM2bigglanglefrac(x_l+1-x_l)^2Deltatau^2biggrangle \n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_phonon_potential_energy","page":"API","title":"SmoQyDQMC.measure_phonon_potential_energy","text":"measure_phonon_potential_energy(\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    n::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average phonon potential energy, given by\n\nU = frac12 M Omega^2 langle hatX^2 rangle + frac124 M Omega_4^2 langle hatX^4 rangle\n\nfor phonon mode n in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_phonon_position_moment","page":"API","title":"SmoQyDQMC.measure_phonon_position_moment","text":"measure_phonon_position_moment(\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    n::Int, m::Int\n) where {T<:Number, E<:AbstractFloat}\n\nMeasure langle X^m rangle for phonon mode n in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_holstein_energy","page":"API","title":"SmoQyDQMC.measure_holstein_energy","text":"measure_holstein_energy(\n    holstein_parameters::HolsteinParameters{E},\n    G::Matrix{T},\n    x::Matrix{E},\n    holstein_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate and return both the spin-resolved Holstein interaction energy\n\nepsilon_rm holsigma = \n                            leftlangle\n                                \n                                    alpha   hatX   + alpha_2 hatX^2\n                                  + alpha_3 hatX^3 + alpha_4 hatX^4\n                                \n                                left(\n                                    hatn_sigma - frac12\n                                right)\n                            rightrangle\n\ncorresponding to holstein_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_ssh_energy","page":"API","title":"SmoQyDQMC.measure_ssh_energy","text":"measure_ssh_energy(\n    ssh_parameters::SSHParameters{T},\n    G::Matrix{T}, x::Matrix{E}, ssh_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nCalculate the return the SSH interaction energy\n\nepsilon_rm ssh = leftlangle alpha hatX     + alpha_2 hatX^2\n                                   alpha_3 hatX^3 + alpha_4 hatX^4\n                        (hatc^dagger_sigmai hatc_sigmaj + rm hc) rightrangle\n\nfor coupling definition specified by ssh_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_dispersion_energy","page":"API","title":"SmoQyDQMC.measure_dispersion_energy","text":"measure_dispersion_energy(\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    dispersion_id::Int\n) where {T<:Number, E<:AbstractFloat}\n\nEvaluate the average dispersion energy\n\nepsilon_rm disp = frac12 M_rm red Omega^2 langle(hatX_i - hatX_j)^2rangle\n                    + frac124 Mrm red Omega_4^2 langle(hatX_i - hatX_j)^4rangle\n\nwhere M_rm red = fracM_i M_jM_i + M_j is the reduced mass, for the dispersive coupling definition specified by dispersion_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.EFAHMCUpdater","page":"API","title":"SmoQyDQMC.EFAHMCUpdater","text":"EFAHMCUpdater{T<:Number, E<:AbstractFloat, PFFT, PIFFT}\n\nDefines an Exact Fourier Acceleration Hamiltonian/Hybrid Monte Carlo (EFA-HMC) update for the phonon degrees of freedom.\n\nFields\n\nNt::Int: Number of time-steps in HMC trajectory.\nΔt::E: Average time-step size used in HMC update.\nδ::E: Time-step used in EFA-HMC update is jittered by an amount Δt = Δt * (1 + δ*(2*rand(rng)-1)).\nx::Matrix{E}: Records initial phonon configuration in position space.\np::Matrix{E}: Conjugate momentum in HMC dynamics.\ndSdx::Matrix{E}: Stores the derivative of the action.\nGup′::Matrix{T}: Intermediate spin-up Green's function matrix during HMC trajectory.\nGdn′::Matrix{T}: Intermediate spin-down Green's function matrix during HMC trajectory.\nefa::ExactFourierAccelerator{E,PFFT,PIFFT}: Type to perform exact integration of equations of motion of quantum harmonic oscillator. \n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.EFAHMCUpdater-Tuple{}","page":"API","title":"SmoQyDQMC.EFAHMCUpdater","text":"EFAHMCUpdater(;\n    # KEYWORD ARGUMENTS\n    electron_phonon_parameters::ElectronPhononParameters{T,E},\n    G::Matrix{T},\n    Nt::Int,\n    Δt::E = π/(2*Nt),\n    reg::E = 0.0,\n    δ::E = 0.05\n) where {T<:Number, E<:AbstractFloat}\n\nKeyword Arguments\n\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Defines electron-phonon model.\nG::Matrix{T}: Sample Green's function matrix.\nNt::Int: Number of time-steps used in EFA-HMC update.\nΔt::E = π/(2*Nt): Average step size used for HMC update.\nreg::E = 0.0: Regularization used for mass in equations of motion.\nδ::E = 0.05: Amount of jitter added to time-step used in EFA-HMC update.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, ElectronPhononParameters{T, R}, EFAHMCUpdater{T, R}}} where {H<:Number, T<:Number, R<:Real, P<:(AbstractPropagator{T})}","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(\n    # ARGUMENTS\n    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,\n    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,\n    electron_phonon_parameters::ElectronPhononParameters{T,R},\n    hmc_updater::EFAHMCUpdater{T,R};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral_up::FermionPathIntegral{H,T},\n    fermion_path_integral_dn::FermionPathIntegral{H,T},\n    fermion_greens_calculator_up::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_dn::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R},\n    Bup::Vector{P}, Bdn::Vector{P},\n    δG::R, δθ::R, rng::AbstractRNG, \n    update_stabilization_frequency::Bool = false,\n    δG_max::R = 1e-5,\n    δG_reject::R = 1e-2,\n    recenter!::Function = identity,\n    Nt::Int = hmc_updater.Nt,\n    Δt::R = hmc_updater.Δt,\n    δ::R = hmc_updater.δ\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator{T}}\n\nPerform EFA-HMC update to the phonon degrees of freedom. This method returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ), where accepted is a boolean field indicating whether the proposed HMC update was accepted or rejected.\n\nArguments\n\nGup::Matrix{H}: Green's function matrix for spin up.\nlogdetGup::R: Log determinant of Green's function matrix for spin up.\nsgndetGup::H: Sign of determinant of Green's function matrix for spin up.\nGdn::Matrix{H}: Green's function matrix for spin down.\nlogdetGdn::R: Log determinant of Green's function matrix for spin down.\nelectron_phonon_parameters::ElectronPhononParameters{T,R}: Electron-phonon model parameters.\nhmc_updater::EFAHMCUpdater{T,R}: EFA-HMC updater.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{H}: Fermion path integral for spin up.\nfermion_path_integral_dn::FermionPathIntegral{H}: Fermion path integral for spin down.\nfermion_greens_calculator_up::FermionGreensCalculator{H,R}: Fermion greens calculator for spin up.\nfermion_greens_calculator_dn::FermionGreensCalculator{H,R}: Fermion greens calculator for spin down.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{H,R}: Alternative fermion greens calculator for spin up.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R}: Alternative fermion greens calculator for spin down.\nBup::Vector{P}: Spin up propagators.\nBdn::Vector{P}: Spin down propagators.\nδG::R: Numerical error in Green's function corrected by numerical stabilization.\nδθ::R: Numerical error in the phase of the determinant of the Green's function matrix corrected by numerical stabilization.\nrng::AbstractRNG: Random number generator.\nupdate_stabilization_frequency::Bool = false: Whether to update the stabilization frequency.\nδG_max::R = 1e-5: Maximum numerical error in Green's function corrected by numerical stabilization.\nδG_reject::R = 1e-2: Reject the update if the numerical error in Green's function corrected by numerical stabilization is greater than this value.\nNt::Int = hmc_updater.Nt: Number of time-steps used in EFA-HMC update.\nΔt::R = hmc_updater.Δt: Average step size used for HMC update.\nδ::R = hmc_updater.δ: Amount of jitter added to time-step used in EFA-HMC update.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, ElectronPhononParameters{T, R}, EFAHMCUpdater{T, R}}} where {H<:Number, T<:Number, R<:Real, P<:(AbstractPropagator{T})}","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(\n    # ARGUMENTS\n    G::Matrix{H}, logdetG::R, sgndetG::H,\n    electron_phonon_parameters::ElectronPhononParameters{T,R},\n    hmc_updater::EFAHMCUpdater{T,R};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{H,T},\n    fermion_greens_calculator::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_alt::FermionGreensCalculator{H,R},\n    B::Vector{P},\n    δG::R, δθ::R, rng::AbstractRNG,\n    update_stabilization_frequency::Bool = false,\n    δG_max::R = 1e-5,\n    δG_reject::R = 1e-2,\n    recenter!::Function = identity,\n    Nt::Int = hmc_updater.Nt,\n    Δt::R = hmc_updater.Δt,\n    δ::R = hmc_updater.δ\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator{T}}\n\nPerform EFA-HMC update to the phonon degrees of freedom. This method returns (accepted, logdetG, sgndetG, δG, δθ), where accepted is a boolean field indicating whether the proposed HMC update was accepted or rejected.\n\nArguments\n\nG::Matrix{H}: Green's function matrix for spin up.\nlogdetG::R: Log determinant of Green's function matrix for spin up.\nsgndetG::H: Sign of determinant of Green's function matrix for spin up.\nelectron_phonon_parameters::ElectronPhononParameters{T,R}: Electron-phonon model parameters.\nhmc_updater::EFAHMCUpdater{T,R}: EFA-HMC updater.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{H}: Fermion path integral.\nfermion_greens_calculator::FermionGreensCalculator{H,R}: Fermion greens calculator.\nfermion_greens_calculator_alt::FermionGreensCalculator{H,R}: Alternative fermion greens calculator.\nB::Vector{P}: Spin up propagators.\nδG::R: Numerical error in Green's function corrected by numerical stabilization.\nδθ::R: Numerical error in the phase of the determinant of the Green's function matrix corrected by numerical stabilization.\nrng::AbstractRNG: Random number generator.\nupdate_stabilization_frequency::Bool = false: Whether to update the stabilization frequency.\nδG_max::R = 1e-5: Maximum numerical error in Green's function corrected by numerical stabilization.\nδG_reject::R = 1e-2: Reject the update if the numerical error in Green's function corrected by numerical stabilization is greater than this value.\nNt::Int = hmc_updater.Nt: Number of time-steps used in EFA-HMC update.\nΔt::R = hmc_updater.Δt: Average step size used for HMC update.\nδ::R = hmc_updater.δ: Amount of jitter added to time-step used in EFA-HMC update.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H<:Number, T<:Number, R<:Real, P<:(AbstractPropagator{T})}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(\n    # ARGUMENTS\n    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,\n    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,\n    electron_phonon_parameters::ElectronPhononParameters{T,R};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral_up::FermionPathIntegral{T,U},\n    fermion_path_integral_dn::FermionPathIntegral{T,U},\n    fermion_greens_calculator_up::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_dn::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R},\n    Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,\n    phonon_types = nothing\n) where {H<:Number, T<:Number, U<:Number, R<:Real, P<:AbstractPropagator{T,U}}\n\nRandomly sample a phonon mode in the lattice, and propose an update that reflects all the phonon fields associated with that phonon mode x rightarrow -x This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{H}: Spin-up equal-time Greens function matrix.\nlogdetGup::R: Log of the determinant of the spin-up equal-time Greens function matrix.\nsgndetGup::H: Sign/phase of the determinant of the spin-up equal-time Greens function matrix.\nGdn::Matrix{H}: Spin-down equal-time Greens function matrix.\nlogdetGdn::R: Log of the determinant of the spin-down equal-time Greens function matrix.\nsgndetGdn::H: Sign/phase of the determinant of the spin-down equal-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,R}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,U}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,U}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{H,R}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{H,R}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_types = nothing: Collection of phonon types in the unit cell to randomly sample a phonon mode from. If nothing then all phonon modes in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H<:Number, T<:Number, R<:Real, P<:(AbstractPropagator{T})}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(\n    # ARGUMENTS\n    G::Matrix{H}, logdetG::R, sgndetG::H,\n    electron_phonon_parameters::ElectronPhononParameters{T,R};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{H,T},\n    fermion_greens_calculator::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_alt::FermionGreensCalculator{H,R},\n    B::Vector{P}, rng::AbstractRNG,\n    phonon_types = nothing\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator{T}}\n\nRandomly sample a phonon mode in the lattice, and propose an update that reflects all the phonon fields associated with that phonon mode x rightarrow -x This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{H}: equal-time Greens function matrix.\nlogdetG::R: Log of the determinant of the equal-time Greens function matrix.\nsgndetG::H: Sign/phase of the determinant of the equal-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhonParameters{T,R}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{H,T}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{H,R}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_types = nothing: Collection of phonon types (specified my PHONON_ID) in the unit cell to randomly sample a phonon mode from. If nothing then all phonon modes in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H<:Number, T<:Number, R<:Real, P<:(AbstractPropagator{T})}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(\n    # ARGUMENTS\n    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,\n    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,\n    electron_phonon_parameters::ElectronPhononParameters{T,R};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral_up::FermionPathIntegral{H,T},\n    fermion_path_integral_dn::FermionPathIntegral{H,T},\n    fermion_greens_calculator_up::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_dn::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R},\n    Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,\n    phonon_id_pairs = nothing\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator{T}}\n\nRandomly sample a pairs of phonon modes and exchange the phonon fields associated with the pair of phonon modes. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{H}: Spin-up equal-time Greens function matrix.\nlogdetGup::R: Log of the determinant of the spin-up equal-time Greens function matrix.\nsgndetGup::H: Sign/phase of the determinant of the spin-up equal-time Greens function matrix.\nGdn::Matrix{H}: Spin-down equal-time Greens function matrix.\nlogdetGdn::R: Log of the determinant of the spin-down equal-time Greens function matrix.\nsgndetGdn::H: Sign/phase of the determinant of the spin-down equal-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,R}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{H,T}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{H,T}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{H,R}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{H,R}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_id_pairs = nothing: Collection of phonon type pairs (specified by pairs of PHONON_ID values) in the unit cell to randomly sample a phonon modes from. If nothing then all phonon mode pairs in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H<:Number, T<:Number, R<:Real, P<:(AbstractPropagator{T})}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(\n    # ARGUMENTS\n    G::Matrix{H}, logdetG::R, sgndetG::H,\n    electron_phonon_parameters::ElectronPhononParameters{T,R};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{H,T},\n    fermion_greens_calculator::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_alt::FermionGreensCalculator{H,R},\n    B::Vector{P}, rng::AbstractRNG,\n    phonon_id_pairs = nothing\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator{T}}\n\nRandomly sample a pairs of phonon modes and exchange the phonon fields associated with the pair of phonon modes. This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{H}: equal-time Greens function matrix.\nlogdetG::R: Log of the determinant of the equal-time Greens function matrix.\nsgndetG::H: Sign/phase of the determinant of the equal-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,R}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{H,T}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{H,R}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_id_pairs = nothing: Collection of phonon type pairs in the unit cell to randomly sample a phonon modes from. If nothing then all phonon mode pairs in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.radial_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H<:Number, T<:Number, R<:Real, P<:(AbstractPropagator{T})}","page":"API","title":"SmoQyDQMC.radial_update!","text":"radial_update!(\n    # ARGUMENTS\n    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,\n    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H,\n    electron_phonon_parameters::ElectronPhononParameters{T,R};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral_up::FermionPathIntegral{H,T},\n    fermion_path_integral_dn::FermionPathIntegral{H,T},\n    fermion_greens_calculator_up::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_dn::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_up_alt::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R},\n    Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,\n    phonon_id::Union{Int, Nothing} = nothing,\n    σ::R = 1.0\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator{T}}\n\nPerform a radial update to the phonon fields, as described by Algorithm 1 in the paper arXiv:2411.18218. Specifically, the proposed update to the phonon fields x is a rescaling such that x rightarrow e^gamma x where gamma sim N(0 sigmasqrtd) and d is the number of phonon fields being updated.\n\nArguments\n\nGup::Matrix{H}: Spin-up equal-time Greens function matrix.\nlogdetGup::R: Log of the determinant of the spin-up equal-time Greens function matrix.\nsgndetGup::H: Sign/phase of the determinant of the spin-up equal-time Greens function matrix.\nGdn::Matrix{H}: Spin-down equal-time Greens function matrix.\nlogdetGdn::R: Log of the determinant of the spin-down equal-time Greens function matrix.\nsgndetGdn::H: Sign/phase of the determinant of the spin-down equal-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,R}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{H,T}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{H,T}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{H,R}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{H,R}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_id::Union{Int, Nothing} = nothing: Apply radial update to phonon fields corresponding tp specified PHONON_ID. If phonon_id = nothing, then radial update is applied to all phonon fields.\nσ::R = 1.0: Relative size of the radial update.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.radial_update!-Union{Tuple{P}, Tuple{R}, Tuple{T}, Tuple{H}, Tuple{Matrix{H}, R, H, ElectronPhononParameters{T, R}}} where {H<:Number, T<:Number, R<:Real, P<:(AbstractPropagator{T})}","page":"API","title":"SmoQyDQMC.radial_update!","text":"radial_update!(\n    # ARGUMENTS\n    G::Matrix{H}, logdetG::R, sgndetG::H,\n    electron_phonon_parameters::ElectronPhononParameters{T,R};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{H,T},\n    fermion_greens_calculator::FermionGreensCalculator{H,R},\n    fermion_greens_calculator_alt::FermionGreensCalculator{H,R},\n    B::Vector{P}, rng::AbstractRNG,\n    phonon_id::Union{Int, Nothing} = nothing,\n    σ::R = 1.0\n) where {H<:Number, T<:Number, R<:Real, P<:AbstractPropagator{T}}\n\nPerform a radial update to the phonon fields, as described by Algorithm 1 in the paper arXiv:2411.18218. Specifically, the proposed update to the phonon fields x is a rescaling such that x rightarrow e^gamma x where gamma sim N(0 sigmasqrtd) and d is the number of phonon fields being updated.\n\nArguments\n\nG::Matrix{H}: equal-time Greens function matrix.\nlogdetG::R: Log of the determinant of the equal-time Greens function matrix.\nsgndetG::H: Sign/phase of the determinant of the equal-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,R}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{H,T}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{H,R}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{H,R}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_id::Union{Int, Nothing} = nothing: Apply radial update to phonon fields corresponding tp specified PHONON_ID. If phonon_id = nothing, then radial update is applied to all phonon fields.\nσ::R = 1.0: Relative size of the radial update.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.update_chemical_potential!","page":"API","title":"SmoQyDQMC.update_chemical_potential!","text":"update_chemical_potential!(\n    # ARGUMENTS\n    Gup::Matrix{H}, logdetGup::R, sgndetGup::H,\n    Gdn::Matrix{H}, logdetGdn::R, sgndetGdn::H;\n    # KEYWORD ARGUMENTS\n    chemical_potential_tuner::MuTunerLogger{R,H},\n    tight_binding_parameters::Union{TightBindingParameters, Nothing} = nothing,\n    tight_binding_parameters_up::Union{TightBindingParameters, Nothing} = nothing,\n    tight_binding_parameters_dn::Union{TightBindingParameters, Nothing} = nothing,\n    fermion_path_integral_up::FermionPathIntegral{H},\n    fermion_path_integral_dn::FermionPathIntegral{H},\n    fermion_greens_calculator_up::FermionGreensCalculator{H},\n    fermion_greens_calculator_dn::FermionGreensCalculator{H},\n    Bup::Vector{P}, Bdn::Vector{P}\n) where {H<:Number, R<:AbstractFloat, P<:AbstractPropagator}\n\nUpdate the chemical potential mu in the simulation to approach the target density/filling. This method returns the new values for (logdetGup, sgndetGup, logdetGup, sgndetGup). Note that either the keyword tight_binding_parameters needs to be specified, or tight_binding_parameters_up and tight_binding_parameters_dn both need to be specified.\n\n\n\n\n\nupdate_chemical_potential!(\n    # ARGUMENTS\n    G::Matrix{H}, logdetG::R, sgndetG::H;\n    # KEYWORD ARGUMENTS\n    chemical_potential_tuner::MuTunerLogger{R,H},\n    tight_binding_parameters::TightBindingParameters,\n    fermion_path_integral::FermionPathIntegral{H},\n    fermion_greens_calculator::FermionGreensCalculator{H},\n    B::Vector{P}\n) where {H<:Number, R<:AbstractFloat, P<:AbstractPropagator}\n\nUpdate the chemical potential mu in the simulation to approach the target density/filling. This method returns the new values for (logdetG, sgndetG).\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.save_density_tuning_profile","page":"API","title":"SmoQyDQMC.save_density_tuning_profile","text":"save_density_tuning_profile(\n    # ARGUMENTS\n    simulation_info::SimulationInfo,\n    chemical_potential_tuner::MuTunerLogger{R, H};\n    # KEYWORD ARGUMENTS\n    export_to_h5::Bool = true,\n    export_to_csv::Bool = false,\n    scientific_notation::Bool = false,\n    decimals::Int = 9,\n    delimiter::String = \" \",\n) where {R<:AbstractFloat, H<:Number}\n\nRecord the history of chemical potential and density tuning that occurred during the simulation, writing the information to an HDF5 and/or CSV file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.GLOBAL_MEASUREMENTS","page":"API","title":"SmoQyDQMC.GLOBAL_MEASUREMENTS","text":"const GLOBAL_MEASUREMENTS = (\n    \"logdetGup\",\n    \"logdetGdn\",\n    \"sgndetGup\",\n    \"sgndetGdn\",\n    \"sgn\",\n    \"action_total\",\n    \"action_bosonic\",\n    \"action_fermionic\",\n    \"density\",\n    \"density_up\",\n    \"density_dn\",\n    \"double_occ\",\n    \"Nsqrd\"\n)\n\nList of all the global measurements that are made.\n\n\n\n\n\n","category":"constant"},{"location":"api/#SmoQyDQMC.LOCAL_MEASUREMENTS","page":"API","title":"SmoQyDQMC.LOCAL_MEASUREMENTS","text":"const LOCAL_MEASUREMENTS = Base.ImmutableDict(\n    \"density\"                  => \"ORBITAL_ID\",\n    \"density_up\"               => \"ORBITAL_ID\",\n    \"density_dn\"               => \"ORBITAL_ID\",\n    \"double_occ\"               => \"ORBITAL_ID\",\n    \"onsite_energy\"            => \"ORBITAL_ID\",\n    \"onsite_energy_up\"         => \"ORBITAL_ID\",\n    \"onsite_energy_dn\"         => \"ORBITAL_ID\",\n    \"bare_hopping_energy\"      => \"HOPPING_ID\",\n    \"bare_hopping_energy_up\"   => \"HOPPING_ID\",\n    \"bare_hopping_energy_dn\"   => \"HOPPING_ID\",\n    \"hopping_energy\"           => \"HOPPING_ID\",\n    \"hopping_energy_up\"        => \"HOPPING_ID\",\n    \"hopping_energy_dn\"        => \"HOPPING_ID\",\n    \"hopping_amplitude_up\"     => \"HOPPING_ID\",\n    \"hopping_amplitude_dn\"     => \"HOPPING_ID\",\n    \"hopping_amplitude\"        => \"HOPPING_ID\",\n    \"hopping_inversion_up\"     => \"HOPPING_ID\",\n    \"hopping_inversion_dn\"     => \"HOPPING_ID\",\n    \"hopping_inversion\"        => \"HOPPING_ID\",\n    \"hubbard_energy\"           => \"HUBBARD_ID\",\n    \"ext_hub_energy\"           => \"EXT_HUB_ID\",\n    \"phonon_kin_energy\"        => \"PHONON_ID\",\n    \"phonon_pot_energy\"        => \"PHONON_ID\",\n    \"X\"                        => \"PHONON_ID\",\n    \"X2\"                       => \"PHONON_ID\",\n    \"X3\"                       => \"PHONON_ID\",\n    \"X4\"                       => \"PHONON_ID\",\n    \"holstein_energy\"          => \"HOLSTEIN_ID\",\n    \"holstein_energy_up\"       => \"HOLSTEIN_ID\",\n    \"holstein_energy_dn\"       => \"HOLSTEIN_ID\",\n    \"ssh_energy\"               => \"SSH_ID\",\n    \"ssh_energy_up\"            => \"SSH_ID\",\n    \"ssh_energy_dn\"            => \"SSH_ID\",\n    \"dispersion_energy\"        => \"DISPERSION_ID\"\n)\n\nList of all the local measurements than can be made, with a mapping to the corresponding type of ID each measurement is reported in terms of.\n\n\n\n\n\n","category":"constant"},{"location":"api/#SmoQyDQMC.CORRELATION_FUNCTIONS","page":"API","title":"SmoQyDQMC.CORRELATION_FUNCTIONS","text":"CORRELATION_FUNCTIONS = Base.ImmutableDict(\n    \"greens\"           => \"ORBITAL_ID\",\n    \"greens_up\"        => \"ORBITAL_ID\",\n    \"greens_dn\"        => \"ORBITAL_ID\",\n    \"greens_tautau\"    => \"ORBITAL_ID\",\n    \"greens_tautau_up\" => \"ORBITAL_ID\",\n    \"greens_tautau_dn\" => \"ORBITAL_ID\",\n    \"density\"          => \"ORBITAL_ID\",\n    \"density_upup\"     => \"ORBITAL_ID\",\n    \"density_dndn\"     => \"ORBITAL_ID\",\n    \"density_updn\"     => \"ORBITAL_ID\",\n    \"density_dnup\"     => \"ORBITAL_ID\",\n    \"spin_x\"           => \"ORBITAL_ID\",\n    \"spin_z\"           => \"ORBITAL_ID\",\n    \"pair\"             => \"BOND_ID\",\n    \"bond\"             => \"BOND_ID\",\n    \"bond_upup\"        => \"BOND_ID\",\n    \"bond_dndn\"        => \"BOND_ID\",\n    \"bond_updn\"        => \"BOND_ID\",\n    \"bond_dnup\"        => \"BOND_ID\",\n    \"current\"          => \"HOPPING_ID\",\n    \"current_upup\"     => \"HOPPING_ID\",\n    \"current_dndn\"     => \"HOPPING_ID\",\n    \"current_updn\"     => \"HOPPING_ID\",\n    \"current_dnup\"     => \"HOPPING_ID\",\n    \"phonon_greens\"    => \"PHONON_ID\"\n)\n\nList of all the correlation functions that can be measured, along with the corresponding type of ID the correlation measurement is reported in terms of. Correlation functions are well defined in both position and momentum space.\n\n\n\n\n\n","category":"constant"},{"location":"api/#SmoQyDQMC.initialize_measurement_container","page":"API","title":"SmoQyDQMC.initialize_measurement_container","text":"initialize_measurement_container(\n    model_geometry::ModelGeometry{D,T,N},\n    β::T, Δτ::T\n) where {T<:AbstractFloat, D, N}\n\nInitialize and return a measurement container of type NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_measurements!","page":"API","title":"SmoQyDQMC.initialize_measurements!","text":"initialize_measurements!(\n    measurement_container::NamedTuple,\n    tight_binding_model_up::TightBindingModel{T,E},\n    tight_binding_model_dn::TightBindingModel{T,E},\n) where {T<:Number, E<:AbstractFloat}\n\ninitialize_measurements!(\n    measurement_container::NamedTuple,\n    tight_binding_model::TightBindingModel{T,E}\n) where {T<:Number, E<:AbstractFloat}\n\nInitialize tight-binding model related measurements.\n\nInitialized Measurements\n\nonsite_energy: Refer to measure_onsite_energy.\nonsite_energy_up: Refer to measure_onsite_energy.\nonsite_energy_dn: Refer to measure_onsite_energy.\nhopping_energy: Refer to measure_hopping_energy.\nhopping_energy_up: Refer to measure_hopping_energy.\nhopping_energy_dn: Refer to measure_hopping_energy.\n\n\n\n\n\ninitialize_measurements!(\n    measurement_container::NamedTuple,\n    hubbard_model::HubbardModel{T}\n) where {T<:AbstractFloat}\n\nInitialize Hubbard model related measurements.\n\nInitialized Measurements:\n\nhubbard_energy: Refer to measure_hopping_energy.\n\n\n\n\n\ninitialize_measurements!(\n    measurement_container::NamedTuple,\n    extended_hubbard_model::ExtendedHubbardModel{T}\n) where {T<:AbstractFloat}\n\nInitialize Extended Hubbard model related measurements.\n\nInitialized Measurements:\n\next_hubbard_energy: Refer to measure_ext_hub_energy.\n\n\n\n\n\ninitialize_measurements!(\n    measurement_container::NamedTuple,\n    electron_phonon_model::ElectronPhononModel{T, E, D}\n) where {T<:Number, E<:AbstractFloat, D}\n\nInitialize electron-phonon model related measurements.\n\nInitialized Measurements:\n\nphonon_kinetic_energy: Refer to measure_phonon_kinetic_energy.\nphonon_potential_energy: Refer to measure_phonon_potential_energy.\nX: Measure langle hatX rangle, refer to measure_phonon_position_moment.\nX2: Measure langle hatX^2 rangle, refer to measure_phonon_position_moment.\nX3: Measure langle hatX^3 rangle, refer to measure_phonon_position_moment.\nX4: Measure langle hatX^4 rangle, refer to measure_phonon_position_moment.\nholstein_energy: Refer to measure_holstein_energy.\nholstein_energy_up: Refer to measure_holstein_energy.\nholstein_energy_dn: Refer to measure_holstein_energy.\nssh_energy: Refer to measure_ssh_energy.\nssh_energy_up: Refer to measure_ssh_energy.\nssh_energy_dn: Refer to measure_ssh_energy.\ndispersion_energy: Refer to measure_dispersion_energy.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_correlation_measurements!","page":"API","title":"SmoQyDQMC.initialize_correlation_measurements!","text":"initialize_correlation_measurements!(;\n    measurement_container::NamedTuple,\n    model_geometry::ModelGeometry{D,T,N},\n    correlation::String,\n    pairs::AbstractVector{NTuple{2,Int}},\n    time_displaced::Bool,\n    integrated::Bool = false\n)  where {T<:AbstractFloat, D, N}\n\nInitialize measurements of correlation for all ID pairs; refer to CORRELATION_FUNCTIONS for ID type associated with each correlation measurement. The name correlation must therefore also appear in [CORRELATION_FUNCTIONS]@ref. If time_displaced = true then time-displaced and integrated correlation measurements are made. If time_displaced = false and integrated = false, then just equal-time correlation measurements are made. If time_displaced = false and integrated = true, then both equal-time and integrated correlation measurements are made.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_composite_correlation_measurement!","page":"API","title":"SmoQyDQMC.initialize_composite_correlation_measurement!","text":"initialize_composite_correlation_measurement!(;\n    measurement_container::NamedTuple,\n    model_geometry::ModelGeometry{D,T,N},\n    name::String,\n    correlation::String,\n    ids::Union{Nothing,Vector{Int}} = nothing,\n    id_pairs::Union{Nothing,Vector{NTuple{2,Int}}} = nothing,\n    coefficients,\n    displacement_vecs = nothing,\n    time_displaced::Bool,\n    integrated::Bool = false\n)  where {T<:AbstractFloat, D, N}\n\nInitialize a composite correlation measurement called name based on a linear combination of local operators used in a standard correlation measurement.\n\nIf the keyword ids is passed and id_pairs = nothing, then the composite correlation function is given by\n\nbeginalign*\n    C_mathbfr(tau)  = frac1Nsum_mathbfilanglehatPhi_mathbfi+mathbfr^dagger(tau)hatPhi_mathbfi^phantomdagger(0)rangle \n                          = frac1Nsum_etanusum_mathbfic_eta^*c_nulanglehatO_mathbfi+mathbfreta^dagger(tau)hatO_mathbfinu^phantomdagger(0)rangle \n                          = sum_etanuc_eta^*c_nuC_mathbfr^etanu(tau)\nendalign*\n\nwhere the composite operator is\n\nhatPhi_mathbfmathbfr(tau)=sum_nuc_nuhatO_mathbfrnu(tau)\n\nThe sum over mathbfi runs over all unit cells, mathbfr denotes a displacement in unit cells and N is the number unit cells. The operator type hatO^nu and corresponding correlation function type C_mathbfr^etanu(tau) are specified by the correlation keyword, while nu corresponds to labels/IDs specified by the ids keyword argument. Lastly, the c_nu coefficients are specified using the coefficients keyword arguments. The corresponding fourier transform of this composite correlation function measurement is given by\n\nS_mathbfq(tau)=sum_etanusum_mathbfre^-rm imathbfqcdot(mathbfr+mathbfr_eta-mathbfr_nu)C_mathbfr^etanu(tau)\n\nwhere the static vectors mathbfr_nu are specified using the displacement_vecs keyword arguments. If displacement_vecs = nothing then mathbfr_nu = 0 for all label/ID values nu.\n\nOn the other hand, if id_pairs is passed and ids = nothing, then the composite correlation function is given by\n\nbeginalign*\n    C_mathbfr(tau)  = sum_nc_nC_mathbfr^eta_nnu_n(tau) \n                          = frac1Nsum_nsum_mathbfic_nlanglehatO_mathbfi+mathbfreta_n^dagger(tau)hatO_mathbfinu_n^phantomdagger(0)rangle\nendalign*\n\nwhere the n index runs over pairs of labels/IDs (nu_n eta_n) specified by the id_pairs keyword argument. Note that the order of the label/ID pair (nu_n eta_n) reflects how each tuple in the id_pairs vector will be interpreted. Once again, operator type hatO^nu_n and corresponding correlation function type C_mathbfr^eta_nnu_n(tau) are specified by the correlation keyword. The corresponding fourier transform of this composite correlation function measurement is given by\n\nS_mathbfq(tau)=sum_nsum_mathbfre^-rm imathbfqcdot(mathbfr+mathbfr_n)C_mathbfr^eta_nnu_n(tau)\n\nwhere the static displacement vectors mathbfr_n are specified by the displacement_vecs keyword argument. As before, if displacement_vecs = nothing, then mathbfr_n = 0 for all n.\n\nNote that the specified correlation type correlation needs to correspond to one of the keys in the global CORRELATION_FUNCTIONS dictionary, which lists all the predefined types of correlation functions that can be measured.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.make_measurements!","page":"API","title":"SmoQyDQMC.make_measurements!","text":"make_measurements!(\n    # ARGUMENTS\n    measurement_container::NamedTuple,\n    logdetGup::E, sgndetGup::T, Gup::AbstractMatrix{T},\n    Gup_ττ::AbstractMatrix{T}, Gup_τ0::AbstractMatrix{T}, Gup_0τ::AbstractMatrix{T},\n    logdetGdn::E, sgndetGdn::T, Gdn::AbstractMatrix{T},\n    Gdn_ττ::AbstractMatrix{T}, Gdn_τ0::AbstractMatrix{T}, Gdn_0τ::AbstractMatrix{T};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral_up::FermionPathIntegral{T,E},\n    fermion_path_integral_dn::FermionPathIntegral{T,E},\n    fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n    fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n    Bup::Vector{P}, Bdn::Vector{P},\n    model_geometry::ModelGeometry{D,E,N},\n    tight_binding_parameters::Union{Nothing, TightBindingParameters} = nothing,\n    tight_binding_parameters_up::Union{Nothing, TightBindingParameters} = nothing,\n    tight_binding_parameters_dn::Union{Nothing, TightBindingParameters} = nothing,\n    coupling_parameters::Tuple,\n    δG::E, δθ::E, δG_max::E = 1e-6\n) where {T<:Number, E<:AbstractFloat, D, N, P<:AbstractPropagator}\n\nMake measurements, including time-displaced correlation and zero Matsubara frequency measurements. This method also returns (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ). Note that either the keyword tight_binding_parameters needs to be specified, or tight_binding_parameters_up and tight_binding_parameters_dn both need to be specified.\n\n\n\n\n\nmake_measurements!(\n    # ARGUMENTS\n    measurement_container::NamedTuple,\n    logdetG::E, sgndetG::T, G::AbstractMatrix{T},\n    G_ττ::AbstractMatrix{T}, G_τ0::AbstractMatrix{T}, G_0τ::AbstractMatrix{T};\n    # KEYWORD ARGUMENTS\n    fermion_path_integral::FermionPathIntegral{T},\n    fermion_greens_calculator::FermionGreensCalculator{T,E},\n    B::Vector{P},\n    model_geometry::ModelGeometry{D,E,N},\n    tight_binding_parameters::TightBindingParameters,\n    coupling_parameters::Tuple,\n    δG::E, δθ::E, δG_max::E = 1e-6\n) where {T<:Number, E<:AbstractFloat, D, N, P<:AbstractPropagator}\n\nMake measurements, including time-displaced correlation and zero Matsubara frequency measurements. This method also returns (logdetG, sgndetG, δG, δθ).\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.write_measurements!","page":"API","title":"SmoQyDQMC.write_measurements!","text":"write_measurements!(;\n    measurement_container::NamedTuple,\n    simulation_info::SimulationInfo,\n    model_geometry::ModelGeometry{D, E, N},\n    Δτ::E,\n    bin_size::Int,\n    measurement::Int = 0,\n    bin::Int = measurement ÷ bin_size\n) where {D, E<:AbstractFloat, N}\n\nWrite the measurements contained in measurement_container to file if update % bin_size == 0. Measurements are written to file in a binary format using the JLD2.jl package.\n\nThis function also does a few other things:\n\nNormalizes all the measurements by the bin_size i.e. the number of measurements that were accumulated into the measurement container.\nTake position space correlation function measurements and fourier transform them to momentum space.\nIntegrate relevant time-displaced correlation function measurements over imaginary time to get the corresponding zero Matsubara frequency correlation function.\nReset all the measurements in measurement_container to zero after the measurements are written to file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.merge_bins","page":"API","title":"SmoQyDQMC.merge_bins","text":"merge_bins(\n    # ARGUMENTS\n    simulation_info::SimulationInfo\n)\n\nMerge the separate HDF5 files containing the binned measurements into a single HDF5 file. This is true even if the HDF5 \"files\" containing the binned data were held in memory during the simulation (simulation_info.write_bins_concurrent = false) instead of being actively written to file during the simulation (simulation_info.write_bins_concurrent = true).\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.rm_bins","page":"API","title":"SmoQyDQMC.rm_bins","text":"rm_bins(\n    comm::MPI.Comm,\n    datafolder::String\n)\n\nrm_bins(\n    datafolder::String\n)\n\nDelete the binned data stored in the datafolder directory. This function essentially deletes the directory datafolder/bins and its contents.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.write_jld2_checkpoint","page":"API","title":"SmoQyDQMC.write_jld2_checkpoint","text":"write_jld2_checkpoint(\n    # Arguments\n    comm::MPI.Comm,\n    simulation_info::SimulationInfo;\n    # Required Keyword Arguments\n    model_geometry::ModelGeometry,\n    measurement_container::NamedTuple,\n    # Optional Keyword Arguments\n    checkpoint_timestamp::T = 0.0,\n    checkpoint_freq::T = 0.0,\n    start_timestamp::T = 0.0,\n    runtime_limit::T = Inf,\n    error_code::Int = 13,\n    # Arbitrary Keyword Arguments Written to Checkpoint\n    kwargs...\n) where {T<:AbstractFloat}\n\nwrite_jld2_checkpoint(\n    # Arguments\n    simulation_info::SimulationInfo;\n    # Required Keyword Arguments\n    model_geometry::ModelGeometry,\n    measurement_container::NamedTuple,\n    # Optional Keyword Arguments\n    checkpoint_timestamp::T = 0.0,\n    checkpoint_freq::T = 0.0,\n    start_timestamp::T = 0.0,\n    runtime_limit::T = Inf,\n    error_code::Int = 13,\n    # Arbitrary Keyword Arguments Written to Checkpoint\n    kwargs...\n) where {T<:AbstractFloat}\n\nCheckpoint a simulation by writing a new checkpoint file if necessary The checkpoint file is a JLD2 binary file.\n\nArguments\n\ncomm::MPI.Comm: (optional) MPI communicator object used to synchronize processes. Ensures all MPI processes remain synchronized.\nsimulation_info::SimulationInfo: Contains datafolder and MPI process ID information.\n\nKeyword Arguments\n\ncheckpoint_timestamp::T = 0.0: (optional) Epoch timestamp of previously written checkpoint file.\ncheckpoint_freq::T = 0.0: (optional) Frequency with with checkpoint files are written; new checkpoint is written only if this many seconds has elapsed since previous checkpoint.\nstart_timestamp::T = 0.0: (optional) Epoch timestamp of the start time of the simulation.\nruntime_limit::T = Inf: (optional) Maximum runtime for simulation in seconds; if after writing a new checkpoint file the next checkpoint file that would be written in the future exceeds the runtime limit then exit the simulation.\nerror_code::Int = 13: (optional) Error code used to exit simulation if the runtime limit is exceeded.\nkwargs...: Additional keyword arguments containing the information that will stored in the checkpoint file; keyword arguments can point to arbitrary Julia objects.\n\nNotes\n\nThe default values for the checkpoint_timestamp, checkpoint_freq, start_timestamp, and runtime_limit keyword arguments result in there being no runtime limit for the simulation and a new checkpoint file being written every time this function is called.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.read_jld2_checkpoint","page":"API","title":"SmoQyDQMC.read_jld2_checkpoint","text":"read_jld2_checkpoint(\n    simulation_info::SimulationInfo\n)\n\nRead in a checkpoint file written using the write_jld2_checkpoint function and return its contents as a dictionary. This function returns the tuple (checkpoint, checkpoint_timestamp) where checkpoint is a dictionary containing the contents of the checkpoint file and checkpoint_timestamp is the epoch timestamp corresponding to when the checkpoint file was read in. Behind the scenes, the JLD2.jl package is used to read (and write) the checkpoint files.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.rm_jld2_checkpoints","page":"API","title":"SmoQyDQMC.rm_jld2_checkpoints","text":"rm_jld2_checkpoints(\n    # ARGUMENTS\n    comm::MPI.Comm,\n    simulation_info::SimulationInfo\n)\n\nrm_jld2_checkpoints(\n    # ARGUMENTS\n    simulation_info::SimulationInfo\n)\n\nDelete the JLD2 checkpoint files.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.rename_complete_simulation","page":"API","title":"SmoQyDQMC.rename_complete_simulation","text":"rename_complete_simulation(\n    # Arguments\n    comm::MPI.Comm,\n    simulation_info::SimulationInfo;\n    # Keyword Arguments\n    delete_jld2_checkpoints::Bool = true\n)\n\nrename_complete_simulation(\n    # Arguments\n    simulation_info::SimulationInfo;\n    # Keyword Arguments\n    delete_jld2_checkpoints::Bool = true\n)\n\nWhen a simulation is complete, this function renames the data folder the results were written to such that the directory name now begins with \"complete_\", making it simpler to identify which simulations no longer need to be resumed if checkpointing is being used. This function also deletes the any checkpoint files written using the write_jld2_checkpoint function if delete_jld2_checkpoints = true.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.save_simulation_info","page":"API","title":"SmoQyDQMC.save_simulation_info","text":"save_simulation_info(\n    # ARGUMENTS\n    sim_info::SimulationInfo,\n    metadata = nothing;\n    # KEYWORD ARGUMENTS\n    filename = @sprintf \"simulation_info_sID-%d_pID-%d.toml\" sim_info.sID sim_info.pID\n)\n\nSave the contents sim_info to a TOML file, and add an optional additional table to the output file based on the contents of a dictionary metadata.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.process_measurements","page":"API","title":"SmoQyDQMC.process_measurements","text":"process_measurements(\n    # ARGUMENTS\n    comm::MPI.Comm;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    ...\n)\n\nprocess_measurements(;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    ...\n)\n\nProcess the HDF5 files containing the binned data generated by a DQMC simulation, and then write final statistics to a new HDF5 file(s). There is also functionality available that allows the final stats to then be exported to CSV files as well.\n\nWhen the first passed arguments is comm::MPI.Comm, then the workflow is parallelized using MPI.\n\nKeyword Arguments\n\nThis function has many possible keyword arguments. Below I group them together into related categories and define their meanings.\n\nRequired Keyword Arguments\n\ndatafolder::String: Specify the directory generated by a DQMC simulation into which all the results were written.\n\nKeyword for Controlling Workflow\n\nn_bins::Union{Int, Nothing} = nothing: Number of bins used to calculate statistics. If nothing then set equal to the number of data bins written to file during the simulation. Must be a factor of the number of bins written to file during the DQMC simulation.\npIDs::Union{Int,Vector{Int}} = Int[]: Specifies for which process IDs to calculate average statistics. If pIDs = Int[], the calculate for all process IDs. If comm::MPI.Comm is passed as first function argument then pIDs must be of type Vector{Int} and not Int.\nfilename_prefix::String = \"stats\": Start of filename for HDF5 containing final statistics. HDF5 files containing statistics for a single process ID will end with pID-$(pID).h5.\nrm_binned_data::Bool = false: Whether to delete the binned data after final statistics are computed.\n\nKeywords for Exporting Statistics to CSV\n\nexport_to_csv::Bool = true: Whether to export the final statistics to CSV file.\nscientific_notation::Bool = false: Whether to use scientific notation when exporting statistics to CSV file.\ndecimals::Int = 9: How many decimal places to include when exporting statistics to CSV files.\ndelimiter::String = \" \": Delimiter used when writing CSV files.\n\nKeyword Acting as Boolean Flags Indicating Which Statistics to Compute\n\nprocess_global_measurements::Bool = true: Whether to calculate the statistics for global measurements.\nprocess_local_measurements::Bool = true: Whether to calculate the statistics for local measurements.\nprocess_all_equal_time_measurements::Bool = true: Whether to calculate statistics for all equal-time correlation measurements.\nprocess_all_time_displaced_measurements::Bool = false: Whether to calculate statistics for all time-displaced correlation measurements.\nprocess_all_integrated_measurements::Bool = true: Whether to calculate statistics for all integrated correlation measurements.\n\nKeyword Specifying Specific Correlation Statistics to Compute\n\nIf process_all_equal_time_measurements = false, then the keyword arguments below can be used to specify which specific equal-time correlation measurements to calculate statistics for.\n\nstandard_equal_time::Vector{String} = String[]\ncomposite_integrated::Vector{String} = String[]\n\nIf process_all_time_displaced_measurements = true, then the keyword arguments below can be used to specify which specific time-displaced correlation measurements to calculate statistics for.\n\nstandard_time_displaced::Vector{String} = String[]\ncomposite_time_displaced::Vector{String} = String[]\n\nIf process_all_integrated_measurements = false, then the keyword arguments below can be used to specify which specific integrated correlation measurements to calculate statistics for.\n\nstandard_integrated::Vector{String} = String[]\ncomposite_integrated::Vector{String} = String[]\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.compute_correlation_ratio","page":"API","title":"SmoQyDQMC.compute_correlation_ratio","text":"compute_correlation_ratio(\n    comm::MPI.Comm;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    correlation::String,\n    type::String,\n    id_pairs::Vector{NTuple{2,Int}},\n    id_pair_coefficients::Vector{T},\n    q_point::NTuple{D,Int},\n    q_neighbors::Vector{NTuple{D,Int}},\n    num_bins::Int = 0,\n    pIDs::Vector{Int} = Int[],\n) where {D, T<:Number}\n\ncompute_correlation_ratio(;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    correlation::String,\n    type::String,\n    id_pairs::Vector{NTuple{2,Int}},\n    id_pair_coefficients::Vector{T},\n    q_point::NTuple{D,Int},\n    q_neighbors::Vector{NTuple{D,Int}},\n    num_bins::Int = 0,\n    pIDs::Union{Int,Vector{Int}} = Int[]\n) where {D, T<:Number}\n\nCompute the correlation ratio at the mathbfk-point using a linear combination of standard correlation function measurements. The linear combination of correlation functions used is defined by id_pairs and coefs. If type is \"equal-time\" or \"time-displaced\" then the equal-time correlation ratio is calculated. If type is \"integrated\" then the integrated correlation ratio is calculated.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.compute_composite_correlation_ratio","page":"API","title":"SmoQyDQMC.compute_composite_correlation_ratio","text":"compute_composite_correlation_ratio(\n    comm::MPI.Comm;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    name::String,\n    type::String,\n    q_point::NTuple{D,Int},\n    q_neighbors::Vector{NTuple{D,Int}},\n    pIDs::Vector{Int} = Int[]\n) where {D}\n\ncompute_composite_correlation_ratio(;\n    # Keyword Arguments\n    datafolder::String,\n    name::String,\n    type::String,\n    q_point::NTuple{D,Int},\n    q_neighbors::Vector{NTuple{D,Int}},\n    num_bins::Int = 0,\n    pIDs::Union{Int,Vector{Int}} = Int[]\n) where {D}\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.compute_function_of_correlations","page":"API","title":"SmoQyDQMC.compute_function_of_correlations","text":"compute_function_of_correlations(\n    # ARGUMENTS\n    comm::MPI.Comm;\n    # KEYWORD ARGUMENTS\n    f::Function,\n    datafolder::String,\n    correlations::AbstractVector{<:NamedTuple},\n    num_bins::Int = 0,\n    pIDs::Vector{Int} = Int[],\n)\n\ncompute_function_of_correlations(;\n    # KEYWORD ARGUMENTS\n    f::Function,\n    datafolder::String,\n    correlations::AbstractVector{<:NamedTuple},\n    num_bins::Int = 0,\n    pIDs::Union{Int,Vector{Int}} = Int[]\n)\n\nCalculate the mean and error associated with computing a function of measured correlation functions.\n\nThe correlation measurements that are passed as arguments to the function to evaluate are specified by the vector of named tuples correlations. The keys of the named tuple used to specify the correlation measurements are given below:\n\nname::String: Name of correlation function.\ntype::String: Specifies whether to use \"EQUAL-TIME\", \"TIME-DISPLACED\" or \"INTEGRATED\" correlation measurement.\nid_pair::NTuple{2,Int}: If a standard correlation measurement, then specifies the ID pair for the correlation measurement.\nR::NTuple{D,Int} xor K::NTuple{D,Int}: Specifies either displacement vector or momentum point in D dimensions.\nτ::Float64 xor l::Int: Imaginary-time or imaginary-time slice used if the type is \"TIME-DISPLACED\".\n\nKeyword Arguments\n\nf::Function: The function to evaluate.\ndatafolder::String: Output directory generated by SmoQyDQMC simulation.\ncorrelations::AbstractVector{NamedTuple}: Vector of named tuples specifying the correlation measurement function arguments.\nnum_bins::Int = 0: Number of bins used to compute statistics. If zero then use all number of bins.\npIDs = Int[]: Process ID's used when measuring function of correlation measurements. If is Int[], then all process ID's are used.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.export_global_stats_to_csv","page":"API","title":"SmoQyDQMC.export_global_stats_to_csv","text":"export_global_stats_to_csv(\n    # ARGUMENTS\n    comm::MPI.Comm;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    h5filename::String = \"stats.h5\",,\n    csvfilename_prefix::String = \"global\",\n    measurements::Vector{String} = String[],\n    decimals::Int = 6,\n    scientific_notation::Bool = false,\n    delimiter::String = \" \"\n)\n\nexport_global_stats_to_csv(;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    h5filename::String = \"stats.h5\",,\n    csvfilename_prefix::String = \"global\",\n    measurements::Vector{String} = String[],\n    decimals::Int = 6,\n    scientific_notation::Bool = false,\n    delimiter::String = \" \"\n)\n\nThis function writes the global measurement statistics stored in the h5filename HDF5 file found in the directory datafolder to CSV file, returning the name of the CSV file that was written. The measurements keyword argument specifies the measurements to be exported. If measurements = String[], then all measurements are exported.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.export_global_bins_to_h5","page":"API","title":"SmoQyDQMC.export_global_bins_to_h5","text":"export_global_bins_to_h5(\n    # ARGUMENTS\n    comm::MPI.Comm;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    filename_prefix::String = \"global_bins\",\n    pIDs::Union{Vector{Int},Int} = Int[],\n    global_measurements::Vector{String} = String[] \n)\n\nexport_global_bins_to_h5(;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    filename_prefix::String = \"global_bins\",\n    pIDs::Union{Vector{Int},Int} = Int[],\n    global_measurements::Vector{String} = String[]\n)\n\nExport the binned global measurements for specified process IDs pIDs to a single HDF5 file. If pIDs = Int[], then binned global measurements for all process IDs are exported. You can specify a subset of specific global measurements using the global_measurements keyword argument. If global_measurements = String[], then all global measurements are exported.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.export_global_bins_to_csv","page":"API","title":"SmoQyDQMC.export_global_bins_to_csv","text":"export_global_bins_to_csv(\n    # ARGUMENTS\n    comm::MPI.Comm;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    filename_prefix::String = \"global_bins\",\n    pIDs::Union{Vector{Int},Int} = Int[],\n    global_measurements::Vector{String} = String[],\n    decimals::Int = 9,\n    scientific_notation::Bool = false,\n    delimiter::String = \" \"\n)\n\nexport_global_bins_to_csv(;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    filename_prefix::String = \"global_bins\",\n    pIDs::Union{Vector{Int},Int} = Int[],\n    global_measurements::Vector{String} = String[],\n    decimals::Int = 9,\n    scientific_notation::Bool = false,\n    delimiter::String = \" \"\n)\n\nExport the binned global measurements for specified process IDs pIDs to a single CSV file. If pIDs = Int[], then binned global measurements for all process IDs are exported. You can specify a subset of specific global measurements using the global_measurements keyword argument. If global_measurements = String[], then all global measurements are exported.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.export_local_stats_to_csv","page":"API","title":"SmoQyDQMC.export_local_stats_to_csv","text":"export_local_stats_to_csv(\n    # ARGUMENTS\n    comm::MPI.Comm;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    h5filename::String = \"stats.h5\",\n    csvfilename_prefix::String = \"local\",\n    measurements::Vector{String} = String[],\n    decimals::Int = 6,\n    scientific_notation::Bool = false,\n    delimiter::String = \" \"\n)\n\nexport_local_stats_to_csv(;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    h5filename::String = \"stats.h5\",\n    csvfilename_prefix::String = \"local\",\n    measurements::Vector{String} = String[],\n    decimals::Int = 6,\n    scientific_notation::Bool = false,\n    delimiter::String = \" \"\n)\n\nThis function writes the local measurement statistics stored in the h5filename HDF5 file found in the directory datafolder to CSV file, returning the name of the CSV file that was written. The measurements keyword argument specifies the measurements to be exported. If measurements = String[], then all measurements are exported.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.export_local_bins_to_csv","page":"API","title":"SmoQyDQMC.export_local_bins_to_csv","text":"export_local_bins_to_csv(\n    # ARGUMENTS\n    comm::MPI.Comm;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    filename_prefix::String = \"local_bins\",\n    pIDs::Union{Vector{Int},Int} = Int[],\n    local_measurements::Vector{String} = String[],\n    decimals::Int = 9,\n    scientific_notation::Bool = false,\n    delimiter::String = \" \"\n)\n\nexport_local_bins_to_csv(;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    filename_prefix::String = \"local_bins\",\n    pIDs::Union{Vector{Int},Int} = Int[],\n    local_measurements::Vector{String} = String[],\n    decimals::Int = 9,\n    scientific_notation::Bool = false,\n    delimiter::String = \" \"\n)\n\nExport the binned local measurements for specified process IDs pIDs to a single CSV file. If pIDs = Int[], then binned local measurements for all process IDs are exported. You can specify a subset of specific local measurements using the local_measurements keyword argument. If local_measurements = String[], then all local measurements are exported.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.export_local_bins_to_h5","page":"API","title":"SmoQyDQMC.export_local_bins_to_h5","text":"export_local_bins_to_h5(\n    # ARGUMENTS\n    comm::MPI.Comm;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    filename_prefix::String = \"local_bins\",\n    pIDs::Union{Vector{Int},Int} = Int[],\n    local_measurements::Vector{String} = String[],\n)\n\nexport_local_bins_to_h5(;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    filename_prefix::String = \"local_bins\",\n    pIDs::Union{Vector{Int},Int} = Int[],\n    local_measurements::Vector{String} = String[],\n)\n\nExport the binned local measurements for specified process IDs pIDs to a single HDF5 file. If pIDs = Int[], then binned local measurements for all process IDs are exported. You can specify a subset of specific local measurements using the local_measurements keyword argument. If local_measurements = String[], then all local measurements are exported.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.export_correlation_stats_to_csv","page":"API","title":"SmoQyDQMC.export_correlation_stats_to_csv","text":"export_correlation_stats_to_csv(\n    # ARGUMENTS\n    comm::MPI.Comm;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    correlation::String,\n    type::String,\n    space::String,\n    h5filename::HDF5.File = \"stats.h5\",\n    decimals::Int = 6,\n    scientific_notation::Bool = false,\n    delimiter::String = \" \"\n)\n\nexport_correlation_stats_to_csv(;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    correlation::String,\n    type::String,\n    space::String,\n    h5filename::HDF5.File = \"stats.h5\",\n    decimals::Int = 6,\n    scientific_notation::Bool = false,\n    delimiter::String = \" \"\n)\n\nExport statistics for specified type of correlation function from HDF5 file to a CSV file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.export_correlation_bins_to_csv","page":"API","title":"SmoQyDQMC.export_correlation_bins_to_csv","text":"export_correlation_bins_to_csv(\n    # ARGUMENTS\n    comm::MPI.Comm;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    correlation::String,\n    type::String,\n    space::String,\n    pIDs::Union{Vector{Int},Int} = Int[],\n    write_index_key::Bool = true,\n    decimals::Int = 6,\n    scientific_notation::Bool = false,\n    delimiter::String = \" \"\n)\n\nexport_correlation_bins_to_csv(;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    correlation::String,\n    type::String,\n    space::String,\n    pIDs::Union{Vector{Int},Int} = Int[],\n    write_index_key::Bool = true,\n    decimals::Int = 6,\n    scientific_notation::Bool = false,\n    delimiter::String = \" \"\n)\n\nExport the binned data for a specified type of correlation to an CSV file living in the directory /datafolder/type/correlation/space. The type of correlation function is specified by type ∈ (\"equal-time\", \"time-displaced\", \"integrated\"). Where the correlation function is in position or momentum space is given by space ∈ (\"momentum\", \"position\"). The pIDs keyword specifies for which process IDs the binned correlation data is exported. If pIDs = Int[], then binned local measurements for all process IDs are exported. If write_index_key = true, then another CSV file is written to the /datafolder/type/correlation/space directory which provides a key on how to interpret the INDEX column appearing in the CSV file containing the binned data.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.export_correlation_bins_to_h5","page":"API","title":"SmoQyDQMC.export_correlation_bins_to_h5","text":"export_correlation_bins_to_h5(\n    # ARGUMENTS\n    comm::MPI.Comm;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    correlation::String,\n    type::String,\n    space::String,\n    pIDs::Union{Vector{Int},Int} = Int[]\n)\n\nexport_correlation_bins_to_h5(;\n    # KEYWORD ARGUMENTS\n    datafolder::String,\n    correlation::String,\n    type::String,\n    space::String,\n    pIDs::Union{Vector{Int},Int} = Int[]\n)\n\nExport the binned data for a specified type of correlation to an HDF5 file living in the directory /datafolder/type/correlation/space. The type of correlation function is specified by type ∈ (\"equal-time\", \"time-displaced\", \"integrated\"). Where the correlation function is in position or momentum space is given by space ∈ (\"momentum\", \"position\"). The pIDs keyword specifies for which process IDs the binned correlation data is exported. If pIDs = Int[], then binned local measurements for all process IDs are exported.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/holstein_honeycomb/#2a)-Honeycomb-Holstein-Model","page":"2a) Honeycomb Holstein Model","title":"2a) Honeycomb Holstein Model","text":"Download this example as a Julia script.\n\nIn this example we will work through simulating the Holstein model on a honeycomb lattice. The Holstein Hamiltonian is given by\n\nbeginalign*\nhatH =  -t sum_langle i j rangle sigma (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n- mu sum_isigma hatn_sigmai \n + frac12 M Omega^2 sum_i hatX_i^2 + sum_i frac12M hatP_i^2\n+ alpha sum_i hatX_i (hatn_uparrowi + hatn_downarrowi - 1)\nendalign*\n\nwhere hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. Here mu is the chemical potential and  t is the nearest-neighbor hopping amplitude, with the sum over langle ij rangle denoting a sum over all nearest-neighbor pairs of sites. A local dispersionless phonon mode is then placed on each site in the lattice, with hatX_i and hatP_i the corresponding phonon position and momentum operator on site i in the lattice. The phonon mass and energy are denoted M and Omega respectively. Lastly, the phonon displacement hatX_i couples to the total local density hatn_uparrowi + hatn_downarrowi with the parameter alpha controlling the strength of this coupling.","category":"section"},{"location":"tutorials/holstein_honeycomb/#Import-packages","page":"2a) Honeycomb Holstein Model","title":"Import packages","text":"As in the previous tutorial, we begin by importing the necessary packages; for more details refer to here.\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf","category":"section"},{"location":"tutorials/holstein_honeycomb/#Specify-simulation-parameters","page":"2a) Honeycomb Holstein Model","title":"Specify simulation parameters","text":"The entire main body of the simulation we will wrapped in a top-level function named run_simulation that will take as keyword arguments various model and simulation parameters that we may want to change. The function arguments with default values are ones that are typically left unchanged between simulations.\n\n# Top-level function to run simulation.\nfunction run_simulation(;\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    Nt = 8, # Number of time-steps in HMC update.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"section"},{"location":"tutorials/holstein_honeycomb/#Initialize-simulation","page":"2a) Honeycomb Holstein Model","title":"Initialize simulation","text":"In this first part of the script we name and initialize our simulation, record important metadata about the simulation and create the data folder our simulation results will be written to. For more information refer to here.\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_honeycomb_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 7),\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb/#Initialize-simulation-metadata","page":"2a) Honeycomb Holstein Model","title":"Initialize simulation metadata","text":"In this section of the code we record important metadata about the simulation, including initializing the random number generator that will be used throughout the simulation. The important metadata within the simulation will be recorded in the metadata dictionary.\n\n    # Initialize random number generator\n    rng = Xoshiro(seed)\n\n    # Initialize metadata dictionary\n    metadata = Dict()\n\n    # Record simulation parameters.\n    metadata[\"Nt\"] = Nt\n    metadata[\"N_therm\"] = N_therm\n    metadata[\"N_measurements\"] = N_measurements\n    metadata[\"N_bins\"] = N_bins\n    metadata[\"n_stab\"] = n_stab\n    metadata[\"dG_max\"] = δG_max\n    metadata[\"symmetric\"] = symmetric\n    metadata[\"checkerboard\"] = checkerboard\n    metadata[\"seed\"] = seed\n\nHere we also update variables to keep track of the acceptance rates for the various types of Monte Carlo updates that will be performed during the simulation. This will be discussed in more detail in later sections of the tutorial.\n\n    metadata[\"hmc_acceptance_rate\"] = 0.0\n    metadata[\"reflection_acceptance_rate\"] = 0.0\n    metadata[\"swap_acceptance_rate\"] = 0.0","category":"section"},{"location":"tutorials/holstein_honeycomb/#Initialize-model","page":"2a) Honeycomb Holstein Model","title":"Initialize model","text":"The next step is define the model we wish to simulate. In this example the relevant model parameters the phonon energy Omega (Ω), electron-phonon coupling alpha (α), chemical potential mu (μ), and lattice size L (L). The nearest-neighbor hopping amplitude and phonon mass are normalized to unity, t = M = 1.\n\n    # Define lattice vectors.\n    a1 = [+3/2, +√3/2]\n    a2 = [+3/2, -√3/2]\n\n    # Define basis vectors for two orbitals in the honeycomb unit cell.\n    r1 = [0.0, 0.0] # Location of first orbital in unit cell.\n    r2 = [1.0, 0.0] # Location of second orbital in unit cell.\n\n    # Define the unit cell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [a1, a2],\n        basis_vecs = [r1, r2]\n    )\n\n    # Define finite lattice with periodic boundary conditions.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize model geometry.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the first nearest-neighbor bond in a honeycomb lattice.\n    bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n    # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_1_id = add_bond!(model_geometry, bond_1)\n\n    # Define the second nearest-neighbor bond in a honeycomb lattice.\n    bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n    # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_2_id = add_bond!(model_geometry, bond_2)\n\n    # Define the third nearest-neighbor bond in a honeycomb lattice.\n    bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n    # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_3_id = add_bond!(model_geometry, bond_3)\n\nNext we specify the Honeycomb tight-binding term in our Hamiltonian with the TightBindingModel type.\n\n    # Set nearest-neighbor hopping amplitude to unity,\n    # setting the energy scale in the model.\n    t = 1.0\n\n    # Define the honeycomb tight-binding model.\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_1, bond_2, bond_3], # defines hopping\n        t_mean = [t, t, t], # defines corresponding hopping amplitude\n        μ  = μ, # set chemical potential\n        ϵ_mean = [0.0, 0.0] # set the (mean) on-site energy\n    )\n\nNow we need to initialize the electron-phonon part of the Hamiltonian with the ElectronPhononModel type.\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\nThen we need to define and add two types phonon modes to the model, one for each orbital in the Honeycomb unit cell, using the PhononMode type and add_phonon_mode! function.\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon_1 = PhononMode(\n        basis_vec = r1,\n        Ω_mean = Ω\n    )\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_1_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_1\n    )\n\n    # Define a dispersionless electron-phonon mode to live on the second sublattice.\n    phonon_2 = PhononMode(\n        basis_vec = r2,\n        Ω_mean = Ω\n    )\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_2_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_2\n    )\n\nNow we need to define and add a local Holstein couplings to our model for each of the two phonon modes in each unit cell using the HolsteinCoupling type and add_holstein_coupling! function. Here, when initializing the HolsteinCoupling type the boolean ph_sym_form keyword argument indicates whether the particle-hole symmetric form (ph_sym_form = true) the Holstein interaction alpha hatX_i left(hatn_sigmai - frac12right) is used, or the form alpha hatX_i hatn_sigmai is used (ph_sym_form = false).\n\n    # Define first local Holstein coupling for first phonon mode.\n    holstein_coupling_1 = HolsteinCoupling(\n        model_geometry = model_geometry,\n        phonon_id = phonon_1_id,\n        orbital_id = 1,\n        displacement = [0, 0],\n        α_mean = α,\n        ph_sym_form = true,\n    )\n\n    # Add the first local Holstein coupling definition to the model.\n    holstein_coupling_1_id = add_holstein_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        holstein_coupling = holstein_coupling_1,\n        model_geometry = model_geometry\n    )\n\n    # Define second local Holstein coupling for second phonon mode.\n    holstein_coupling_2 = HolsteinCoupling(\n        model_geometry = model_geometry,\n        phonon_id = phonon_2_id,\n        orbital_id = 2,\n        displacement = [0, 0],\n        α_mean = α,\n        ph_sym_form = true,\n    )\n\n    # Add the second local Holstein coupling definition to the model.\n    holstein_coupling_2_id = add_holstein_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        holstein_coupling = holstein_coupling_2,\n        model_geometry = model_geometry\n    )\n\nLastly, the model_summary function is used to write a model_summary.toml file, completely specifying the Hamiltonian that will be simulated.\n\n    # Write model summary TOML file specifying Hamiltonian that will be simulated.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb/#Initialize-model-parameters","page":"2a) Honeycomb Holstein Model","title":"Initialize model parameters","text":"The next step is to initialize our model parameters given the size of our finite lattice. To clarify, both the TightBindingModel and ElectronPhononModel types are agnostic to the size of the lattice being simulated, defining the model in a translationally invariant way. As SmoQyDQMC.jl supports random disorder in the terms appearing in the Hamiltonian, it is necessary to initialize separate parameter values for each unit cell in the lattice. For instance, we need to initialize a separate number to represent the on-site energy for each orbital in our finite lattice.\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb/#Initialize-measurements","page":"2a) Honeycomb Holstein Model","title":"Initialize measurements","text":"Having initialized both our model and the corresponding model parameters, the next step is to initialize the various measurements we want to make during our DQMC simulation. For more information refer to here.\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [\n            # Measure green's functions for all pairs or orbitals.\n            (1, 1), (2, 2), (1, 2)\n        ]\n    )\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [\n            # Measure green's functions for all pairs of modes.\n            (1, 1), (2, 2), (1, 2)\n        ]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            (1, 1), (2, 2),\n        ]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            # Measure local s-wave pair susceptibility associated with\n            # each orbital in the unit cell.\n            (1, 1), (2, 2)\n        ]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            (1, 1), (2, 2)\n        ]\n    )\n\nIt is also useful to initialize more specialized composite correlation function measurements.\n\nFirst, it can be useful to measure the time-displaced single-particle electron Green's function traced over both orbitals in the unit cell. We can easily implement this measurement using the initialize_composite_correlation_measurement! function, as shown below.\n\n    # Initialize measurement of electron Green's function traced\n    # over both orbitals in the unit cell.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"tr_greens\",\n        correlation = \"greens\",\n        id_pairs = [(1,1), (2,2)],\n        coefficients = [1.0, 1.0],\n        time_displaced = true,\n    )\n\nAdditionally, to detect the formation of charge-density wave order where the electrons preferentially localize on one of the two sub-lattices of the honeycomb lattice, it is useful to measure the correlation function\n\nC_textcdw(mathbfrtau) = frac1L^2sum_mathbfi langle hatPhi^dagger_mathbfi+mathbfr(tau) hatPhi^phantomdagger_mathbfi(0) rangle\n\nwhere\n\nhatPhi_mathbfi(tau) = hatn_mathbfiA(tau) - hatn_mathbfiB(tau)\n\nand hatn_mathbfigamma = (hatn_uparrowmathbfio + hatn_downarrowmathbfio) is the total electron number operator for orbital gamma in AB in unit cell mathbfi. It is then also useful to calculate the corresponding structure factor S_textcdw(mathbfqtau) and susceptibility chi_textcdw(mathbfq) Again, this can all be easily calculated using the initialize_composite_correlation_measurement! function, as shown below.\n\n    # Initialize CDW correlation measurement.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"cdw\",\n        correlation = \"density\",\n        ids = [1, 2],\n        coefficients = [1.0, -1.0],\n        displacement_vecs = [[0.0, 0.0], [0.0, 0.0]],\n        time_displaced = false,\n        integrated = true\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb/#Setup-DQMC-simulation","page":"2a) Honeycomb Holstein Model","title":"Setup DQMC simulation","text":"This section of the code sets up the DQMC simulation by allocating the initializing the relevant types and arrays we will need in the simulation.\n\nThis section of code is perhaps the most opaque and difficult to understand, and will be discussed in more detail once written. That said, you do not need to fully comprehend everything that goes on in this section as most of it is fairly boilerplate, and will not need to be changed much once written. This is true even if you want to modify this script to perform a DQMC simulation for a different Hamiltonian. For more information refer to here.\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing EFA-HMC, reflection and swap updates below.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time electron Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize electron Green's function matrix, also calculating the matrix determinant as the same time.\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize diagnostic parameters to asses numerical stability.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)","category":"section"},{"location":"tutorials/holstein_honeycomb/#holstein_square_efa-hmc_updates","page":"2a) Honeycomb Holstein Model","title":"Setup EFA-HMC Updates","text":"Before we begin the simulation, we also want to initialize an instance of the EFAHMCUpdater type, which will be used to perform hybrid Monte Carlo (HMC) updates to the phonon fields that use exact fourier acceleration (EFA) to further reduce autocorrelation times.\n\nThe two main parameters that need to be specified are the time-step size Delta t and number of time-steps N_t performed in the HMC update, with the corresponding integrated trajectory time then equalling T_t = N_t cdot Delta t Note that the computational cost of an HMC update is linearly proportional to N_t while the acceptance rate is approximately proportional to 1(Delta t)^2\n\nPrevious studies have shown that a good place to start with the integrated trajectory time T_t is a quarter the period associated with the bare phonon frequency, T_t approx frac14 left( frac2piOmega right) = pi(2Omega) However, in our implementation we effectively normalize all of the bare phonon frequencies to unity in the dynamics. Therefore, a good choice for the trajectory time in our implementation is simply T_t = pi2. Therefore, in most cases you simply need to select a value for N_t and then use the default assigned time-step Delta t = pi  (2 N_t), such that the trajectory length is held fixed at T_t = pi2. With this convention the computational cost of performing updates still increases linearly with N_t, but the acceptance rate also increases with N_t. Note that it can be important to keep the acceptance rate for the HMC updates above sim 90 to avoid numerical instabilities from occurring.\n\nBased on user experience, a good (conservative) starting place is to set the number of time-steps to N_t approx 10 Then, if the acceptance rate is too low you increase N_t which implicitly results in a reduction of Delta t Conversely, if the acceptance rate is very high (gtrsim 99  ) it may be useful to decrease N_t, thereby increasing Delta t as this will reduce the computational cost of performing an EFA-HMC update.\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = π/(2*Nt) # Δt argument is optional\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb/#Thermalize-system","page":"2a) Honeycomb Holstein Model","title":"Thermalize system","text":"The next section of code performs updates to thermalize the system prior to beginning measurements. In addition to EFA-HMC updates that will be performed using the EFAHMCUpdater type initialized above and the hmc_update! function below, we will also perform reflection and swap updates using the reflection_update! and swap_update! functions respectively.\n\n    # Iterate over number of thermalization updates to perform.\n    for n in 1:N_therm\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb/#Make-measurements","page":"2a) Honeycomb Holstein Model","title":"Make measurements","text":"In this next section of code we continue to sample the phonon fields as above, but will also begin making measurements as well. For more discussion on the overall structure of this part of the code, refer to here.\n\n    # Reset diagnostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for measurement in 1:N_measurements\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Make measurements.\n        (logdetG, sgndetG, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (electron_phonon_parameters,)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb/#Merge-binned-data","page":"2a) Honeycomb Holstein Model","title":"Merge binned data","text":"At this point the simulation is essentially complete, with all updates and measurements having been performed. However, the binned measurement data resides in many separate HDF5 files currently. Here we will merge these separate HDF5 files into a single file containing all the binned data using the merge_bins function.\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb/#Record-simulation-metadata","page":"2a) Honeycomb Holstein Model","title":"Record simulation metadata","text":"At this point we are done sampling and taking measurements. Next, we want to calculate the final acceptance rate for the various types of update we performed, as well as write the simulation metadata to file, including the contents of the metadata dictionary.\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Record largest numerical error encountered during simulation.\n    metadata[\"dG\"] = δG\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)","category":"section"},{"location":"tutorials/holstein_honeycomb/#Post-process-results","page":"2a) Honeycomb Holstein Model","title":"Post-process results","text":"In this final section of code we post-process the binned data. This includes calculating the final estimates for the mean and error of all measured observables, which will be written to an HDF5 file using the process_measurements function. Inside this function the binned data gets further re-binned into n_bins, where n_bins is any positive integer satisfying the constraints (N_bins ≥ n_bin) and (N_bins % n_bins == 0). Note that the process_measurements function has many additional keyword arguments that can be used to control the output. For instance, in this example in addition to writing the statistics to an HDF5 file, we also export the statistics to CSV files by setting export_to_csv = true, with additional keyword arguments controlling the formatting of the CSV files. Again, for more information on how to interpret the output refer the Simulation Output Overview page.\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\nA common measurement that needs to be computed at the end of a DQMC simulation is something called the correlation ratio with respect to the ordering wave-vector for a specified type of structure factor measured during the simulation. In the case of the honeycomb Holstein model, we are interested in measuring the correlation ratio\n\nR_textcdw(0) = 1 - frac14 sum_deltamathbfq fracS_textcdw(0 + deltamathbfq)S_textcdw(0)\n\nwith respect to the equal-time charge density wave (CDW) structure factor S_textcdw(0), where `S_\\text{cdw}(q) is equal-time structure factor corresponding to the composite correlation function C_textcdw(mathbfrtau) defined earlier in this tutorial. Note that the CDW ordering wave-vector is mathbfQ_textcdw = 0 in this case, which describes the electrons preferentially localizing on one of the two sub-lattices of the honeycomb lattice. The sum over deltamathbfq runs over the four wave-vectors that neighbor mathbfQ_textcdw = 0\n\nHere we use the compute_composite_correlation_ratio function to compute to compute this correlation ratio. Note that the mathbfQ_textcdw = 0 is specified using the q_point keyword argument, and the four neighboring wave-vectors deltamathbfq are specified using the q_neighbors keyword argument. These wave-vectors are specified using the convention described here in the Simulation Output Overview page. Note that because the honeycomb lattice has a C_6 rotation symmetry, each wave-vector in momentum-space has six nearest-neighbor wave-vectors. Below we specify all six wave-vectors that neighbor the mathbfQ_textcdw = 0 wave-vector ordering wave-vector, accounting for the fact that the Brillouin zone is periodic in the reciprocal lattice vectors.\n\n    # Calculate CDW correlation ratio.\n    Rcdw, ΔRcdw = compute_composite_correlation_ratio(\n        datafolder = simulation_info.datafolder,\n        name = \"cdw\",\n        type = \"equal-time\",\n        q_point = (0, 0),\n        q_neighbors = [\n            (1,0),   (0,1),   (1,1),\n            (L-1,0), (0,L-1), (L-1,L-1)\n        ]\n    )\n\nNext, we record the measurement in the metadata dictionary, and then write a new version of the simulation summary TOML file that contains this new information using the save_simulation_info function.\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rcdw_mean_real\"] = real(Rcdw)\n    metadata[\"Rcdw_mean_imag\"] = imag(Rcdw)\n    metadata[\"Rcdw_std\"]       = ΔRcdw\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\nNote that as long as the binned data persists the process_measurements and compute_correlation_ratio functions can be rerun to recompute the final statistics for the measurements without needing to rerun the simulation.\n\n    return nothing\nend # end of run_simulation function","category":"section"},{"location":"tutorials/holstein_honeycomb/#Execute-script","page":"2a) Honeycomb Holstein Model","title":"Execute script","text":"DQMC simulations are typically run from the command line as jobs on a computing cluster. With this in mind, the following block of code only executes if the Julia script is run from the command line, also reading in additional command line arguments.\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Run the simulation.\n    run_simulation(;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins = parse(Int, ARGS[9]) # Number of times bin-averaged measurements are written to file.\n    )\nend\n\nFor instance, the command\n\n> julia holstein_honeycomb.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100\n\nruns a DQMC simulation of a Holstein model on a 3 times 3 unit cell (N = 2 \\times 3^2 = 18 site) honeycomb lattice at half-filling (mu = 0) and inverse temperature beta = 40. The phonon energy is set to Omega = 10 and the electron-phonon coupling is set to alpha = 15 In the DQMC simulation, 5,000 EFA-HMC, reflection and swap updates are performed to thermalize the system. Then an additional 10,000 such updates are performed, after each of set of which measurements are made. During the simulation, bin-averaged measurements are written to file 100 times, with each bin of data containing the average of 10,000/100 = 100 sequential measurements.","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#2b)-Honeycomb-Holstein-Model-with-MPI-Parallelization","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"2b) Honeycomb Holstein Model with MPI Parallelization","text":"Download this example as a Julia script.\n\nThis tutorial will build on the previous 2a) Honeycomb Holstein Model tutorial, demonstrating how to add parallelization with MPI using the MPI.jl package. By this we mean that each MPI process will act as independent walker, running it's own independent DQMC simulation, with the final reported estimates for measured quantities being the average across all walkers.","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Import-packages","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Import packages","text":"We now need to import the MPI.jl package as well.\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf\nusing MPI","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Specify-simulation-parameters","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Specify simulation parameters","text":"Here we have introduced the comm argument to the run_simulation function, which is a type exported by the MPI.jl package to facilitate communication and synchronization between the different MPI processes.\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    Nt = 8, # Number of time-steps in HMC update.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-simulation","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize simulation","text":"Now when initializing the SimulationInfo type, we also need to include the MPI process ID pID, which can be retrieved using the MPI.Comm_rank function.\n\nWe also the initialize_datafolder function such that it takes the comm as the first argument. This ensures that all the MPI processes remained synchronized, and none try proceeding beyond this point until the data folder has been initialized.\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_honeycomb_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 7),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-simulation-metadata","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize simulation metadata","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.\n\n    # Initialize random number generator\n    rng = Xoshiro(seed)\n\n    # Initialize metadata dictionary\n    metadata = Dict()\n\n    # Record simulation parameters.\n    metadata[\"Nt\"] = Nt\n    metadata[\"N_therm\"] = N_therm\n    metadata[\"N_measurements\"] = N_measurements\n    metadata[\"N_bins\"] = N_bins\n    metadata[\"n_stab\"] = n_stab\n    metadata[\"dG_max\"] = δG_max\n    metadata[\"symmetric\"] = symmetric\n    metadata[\"checkerboard\"] = checkerboard\n    metadata[\"seed\"] = seed\n    metadata[\"hmc_acceptance_rate\"] = 0.0\n    metadata[\"reflection_acceptance_rate\"] = 0.0\n    metadata[\"swap_acceptance_rate\"] = 0.0","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-model","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize model","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.\n\n    # Define lattice vectors.\n    a1 = [+3/2, +√3/2]\n    a2 = [+3/2, -√3/2]\n\n    # Define basis vectors for two orbitals in the honeycomb unit cell.\n    r1 = [0.0, 0.0] # Location of first orbital in unit cell.\n    r2 = [1.0, 0.0] # Location of second orbital in unit cell.\n\n    # Define the unit cell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [a1, a2],\n        basis_vecs = [r1, r2]\n    )\n\n    # Define finite lattice with periodic boundary conditions.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize model geometry.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the first nearest-neighbor bond in a honeycomb lattice.\n    bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n    # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_1_id = add_bond!(model_geometry, bond_1)\n\n    # Define the second nearest-neighbor bond in a honeycomb lattice.\n    bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n    # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_2_id = add_bond!(model_geometry, bond_2)\n\n    # Define the third nearest-neighbor bond in a honeycomb lattice.\n    bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n    # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_3_id = add_bond!(model_geometry, bond_3)\n\n    # Set nearest-neighbor hopping amplitude to unity,\n    # setting the energy scale in the model.\n    t = 1.0\n\n    # Define the honeycomb tight-binding model.\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_1, bond_2, bond_3], # defines hopping\n        t_mean = [t, t, t], # defines corresponding hopping amplitude\n        μ  = μ, # set chemical potential\n        ϵ_mean = [0.0, 0.0] # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon_1 = PhononMode(\n        basis_vec = r1,\n        Ω_mean = Ω\n    )\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_1_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_1\n    )\n\n    # Define a dispersionless electron-phonon mode to live on the second sublattice.\n    phonon_2 = PhononMode(\n        basis_vec = r2,\n        Ω_mean = Ω\n    )\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_2_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_2\n    )\n\n    # Define first local Holstein coupling for first phonon mode.\n    holstein_coupling_1 = HolsteinCoupling(\n        model_geometry = model_geometry,\n        phonon_id = phonon_1_id,\n        orbital_id = 1,\n        displacement = [0, 0],\n        α_mean = α,\n        ph_sym_form = true,\n    )\n\n    # Add the first local Holstein coupling definition to the model.\n    holstein_coupling_1_id = add_holstein_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        holstein_coupling = holstein_coupling_1,\n        model_geometry = model_geometry\n    )\n\n    # Define second local Holstein coupling for second phonon mode.\n    holstein_coupling_2 = HolsteinCoupling(\n        model_geometry = model_geometry,\n        phonon_id = phonon_2_id,\n        orbital_id = 2,\n        displacement = [0, 0],\n        α_mean = α,\n        ph_sym_form = true,\n    )\n\n    # Add the second local Holstein coupling definition to the model.\n    holstein_coupling_2_id = add_holstein_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        holstein_coupling = holstein_coupling_2,\n        model_geometry = model_geometry\n    )\n\n    # Write model summary TOML file specifying Hamiltonian that will be simulated.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-model-parameters","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize model parameters","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Initialize-measurements","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Initialize measurements","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [\n            # Measure green's functions for all pairs or orbitals.\n            (1, 1), (2, 2), (1, 2)\n        ]\n    )\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [\n            # Measure green's functions for all pairs of modes.\n            (1, 1), (2, 2), (1, 2)\n        ]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            (1, 1), (2, 2),\n        ]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            # Measure local s-wave pair susceptibility associated with\n            # each orbital in the unit cell.\n            (1, 1), (2, 2)\n        ]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [\n            (1, 1), (2, 2)\n        ]\n    )\n\n    # Initialize measurement of electron Green's function traced\n    # over both orbitals in the unit cell.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"tr_greens\",\n        correlation = \"greens\",\n        id_pairs = [(1,1), (2,2)],\n        coefficients = [1.0, 1.0],\n        time_displaced = true,\n    )\n\n    # Initialize CDW correlation measurement.\n    initialize_composite_correlation_measurement!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        name = \"cdw\",\n        correlation = \"density\",\n        ids = [1, 2],\n        coefficients = [1.0, -1.0],\n        time_displaced = false,\n        integrated = true\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Setup-DQMC-simulation","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Setup DQMC simulation","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing EFA-HMC, reflection and swap updates below.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time electron Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize electron Green's function matrix, also calculating the matrix determinant as the same time.\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize diagnostic parameters to asses numerical stability.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Setup-EFA-HMC-Updates","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Setup EFA-HMC Updates","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = π/(2*Nt)\n    )","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Thermalize-system","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Thermalize system","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.\n\n    # Iterate over number of thermalization updates to perform.\n    for update in 1:N_therm\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Make-measurements","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Make measurements","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.\n\n    # Reset diagnostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over measurements.\n    for measurement in 1:N_measurements\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Make measurements.\n        (logdetG, sgndetG, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (electron_phonon_parameters,)\n        )\n\n        # Write record and write bin-averaged measurements.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Merge-binned-data","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Merge binned data","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Record-simulation-metadata","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Record simulation metadata","text":"No changes need to made to this section of the code from the previous 2a) Honeycomb Holstein Model tutorial.\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Record largest numerical error encountered during simulation.\n    metadata[\"dG\"] = δG\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Post-process-results","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Post-process results","text":"The main change we need to make from the previous 2a) Honeycomb Holstein Model tutorial is to call the process_measurements and compute_composite_correlation_ratio functions such that the first argument is the comm object, thereby ensuring a parallelized version of each method is called.\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm;\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\n    # Calculate CDW correlation ratio.\n    Rcdw, ΔRcdw = compute_composite_correlation_ratio(\n        comm;\n        datafolder = simulation_info.datafolder,\n        name = \"cdw\",\n        type = \"equal-time\",\n        q_point = (0, 0),\n        q_neighbors = [\n            (1,0),   (0,1),   (1,1),\n            (L-1,0), (0,L-1), (L-1,L-1)\n        ]\n    )\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rcdw_mean_real\"] = real(Rcdw)\n    metadata[\"Rcdw_mean_imag\"] = imag(Rcdw)\n    metadata[\"Rcdw_std\"]       = ΔRcdw\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    return nothing\nend # end of run_simulation function","category":"section"},{"location":"tutorials/holstein_honeycomb_mpi/#Execute-script","page":"2b) Honeycomb Holstein Model with MPI Parallelization","title":"Execute script","text":"Here we first need to initialize MPI using the MPI.Init command. Then, we need to make sure to pass the comm = MPI.COMM_WORLD to the run_simulation function. At the very end of simulation it is good practice to run the MPI.Finalize() function even though it is typically not strictly required.\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm  = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins = parse(Int, ARGS[9]) # Number of times bin-averaged measurements are written to file.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend\n\nHere is an example of what the command to run this script might look like:\n\nmpiexecjl -n 16 julia holstein_honeycomb_mpi.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100\n\nThis will 16 MPI processes, each running and independent simulation using a different random seed the the final results arrived at by averaging over all 16 walkers. Here mpiexecjl is the MPI executable that can be easily install using the directions found here in the MPI.jl documentation. However, you can substitute a different MPI executable here if one is already configured on your system.\n\nAlso, when submitting jobs via SLURM on a High-Performance Computing (HPC) cluster, if a default MPI executable is already configured on the system, as is frequently the case, then the script can likely be run inside the *.sh job file using the srun command:\n\nsrun julia holstein_honeycomb_mpi.jl 1 1.0 1.5 0.0 3 4.0 5000 10000 100\n\nThe srun command should automatically detect the number of available cores requested by the job and run the script using the MPI executable with the appropriate number of processes.","category":"section"},{"location":"examples/ossh_square/#Square-Optical-Su-Schrieffer-Heeger-Model","page":"Square Optical Su-Schrieffer-Heeger Model","title":"Square Optical Su-Schrieffer-Heeger Model","text":"Download this example as a Julia script.\n\nIn this example we simulate the optical Su-Schrieffer-Heeger (OSSH) model on a square lattice, with a Hamiltonian given by\n\nbeginalign*\nhatH  = sum_mathbfileft(frac12MhatP_mathbfix^2+frac12MOmega^2hatX_mathbfi^2right) + sum_mathbfileft(frac12MhatP_mathbfiy^2+frac12MOmega^2hatY_mathbfi^2right) \n         - sum_mathbfisigmaleftt-alphaleft(hatX_mathbfi+mathbfx-hatX_mathbfiright)rightleft(hatc_sigmamathbfi+mathbfx^daggerhatc_sigmamathbfi^phantomdagger+hatc_sigmamathbfi^daggerhatc_sigmamathbfi+mathbfx^phantomdaggerright) \n         - sum_mathbfisigmaleftt-alphaleft(hatY_mathbfi+mathbfy-hatY_mathbfiright)rightleft(hatc_sigmamathbfi+mathbfy^daggerhatc_sigmamathbfi^phantomdagger+hatc_sigmamathbfi^daggerhatc_sigmamathbfi+mathbfy^phantomdaggerright) \n         - musum_mathbfisigmahatn_sigmamathbfi\nendalign*\n\nin which the fluctuations in the position of dispersionless phonon modes placed on each site in the lattice modulate the hopping amplitude between neighboring sites. In the above expression hatc^dagger_sigmamathbfi  (hatc^phantom dagger_sigmamathbfi) creation (annihilation) operator a spin sigma electron on site mathbfi in the lattice, and hatn_sigmamathbfi = hatc^dagger_sigmamathbfi hatc^phantom dagger_sigmamathbfi is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on site mathbfi is given by hatX_mathbfi  (hatP_mathbfi), where Omega and M are the phonon frequency and associated ion mass respectively. Lastly, the strength of the electron-phonon coupling is controlled by the parameter alpha.\n\nNote that this example script comes with all the bells and whistles so to speak, including support for MPI parallelization as well as checkpointing.\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf\nusing MPI\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Nt = 10, # Number of time-steps in HMC update.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"square_ossh_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 10),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"Nt\"] = Nt\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_measurements\"] = N_measurements\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"n_stab\"] = n_stab\n        metadata[\"dG_max\"] = δG_max\n        metadata[\"symmetric\"] = symmetric\n        metadata[\"checkerboard\"] = checkerboard\n        metadata[\"seed\"] = seed\n        metadata[\"hmc_acceptance_rate\"] = 0.0\n        metadata[\"reflection_acceptance_rate\"] = 0.0\n        metadata[\"swap_acceptance_rate\"] = 0.0\n\n        # Initialize an instance of the type UnitCell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [[1.0,0.0],\n                            [0.0,1.0]],\n            basis_vecs   = [[0.0,0.0]]\n        )\n\n        # Initialize an instance of the type Lattice.\n        lattice = lu.Lattice(\n            L = [L,L],\n            periodic = [true,true]\n        )\n\n        # Get the number of sites in the lattice.\n        N = lu.nsites(unit_cell, lattice)\n\n        # Initialize an instance of the ModelGeometry type.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the nearest-neighbor bond in the +x-direction.\n        bond_px = lu.Bond(orbitals = (1,1), displacement = [1,0])\n\n        # Add this bond in +x-direction to the model geometry.\n        bond_px_id = add_bond!(model_geometry, bond_px)\n\n        # Define the nearest-neighbor bond in the +y-direction.\n        bond_py = lu.Bond(orbitals = (1,1), displacement = [0,1])\n\n        # Add this bond in +y-direction to the model geometry.\n        bond_py_id = add_bond!(model_geometry, bond_py)\n\n        # Define the nearest-neighbor bond in the -x-direction.\n        bond_nx = lu.Bond(orbitals = (1,1), displacement = [-1,0])\n\n        # Add this bond in +x-direction to the model geometry.\n        bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n        # Define the nearest-neighbor bond in the -y-direction.\n        bond_ny = lu.Bond(orbitals = (1,1), displacement = [0,-1])\n\n        # Add this bond in +y-direction to the model geometry.\n        bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n        # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n        t = 1.0\n\n        # Define the tight-binding model\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond_px, bond_py], # defines hopping\n            t_mean = [t, t], # defines corresponding hopping amplitude\n            μ = μ, # set chemical potential\n            ϵ_mean = [0.] # set the (mean) on-site energy\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless phonon mode to represent vibrations in the x-direction.\n        phonon_x = PhononMode(\n            basis_vec = [0.0,0.0],\n            Ω_mean = Ω\n        )\n\n        # Add x-direction optical ssh phonon to electron-phonon model.\n        phonon_x_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_x\n        )\n\n        # Define a dispersionless phonon mode to represent vibrations in the y-direction.\n        phonon_y = PhononMode(\n            basis_vec = [0.0,0.0],\n            Ω_mean = Ω\n        )\n\n        # Add y-direction optical ssh phonon to electron-phonon model.\n        phonon_y_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_y\n        )\n\n        # Defines ssh e-ph coupling such that total effective hopping.\n        ossh_x_coupling = SSHCoupling(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            phonon_ids = (phonon_x_id, phonon_x_id),\n            bond = bond_px,\n            α_mean = α\n        )\n\n        # Add x-direction optical SSH coupling to the electron-phonon model.\n        ossh_x_coupling_id = add_ssh_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            ssh_coupling = ossh_x_coupling,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Defines ssh e-ph coupling such that total effective hopping.\n        ossh_y_coupling = SSHCoupling(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            phonon_ids = (phonon_y_id, phonon_y_id),\n            bond = bond_py,\n            α_mean = α\n        )\n\n        # Add y-direction optical SSH coupling to the electron-phonon model.\n        ossh_y_coupling_id = add_ssh_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            ssh_coupling = ossh_y_coupling,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Write a model summary to file.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                (phonon_x_id, phonon_x_id),\n                (phonon_y_id, phonon_y_id)\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the bond correlation measurement\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"bond\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (bond_px_id, bond_px_id),\n                (bond_py_id, bond_py_id),\n                (bond_px_id, bond_py_id),\n            ]\n        )\n\n        # Measure composite bond correlation for detecting a bond ordered wave (BOW)\n        # that breaks a C4 rotation symmetry.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"BOW_C4\",\n            correlation = \"bond\",\n            ids = [bond_px_id, bond_py_id, bond_nx_id, bond_ny_id],\n            coefficients = [+1.0, +1.0im, -1.0, -1.0im],\n            displacement_vecs = [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Measure composite bond correlation for detecting a bond ordered wave (BOW)\n        # that breaks a C2 rotation symmetry.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"BOW_C2\",\n            correlation = \"bond\",\n            ids = [bond_px_id, bond_py_id, bond_nx_id, bond_ny_id],\n            coefficients = [+1.0, -1.0, +1.0, -1.0],\n            displacement_vecs = [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            exit_code = 13,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        electron_phonon_parameters = checkpoint[\"electron_phonon_parameters\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing EFA-HMC, reflection and swap updates below.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time electron Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize electron Green's function matrix, also calculating the matrix determinant as the same time.\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize diagnostic parameters to asses numerical stability.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = π/(2*Nt)\n    )\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            exit_code = 13,\n            # Contents of checkpoint file below.\n            n_therm = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Reset diagnostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for measurement in n_measurements:N_measurements\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Make measurements.\n        (logdetG, sgndetG, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (electron_phonon_parameters,)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            exit_code = 13,\n            # Contents of checkpoint file below.\n            n_therm = N_therm + 1,\n            n_measurements = measurement + 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Record largest numerical error encountered during simulation.\n    metadata[\"dG\"] = δG\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm,\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\n    # Calculate C4 BOW q=(π,π) correlation ratio.\n    Rbow, ΔRbow = compute_composite_correlation_ratio(\n        comm;\n        datafolder = simulation_info.datafolder,\n        name = \"BOW_C4\",\n        type = \"equal-time\",\n        q_point = (L÷2, L÷2),\n        q_neighbors = [\n            (L÷2+1, L÷2), (L÷2, L÷2+1),\n            (L÷2-1, L÷2), (L÷2, L÷2-1)\n        ]\n    )\n\n    # Record the correlation ratio.\n    metadata[\"Rbow_mean_real\"] = real(Rbow)\n    metadata[\"Rbow_mean_imag\"] = imag(Rbow)\n    metadata[\"Rbow_std\"] = ΔRbow\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]), # Total number of measurements.\n        N_bins = parse(Int, ARGS[9]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[10]), # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"section"},{"location":"examples/ossh_chain/#Optical-Su-Schrieffer-Heeger-Chain","page":"Optical Su-Schrieffer-Heeger Chain","title":"Optical Su-Schrieffer-Heeger Chain","text":"Download this example as a Julia script.\n\nIn this example we simulate the optical Su-Schrieffer-Heeger (OSSH) model on a 1D chain, with a Hamiltonian given by\n\nbeginalign*\nhatH = sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)\n          - sum_sigmai t-alpha(hatX_i+1-hatX_i) (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n          - mu sum_sigmai hatn_sigmai\nendalign*\n\nin which the fluctuations in the position of dispersionless phonon modes placed on each site in the lattice modulate the hopping amplitude between neighboring sites. In the above expression hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creation (annihilation) operator a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on site i is given by hatX_i  (hatP_i), where Omega and M are the phonon frequency and associated ion mass respectively. Lastly, the strength of the electron-phonon coupling is controlled by the parameter alpha.\n\nNote that this example script comes with all the bells and whistles so to speak, including support for MPI parallelization as well as checkpointing.\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf\nusing MPI\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements and measurement updates.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Nt = 10, # Number of time-steps in HMC update.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"ossh_chain_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 100),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"Nt\"] = Nt\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_measurements\"] = N_measurements\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"n_stab\"] = n_stab\n        metadata[\"dG_max\"] = δG_max\n        metadata[\"symmetric\"] = symmetric\n        metadata[\"checkerboard\"] = checkerboard\n        metadata[\"seed\"] = seed\n        metadata[\"hmc_acceptance_rate\"] = 0.0\n        metadata[\"reflection_acceptance_rate\"] = 0.0\n        metadata[\"swap_acceptance_rate\"] = 0.0\n\n        # Initialize an instance of the type UnitCell.\n        unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                                basis_vecs   = [[0.0]])\n\n        # Initialize an instance of the type Lattice.\n        lattice = lu.Lattice(\n            L = [L],\n            periodic = [true]\n        )\n\n        # Get the number of sites in the lattice.\n        N = lu.nsites(unit_cell, lattice)\n\n        # Initialize an instance of the ModelGeometry type.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the nearest-neighbor bond for a 1D chain.\n        bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n        # Add this bond to the model, by adding it to the ModelGeometry type.\n        bond_id = add_bond!(model_geometry, bond)\n\n        # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n        t = 1.0\n\n        # Define the tight-binding model\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond], # defines hopping\n            t_mean = [t],     ## defines corresponding hopping amplitude\n            μ = μ,            ## set chemical potential\n            ϵ_mean = [0.]     ## set the (mean) on-site energy\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless phonon mode to live on each site in the lattice.\n        phonon = PhononMode(\n            basis_vec = [0.0],\n            Ω_mean = Ω\n        )\n\n        # Add optical ssh phonon to electron-phonon model.\n        phonon_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon\n        )\n\n        # Defines ssh e-ph coupling such that total effective hopping is t_eff = t-α⋅(Xᵢ₊₁-Xᵢ).\n        ossh_coupling = SSHCoupling(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            phonon_ids = (phonon_id, phonon_id),\n            bond = bond,\n            α_mean = α\n        )\n\n        # Add optical SSH coupling to the electron-phonon model.\n        ossh_coupling_id = add_ssh_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            ssh_coupling = ossh_coupling,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Write a model summary to file.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs of modes.\n                (1, 1),\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the bond correlation measurement\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"bond\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (bond_id, bond_id),\n            ]\n        )\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        electron_phonon_parameters = checkpoint[\"electron_phonon_parameters\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing EFA-HMC, reflection and swap updates below.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time electron Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize electron Green's function matrix, also calculating the matrix determinant as the same time.\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize diagnostic parameters to asses numerical stability.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = π/(2*Nt)\n    )\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Reset diagnostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for measurement in n_measurements:N_measurements\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Make measurements.\n        (logdetG, sgndetG, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (electron_phonon_parameters,)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_measurements = measurement + 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Record largest numerical error encountered during simulation.\n    metadata[\"dG\"] = δG\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm,\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]), # Total number of measurements and measurement updates.\n        N_bins = parse(Int, ARGS[9]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[10]), # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"section"},{"location":"examples/hubbard_holstein_square/#Square-Holstein-Hubbard-Model","page":"Square Holstein-Hubbard Model","title":"Square Holstein-Hubbard Model","text":"Download this example as a Julia script.\n\nIn this example we simulate the Holstein-Hubbard model on a square lattice, with a Hamiltonian given by\n\nbeginalign*\nhatH  = sum_i left( frac12MhatP_i^2 + frac12 M Omega^2 hatX_i^2 right) \n - t sum_sigmalangle ij rangle left( hatc_sigmai^dagger hatc_sigmaj^phantomdagger + hatc_sigmaj^dagger hatc_sigmai^phantomdagger right) - mu sum_sigmai hatn_sigmai \n + U sum_i left( hatn_uparrowi - tfrac12 right)left( hatn_downarrowj + tfrac12 right) + alpha sum_sigmai hatX_i left( hatn_sigmai - tfrac12 right)\nendalign*\n\nin which the fluctuations in the position of dispersionless phonon modes placed on each site in the lattice modulate the on-site energy. In the above expression hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creation (annihilation) operator a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is corresponding electron number operator. Here the sum over langle ij rangle runs over all nearest-neighbor pairs of sites in the lattice, and t and mu are the nearest-neighbor hopping amplitude and chemical potential, respectively. The phonon position (momentum) operator for the dispersionless phonon mode on site i is given by hatX_i  (hatP_i), where Omega and M are the phonon frequency and associated ion mass respectively. Therefore, the strength of the electron-phonon coupling is controlled by the parameter alpha. Lastly, the parameter U controls the strength of the on-site Hubbard interaction.\n\nNote that this example script comes with all the bells and whistles so to speak, including support for MPI parallelization as well as checkpointing.\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf\nusing MPI\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    U, # Hubbard interaction strength.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    N_local_updates, # Number of local update sweeps per HMC update and measurement.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Nt = 8, # Number of time-steps in HMC update.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"square_hol_hub_U%2.f_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" U Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 10),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"Nt\"] = Nt\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_measurements\"] = N_measurements\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"n_stab\"] = n_stab\n        metadata[\"dG_max\"] = δG_max\n        metadata[\"symmetric\"] = symmetric\n        metadata[\"checkerboard\"] = checkerboard\n        metadata[\"seed\"] = seed\n        metadata[\"reflection_acceptance_rate\"] = 0.0\n        metadata[\"hmc_acceptance_rate\"] = 0.0\n        metadata[\"local_acceptance_rate\"] = 0.0\n\n        # Initialize an instance of the type UnitCell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [[1.0,0.0],\n                            [0.0,1.0]],\n            basis_vecs = [[0.0,0.0]]\n        )\n\n        # Initialize an instance of the type Lattice.\n        lattice = lu.Lattice(\n            L = [L,L],\n            periodic = [true,true]\n        )\n\n        # Get the number of sites in the lattice.\n        N = lu.nsites(unit_cell, lattice)\n\n        # Initialize an instance of the ModelGeometry type.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the nearest-neighbor bond in the x-direction.\n        bond_px = lu.Bond(orbitals = (1,1), displacement = [1,0])\n\n        # Add this bond in x-direction to the model geometry.\n        bond_px_id = add_bond!(model_geometry, bond_px)\n\n        # Define the nearest-neighbor bond in the y-direction.\n        bond_py = lu.Bond(orbitals = (1,1), displacement = [0,1])\n\n        # Add this bond in y-direction to the model geometry.\n        bond_py_id = add_bond!(model_geometry, bond_py)\n\n        # Define the nearest-neighbor bond in the -x-direction.\n        bond_nx = lu.Bond(orbitals = (1,1), displacement = [-1,0])\n\n        # Add this bond in +x-direction to the model geometry.\n        bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n        # Define the nearest-neighbor bond in the -y-direction.\n        bond_ny = lu.Bond(orbitals = (1,1), displacement = [0,-1])\n\n        # Add this bond in +y-direction to the model geometry.\n        bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n        # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n        t = 1.0\n\n        # Define the tight-binding model\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond_px, bond_py], # defines hopping\n            t_mean = [t, t], # defines corresponding hopping amplitude\n            μ = μ, # set chemical potential\n            ϵ_mean = [0.] # set the (mean) on-site energy\n        )\n\n        # Define the Hubbard interaction in the model.\n        hubbard_model = HubbardModel(\n            ph_sym_form = true, # if particle-hole symmetric form for Hubbard interaction is used.\n            U_orbital   = [1], # orbitals in unit cell with Hubbard interaction.\n            U_mean      = [U], # mean Hubbard interaction strength for corresponding orbital species in unit cell.\n            U_std       = [0.], # standard deviation of Hubbard interaction strength for corresponding orbital species in unit cell.\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless phonon mode.\n        phonon = PhononMode(\n            basis_vec = [0.0,0.0],\n            Ω_mean = Ω\n        )\n\n        # Add dispersionless phonon mode phonon to the model.\n        phonon_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon\n        )\n\n        # Define first local Holstein coupling for first phonon mode.\n        holstein_coupling = HolsteinCoupling(\n            model_geometry = model_geometry,\n            phonon_id = phonon_id,\n            orbital_id = 1,\n            displacement = [0, 0],\n            α_mean = α,\n            ph_sym_form = true,\n        )\n\n        # Add Holstein coupling to the model.\n        holstein_coupling_id = add_holstein_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            holstein_coupling = holstein_coupling,\n            model_geometry = model_geometry\n        )\n\n        # Write a model summary to file.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize Hubbard interaction parameters.\n        hubbard_parameters = HubbardParameters(\n            model_geometry = model_geometry,\n            hubbard_model = hubbard_model,\n            rng = rng\n        )\n\n        # Apply Spin Channel Hirsch Hubbard-Stratonovich transformation.\n        hst_parameters = HubbardSpinHirschHST(\n            β = β, Δτ = Δτ,\n            hubbard_parameters = hubbard_parameters,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the hubbard interaction related measurements.\n        initialize_measurements!(measurement_container, hubbard_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                (phonon_id, phonon_id)\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the d-wave pair susceptibility measurement.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"d-wave\",\n            correlation = \"pair\",\n            ids = [bond_px_id, bond_nx_id, bond_py_id, bond_ny_id],\n            coefficients = [0.5, 0.5, -0.5, -0.5],\n            time_displaced = true,\n            integrated = true\n        )\n\nInitialize trace of bond correlation measurements.\n\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"tr_bonds\",\n            correlation = \"bond\",\n            id_pairs = [\n                (bond_px_id, bond_px_id),\n                (bond_py_id, bond_py_id)\n            ],\n            coefficients = [\n                +1.0, +1.0\n            ],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            exit_code = 13,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, electron_phonon_parameters,\n            hubbard_parameters, hst_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        hubbard_parameters = checkpoint[\"hubbard_parameters\"]\n        hst_parameters = checkpoint[\"hst_parameters\"]\n        electron_phonon_parameters = checkpoint[\"electron_phonon_parameters\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for Hubbard interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for the current\n    # Hubbard-Stratonovich field configuration.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hst_parameters)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, electron_phonon_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices for spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type for spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Initialize alternate FermionGreensCalculator type for performing reflection updates.\n    fermion_greens_calculator_up_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_up)\n    fermion_greens_calculator_dn_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_dn)\n\n    # Allocate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # Gup(τ,τ)\n    Gup_τ0 = similar(Gup) # Gup(τ,0)\n    Gup_0τ = similar(Gup) # Gup(0,τ)\n    Gdn_ττ = similar(Gdn) # Gdn(τ,τ)\n    Gdn_τ0 = similar(Gdn) # Gdn(τ,0)\n    Gdn_0τ = similar(Gdn) # Gdn(0,τ)\n\n    # Initialize diagnostic parameters to asses numerical stability.\n    δG = zero(logdetGup)\n    δθ = zero(logdetGup)\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = Gup, Nt = Nt, Δt = π/(2*Nt)\n    )\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = hmc_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Iterate over number of local updates to perform.\n        for local_update in 1:N_local_updates\n\n            # Perform local update.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn,\n                hst_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n                update_stabilization_frequency = true\n            )\n\n            # Record acceptance rate for sweep.\n            metadata[\"local_acceptance_rate\"] += acceptance_rate\n        end\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            exit_code = 13,\n            # Contents of checkpoint file below.\n            n_therm = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            hubbard_parameters, hst_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Reset diagnostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetGup)\n    δθ = zero(logdetGup)\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over measurements.\n    for measurement in n_measurements:N_measurements\n\n        # Perform a reflection update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = hmc_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Iterate over number of local updates to perform.\n        for local_update in 1:N_local_updates\n\n            # Perform local update.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn,\n                hst_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n                update_stabilization_frequency = true\n            )\n\n            # Record acceptance rate for sweep.\n            metadata[\"local_acceptance_rate\"] += acceptance_rate\n        end\n\n        # Make measurements.\n        (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n            logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry,\n            tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (hubbard_parameters, hst_parameters, electron_phonon_parameters)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            exit_code = 13,\n            # Contents of checkpoint file below.\n            n_therm = N_therm + 1,\n            n_measurements = measurement + 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            hubbard_parameters, hst_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)\n\n    # Calculate acceptance rates.\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"local_acceptance_rate\"] /= (N_local_updates * N_measurements + N_therm)\n\n    # Record largest numerical error encountered during simulation.\n    metadata[\"dG\"] = δG\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm;\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = true,\n        decimals = 6,\n        delimiter = \" \"\n    )\n\n    # Calculate CDW correlation ratio.\n    Rcdw, ΔRcdw = compute_correlation_ratio(\n        datafolder = simulation_info.datafolder,\n        correlation = \"density\",\n        type = \"equal-time\",\n        id_pairs = [(1, 1)],\n        id_pair_coefficients = [1.0],\n        q_point = (L÷2, L÷2),\n        q_neighbors = [\n            (L÷2+1, L÷2), (L÷2-1, L÷2),\n            (L÷2, L÷2+1), (L÷2, L÷2-1)\n        ]\n    )\n\n    # Record the correlation ratio.\n    metadata[\"Rcdw_mean\"] = real(Rcdw)\n    metadata[\"Rcdw_std\"] = ΔRcdw\n\n    # Calculate AFM correlation ratio.\n    Rafm, ΔRafm = compute_correlation_ratio(\n        datafolder = simulation_info.datafolder,\n        correlation = \"spin_z\",\n        type = \"equal-time\",\n        id_pairs = [(1, 1)],\n        id_pair_coefficients = [1.0],\n        q_point = (L÷2, L÷2),\n        q_neighbors = [\n            (L÷2+1, L÷2), (L÷2-1, L÷2),\n            (L÷2, L÷2+1), (L÷2, L÷2-1)\n        ]\n    )\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rafm_mean\"] = real(Rafm)\n    metadata[\"Rafm_std\"] = ΔRafm\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        U = parse(Float64, ARGS[2]), # Hubbard interaction strength.\n        Ω = parse(Float64, ARGS[3]), # Phonon energy.\n        α = parse(Float64, ARGS[4]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[5]), # Chemical potential.\n        L = parse(Int, ARGS[6]), # System size.\n        β = parse(Float64, ARGS[7]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[8]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[9]), # Total number of measurements.\n        N_bins = parse(Int, ARGS[10]), # Number of times bin-averaged measurements are recorded.\n        N_local_updates = parse(Int, ARGS[11]), # Number of local update sweeps per HMC update and measurement.\n        checkpoint_freq = parse(Float64, ARGS[12]), # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"section"},{"location":"hamiltonian/#Supported-Hamiltonians","page":"Supported Hamiltonians","title":"Supported Hamiltonians","text":"This section describes the class of Hamiltonians SmoQyDQMC.jl currently supports, and how the various terms appearing in the Hamiltonian are parameterized within the code. We start by partitioning the full Hamiltonian as \n\nbeginalign*\n    hatmathcalH = hatmathcalU + hatmathcalK + hatmathcalV\nendalign*\n\nwhere hatmathcalU is the bare lattice energy, hatmathcalK the total electron kinetic energy, and hatmathcalV the total electron potential energy. In the discussion that follows we apply the normalization hbar = 1 throughout.\n\nThe bare lattice term is further decomposed into\n\nbeginalign*\n    hatmathcalU = hatmathcalU_rm ph + hatmathcalU_rm disp\nendalign*\n\nwhere\n\nbeginalign*\n    hatmathcalU_rm ph = sum_mathbfinusum_n_mathbfinu\n        left\n            frac12M_n_mathbfinuhatP_n_mathbfinu\n            + frac12M_n_mathbfinuOmega_0n_mathbfinu^2hatX_n_mathbfinu^2\n            + frac124M_n_mathbfinuOmega_an_mathbfinu^2hatX_n_mathbfinu^4\n        right\nendalign*\n\ndescribes the placement of local dispersionless phonon (LDP) modes in the lattice, i.e. an Einstein solid, and\n\nbeginalign*\n    hatmathcalU_rm disp = sum_substackmathbfinu  mathbfjgammasum_substackn_mathbfinu  n_mathbfjgamma\n        fracM_n_mathbfialphaM_n_mathbfjgammaM_n_mathbfialpha+M_n_mathbfjgammaleft\n            tildeOmega^2_0n_mathbfialphan_mathbfjgamma(hatX_n_mathbfinu-hatX_n_mathbfjgamma)^2\n            + frac112tildeOmega^2_an_mathbfialphan_mathbfjgamma(hatX_n_mathbfinu-hatX_n_mathbfjgamma)^4\n        right\nendalign*\n\nintroduces dispersion between the LDP modes. The sums over mathbfi  (mathbfj) and nu  (gamma) run over unit cells in the lattice and orbitals within each unit cell respectively. A sum over n_mathbfinu  (n_mathbfjgamma) then runs over the LDP modes placed on a given orbital in the lattice.\n\nThe position and momentum operators for each LPD mode are given by hatX_n_mathbfinu and hatP_n_mathbfinu respectively, with corresponding phonon mass M_n_mathbfinu. The spring constant is K_n_mathbfinu = M_n_mathbfinu Omega_0n_n_mathbfinu^2, with Omega_0n_n_mathbfinu specifying the phonon frequency. The U_rm ph also supports an anharmonic hatX_n_mathbfinu^4 contribution to the LDP potential energy that is controlled by the parameter Omega_an_n_mathbfinu. Similary, tildeOmega_0n_mathbfialphan_mathbfjgamma  (tildeOmega_an_mathbfialphan_mathbfjgamma) is the coefficient controlling harmonic (anhmaronic) dispersion between LDP modes.\n\nNext we trace out the phonon degrees of freedom \n\nThe electron kinetic energy is decomposed as\n\nbeginalign*\n    hatmathcalK = sum_sigma=uparrowdownarrow left hatmathcalK_sigma0 + hatmathcalK_sigmarm ssh right\nendalign*\n\nwhere\n\nbeginalign*\n    hatmathcalK_sigma0 = -sum_substackmathbfinu  mathbfjgamma\n        left\n            t_sigma(mathbfinu)(mathbfjgamma) hatc^dagger_sigmamathbfinuhatc_sigmamathbfjgamma + rm hc\n        right\nendalign*\n\nis the non-interacting spin-sigma electron kinetic energy, and\n\nbeginalign*\n    hatmathcalK_sigmarm ssh = sum_substackmathbfinu  mathbfjgammasum_substackn_mathbfinu  n_mathbfjgammasum_m=1^4\n        (hatX_n_mathbfinu-hatX_n_mathbfjgamma)^mleft\n            alpha_sigmamn_mathbfinun_mathbfjgamma hatc^dagger_sigmamathbfinuhatc_sigmamathbfjgamma + rm hc\n        right\nendalign*\n\nis describes the interaction between the lattice degrees of freedom and the spin-sigma electron kinetic energy via a Su-Schrieffer-Heeger (SSH)-like coupling mechanism. The hopping integral between from orbital gamma in unit cell mathbfj to orbital nu in unit cell mathbfi is given by t_(mathbfinu)(mathbfjgamma), and may in general be complex. The modulations to this hopping integral are controlled by the parameters alpha_m(mathbfinu)(mathbfjgamma), where min 14 specifies the order of the difference in the phonon positions that modulates the hopping integral.\n\nLastly, the electron potential energy is broken down into the three terms\n\nbeginalign*\n    hatmathcalV = sum_sigma=uparrowdownarrow left hatmathcalV_sigma0 + hatmathcalV_sigmarm hol right + hatmathcalV_rm hub\nendalign*\n\nwhere\n\nbeginalign*\n    hatmathcalV_sigma0 = sum_mathbfinu\n        left\n            (epsilon_sigmamathbfinu - mu) hatn_sigmamathbfinu\n        right\nendalign*\n\nis the non-interacting spin-sigma electron potential energy,\n\nbeginalign*\n    hatmathcalV_sigmarm hol =\n    begincases\n        sum_mathbfinu summathbfjgamma sum_n_mathbfinu leftsum_m=13tildealpha_sigmamn_mathbfinu(mathbfjgamma)  hatX^m_n_mathbfinu(hatn_sigmamathbfjgamma - tfrac12) + sum_m=24tildealpha_sigmamn_mathbfinu(mathbfjgamma)  hatX^m_n_mathbfinuhatn_sigmamathbfjgammaright \n        sum_mathbfinu summathbfjgamma sum_n_mathbfinu sum_m=1^4 tildealpha_sigmamn_mathbfinu(mathbfjgamma)  hatX^m_n_mathbfinu hatn_sigmamathbfjgamma\n    endcases\nendalign*\n\nis the contribution to the spin-sigma electron potential energy that results from a Holstein-like coupling to the lattice degrees of freedom, and\n\nbeginalign*\n    hatmathcalV_rm hub=\n    begincases\n        sum_mathbfinuU_mathbfinubig(hatn_uparrowmathbfinu-tfrac12big)big(hatn_downarrowmathbfinu-tfrac12big)\n        sum_mathbfinuU_mathbfinuhatn_uparrowmathbfinuhatn_downarrowmathbfinu\n    endcases\nendalign*\n\nis the on-site Hubbard interaction contribution to the electron potential energy. In hatmathcalV_0 the chemical potential is given by mu, and epsilon_mathbfinu is the on-site energy, the parameter tildealpha_mn_mathbfinu(mathbfjgamma) controls the strength of the Holstein-like coupling in hatmathcalV_rm ph, and U_mathbfinu is the on-site Hubbard interaction strength in hatmathcalV_rm hub. Note that either functional form for hatmathcalV_rm hub and hatmathcalV_sigma rm hub can be used in the code. Note that the two possible parameterizations for hatmathcalV_sigma rm hub are inequivalent! ","category":"section"},{"location":"simulation_output/#Simulation-Output-Overview","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"In this section we define and provide an overview of the output generated by a DQMC simulation performed using the SmoQyDQMC.jl package.","category":"section"},{"location":"simulation_output/#Output-Data-Folder-Structure","page":"Simulation Output Overview","title":"Output Data Folder Structure","text":"Each simulation performed with SmoQyDQMC.jl will generate a directory with a user defined name that all the output of the simulation will be written to. Here we will simply refer to this top-level directory as the datafolder, but again, the user may call it whatever they like. Inside the datafolder a set of files and folders resembling the structure outlined below will be found; note the CSV files will only be present if results are exported to CSV files as the default storage format is HDF5 files:\n\n[datafolder]: \nmodel_summary.toml: A TOML file that describes the Hamiltonian that was simulated, and defines the various types of IDs that measurements are reported in terms of.\nsimulation_info_pID*_sID*.toml: A TOML file reporting basic information about the simulation, including the version of Julia and SmoQyDQMC.jl that was used to run the simulation. An [metadata] table contains the contents of a user defined dictionary as well. One such file is generated for each pID MPI rank if multiple simulations are being performed in parallel using MPI.\nstats.h5: HDF5 file containing computed measurement statistics.\n[bins]: Directory containing binned measurent data stored in HDF5 files.\nbins_pID-0.h5: HDF5 file containing the binned measurement data associated with pID = 0.\nbins_pID-1.h5: HDF5 file containing the binned measurement data associated with pID = 1.\n[...]\nglobal_stats.csv: CSV file containing final average and error for all global measurements.\nlocal_stats.csv: CSV file containing final average and error for all local measurements.\n[equal-time]: Top-level directory containing all equal-time correlation function measurement results.\n[density]: As an example, directory containing equal-time density-density correlations.\ndensity_momentum_equal-time_stats.csv: CSV file containing average and error for density-density correlation in momentum space.\ndensity_position_equal-time_stats.csv: CSV file containing average and error for density-density correlation in position space.\n[...]\n[time-displaced]: Top-level directory containing all time-displaced correlation function measurement results.\n[greens]\ngreens_momentum_equal-time_stats.csv\ngreens_position_equal-time_stats.csv\n[...]\n[integrated]: Top-level directory containing all integrated correlation function measurement results.\n[density]\ndensity_momentum_integrated_stats.csv\ndensity_position_integrated_stats.csv\n[...]","category":"section"},{"location":"simulation_output/#Model-Summary","page":"Simulation Output Overview","title":"Model Summary","text":"The function model_summary is used to a TOML file named model_summary.toml that full describes and parameterizes the Hamiltonian simulated in a DQMC simulation using SmoQyDQMC.jl. Significantly, this method also defines the types of IDs (ORBITAL_ID, BOND_ID, HOPPING_ID, PHONON_ID, HOLSTEIN_ID, SSH_ID, DISPERSION_ID) that the various measurements are reported in terms of. The type of ID used to report correlation and local measurements are recorded in the exported dictionaries CORRELATION_FUNCTIONS and LOCAL_MEASUREMENTS.","category":"section"},{"location":"simulation_output/#Uncertainty-Reporting-Conventions","page":"Simulation Output Overview","title":"Uncertainty Reporting Conventions","text":"The average value barC for any measured expectation value langle C rangle is reported as a complex number in all  *_stats.csv files, even if it is known formally to be a strictly real quantity. On the other hand, the error, or standard deviation, associated with each measurement is reported as a strictly positive real number such that the error associated with the complex expectation value langle C rangle is given by Delta C = sqrtDelta C_rm Re^2 + Delta C_rm Im^2.","category":"section"},{"location":"simulation_output/#Global-Measurements","page":"Simulation Output Overview","title":"Global Measurements","text":"At the end of a simulation once the measurements are processed using the process_measurements method, a file global_stats.csv file is created that contains the final estimates and errors for all \"global\" measurements. The corresponding binned global data is stored as binary JLD2 files in the directory global inside the simulation directory. We define each global measurement below.\n\nsgn: The average sign mathcalS = langle rm sign( det G_uparrow cdot det G_downarrow ) rangle.\nsgndetGup: The average spin-up sign mathcalS_uparrow = langle rm sign(det G_uparrow) rangle.\nsgndetGdn: The average spin-up sign mathcalS_downarrow = langle rm sign(det G_downarrow) rangle.\ndensity: Average global total charge density langle n rangle = langle n_uparrow rangle + langle n_downarrow rangle.\ndensity_up: Average global spin-up charge density langle n_uparrow rangle.\ndensity_dn: Average global spin-down charge density langle n_downarrow rangle.\ndouble_occ: Average global double occupancy langle n_uparrow n_downarrow rangle.\nNsqrd: Expectation value for total electron number squared langle N^2 rangle, where hatN = sum_sigmamathbfinu hatn_sigma mathbfi nu.\nchemical_potential: The measured chemical potential mu.\ncompressibility: The measured compressibility kappa = fracd langle n rangled mu = fracbetamathcalNleft( langle N^2 rangle - langle N rangle^2 right).","category":"section"},{"location":"simulation_output/#Local-Measurement","page":"Simulation Output Overview","title":"Local Measurement","text":"At the end of a simulation once the measurements are processed using the process_measurements method, a file local_stats.csv file is created that contains the final estimates and errors for all \"local\" measurements. The corresponding binned local data is stored as binary JLD2 files in the directory local inside the simulation directory. All \"local\" measurements are reported in terms of an ID type, defined in the model_summary.toml file generated by the model_summary function. The definition for each local measurement that may be reported, including the type of ID it is reported in terms of, is defined below.\n\ndensity: (ORBITAL_ID) The charge density langle n_nu rangle = langle n_uparrownu rangle + langle n_downarrownu rangle for orbital nu in the unit cell.\ndensity_up: (ORBITAL_ID) The spin-up charge density langle n_uparrownu rangle for orbital nu in the unit cell.\ndensity_dn: (ORBITAL_ID) The spin-down charge density langle n_downarrownu rangle for orbital nu in the unit cell.\ndouble_occ: (ORBITAL_ID) The double-occupance langle n_uparrownu n_downarrownu rangle for orbital nu in the unit cell.","category":"section"},{"location":"simulation_output/#Local-Tight-Binding-Measurements","page":"Simulation Output Overview","title":"Local Tight-Binding Measurements","text":"onsite_energy: (ORBITAL_ID) The total on-site energy sum_sigma (epsilon_sigmanu - mu) langle n_sigmanu rangle for orbital nu in the unit cell.\nonsite_energy_up: (ORBITAL_ID) The spin-up on-site energy (epsilon_uparrownu - mu) langle n_uparrownu rangle for orbital nu in the unit cell.\nonsite_energy_dn: (ORBITAL_ID) The spin-down on-site energy (epsilon_downarrownu - mu) langle n_downarrownu rangle for orbital nu in the unit cell.\nbare_hopping_energy: (HOPPING_ID) The bare hopping energy -sum_sigma langle t_sigma(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_sigmamathbfi+mathbfrnu c^phantomdagger_sigmamathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_(mathbfi+mathbfrnu)(mathbfigamma) is the bare hopping amplitude.\nbare_hopping_energy_up: (HOPPING_ID) The bare spin-up hopping energy -langle t_uparrow(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_uparrowmathbfi+mathbfrnu c^phantomdagger_uparrowmathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_sigma(mathbfi+mathbfrnu)(mathbfigamma) is the bare hopping amplitude.\nbare_hopping_energy_dn: (HOPPING_ID) The bare spin-up hopping energy -langle t_downarrow(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_downarrowmathbfi+mathbfrnu c^phantomdagger_downarrowmathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_downarrow(mathbfi+mathbfrnu)(mathbfigamma) is the bare hopping amplitude.\nhopping_energy: (HOPPING_ID) The total hopping energy -sum_sigma langle t_lsigma(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_sigmamathbfi+mathbfrnu c^phantomdagger_sigmamathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_l(mathbfi+mathbfrnu)(mathbfigamma) is the modulated hopping amplitude.\nhopping_energy_up: (HOPPING_ID) The spin-up hopping energy -langle t_luparrow(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_uparrowmathbfi+mathbfrnu c^phantomdagger_uparrowmathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_lsigma(mathbfi+mathbfrnu)(mathbfigamma) is the modulated hopping amplitude.\nhopping_energy_dn: (HOPPING_ID) The spin-up hopping energy -langle t_ldownarrow(mathbfi+mathbfrnu)(mathbfigamma) c^dagger_downarrowmathbfi+mathbfrnu c^phantomdagger_downarrowmathbfigamma + rm hc rangle for a hopping connecting orbitals gamma and nu displaced mathbfr unit cells, where t_ldownarrow(mathbfi+mathbfrnu)(mathbfigamma) is the modulated hopping amplitude.\nhopping_amplitude: (HOPPING_ID) The average hopping amplitude frac12 N sum_sigmamathbfi langle t_sigma(mathbfi+mathbfrnu)(mathbfigamma)rangle.\nhopping_amplitude_up: (HOPPING_ID) The average spin-up hopping amplitude frac1N sum_mathbfi langle t_uparrow(mathbfi+mathbfrnu)(mathbfigamma)rangle.\nhopping_amplitude_dn: (HOPPING_ID) The average spin-down hopping amplitude frac1N sum_mathbfi langle t_downarrow(mathbfi+mathbfrnu)(mathbfigamma)rangle.\nhopping_inversion: (HOPPING_ID) Fraction of the time the overall sign of the total hopping amplitude is inverted as a result of interactions, without first averaging the hopping amplitude over imaginary time.\nhopping_inversion_up: (HOPPING_ID) Fraction of the time the overall sign of the spin-up hopping amplitude is inverted as a result of interactions, without first averaging the hopping amplitude over imaginary time.\nhopping_inversion_dn: (HOPPING_ID) Fraction of the time the overall sign of the spin-down hopping amplitude is inverted as a result of interactions, without first averaging the hopping amplitude over imaginary time.","category":"section"},{"location":"simulation_output/#Local-Hubbard-Measurements","page":"Simulation Output Overview","title":"Local Hubbard Measurements","text":"hubbard_energy: (ORBITAL_ID) The Hubbard interaction energy U_nu langle n_uparrownu n_downarrownu rangle for orbital nu in the unit cell.","category":"section"},{"location":"simulation_output/#Local-Phonon-Measurements","page":"Simulation Output Overview","title":"Local Phonon Measurements","text":"phonon_kin_energy: (PHONON_ID) The phonon kinetic energy frac12 M_n_nu langle P_n_nu^2 rangle for phonon mode n_nu in unit cell.\nphonon_pot_energy: (PHONON_ID) The phonon potential energy frac12M_n_nuOmega_0n_nu^2langle X_n_nu^2 rangle + frac124M_n_nuOmega_an_nu^2langle X_n_nu^4 rangle for phonon mode n_nu in unit cell.\nX: (PHONON_ID): The expecation values langle X_n_nu rangle for phonon mode n_nu in unit cell.\nX2: (PHONON_ID): The expecation values langle X_n_nu^2 rangle for phonon mode n_nu in unit cell.\nX3: (PHONON_ID): The expecation values langle X_n_nu^3 rangle for phonon mode n_nu in unit cell.\nX4: (PHONON_ID): The expecation values langle X_n_nu^4 rangle for phonon mode n_nu in unit cell.\ndispersion_energy: (DISPERSION_ID) The dispersion energy langle mathcalU_rm disp (mathbfr n_nu n_gamma) rangle between the two phonon models n_nu and n_gamma displaced mathbfr unit cells from eachother.","category":"section"},{"location":"simulation_output/#Local-Electron-Phonon-Interaction-Measurements","page":"Simulation Output Overview","title":"Local Electron-Phonon Interaction Measurements","text":"holstein_energy: (HOLSTEIN_ID) The total Holstein interaction energy langle hatmathcalV_rm hol n_mathbfinu (mathbfi+mathbfrgamma) rangle between a phonon mode n_mathbfinu and total charge density on orbital gamma displaced mathbfr unit cells away.\nholstein_energy_up: (HOLSTEIN_ID) The spin-up Holstein interaction energy langle hatmathcalV_rm hol uparrow n_mathbfinu (mathbfi+mathbfrgamma) rangle between a phonon mode n_mathbfinu and the spin-uparrow density on orbital gamma displaced mathbfr unit cells away.\nholstein_energy_dn: (HOLSTEIN_ID) The spin-down Holstein interaction energy langle hatmathcalV_rm hol downarrow n_mathbfinu (mathbfi+mathbfrgamma) rangle between a phonon mode n_mathbfinu and the spin-downarrow on orbital gamma displaced mathbfr unit cells away.\nssh_energy: (SSH_ID) The total SSH interaction enery langle mathcalK_rm ssh(n_mathbfinun_mathbfi+mathbfrgamma)rangle between phonon modes n_nu and n_gamma displaced mathbfr unit cells from eachother.\nssh_energy_up: (SSH_ID) The spin-up SSH interaction enery langle mathcalK_rm sshuparrow(n_mathbfinun_mathbfi+mathbfrgamma)rangle between phonon modes n_nu and n_gamma displaced mathbfr unit cells from eachother.\nssh_energy_dn: (SSH_ID) The spin-down SSH interaction enery langle mathcalK_rm sshdownarrow(n_mathbfinun_mathbfi+mathbfrgamma)rangle between phonon modes n_nu and n_gamma displaced mathbfr unit cells from eachother.","category":"section"},{"location":"simulation_output/#Correlation-Function-Measurements","page":"Simulation Output Overview","title":"Correlation Function Measurements","text":"Three types of correlation functions are reported by SmoQyDQMC.jl package. Let hatO_mathbfinu represent some operator associated with unit cell mathbfi and ID index nu. For instance, in the case of a density-density correlation, nu corresponds to an ORBITAL_ID index. The first type of correlation that may be reported are equal-time correlation function of the form\n\nC_nugamma(mathbfr) = frac1N sum_mathbfi langle O^dagger_mathbfi+mathbfrnu O^phantomdagger_mathbfigamma rangle\n\nin position space, where the sum over mathbfi runs over all unit cells, and mathbfr represents a displacement in unit cells. The corresponding equal-time correlation function in momentum space is given by\n\nC_nugamma(mathbfq) = sum_mathbfr e^-rm imathbfqcdot(mathbfr+mathbfr_nu-mathbfr_gamma) C_nugamma(mathbfr)\n\nwhere mathbfr_nu and mathbfr_gamma are static displacement vector associated with the operators hatO_mathbfinu and hatO_mathbfigamma. For instance, in the case of the density-density correlation, mathbfr_nu is the location of the orbital nu in the unit cell.\n\nThe second type of correlation function is the time-displaced correlation function in position space is given by\n\nC_nugamma(mathbfrtau) = frac1N sum_mathbfi langle O^dagger_mathbfi+mathbfrnu(tau) O^phantomdagger_mathbfigamma(0) rangle\n\nand in momentum space by\n\nC_nugamma(mathbfqtau) = sum_mathbfr e^-rm imathbfqcdot(mathbfr+mathbfr_nu-mathbfr_gamma) C_nugamma(mathbfrtau)\n\nThe last type is the integrated correlation functions in position space, given by\n\nchi_nugamma(mathbfr) = int_0^beta dtau  C_nugamma(mathbfrtau)\n\nand in momentum space by\n\nchi_nugamma(mathbfq) = int_0^beta dtau  C_nugamma(mathbfqtau)","category":"section"},{"location":"simulation_output/#vector_reporting_conventions","page":"Simulation Output Overview","title":"Displacement Vector and Momentum Reporting Conventions","text":"Consider a D dimensional finite periodic lattice, where mathbfa_d and mathbfb_d denote the corresponding lattice vectors and reciprocal lattice vectors, where d in 1D. The extent of the lattice in unit cells in the direction of each of the lattice vectors is denoted by L_d. Given these definitions, the displacement vectors are parametetized as\n\nmathbfr = sum_d=1^D mathttR_d mathbfa_d\n\nand then reported in terms of the set of integers mathttR_d in 0 L_d). Similarly, the set of mathbfk-points associated with the finite lattice are given by\n\nmathbfk = sum_d=1^D left( fracmathttK_dL_d right) mathbfb_d\n\nand then reported in term of the set of integers mathttK_d in 0 L_d).","category":"section"},{"location":"simulation_output/#Correlation-Function-Reporting-Conventions","page":"Simulation Output Overview","title":"Correlation Function Reporting Conventions","text":"In addition to reporting the set of integers mathttR_d  (mathttK_d) used to define correlation functions in position (momentum) space, they are also identified by an ID pair (mathtt*_ID_2 mathtt*_ID_1) specifying the subscripts nu and gamma. Lastly, time-displaced correlation functions also report the displacement in imaginary time, given as an integer mathttTAU in 0 L_tau such that tau = Deltatau cdot mathttTAU where beta = Deltatau cdot L_tau.","category":"section"},{"location":"simulation_output/#Defined-Correlation-Functions","page":"Simulation Output Overview","title":"Defined Correlation Functions","text":"In this section we review the various correlation measurements that the SmoQyDQMC.jl package currently supports.\n\ngreens: (ORBITAL_ID) Measures spin averaged single-particle electron Green's functions.\ngreens_up: (ORBITAL_ID) Measures spin-up single-particle electron Green's functions..\ngreens_dn: (ORBITAL_ID) Measures spin-down single-particle electron Green's functions..\ndensity: (ORBITAL_ID) Measures total density correlation functions.\nspin_z: (ORBITAL_ID) Measures spin-z correlation functions.\nspin_x: (ORBITAL_ID) Measures spin-z correlation functions.\npair: (BOND_ID) Measures pair correlation functions.\nbond: (BOND_ID) Measures bond correlation functions.\ncurrent: (HOPPING_ID) Measures current correlation functions.\nphonon_greens: (PHONON_ID) Measures phonon Green's functions, parameterized as the phonon position correlation function. The position space definition is given below, with n_alpha and n_gamma specifying phonon modes associated with orbitals alpha and gamma in the unit cell respectively.\n\nmathcalD_mathbfr^n_alpha n_gamma(tau) = frac1N sum_mathbfi langle hatX_n_alphamathbfi+mathbfr(tau) hatX_n_gammamathbfi(0) rangle","category":"section"},{"location":"simulation_output/#Composite-Correlation-Measurements","page":"Simulation Output Overview","title":"Composite Correlation Measurements","text":"Lastly, with the initialize_composite_correlation_measurement! it is possible to make user named composite correlation measurements, defined by a linear combination of one of the above correlation measuremesnts of the form\n\nhatO_mathbfi = sum_nu c_nu hatO_mathbfinu\n\nwhere c_nu are user-specified (complex or real) coefficients. Note that all cross-terms are automatically expanded out when making the composite correlation measurement, by which we mean that\n\nlangle hatO^dagger_mathbfi+mathbfr(tau) hatO^phantomdagger_mathbfi(0)  rangle\n= sum_nunu c_nu^* c_nu^phantom * langle hatO^dagger_mathbfi+mathbfrnu(tau) hatO^phantomdagger_mathbfinu(0)  rangle\n\nis measured. Note that the ID pair (mathtt*_ID_2 mathtt*_ID_1) columns are omitted from the composite correlation CSV stat files generated at the end of a simulation.","category":"section"},{"location":"examples/hubbard_ossh_square/#Square-Optical-Su-Schrieffer-Heeger-Hubbard-Model","page":"Square Optical Su-Schrieffer-Heeger-Hubbard Model","title":"Square Optical Su-Schrieffer-Heeger-Hubbard Model","text":"Download this example as a Julia script.\n\nIn this example we simulate the optical Su-Schrieffer-Heeger (OSSH)-Hubbard model on a square lattice, with a Hamiltonian given by\n\nbeginalign*\nhatH  = sum_mathbfileft(frac12MhatP_mathbfix^2+frac12MOmega^2hatX_mathbfi^2right) + sum_mathbfileft(frac12MhatP_mathbfiy^2+frac12MOmega^2hatY_mathbfi^2right) \n         + U sum_mathbfi(hatn_uparrowmathbfi-tfrac12) (hatn_downarrowmathbfi-tfrac12) - musum_mathbfisigmahatn_sigmamathbfi\n         - sum_mathbfisigmaleftt-alphaleft(hatX_mathbfi+mathbfx-hatX_mathbfiright)rightleft(hatc_sigmamathbfi+mathbfx^daggerhatc_sigmamathbfi^phantomdagger+hatc_sigmamathbfi^daggerhatc_sigmamathbfi+mathbfx^phantomdaggerright) \n         - sum_mathbfisigmaleftt-alphaleft(hatY_mathbfi+mathbfy-hatY_mathbfiright)rightleft(hatc_sigmamathbfi+mathbfy^daggerhatc_sigmamathbfi^phantomdagger+hatc_sigmamathbfi^daggerhatc_sigmamathbfi+mathbfy^phantomdaggerright)\nendalign*\n\nin which the fluctuations in the position of dispersionless phonon modes placed on each site in the lattice modulate the hopping amplitude between neighboring sites. In the above expression hatc^dagger_sigmamathbfi  (hatc^phantom dagger_sigmamathbfi) creation (annihilation) operator a spin sigma electron on site mathbfi in the lattice, and hatn_sigmamathbfi = hatc^dagger_sigmamathbfi hatc^phantom dagger_sigmamathbfi is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on site mathbfi is given by hatX_mathbfi  (hatP_mathbfi), where Omega and M are the phonon frequency and associated ion mass respectively. Therefore, the strength of the electron-phonon coupling is controlled by the parameter alpha. Lastly, the parameter U controls the strength of the on-site Hubbard interaction.\n\nNote that this example script comes with all the bells and whistles so to speak, including support for MPI parallelization as well as checkpointing.\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf\nusing MPI\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    U, # Hubbard interaction strength.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    N_local_updates, # Number of local update sweeps per measurement.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Nt = 8, # Number of time-steps in HMC update.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"square_hubbard_ossh_U%2.f_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" U Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L > 10),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"Nt\"] = Nt\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_measurements\"] = N_measurements\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"n_stab\"] = n_stab\n        metadata[\"dG_max\"] = δG_max\n        metadata[\"symmetric\"] = symmetric\n        metadata[\"checkerboard\"] = checkerboard\n        metadata[\"seed\"] = seed\n        metadata[\"hmc_acceptance_rate\"] = 0.0\n        metadata[\"local_acceptance_rate\"] = 0.0\n\n        # Initialize an instance of the type UnitCell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [[1.0,0.0],\n                            [0.0,1.0]],\n            basis_vecs   = [[0.0,0.0]]\n        )\n\n        # Initialize an instance of the type Lattice.\n        lattice = lu.Lattice(\n            L = [L,L],\n            periodic = [true,true]\n        )\n\n        # Get the number of sites in the lattice.\n        N = lu.nsites(unit_cell, lattice)\n\n        # Initialize an instance of the ModelGeometry type.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the nearest-neighbor bond in the x-direction.\n        bond_px = lu.Bond(orbitals = (1,1), displacement = [1,0])\n\n        # Add this bond in x-direction to the model geometry.\n        bond_px_id = add_bond!(model_geometry, bond_px)\n\n        # Define the nearest-neighbor bond in the y-direction.\n        bond_py = lu.Bond(orbitals = (1,1), displacement = [0,1])\n\n        # Add this bond in y-direction to the model geometry.\n        bond_py_id = add_bond!(model_geometry, bond_py)\n\n        # Define the nearest-neighbor bond in the -x-direction.\n        bond_nx = lu.Bond(orbitals = (1,1), displacement = [-1,0])\n\n        # Add this bond in +x-direction to the model geometry.\n        bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n        # Define the nearest-neighbor bond in the -y-direction.\n        bond_ny = lu.Bond(orbitals = (1,1), displacement = [0,-1])\n\n        # Add this bond in +y-direction to the model geometry.\n        bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n        # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n        t = 1.0\n\n        # Define the tight-binding model\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond_px, bond_py], # defines hopping\n            t_mean = [t, t], # defines corresponding hopping amplitude\n            μ = μ, # set chemical potential\n            ϵ_mean = [0.] # set the (mean) on-site energy\n        )\n\n        # Define the Hubbard interaction in the model.\n        hubbard_model = HubbardModel(\n            ph_sym_form = true, # if particle-hole symmetric form for Hubbard interaction is used.\n            U_orbital   = [1], # orbitals in unit cell with Hubbard interaction.\n            U_mean      = [U], # mean Hubbard interaction strength for corresponding orbital species in unit cell.\n            U_std       = [0.], # standard deviation of Hubbard interaction strength for corresponding orbital species in unit cell.\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless phonon mode to represent vibrations in the x-direction.\n        phonon_x = PhononMode(\n            basis_vec = [0.0,0.0],\n            Ω_mean = Ω\n        )\n\n        # Add x-direction optical ssh phonon to electron-phonon model.\n        phonon_x_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_x\n        )\n\n        # Define a dispersionless phonon mode to represent vibrations in the y-direction.\n        phonon_y = PhononMode(\n            basis_vec = [0.0,0.0],\n            Ω_mean = Ω\n        )\n\n        # Add y-direction optical ssh phonon to electron-phonon model.\n        phonon_y_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_y\n        )\n\n        # Defines ssh e-ph coupling such that total effective hopping.\n        ossh_x_coupling = SSHCoupling(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            phonon_ids = (phonon_x_id, phonon_x_id),\n            bond = bond_px,\n            α_mean = α\n        )\n\n        # Add x-direction optical SSH coupling to the electron-phonon model.\n        ossh_x_coupling_id = add_ssh_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            ssh_coupling = ossh_x_coupling,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Defines ssh e-ph coupling such that total effective hopping.\n        ossh_y_coupling = SSHCoupling(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            phonon_ids = (phonon_y_id, phonon_y_id),\n            bond = bond_py,\n            α_mean = α\n        )\n\n        # Add y-direction optical SSH coupling to the electron-phonon model.\n        ossh_y_coupling_id = add_ssh_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            ssh_coupling = ossh_y_coupling,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Write a model summary to file.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize Hubbard interaction parameters.\n        hubbard_parameters = HubbardParameters(\n            model_geometry = model_geometry,\n            hubbard_model = hubbard_model,\n            rng = rng\n        )\n\n        # Apply Spin Channel Hirsch Hubbard-Stratonovich transformation.\n        hst_parameters = HubbardSpinHirschHST(\n            β = β, Δτ = Δτ,\n            hubbard_parameters = hubbard_parameters,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the hubbard interaction related measurements.\n        initialize_measurements!(measurement_container, hubbard_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                (phonon_x_id, phonon_x_id),\n                (phonon_y_id, phonon_y_id)\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the bond correlation measurement\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"bond\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (bond_px_id, bond_px_id),\n                (bond_py_id, bond_py_id),\n                (bond_px_id, bond_py_id),\n            ]\n        )\n\n        # Measure composite bond correlation for detecting a bond ordered wave (BOW)\n        # that breaks a C4 rotation symmetry.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"BOW_C4\",\n            correlation = \"bond\",\n            ids = [bond_px_id, bond_py_id, bond_nx_id, bond_ny_id],\n            coefficients = [+1.0, +1.0im, -1.0, -1.0im],\n            displacement_vecs = [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Measure composite bond correlation for detecting a bond ordered wave (BOW)\n        # that breaks a C2 rotation symmetry.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"BOW_C2\",\n            correlation = \"bond\",\n            ids = [bond_px_id, bond_py_id, bond_nx_id, bond_ny_id],\n            coefficients = [+1.0, -1.0, +1.0, -1.0],\n            displacement_vecs = [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Initialize the d-wave pair susceptibility measurement.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"d-wave\",\n            correlation = \"pair\",\n            ids = [bond_px_id, bond_nx_id, bond_py_id, bond_ny_id],\n            coefficients = [0.5, 0.5, -0.5, -0.5],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Initialize the extended s-wave pair susceptibility measurement.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"ext-s-wave\",\n            correlation = \"pair\",\n            ids = [bond_px_id, bond_nx_id, bond_py_id, bond_ny_id],\n            coefficients = [0.5, 0.5, 0.5, 0.5],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            exit_code = 13,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, electron_phonon_parameters,\n            hubbard_parameters, hst_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        hubbard_parameters = checkpoint[\"hubbard_parameters\"]\n        hst_parameters = checkpoint[\"hst_parameters\"]\n        electron_phonon_parameters = checkpoint[\"electron_phonon_parameters\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for Hubbard interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n\n    # Initialize FermionPathIntegral type for both the spin-up and spin-down electrons to account for the current\n    # Hubbard-Stratonovich field configuration.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hst_parameters)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, electron_phonon_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices for spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type for spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Initialize alternate FermionGreensCalculator type for performing reflection updates.\n    fermion_greens_calculator_up_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_up)\n    fermion_greens_calculator_dn_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_dn)\n\n    # Allocate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # Gup(τ,τ)\n    Gup_τ0 = similar(Gup) # Gup(τ,0)\n    Gup_0τ = similar(Gup) # Gup(0,τ)\n    Gdn_ττ = similar(Gdn) # Gdn(τ,τ)\n    Gdn_τ0 = similar(Gdn) # Gdn(τ,0)\n    Gdn_0τ = similar(Gdn) # Gdn(0,τ)\n\n    # Initialize diagnostic parameters to asses numerical stability.\n    δG = zero(logdetGup)\n    δθ = zero(logdetGup)\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = Gup, Nt = Nt, Δt = π/(2*Nt)\n    )\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform an HMC update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = hmc_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Iterate over number of local updates to perform.\n        for local_update in 1:N_local_updates\n\n            # Perform local update.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn,\n                hst_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n                update_stabilization_frequency = true\n            )\n\n            # Record acceptance rate for sweep.\n            metadata[\"local_acceptance_rate\"] += acceptance_rate\n        end\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            exit_code = 13,\n            # Contents of checkpoint file below.\n            n_therm = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            hubbard_parameters, hst_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Reset diagnostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetGup)\n    δθ = zero(logdetGup)\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over measurements.\n    for measurement in n_measurements:N_measurements\n\n        # Perform an HMC update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = hmc_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters, hmc_updater,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Iterate over number of local updates to perform.\n        for local_update in 1:N_local_updates\n\n            # Perform local update.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn,\n                hst_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n                update_stabilization_frequency = true\n            )\n\n            # Record acceptance rate for sweep.\n            metadata[\"local_acceptance_rate\"] += acceptance_rate\n        end\n\n        # Make measurements.\n        (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n            logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry,\n            tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (hubbard_parameters, hst_parameters, electron_phonon_parameters)\n        )\n\n        # Write the bin-averaged measurements to file if update ÷ bin_size == 0.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            exit_code = 13,\n            # Contents of checkpoint file below.\n            n_therm = N_therm + 1,\n            n_measurements = measurement + 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            hubbard_parameters, hst_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"local_acceptance_rate\"] /= (N_local_updates * N_measurements + N_therm)\n\n    # Record largest numerical error encountered during simulation.\n    metadata[\"dG\"] = δG\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm;\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = true,\n        decimals = 6,\n        delimiter = \" \"\n    )\n\n    # Calculate C4 BOW q=(π,π) correlation ratio.\n    Rbow, ΔRbow = compute_composite_correlation_ratio(\n        comm;\n        datafolder = simulation_info.datafolder,\n        name = \"BOW_C4\",\n        type = \"equal-time\",\n        q_point = (L÷2, L÷2),\n        q_neighbors = [\n            (L÷2+1, L÷2), (L÷2, L÷2+1),\n            (L÷2-1, L÷2), (L÷2, L÷2-1)\n        ]\n    )\n\n    # Record the correlation ratio.\n    metadata[\"Rbow_mean\"] = real(Rbow)\n    metadata[\"Rbow_std\"] = ΔRbow\n\n    # Calculate AFM correlation ratio.\n    Rafm, ΔRafm = compute_correlation_ratio(\n        datafolder = simulation_info.datafolder,\n        correlation = \"spin_z\",\n        type = \"equal-time\",\n        id_pairs = [(1, 1)],\n        id_pair_coefficients = [1.0],\n        q_point = (L÷2, L÷2),\n        q_neighbors = [\n            (L÷2+1, L÷2), (L÷2-1, L÷2),\n            (L÷2, L÷2+1), (L÷2, L÷2-1)\n        ]\n    )\n\n    # Record the AFM correlation ratio mean and standard deviation.\n    metadata[\"Rafm_mean\"] = real(Rafm)\n    metadata[\"Rafm_std\"] = ΔRafm\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        U = parse(Float64, ARGS[2]), # Hubbard interaction strength.\n        Ω = parse(Float64, ARGS[3]), # Phonon energy.\n        α = parse(Float64, ARGS[4]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[5]), # Chemical potential.\n        L = parse(Int, ARGS[6]), # System size.\n        β = parse(Float64, ARGS[7]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[8]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[9]), # Total number of measurements.\n        N_bins = parse(Int, ARGS[10]), # Number of times bin-averaged measurements are recorded.\n        N_local_updates = parse(Int, ARGS[11]), # Number of local updates per measurement.\n        checkpoint_freq = parse(Float64, ARGS[12]), # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"section"},{"location":"#SmoQyDQMC","page":"Home","title":"SmoQyDQMC","text":"Documentation for SmoQyDQMC.jl. This package implements the determinant quantum Monte Carlo (DQMC) method for Hubbard, and electron-phonon interactions, including both Holstein and Su-Schrieffer-Heeger (SSH) style electron-phonon coupling.\n\nThis code is currently in the experimental phase of development.","category":"section"},{"location":"#Funding","page":"Home","title":"Funding","text":"The development of this code was supported by the U.S. Department of Energy, Office of Science, Basic Energy Sciences, under Award Number DE-SC0022311.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install the SmoQyDQMC.jl, simply open the Julia REPL and run the commands\n\njulia> ]\npkg> add SmoQyDQMC\n\nor equivalently via Pkg do\n\njulia> using Pkg; Pkg.add(\"SmoQyDQMC\")","category":"section"},{"location":"#Updating","page":"Home","title":"Updating","text":"To update SmoQyDQMC.jl try the following:\n\njulia> ]\npkg> update SmoQyDQMC\n\nHowever, sometimes this fails to update required dependencies. If issues arise, we recommend first removing and then reinstalling SmoQyDQMC.jl:\n\njulia> ]\npkg> remove SmoQyDQMC\npkg> add SmoQyDQMC","category":"section"},{"location":"#Publication-List","page":"Home","title":"Publication List","text":"This sections lists of some of the publications that report results generated using the SmoQyDQMC.jl package.\n\nS. M. Costa, B. Cohen-Stead and S. Johnston. Antiferromagnetism and Kekulbackslash'e valence bond order in the honeycomb optical Su-Schrieffer-Heeger-Hubbard model, arXiv preprint arXiv:2511.21440 (2025).\n\n\n\nJ. Nys and J. Carrasquilla. Fermionic neural Gibbs states, arXiv preprint arXiv:2512.04663 (2025).\n\n\n\nQ. Li, D.-W. Qu, B.-B. Chen, T. Shi and W. Li. Thermal Tensor Network Simulations of Fermions with a Fixed Filling, arXiv preprint arXiv:2511.07303 (2025).\n\n\n\nM. Naamneh, E. C. O'Quinn, E. Paris, D. McNally, Y. Tseng, W. R. Pudełko, D. J. Gawryluk, J. Shamblin, B. Cohen-Stead, M. Shi, M. Radovic, M. K. Lang, T. Schmitt, S. Johnston and N. C. Plumb. Persistence of small polarons into the superconducting doping range of textBa_1text-xtextK_xtextBiO_3. Phys. Rev. Res. 7, 043082 (2025).\n\n\n\nA. Al-Eryani, S. Andergassen and M. M. Scherer. Intertwined fluctuations and isotope effects in the Hubbard-Holstein model on the square lattice from functional renormalization. Phys. Rev. Res. 7, 043052 (2025).\n\n\n\nJ. Xiong, H. Li, Y. Su and D. Li. Application of many-body nonperturbative theories to the three-dimensional attractive Hubbard model. Phys. Rev. B 112, 064509 (2025).\n\n\n\nY. Su, R. Xiao, J. Xiong, H. Li, H. Huang and D. Li. Nonpertubative Many-Body Theory for the Two-Dimensional Hubbard Model at Low Temperature: From Weak to Strong Coupling Regimes, arXiv preprint arXiv:2503.12468 (2025).\n\n\n\nY. Zhang, P. M. Dee, B. Cohen-Stead, T. A. Maier, S. Johnston and R. Scalettar. Optimizing the critical temperature and superfluid density of a metal-superconductor bilayer. Phys. Rev. B 112, 064510 (2025).\n\n\n\nB. Shi. Semideterministic and stochastic sampling of Feynman diagrams with 1N_f expansions. Phys. Rev. Res. 7, 023177 (2025).\n\n\n\nA. Tanjaroon Ly, B. Cohen-Stead and S. Johnston. Antiferromagnetic and bond-order-wave phases in the half-filled two-dimensional optical Su-Schrieffer-Heeger-Hubbard model. Phys. Rev. B 111, 245138 (2025).\n\n\n\nP. Mai, B. Cohen-Stead, T. A. Maier and S. Johnston. Fluctuating charge-density-wave correlations in the three-band Hubbard model. Proceedings of the National Academy of Sciences 121, e2408717121 (2024).\n\n\n\nJ. Neuhaus, N. S. Nichols, D. Banerjee, B. Cohen-Stead, T. A. Maier, A. D. Maestro and S. Johnston. SmoQyDEAC.jl: A differential evolution package for the analytic continuation of imaginary time correlation functions. SciPost Phys. Codebases, 39 (2024).\n\n\n\nS. Malkaruge Costa, B. Cohen-Stead and S. Johnston. Kekulé valence bond order in the honeycomb lattice optical Su-Schrieffer-Heeger model and its relevance to graphene. Phys. Rev. B 110, 115130 (2024).\n\n\n\nT. Shen, H. Barghathi, A. Del Maestro and B. M. Rubenstein. Disentangling the physics of the attractive Hubbard model as a fully interacting model of fermions via the accessible and symmetry-resolved entanglement entropies. Phys. Rev. B 109, 195119 (2024).\n\n\n\nG.-H. Huang and Z. Wu. Magnetic correlations of a doped and frustrated Hubbard model: Benchmarking the two-particle self-consistent theory against a quantum simulator. Phys. Rev. B 110, L100406 (2024).\n\n\n\nS. Malkaruge Costa, B. Cohen-Stead, A. T. Ly, J. Neuhaus and S. Johnston. Comparative determinant quantum Monte Carlo study of the acoustic and optical variants of the Su-Schrieffer-Heeger model. Phys. Rev. B 108, 165138 (2023).\n\n\n\nA. Tanjaroon Ly, B. Cohen-Stead, S. Malkaruge Costa and S. Johnston. Comparative study of the superconductivity in the Holstein and optical Su-Schrieffer-Heeger models. Phys. Rev. B 108, 184501 (2023).\n\n\n\n","category":"section"},{"location":"#Notable-Package-Dependencies","page":"Home","title":"Notable Package Dependencies","text":"This section reviews some notable package dependencies.","category":"section"},{"location":"#Re-exported-Packages","page":"Home","title":"Re-exported Packages","text":"The SmoQyDQMC.jl re-exports certain packages using the Reexport.jl package in order to simplify the installation process.\n\nLatticeUtilties.jl: Used to represent arbitrary lattice geometries.\nJDQMCFramework.jl: Implements and exports the basic framework for running a DQMC simulation.\nJDQMCMeasurements.jl: Implements various global, local and correlation measurements for a DQMC simulation.\nMuTuner.jl: Impelments and exports an algorithm for tuning the chemical potential to achieve a target density in grand canonical Monte Carlo simulations.","category":"section"},{"location":"#External-Dependencies","page":"Home","title":"External Dependencies","text":"StableLinearAlgebra.jl: Implements optimized numerical stabilizaiton methods required by DQMC simulations.\nCheckerboard.jl: Implements and exports the checkerboard method for approximating exponentiated hopping matrices by a sparse matrix.\nJLD2.jl: Package used to write data to binary files in an HDF5 compatible format. It is also recommended this package be used at the scripting level to implement checkpointing in a simulation.","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you found this library to be useful in the course of academic work, please consider citing us:\n\n@Article{SmoQyDQMC.jl,\n\ttitle={{SmoQyDQMC.jl: A flexible implementation of determinant quantum Monte Carlo for Hubbard and electron-phonon interactions}},\n\tauthor={Benjamin Cohen-Stead and Sohan Malkaruge Costa and James Neuhaus and Andy Tanjaroon Ly and Yutan Zhang and Richard Scalettar and Kipton Barros and Steven Johnston},\n\tjournal={SciPost Phys. Codebases},\n\tpages={29},\n\tyear={2024},\n\tpublisher={SciPost},\n\tdoi={10.21468/SciPostPhysCodeb.29},\n\turl={https://scipost.org/10.21468/SciPostPhysCodeb.29},\n}","category":"section"},{"location":"#Contact-Us","page":"Home","title":"Contact Us","text":"For question and comments regarding this package, please email either Dr. Benjamin Cohen-Stead at bcohenst@utk.edu or Professor Steven Johnston at sjohn145@utk.edu.","category":"section"},{"location":"examples/bssh_square/#Bond-Su-Schrieffer-Heeger-Square","page":"Bond Su-Schrieffer-Heeger Square","title":"Bond Su-Schrieffer-Heeger Square","text":"Download this example as a Julia script.\n\nIn this example we simulate the optical Su-Schrieffer-Heeger (OSSH) model on a square lattice, with a Hamiltonian given by\n\nbeginalign*\nhatH  = sum_langle ijrangleleft(frac12MhatP_langle ijrangle^2+frac12MOmega^2hatX_langle ijrangle^2right) \n         - sum_langle ijranglesigmaleftt-alphahatX_langle ijranglerightleft(hatc_sigmai^daggerhatc_sigmaj^phantomdagger+hatc_sigmaj^daggerhatc_sigmai^phantomdaggerright)-musum_isigmahatn_sigmai\nendalign*\n\nin which the fluctuations in the position of dispersionless phonon modes placed on each site in the lattice modulate the hopping amplitude between neighboring sites. In the above expression hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creation (annihilation) operator a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on the bond connecting sites i and j is given by hatX_langle ij rangle  (hatP_langle ij rangle), where Omega and M are the phonon frequency and associated ion mass respectively. Lastly, the strength of the electron-phonon coupling is controlled by the parameter alpha.\n\nNote that this example script comes with all the bells and whistles so to speak, including support for MPI parallelization as well as checkpointing.\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities as lu\nimport SmoQyDQMC.JDQMCFramework as dqmcf\n\nusing Random\nusing Printf\nusing MPI\n\n# Top-level function to run simulation.\nfunction run_simulation(\n    comm::MPI.Comm; # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID, # Simulation ID.\n    Ω, # Phonon energy.\n    α, # Electron-phonon coupling.\n    μ, # Chemical potential.\n    L, # System size.\n    β, # Inverse temperature.\n    N_therm, # Number of thermalization updates.\n    N_measurements, # Total number of measurements.\n    N_bins, # Number of times bin-averaged measurements are written to file.\n    checkpoint_freq, # Frequency with which checkpoint files are written in hours.\n    runtime_limit = Inf, # Simulation runtime limit in hours.\n    Nt = 10, # Number of time-steps in HMC update.\n    Δτ = 0.05, # Discretization in imaginary time.\n    n_stab = 10, # Numerical stabilization period in imaginary-time slices.\n    δG_max = 1e-6, # Threshold for numerical error corrected by stabilization.\n    symmetric = false, # Whether symmetric propagator definition is used.\n    checkerboard = false, # Whether checkerboard approximation is used.\n    seed = abs(rand(Int)), # Seed for random number generator.\n    filepath = \".\" # Filepath to where data folder will be created.\n)\n\n    # Record when the simulation began.\n    start_timestamp = time()\n\n    # Convert runtime limit from hours to seconds.\n    runtime_limit = runtime_limit * 60.0^2\n\n    # Convert checkpoint frequency from hours to seconds.\n    checkpoint_freq = checkpoint_freq * 60.0^2\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"bssh_square_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Get MPI process ID.\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize simulation info.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        write_bins_concurrent = (L>10),\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(comm, simulation_info)\n\n    # If starting a new simulation i.e. not resuming a previous simulation.\n    if !simulation_info.resuming\n\n        # Begin thermalization updates from start.\n        n_therm = 1\n\n        # Begin measurement updates from start.\n        n_measurements = 1\n\n        # Initialize random number generator\n        rng = Xoshiro(seed)\n\n        # Initialize metadata dictionary\n        metadata = Dict()\n\n        # Record simulation parameters.\n        metadata[\"Nt\"] = Nt\n        metadata[\"N_therm\"] = N_therm\n        metadata[\"N_measurements\"] = N_measurements\n        metadata[\"N_bins\"] = N_bins\n        metadata[\"n_stab\"] = n_stab\n        metadata[\"dG_max\"] = δG_max\n        metadata[\"symmetric\"] = symmetric\n        metadata[\"checkerboard\"] = checkerboard\n        metadata[\"seed\"] = seed\n        metadata[\"hmc_acceptance_rate\"] = 0.0\n        metadata[\"reflection_acceptance_rate\"] = 0.0\n        metadata[\"swap_acceptance_rate\"] = 0.0\n\n        # Initialize an instance of the type UnitCell.\n        unit_cell = lu.UnitCell(\n            lattice_vecs = [[1.0, 0.0],\n                            [0.0, 1.0]],\n            basis_vecs   = [[0.0, 0.0]]\n        )\n\n        # Initialize an instance of the type Lattice.\n        lattice = lu.Lattice(\n            L = [L,L],\n            periodic = [true,true]\n        )\n\n        # Get the number of sites in the lattice.\n        N = lu.nsites(unit_cell, lattice)\n\n        # Initialize an instance of the ModelGeometry type.\n        model_geometry = ModelGeometry(unit_cell, lattice)\n\n        # Define the nearest-neighbor bond in the x-direction.\n        bond_px = lu.Bond(orbitals = (1,1), displacement = [1,0])\n\n        # Add this bond in x-direction to the model geometry.\n        bond_px_id = add_bond!(model_geometry, bond_px)\n\n        # Define the nearest-neighbor bond in the y-direction.\n        bond_py = lu.Bond(orbitals = (1,1), displacement = [0,1])\n\n        # Add this bond in y-direction to the model geometry.\n        bond_py_id = add_bond!(model_geometry, bond_py)\n\n        # Define the nearest-neighbor bond in the -x-direction.\n        bond_nx = lu.Bond(orbitals = (1,1), displacement = [-1,0])\n\n        # Add this bond in +x-direction to the model geometry.\n        bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n        # Define the nearest-neighbor bond in the -y-direction.\n        bond_ny = lu.Bond(orbitals = (1,1), displacement = [0,-1])\n\n        # Add this bond in +y-direction to the model geometry.\n        bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n        # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n        t = 1.0\n\n        # Define the tight-binding model\n        tight_binding_model = TightBindingModel(\n            model_geometry = model_geometry,\n            t_bonds = [bond_px, bond_py], # defines hopping\n            t_mean = [t, t], # defines corresponding hopping amplitude\n            μ = μ, # set chemical potential\n            ϵ_mean = [0.] # set the (mean) on-site energy\n        )\n\n        # Initialize a null electron-phonon model.\n        electron_phonon_model = ElectronPhononModel(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Define a dispersionless phonon mode to represent vibrations in the x-direction.\n        phonon_x = PhononMode(\n            basis_vec = [0.0,0.0],\n            Ω_mean = Ω\n        )\n\n        # Add x-direction optical ssh phonon to electron-phonon model.\n        phonon_x_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_x\n        )\n\n        # Define a dispersionless phonon mode to represent vibrations in the y-direction.\n        phonon_y = PhononMode(\n            basis_vec = [0.0,0.0],\n            Ω_mean = Ω\n        )\n\n        # Add y-direction optical ssh phonon to electron-phonon model.\n        phonon_y_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = phonon_y\n        )\n\n        # Define frozen phonon mode with infinite mass.\n        fphonon = PhononMode(\n            basis_vec = [0.0,0.0],\n            Ω_mean = Ω,\n            M = Inf # Set phonon mass to infinity.\n        )\n\n        # Add frozen phonon mode to model.\n        fphonon_id = add_phonon_mode!(\n            electron_phonon_model = electron_phonon_model,\n            phonon_mode = fphonon\n        )\n\n        # Defines ssh e-ph coupling such that total effective hopping is t_eff = t-α⋅X .\n        bssh_coupling_x = SSHCoupling(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            phonon_ids = (fphonon_id, phonon_x_id),\n            bond = bond_px,\n            α_mean = α\n        )\n\n        # Add bond SSH coupling to the electron-phonon model.\n        bssh_coupling_x_id = add_ssh_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            ssh_coupling = bssh_coupling_x,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Defines ssh e-ph coupling such that total effective hopping is t_eff = t-α⋅Y .\n        bssh_coupling_y = SSHCoupling(\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            phonon_ids = (fphonon_id, phonon_y_id),\n            bond = bond_py,\n            α_mean = α\n        )\n\n        # Add bond SSH coupling to the electron-phonon model.\n        bssh_coupling_y_id = add_ssh_coupling!(\n            electron_phonon_model = electron_phonon_model,\n            ssh_coupling = bssh_coupling_y,\n            tight_binding_model = tight_binding_model\n        )\n\n        # Write a model summary to file.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (electron_phonon_model,)\n        )\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize electron-phonon parameters.\n        electron_phonon_parameters = ElectronPhononParameters(\n            β = β, Δτ = Δτ,\n            electron_phonon_model = electron_phonon_model,\n            tight_binding_parameters = tight_binding_parameters,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the electron-phonon interaction related measurements.\n        initialize_measurements!(measurement_container, electron_phonon_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [\n                # Measure green's functions for all pairs or orbitals.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"phonon_greens\",\n            time_displaced = true,\n            pairs = [\n                (phonon_x_id, phonon_x_id),\n                (phonon_y_id, phonon_y_id),\n            ]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                # Measure local s-wave pair susceptibility associated with\n                # each orbital in the unit cell.\n                (1, 1),\n            ]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (1, 1),\n            ]\n        )\n\n        # Initialize the bond correlation measurement\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"bond\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [\n                (bond_px_id, bond_px_id),\n                (bond_py_id, bond_py_id),\n                (bond_px_id, bond_py_id),\n            ]\n        )\n\n        # Measure composite bond correlation for detecting a bond ordered wave (BOW)\n        # that breaks a C4 rotation symmetry.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"BOW_C4\",\n            correlation = \"bond\",\n            ids = [bond_px_id, bond_py_id, bond_nx_id, bond_ny_id],\n            coefficients = [+1.0, +1.0im, -1.0, -1.0im],\n            displacement_vecs = [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Measure composite bond correlation for detecting a bond ordered wave (BOW)\n        # that breaks a C2 rotation symmetry.\n        initialize_composite_correlation_measurement!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            name = \"BOW_C2\",\n            correlation = \"bond\",\n            ids = [bond_px_id, bond_py_id, bond_nx_id, bond_ny_id],\n            coefficients = [+1.0, -1.0, +1.0, -1.0],\n            displacement_vecs = [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]],\n            time_displaced = false,\n            integrated = true\n        )\n\n        # Write initial checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            exit_code = 13,\n            # Contents of checkpoint file below.\n            n_therm, n_measurements,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n\n    # If resuming a previous simulation.\n    else\n\n        # Load the checkpoint file.\n        checkpoint, checkpoint_timestamp = read_jld2_checkpoint(simulation_info)\n\n        # Unpack contents of checkpoint dictionary.\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        electron_phonon_parameters = checkpoint[\"electron_phonon_parameters\"]\n        measurement_container = checkpoint[\"measurement_container\"]\n        model_geometry = checkpoint[\"model_geometry\"]\n        metadata = checkpoint[\"metadata\"]\n        rng = checkpoint[\"rng\"]\n        n_therm = checkpoint[\"n_therm\"]\n        n_measurements = checkpoint[\"n_measurements\"]\n    end\n\n    # Allocate a single FermionPathIntegral for both spin-up and down electrons.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize FermionPathIntegral type to account for electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Initialize imaginary-time propagators for all imaginary-time slices.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator type.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing EFA-HMC, reflection and swap updates below.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time electron Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize electron Green's function matrix, also calculating the matrix determinant as the same time.\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize diagnostic parameters to asses numerical stability.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)\n\n    # Initialize Hamiltonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = EFAHMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = π/(2*Nt)\n    )\n\n    # Iterate over number of thermalization updates to perform.\n    for update in n_therm:N_therm\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            exit_code = 13,\n            # Contents of checkpoint file below.\n            n_therm  = update + 1,\n            n_measurements = 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Reset diagnostic parameters used to monitor numerical stability to zero.\n    δG = zero(logdetG)\n    δθ = zero(logdetG)\n\n    # Calculate the bin size.\n    bin_size = N_measurements ÷ N_bins\n\n    # Iterate over updates and measurements.\n    for measurement in n_measurements:N_measurements\n\n        # Perform a reflection update.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform a swap update.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        metadata[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        metadata[\"hmc_acceptance_rate\"] += accepted\n\n        # Make measurements.\n        (logdetG, sgndetG, δG, δθ) = make_measurements!(\n            measurement_container,\n            logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n            model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n            coupling_parameters = (electron_phonon_parameters,)\n        )\n\n        # Write the bin-averaged measurements to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            measurement = measurement,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write checkpoint file.\n        checkpoint_timestamp = write_jld2_checkpoint(\n            comm,\n            simulation_info;\n            checkpoint_timestamp = checkpoint_timestamp,\n            checkpoint_freq = checkpoint_freq,\n            start_timestamp = start_timestamp,\n            runtime_limit = runtime_limit,\n            exit_code = 13,\n            # Contents of checkpoint file below.\n            n_therm  = N_therm + 1,\n            n_measurements = measurement + 1,\n            tight_binding_parameters, electron_phonon_parameters,\n            measurement_container, model_geometry, metadata, rng\n        )\n    end\n\n    # Merge binned data into a single HDF5 file.\n    merge_bins(simulation_info)\n\n    # Calculate acceptance rates.\n    metadata[\"hmc_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"reflection_acceptance_rate\"] /= (N_measurements + N_therm)\n    metadata[\"swap_acceptance_rate\"] /= (N_measurements + N_therm)\n\n    # Record largest numerical error encountered during simulation.\n    metadata[\"dG\"] = δG\n\n    # Write simulation metadata to simulation_info.toml file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Process the simulation results, calculating final error bars for all measurements.\n    # writing final statistics to CSV files.\n    process_measurements(\n        comm,\n        datafolder = simulation_info.datafolder,\n        n_bins = N_bins,\n        export_to_csv = true,\n        scientific_notation = false,\n        decimals = 7,\n        delimiter = \" \"\n    )\n\n    # Calculate C4 BOW q=(π,π) correlation ratio.\n    Rbow, ΔRbow = compute_composite_correlation_ratio(\n        comm;\n        datafolder = simulation_info.datafolder,\n        name = \"BOW_C4\",\n        type = \"equal-time\",\n        q_point = (L÷2, L÷2),\n        q_neighbors = [\n            (L÷2+1, L÷2), (L÷2, L÷2+1),\n            (L÷2-1, L÷2), (L÷2, L÷2-1)\n        ]\n    )\n\n    # Record the correlation ratio.\n    metadata[\"Rbow_mean_real\"] = real(Rbow)\n    metadata[\"Rbow_mean_imag\"] = imag(Rbow)\n    metadata[\"Rbow_std\"] = ΔRbow\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)\n\n    # Rename the data folder to indicate the simulation is complete.\n    simulation_info = rename_complete_simulation(\n        comm, simulation_info,\n        delete_jld2_checkpoints = true\n    )\n\n    return nothing\nend # end of run_simulation function\n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Initialize MPI\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_simulation(\n        comm;\n        sID = parse(Int, ARGS[1]), # Simulation ID.\n        Ω = parse(Float64, ARGS[2]), # Phonon energy.\n        α = parse(Float64, ARGS[3]), # Electron-phonon coupling.\n        μ = parse(Float64, ARGS[4]), # Chemical potential.\n        L = parse(Int, ARGS[5]), # System size.\n        β = parse(Float64, ARGS[6]), # Inverse temperature.\n        N_therm = parse(Int, ARGS[7]), # Number of thermalization updates.\n        N_measurements = parse(Int, ARGS[8]), # Total number of measurements.\n        N_bins = parse(Int, ARGS[9]), # Number of times bin-averaged measurements are written to file.\n        checkpoint_freq = parse(Float64, ARGS[10]), # Frequency with which checkpoint files are written in hours.\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"section"}]
}
