var documenterSearchIndex = {"docs":
[{"location":"examples/hubbard_chain_mpi/","page":"Example 1(b): Hubbard Chain with MPI","title":"Example 1(b): Hubbard Chain with MPI","text":"EditURL = \"https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/main/literate_scripts/hubbard_chain_mpi.jl\"","category":"page"},{"location":"examples/hubbard_chain_mpi/#Example-1(b):-Hubbard-Chain-with-MPI","page":"Example 1(b): Hubbard Chain with MPI","title":"Example 1(b): Hubbard Chain with MPI","text":"","category":"section"},{"location":"examples/hubbard_chain_mpi/","page":"Example 1(b): Hubbard Chain with MPI","title":"Example 1(b): Hubbard Chain with MPI","text":"In this example we simulate the same system as in example 1, the half-filled Hubbard chain. However, in this example we use MPI, via the MPI.jl, to perform multiple simulations in parallel, with the results getting automatically averaged over at the end of the simulation. The command to run the script scripts/hubbard_chain_mpi.jl is very similar to the previous example, only modified slightly:","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Example 1(b): Hubbard Chain with MPI","title":"Example 1(b): Hubbard Chain with MPI","text":"> mpiexecjl -n 8 julia hubbard_chain.jl 1 6.0 0.0 8.0 16 2000 10000 50","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Example 1(b): Hubbard Chain with MPI","title":"Example 1(b): Hubbard Chain with MPI","text":"This would result in 8 identical simulations being run in parallel. It possible that this command may need to be modified slightly depending on how MPI is set up on your system. For more information I recommend you refer to the MPI.jl documenation.","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Example 1(b): Hubbard Chain with MPI","title":"Example 1(b): Hubbard Chain with MPI","text":"Below you can find the contents of the script example_scripts/hubbard_chain_mpi.jl with some expanded discussion explaining how MPI is incorporated into the script in the for of additional and longer comments.","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Example 1(b): Hubbard Chain with MPI","title":"Example 1(b): Hubbard Chain with MPI","text":"using LinearAlgebra\nusing Random\nusing Printf\nusing MPI\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# initialize MPI\nMPI.Init()\n\n# Define top-level function for running DQMC simulation\nfunction run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_chain_U%.2f_mu%.2f_L%d_b%.2f\" U μ L β\n\n    # Get the MPI comm rank, which fixes the process ID (pID).\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID,\n        pID = pID\n    )\n\n    # Synchronize all the MPI processes.\n    # Here we need to make sure the data folder is initialized before letting\n    # all the various processes move beyond this point.\n    MPI.Barrier(comm)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"reflection_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted = false, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n        U_orbital = [1],\n        U_mean = [U],\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Write the model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    # Synchronize all the MPI processes.\n    # We need to ensure the sub-directories the measurements will be written are created\n    # prior to letting any of the processes move beyond this point.\n    MPI.Barrier(comm)\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters,)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Synchronize all the MPI processes.\n    # Before we prcoess the binned data to get the final averages and error bars\n    # we need to make sure all the simulations running in parallel have run to\n    # completion.\n    MPI.Barrier(comm)\n\n    # Have the primary MPI process calculate the final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    if iszero(simulation_info.pID)\n        process_measurements(simulation_info.datafolder, N_bins)\n    end\n\n    return nothing\nend\n\n\n# Only excute if script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    μ = parse(Float64, ARGS[3])\n    β = parse(Float64, ARGS[4])\n    L = parse(Int, ARGS[5])\n    N_burnin = parse(Int, ARGS[6])\n    N_updates = parse(Int, ARGS[7])\n    N_bins = parse(Int, ARGS[8])\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins)\n\n    # Finalize MPI (not strictly required).\n    MPI.Finalize()\nend","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Example 1(b): Hubbard Chain with MPI","title":"Example 1(b): Hubbard Chain with MPI","text":"","category":"page"},{"location":"examples/hubbard_chain_mpi/","page":"Example 1(b): Hubbard Chain with MPI","title":"Example 1(b): Hubbard Chain with MPI","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/bssh_chain/","page":"Example 4: Bond Su-Schrieffer-Heeger Chain","title":"Example 4: Bond Su-Schrieffer-Heeger Chain","text":"EditURL = \"https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/main/literate_scripts/bssh_chain.jl\"","category":"page"},{"location":"examples/bssh_chain/#Example-4:-Bond-Su-Schrieffer-Heeger-Chain","page":"Example 4: Bond Su-Schrieffer-Heeger Chain","title":"Example 4: Bond Su-Schrieffer-Heeger Chain","text":"","category":"section"},{"location":"examples/bssh_chain/","page":"Example 4: Bond Su-Schrieffer-Heeger Chain","title":"Example 4: Bond Su-Schrieffer-Heeger Chain","text":"In this example we simulate the bond Su-Schrieffer-Heeger (BSSH) model on a 1D chain, with a Hamiltonian given by","category":"page"},{"location":"examples/bssh_chain/","page":"Example 4: Bond Su-Schrieffer-Heeger Chain","title":"Example 4: Bond Su-Schrieffer-Heeger Chain","text":"beginalign*\nhatH = sum_i left( frac12MhatP_langle i+1 i rangle^2 + frac12MOmega^2hatX_langle i+1 i rangle^2 right)\n          - sum_sigmai t-alpha hatX_langle i+1 i rangle (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n          - mu sum_sigmai hatn_sigmai\nendalign*","category":"page"},{"location":"examples/bssh_chain/","page":"Example 4: Bond Su-Schrieffer-Heeger Chain","title":"Example 4: Bond Su-Schrieffer-Heeger Chain","text":"in which dispersionless phonon modes are placed on each bond, and their positions modulates only that single corresponding hopping amplitude. In the above expression hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creation (annihilation) operator a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on the bond connecting sites i and i+1 is given by hatX_langle i+1 i rangle  (hatP_langle i+1 i rangle), where Omega and M are the phonon frequency and associated ion mass respectively. Lastly, the strength of the electron-phonon coupling is controlled by the parameter alpha.","category":"page"},{"location":"examples/bssh_chain/","page":"Example 4: Bond Su-Schrieffer-Heeger Chain","title":"Example 4: Bond Su-Schrieffer-Heeger Chain","text":"The example script to simulate this sytem is scripts/bssh_chain.jl. A short test simulation using this script that only takes a few minutes on most personal computers is","category":"page"},{"location":"examples/bssh_chain/","page":"Example 4: Bond Su-Schrieffer-Heeger Chain","title":"Example 4: Bond Su-Schrieffer-Heeger Chain","text":"> julia bssh_chain.jl 0 1.0 0.5 0.0 4.0 16 1000 5000 20","category":"page"},{"location":"examples/bssh_chain/","page":"Example 4: Bond Su-Schrieffer-Heeger Chain","title":"Example 4: Bond Su-Schrieffer-Heeger Chain","text":"which simulates an L=16 chain with Omega = 10, alpha = 05 at half-filling (mu = 00) and an inverse temperature of beta = 40. In this example N_burnin = 1000 HMC thermalization updates are performed, followed an additional N_updates = 5000 HMC updates, after each of which measurements are made. Bin averaged measurements are then written to file N_bins = 20 during the simulation.","category":"page"},{"location":"examples/bssh_chain/","page":"Example 4: Bond Su-Schrieffer-Heeger Chain","title":"Example 4: Bond Su-Schrieffer-Heeger Chain","text":"Below you will find the source code in the script scripts/bssh_chain.jl, with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/bssh_chain/","page":"Example 4: Bond Su-Schrieffer-Heeger Chain","title":"Example 4: Bond Su-Schrieffer-Heeger Chain","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running the DQMC simulation.\nfunction run_bssh_chain_simulation(sID, Ω, α, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"bssh_chain_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.05\n\n    # For performance reasons it is important that we represent the exponentiated hopping\n    # matrix with the checkerboard approximation when simulating an SSH model, where the\n    # phonons modulate the hopping amplitudes. Without the checkerboard approximation,\n    # each time a phonon field is updated the kinetic energy matrix would need to be diagonalized\n    # to calculate its exponential, which is very computationally expensive.\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = true\n\n    # As we are using the checkboard approximation, using a symmetric definition for the propagator\n    # matrices is important as it significantly improves the accuracy of approximation.\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = true\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bin size.\n    bin_size = div(N_updates, N_bins)\n\n    # Fermionic time-step used in HMC update.\n    Δt = 1/(10*Ω)\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 10\n\n    # Number of bosonic time-steps per fermionic time-step in HMC udpate.\n    nt = 10\n\n    # Regularizaton parameter for fourier acceleration mass matrix used in HMC dyanmics.\n    reg = 1.0\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"swap_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"Nt\" => Nt,\n        \"nt\" => nt,\n        \"reg\" => reg,\n        \"seed\" => seed,\n    )\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Get the number of sites in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Unlike in the optical SSH model in the previous example, here we need to\n    # introduce two types of phonon modes. One of these phonon modes will have\n    # infinite ion mass, resulting in the associated phonon fields remaining\n    # pinned at zero. The means that when we couple these two types of phonon\n    # modes to the electrons with a SSH-like coupling mechanism, this effectively\n    # results in defining a phonon modes associated with a single bond/hopping\n    # in the lattice.\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon = PhononMode(orbital = 1, Ω_mean = Ω, M = 1.0)\n\n    # Add optical ssh phonon to electron-phonon model.\n    phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon\n    )\n\n    # Define a frozen phonon mode.\n    frozen_phonon = PhononMode(orbital = 1, Ω_mean = Ω, M = Inf)\n\n    # Add frozen phonon mode to electron-phonon model.\n    frozen_phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = frozen_phonon\n    )\n\n    # Define bond SSH coupling.\n    # Defines total effective hopping amplitude given by t_eff = t-α⋅X(i+1,i).\n    bssh_coupling = SSHCoupling(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        phonon_modes = (frozen_phonon_id, phonon_id),\n        bond = bond,\n        α_mean = α\n    )\n\n    # Add bond SSH coupling to the electron-phonon model.\n    bssh_coupling_id = add_ssh_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        ssh_coupling = bssh_coupling,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Write a model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )\n\n    #################################################\n    ### INITIALIZE FINITE LATTICE MODEL PARAMETERS ##\n    #################################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the measurement container.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the measurements associated with the tight-binding model.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the measurements associated with the electron-phonon model.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize time-displaced Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize time-displaced phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(phonon_id, phonon_id)]\n    )\n\n    # Initialize the density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurements.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (bond_id, bond_id)]\n    )\n\n    # Initialize the bond correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"bond\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(bond_id, bond_id)]\n    )\n\n    # Initialize current-current correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"current\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)] # Hopping ID pair.\n    )\n\n    # Initialize the sub-directories the various measurements will be written to.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Allocate and initialize propagators for each imaginary time slice.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize fermion greens calculator.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize equal-time Green's function matrix\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = HMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt, nt = nt, reg = reg\n    )\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a swap update.\n        # In a swap update, to phonon modes are randomly selected in the lattice\n        # and their phonon fields are exchanged for all imaginary time slices.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng, phonon_type_pairs = ((phonon_id, phonon_id),)\n        )\n\n        # Record whether the swap update was accepted or rejected.\n        additional_info[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng, initialize_force = true\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a swap update..\n            (accepted, logdetG, sgndetG) = swap_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, rng = rng, phonon_type_pairs = ((phonon_id, phonon_id),)\n            )\n\n            # Record whether the swap update was accepted or rejected.\n            additional_info[\"swap_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng, initialize_force = true\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Make measurements.\n            (logdetG, sgndetG, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (electron_phonon_parameters,)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate HMC acceptance rate.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Calculate swap update acceptance rate.\n    additional_info[\"swap_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ω = parse(Float64, ARGS[2])\n    α = parse(Float64, ARGS[3])\n    μ = parse(Float64, ARGS[4])\n    β = parse(Float64, ARGS[5])\n    L = parse(Int, ARGS[6])\n    N_burnin = parse(Int, ARGS[7])\n    N_updates = parse(Int, ARGS[8])\n    N_bins = parse(Int, ARGS[9])\n\n    # Run the simulation.\n    run_bssh_chain_simulation(sID, Ω, α, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/bssh_chain/","page":"Example 4: Bond Su-Schrieffer-Heeger Chain","title":"Example 4: Bond Su-Schrieffer-Heeger Chain","text":"","category":"page"},{"location":"examples/bssh_chain/","page":"Example 4: Bond Su-Schrieffer-Heeger Chain","title":"Example 4: Bond Su-Schrieffer-Heeger Chain","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"EditURL = \"https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/main/literate_scripts/holstein_chain.jl\"","category":"page"},{"location":"examples/holstein_chain/#Example-2:-Holstein-Chain-with-Density-Tuning","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"","category":"section"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"In this example we simulate the Holstein model for electron-phonon models on a 1D chain given by","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"hatH = hatH_e + hatH_rm ph + hatH_etextrm-ph","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"The first term describes bare tight-binding Hamiltonian","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"hatH_e = -t sum_sigmai (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n            -mu sum_sigmai hatn_sigmai","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. The second terms is the bare phonon Hamiltonian","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"hatH_rm ph = sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"which describes a dispersionless phonon modes on each site in the lattice, where hatX_i  (hatP_i) is the position (momentum) operator for the phonon mode on site i in the lattice. The phonon frequency is given by Omega, and M is the corresponding ion mass associated with the phonon mode. Lastly, the third term introduces the Holstein electron-phonon interaction","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"hatH_etextrm-ph = alpha sum_sigmai hatX_i left( hatn_sigmai - frac12 right)","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"where the strength of the interaction is controlled by the parameter alpha.","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"The example script example_scripts/holstein_chain.jl additionally simulate the Holstein model with an algorithm recently recently introduced in Phys. Rev. E 105, 045311 that dynamically tunes the chemical potential during the simulation to achieve a target electron density.","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"To run a short test simulation using this script that only takes a few minutes on most personal computers, run the following command:","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"> julia holstein_chain.jl 0 0.1 0.1 0.5 0.0 4.0 16 2000 10000 20","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"Here a Holstein chain of length L=16 is simulate with Omega = 01, alpha = 01 and inverse temperature beta = 40. The chemical potential is initialized to mu = 00, and then tuned to achieve are target electron density of langle n rangle = 05. In this example N_burnin = 2000 thermalizatoin HMC and refleciton updates are performed, followed by an additional N_updates = 10000 such updates, during which time an equivalent number of measurements are made. Bin averaged measurements are written to file N_bins = 20 during the simulation.","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"Below you can find the contents of the script example_scripts/holstein_chain.jl with additional comments that discuss in more detail what certain parts of the code are doing.","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n# Import the MuTuner module that implements the chemical potential tuning algorithm.\nimport SmoQyDQMC.MuTuner           as mt\n\n# Define top-level function for running the DQMC simulation.\nfunction run_holstein_chain_simulation(sID, Ω, α, n, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_chain_w%.2f_a%.2f_n%.2f_L%d_b%.2f\" Ω α n L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.05\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bin size.\n    bin_size = div(N_updates, N_bins)\n\n    # To update the phonon degrees of freedom in this code we primarily perform\n    # hybrid/hamiltonian Monte Carlo (HMC) updates. Below we specify some of the\n    # parameters associated with these HMC updates.\n\n    # Fermionic time-step used in HMC update.\n    Δt = 1/(10*Ω)\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 10\n\n    # Number of bosonic time-steps per fermionic time-step in HMC udpate.\n    nt = 10\n\n    # Regularizaton parameter for fourier acceleration mass matrix used in HMC dyanmics.\n    reg = 1.0\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"reflection_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"dt\" => Δt,\n        \"Nt\" => Nt,\n        \"nt\" => nt,\n        \"reg\" => reg,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Get the number of sites in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon\n    )\n\n    # Define a on-site Holstein coupling between the electron and the local dispersionless phonon mode.\n    holstein_coupling = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_id,\n    \tbond = lu.Bond(orbitals = (1,1), displacement = [0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model.\n    holstein_coupling_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Write a model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )\n\n    #################################################\n    ### INITIALIZE FINITE LATTICE MODEL PARAMETERS ##\n    #################################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize time-displaced phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(phonon_id, phonon_id)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Note that the spin-up and spin-down electron sectors are equivalent in the Holstein model\n    # without Hubbard interaction. Therefore, there is only a single Fermion determinant\n    # that needs to be calculated. This fact is reflected in the code below.\n\n    # Allocate fermion path integral type.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the fermion path integral type with respect to electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Allocate and initialize propagators for each imaginary time slice.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize fermion greens calculator.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize equal-time Green's function matrix\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = HMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt, nt = nt, reg = reg\n    )\n\n    # Initialize the density/chemical potential tuner.\n    # This type facilitates the tuning of the chemical potential to achieve\n    # at target electron density.\n    chemical_potential_tuner = mt.MuTunerLogger(n₀ = n, β = β, V = N, u₀ = 1.0, μ₀ = μ, c = 0.5)\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a reflection update.\n        # This update randomly selects a phonon mode in the lattice and reflects\n        # all the associated phonon about the origin, (xᵢ → -xᵢ).\n        # This updates all the phonon fields to cross the on-site energy barrier\n        # associated with bipolaron formation, helping reduce autocorrelation times.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng, phonon_types = (phonon_id,)\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng, initialize_force = true\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n\n        # Update the chemical potential.\n        logdetG, sgndetG = update_chemical_potential!(\n            G, logdetG, sgndetG,\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B\n        )\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a reflection update.\n            (accepted, logdetG, sgndetG) = reflection_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, rng = rng, phonon_types = (phonon_id,)\n            )\n\n            # Record whether the reflection update was accepted or rejected.\n            additional_info[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng, initialize_force = true\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Make measurements.\n            (logdetG, sgndetG, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (electron_phonon_parameters,)\n            )\n\n            # Update the chemical potential.\n            logdetG, sgndetG = update_chemical_potential!(\n                G, logdetG, sgndetG,\n                chemical_potential_tuner = chemical_potential_tuner,\n                tight_binding_parameters = tight_binding_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate HMC acceptance rate.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Calculate reflection update acceptance rate.\n    additional_info[\"reflection_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Save the density tuning profile.\n    save_density_tuning_profile(simulation_info, chemical_potential_tuner)\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ω = parse(Float64, ARGS[2])\n    α = parse(Float64, ARGS[3])\n    n = parse(Float64, ARGS[4]) # target electorn density\n    μ = parse(Float64, ARGS[5]) # intial chemical potential\n    β = parse(Float64, ARGS[6])\n    L = parse(Int, ARGS[7])\n    N_burnin = parse(Int, ARGS[8])\n    N_updates = parse(Int, ARGS[9])\n    N_bins = parse(Int, ARGS[10])\n\n    # Run the simulation.\n    run_holstein_chain_simulation(sID, Ω, α, n, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"","category":"page"},{"location":"examples/holstein_chain/","page":"Example 2: Holstein Chain with Density Tuning","title":"Example 2: Holstein Chain with Density Tuning","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/hubbard_threeband/","page":"Example 6: 3-band Hubbard Model","title":"Example 6: 3-band Hubbard Model","text":"EditURL = \"https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/main/literate_scripts/hubbard_threeband.jl\"","category":"page"},{"location":"examples/hubbard_threeband/#Example-6:-3-band-Hubbard-Model","page":"Example 6: 3-band Hubbard Model","title":"Example 6: 3-band Hubbard Model","text":"","category":"section"},{"location":"examples/hubbard_threeband/","page":"Example 6: 3-band Hubbard Model","title":"Example 6: 3-band Hubbard Model","text":"In this example we simulate an effective two-dimensional 3-band Hubbard model meant to represent a copper-oxide plane in the superconducting cuprates, with a Hamiltonian written in hole language given by","category":"page"},{"location":"examples/hubbard_threeband/","page":"Example 6: 3-band Hubbard Model","title":"Example 6: 3-band Hubbard Model","text":"beginalign*\nhatH=  sum_sigmalangle ijalpharanglet_pd^ijalpha(hatd_sigmai^daggerhatp_sigmajalpha^phantomdagger+rm hc)\n           + sum_sigmalangle ialphajalpharanglet_pp^ialphajalpha(hatp_sigmaialpha^daggerhatp_sigmajalpha^phantomdagger+rm hc)\n          +(epsilon_d-mu)sum_sigmaihatn_uparrowi^d+(epsilon_p-mu)sum_sigmajhatn_sigmajalpha^p\n          +U_dsum_ihatn_uparrowi^dhatn_downarrowi^d+U_psum_jalphahatn_uparrowjalpha^phatn_downarrowjalpha^p\nendalign*","category":"page"},{"location":"examples/hubbard_threeband/","page":"Example 6: 3-band Hubbard Model","title":"Example 6: 3-band Hubbard Model","text":"The operator hatd^dagger_sigma i  (hatd^phantom dagger_sigma i) creates (annihilates) a spin-sigma hole on a Cu-3d_x^2-y^2 orbital in unit i in the lattice. The hatp^dagger_sigmaialpha  (hatp^phantom dagger_sigmaialpha) operator creates (annihilates) a spin-sigma hole on a O-2p_alpha orbital in unit cell i, where alpha = x  rm or  y The corresponding spin-sigma hole number operators for the Cu-3d_x^2-y^2 and O-2p_alpha orbitals in unit cell i are hatn^d_sigmai and hatn^p_sigmaialpha. The hopping integrals between the Cu-3d_x^2-y^2 orbitals and nearest-neighbor O-2p_alpha are parameterized as t_pd^ijalpha = P_pd^ijalpha t_pd where P_pd^ijalpha = pm 1 is a overall phase factor. Similarly, the hopping integral between nearest-neighbor O-2p_x and O-2p_y orbitals is parameterized as t_pp^ialphajalpha = P_pp^ialphajalpha t_pp, where again P_pp^ialphajalpha t_pp = pm 1 is an overall phase factor. Refer to Fig. 1 in PhysRevB.103.144514 to see a figure detailing these phase factor conventions. The on-site energies epsilon_d and epsilon_p are for the Cu-3d_x^2-y^2 and O-2p_alpha orbitals respectively, and mu is the global chemical potential. Finally, U_d and U_p are the on-site Hubbard interactions for the Cu-3d_x^2-y^2 and O-2p_alpha orbitals respectively.","category":"page"},{"location":"examples/hubbard_threeband/","page":"Example 6: 3-band Hubbard Model","title":"Example 6: 3-band Hubbard Model","text":"The example script to simulate this sytem is scripts/hubbard_threeband.jl. A short test simulation using this script that only takes a few minutes on most personal computers is","category":"page"},{"location":"examples/hubbard_threeband/","page":"Example 6: 3-band Hubbard Model","title":"Example 6: 3-band Hubbard Model","text":"> julia hubbard_threeband.jl 0 8.5 4.1 1.13 0.49 0.0 3.24 0.0 4.0 8 2 2000 10000 50","category":"page"},{"location":"examples/hubbard_threeband/","page":"Example 6: 3-band Hubbard Model","title":"Example 6: 3-band Hubbard Model","text":"In this example we are simulating the three-band Hubbard model on a 8 times 2 unit cell finite lattice at inverse temperature beta = 40. The on-site Hubbard interaction on the Cu-3d_x^2-y^2 and O-2p_alpha is U_d = 85 and U_p = 41 respectively. The nearest-neighbor hopping integral amplitude between the Cu-3d_x^2-y^2 and O-2p_alpha orbitals is t_pd = 113, while it is t_pp = 049 between the nearest-neighbor O-2p_x and O-2p_y orbitals. The on-site energy for the Cu-3d_x^2-y^2 and O-2p_alpha orbitals epsilon_d = 00 and epsilon_p = 325. Lastly, the global chemical potential is set to mu = 00. In this simulation N_burnin = 2000 sweeps through the lattice updating the Hubbard-Stratonovich fields are performed to thermalize the system, followed by N_udpates = 10000 sweeps, after each of which measurements are made. Bin averaged measurements are written to file N_bins = 50 times during the simulation.","category":"page"},{"location":"examples/hubbard_threeband/","page":"Example 6: 3-band Hubbard Model","title":"Example 6: 3-band Hubbard Model","text":"Below you will find a more heavily commented version of the example_scripts/hubbard_threeband.jl script that includes additional exposition on what each part of the code is doing.","category":"page"},{"location":"examples/hubbard_threeband/","page":"Example 6: 3-band Hubbard Model","title":"Example 6: 3-band Hubbard Model","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running DQMC simulation\nfunction run_hubbard_threeband_simulation(sID, Ud, Up, tpd, tpp, ϵd, ϵp, μ, β, Lx, Ly, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_threeband_Ud%.2f_Up%.2f_tpd%.2f_tpp%.2f_ed%.2f_ep%.2f_mu%.2f_b%.2f_Lx%d_Ly%d\" Ud Up tpd tpp ϵd ϵp μ β Lx Ly\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[1.0, 0.0], [0.0, 1.0]],\n        basis_vecs   = [[0.0, 0.0], # Orbital ID = 1 <==> Cu-3d\n                        [0.5, 0.0], # Orbital ID = 2 <==> O-2px\n                        [0.0, 0.5]] # Orbital ID = 3 <==> O-2py\n    )\n\n    # Initialize variables to map orbitals to orbital ID.\n    (Cu_3d, O_2px, O_2py) = (1, 2, 3)\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [Lx, Ly],\n        periodic = [true, true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define bond going from Cu-3d to O-2px in +x direction.\n    bond_3d_2px_px = lu.Bond(orbitals = (Cu_3d, O_2px), displacement = [0,0])\n    bond_3d_2px_px_id = add_bond!(model_geometry, bond_3d_2px_px)\n\n    # Define bond going from Cu-3d to O-2py in +y direction.\n    bond_3d_2py_py = lu.Bond(orbitals = (Cu_3d, O_2py), displacement = [0,0])\n    bond_3d_2py_py_id = add_bond!(model_geometry, bond_3d_2py_py)\n\n    # Define bond going from Cu-3d to O-2px in -x direction.\n    bond_2px_3d_nx = lu.Bond(orbitals = (Cu_3d, O_2px), displacement = [-1,0])\n    bond_2px_3d_nx_id = add_bond!(model_geometry, bond_2px_3d_nx)\n\n    # Define bond going from Cu-3d to O-2py in -y direction.\n    bond_2py_3d_ny = lu.Bond(orbitals = (Cu_3d, O_2py), displacement = [0,-1])\n    bond_2py_3d_ny_id = add_bond!(model_geometry, bond_2py_3d_ny)\n\n    # Define bond going from O-2px to O-2py in the (-x+y)/√2 direction.\n    bond_2px_2py_nxpy = lu.Bond(orbitals = (O_2px, O_2py), displacement = [0,0])\n    bond_2px_2py_nxpy_id = add_bond!(model_geometry, bond_2px_2py_nxpy)\n\n    # Define bond going to O-2px to O-2py in the (-x-y)/√2 direction.\n    bond_2px_2py_nxny = lu.Bond(orbitals = (O_2px, O_2py), displacement = [0,-1])\n    bond_2px_2py_nxny_id = add_bond!(model_geometry, bond_2px_2py_nxny)\n\n    # Define bond going from O-2px to O-2py in the (+x+y)/√2 direction.\n    bond_2px_2py_pxpy = lu.Bond(orbitals = (O_2px, O_2py), displacement = [1,0])\n    bond_2px_2py_pxpy_id = add_bond!(model_geometry, bond_2px_2py_pxpy)\n\n    # Define bond going from O-2px to O-2py in the (+x-y)/√2 direction.\n    bond_2px_2py_pxny = lu.Bond(orbitals = (O_2px, O_2py), displacement = [1,-1])\n    bond_2px_2py_pxny_id = add_bond!(model_geometry, bond_2px_2py_pxny)\n\n    # These nexts bonds are needed to measuring a pairing channel needed to\n    # reconstruct the d-wave pair susceptibility.\n\n    # Define bond going from Cu-3d to Cu-3d in +x direction.\n    bond_3d_3d_px = lu.Bond(orbitals = (Cu_3d, Cu_3d), displacement = [1, 0])\n    bond_3d_3d_px_id = add_bond!(model_geometry, bond_3d_3d_px)\n\n    # Define bond going from Cu-3d to Cu-3d in -x direction.\n    bond_3d_3d_nx = lu.Bond(orbitals = (Cu_3d, Cu_3d), displacement = [-1, 0])\n    bond_3d_3d_nx_id = add_bond!(model_geometry, bond_3d_3d_nx)\n\n    # Define bond going from Cu-3d to Cu-3d in +y direction.\n    bond_3d_3d_py = lu.Bond(orbitals = (Cu_3d, Cu_3d), displacement = [0, 1])\n    bond_3d_3d_py_id = add_bond!(model_geometry, bond_3d_3d_py)\n\n    # Define bond going from Cu-3d to Cu-3d in -y direction.\n    bond_3d_3d_ny = lu.Bond(orbitals = (Cu_3d, Cu_3d), displacement = [0, -1])\n    bond_3d_3d_ny_id = add_bond!(model_geometry, bond_3d_3d_ny)\n\n    # Define tight binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        μ = μ,\n        ϵ_mean  = [ϵd, ϵp, ϵp],\n        t_bonds = [bond_3d_2px_px, bond_3d_2py_py, bond_2px_3d_nx, bond_2py_3d_ny,\n                   bond_2px_2py_nxpy, bond_2px_2py_nxny, bond_2px_2py_pxpy, bond_2px_2py_pxny],\n        t_mean  = [tpd, -tpd, -tpd, tpd, -tpp, tpp, tpp, -tpp]\n    )\n\n    # Initialize a finite Hubbard interaction just on copper orbitals.\n    if iszero(Up)\n        hubbard_model = HubbardModel(\n            shifted   = true, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n            U_orbital = [1, 2, 3],\n            U_mean    = [Ud, Up, Up],\n        )\n    # Initialize the Hubbard interaction on copper and oxygen orbitals.\n    else\n        hubbard_model = HubbardModel(\n            shifted   = true, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n            U_orbital = [1],\n            U_mean    = [Ud],\n        )\n    end\n\n    # Write the model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (Cu_3d, O_2px), (Cu_3d, O_2py), (O_2px, O_2py)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (Cu_3d, O_2px), (Cu_3d, O_2py), (O_2px, O_2py)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (Cu_3d, O_2px), (Cu_3d, O_2py), (O_2px, O_2py)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (Cu_3d, O_2px), (Cu_3d, O_2py), (O_2px, O_2py)]\n    )\n\n    # Measure all possible combinations of bond pairing channels\n    # for the bonds we have defined. We will need each of these\n    # pairs channels measured in order to reconstruct the extended\n    # s-wave and d-wave pair susceptibilities.\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(Cu_3d, Cu_3d), (O_2px, O_2px), (O_2py, O_2py),\n                 (bond_3d_3d_px_id, bond_3d_3d_px_id), (bond_3d_3d_px_id, bond_3d_3d_nx_id),\n                 (bond_3d_3d_nx_id, bond_3d_3d_px_id), (bond_3d_3d_nx_id, bond_3d_3d_nx_id),\n                 (bond_3d_3d_py_id, bond_3d_3d_py_id), (bond_3d_3d_py_id, bond_3d_3d_ny_id),\n                 (bond_3d_3d_ny_id, bond_3d_3d_py_id), (bond_3d_3d_ny_id, bond_3d_3d_ny_id),\n                 (bond_3d_3d_px_id, bond_3d_3d_py_id), (bond_3d_3d_px_id, bond_3d_3d_ny_id),\n                 (bond_3d_3d_nx_id, bond_3d_3d_py_id), (bond_3d_3d_nx_id, bond_3d_3d_ny_id),\n                 (bond_3d_3d_py_id, bond_3d_3d_px_id), (bond_3d_3d_py_id, bond_3d_3d_nx_id),\n                 (bond_3d_3d_ny_id, bond_3d_3d_px_id), (bond_3d_3d_ny_id, bond_3d_3d_nx_id)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters,)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    # Measure the d-wave pair suspcetibility.\n    P_d, ΔP_d = composite_correlation_stats(\n        folder = simulation_info.datafolder,\n        correlation = \"pair\",\n        space = \"momentum\",\n        type = \"integrated\",\n        ids = [(bond_3d_3d_px_id, bond_3d_3d_px_id), (bond_3d_3d_px_id, bond_3d_3d_nx_id),\n               (bond_3d_3d_nx_id, bond_3d_3d_px_id), (bond_3d_3d_nx_id, bond_3d_3d_nx_id),\n               (bond_3d_3d_py_id, bond_3d_3d_py_id), (bond_3d_3d_py_id, bond_3d_3d_ny_id),\n               (bond_3d_3d_ny_id, bond_3d_3d_py_id), (bond_3d_3d_ny_id, bond_3d_3d_ny_id),\n               (bond_3d_3d_px_id, bond_3d_3d_py_id), (bond_3d_3d_px_id, bond_3d_3d_ny_id),\n               (bond_3d_3d_nx_id, bond_3d_3d_py_id), (bond_3d_3d_nx_id, bond_3d_3d_ny_id),\n               (bond_3d_3d_py_id, bond_3d_3d_px_id), (bond_3d_3d_py_id, bond_3d_3d_nx_id),\n               (bond_3d_3d_ny_id, bond_3d_3d_px_id), (bond_3d_3d_ny_id, bond_3d_3d_nx_id)],\n        locs = [(0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0),\n                (0,0), (0,0)],\n        num_bins = N_bins,\n        f = (P_px_px, P_px_nx,\n             P_nx_px, P_nx_nx,\n             P_py_py, P_py_ny,\n             P_ny_py, P_ny_ny,\n             P_px_py, P_px_ny,\n             P_nx_py, P_nx_ny,\n             P_py_px, P_py_nx,\n             P_ny_px, P_ny_nx) -> (P_px_px + P_px_nx +\n                                   P_nx_px + P_nx_nx +\n                                   P_py_py + P_py_ny +\n                                   P_ny_py + P_ny_ny -\n                                   P_px_py - P_px_ny -\n                                   P_nx_py - P_nx_ny -\n                                   P_py_px - P_py_nx -\n                                   P_ny_px - P_ny_nx)/4\n    )\n\n    # Record the d-wave pair suspcetibility.\n    additional_info[\"P_d_mean\"] = real(P_d)\n    additional_info[\"P_d_std\"]  = ΔP_d\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    return nothing\nend\n\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ud = parse(Float64, ARGS[2])\n    Up = parse(Float64, ARGS[3])\n    tpd = parse(Float64, ARGS[4])\n    tpp = parse(Float64, ARGS[5])\n    ϵd = parse(Float64, ARGS[6])\n    ϵp = parse(Float64, ARGS[7])\n    μ = parse(Float64, ARGS[8])\n    β = parse(Float64, ARGS[9])\n    Lx = parse(Int, ARGS[10])\n    Ly = parse(Int, ARGS[11])\n    N_burnin = parse(Int, ARGS[12])\n    N_updates = parse(Int, ARGS[13])\n    N_bins = parse(Int, ARGS[14])\n\n    # Run the simulation.\n    run_hubbard_threeband_simulation(sID, Ud, Up, tpd, tpp, ϵd, ϵp, μ, β, Lx, Ly, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/hubbard_threeband/","page":"Example 6: 3-band Hubbard Model","title":"Example 6: 3-band Hubbard Model","text":"","category":"page"},{"location":"examples/hubbard_threeband/","page":"Example 6: 3-band Hubbard Model","title":"Example 6: 3-band Hubbard Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Simulation-Information-Type-and-Methods","page":"API","title":"Simulation Information Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SimulationInfo\ninitialize_datafolder\nmodel_summary","category":"page"},{"location":"api/","page":"API","title":"API","text":"SimulationInfo\nSimulationInfo(;)\ninitialize_datafolder\nmodel_summary","category":"page"},{"location":"api/#SmoQyDQMC.SimulationInfo","page":"API","title":"SmoQyDQMC.SimulationInfo","text":"SimulationInfo\n\nContains identification information about simulation, including the location data is written to, the simulation ID, and MPI process ID, and whether this simulation started a new simulation or resumed a previous simulation.\n\nFields\n\nfilepath::String: File path to where data folder lives.\ndatafolder_prefix: Prefix for the data folder name.\ndatafolder_name::String: The data folder name, given by $(datafolder_prefix)_$(sID).\ndatafolder::String: The data folder, including filepath, given by joinpath(filepath, datafolder_name).\npID::Int: MPI process ID, defaults to 0 if MPI not being used.\nsID::Int: Simulation ID.\nresuming::Bool: Whether current simulation is resuming a previous simulation (true) or starting a new one (false).\nsmoqy_version::VersionNumber: Version of SmoQyDQMC used in simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SimulationInfo-Tuple{}","page":"API","title":"SmoQyDQMC.SimulationInfo","text":"SimulationInfo(; datafolder_prefix::String, filepath::String = \".\", sID::Int=0, pID::Int=0)\n\nInitialize and return in instance of the type SimulationInfo.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize_datafolder","page":"API","title":"SmoQyDQMC.initialize_datafolder","text":"initialize_datafolder(sim_info::SimulationInfo)\n\nInitalize sim_info.datafolder directory if it does not already exist.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.model_summary","page":"API","title":"SmoQyDQMC.model_summary","text":"model_summary(; simulation_info::SimulationInfo,\n              β::T, Δτ::T, model_geometry::ModelGeometry,\n              tight_binding_model::TightBindingModel,\n              interactions::Tuple) where {T<:AbstractFloat}\n\nWrite model to summary to file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Model-Geometry-Type-and-Methods","page":"API","title":"Model Geometry Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ModelGeometry\nadd_bond!\nget_bond_id","category":"page"},{"location":"api/","page":"API","title":"API","text":"ModelGeometry\nModelGeometry(::UnitCell{D}, ::Lattice{D}) where {D}\nadd_bond!\nget_bond_id","category":"page"},{"location":"api/#SmoQyDQMC.ModelGeometry","page":"API","title":"SmoQyDQMC.ModelGeometry","text":"ModelGeometry{D, T<:AbstractFloat, N}\n\nContains all the information defining the lattice geometry for the model in D spatial dimensions.\n\nComment\n\nThe bond ID associated with a bond::Bond{D} corresponds to the index associated with it into the bonds vector field.\n\nFields\n\nunit_cell::UnitCell{D,T,N}: Defines unit cell.\nlattice::Lattice{D}: Defines finite lattice extent.\nbonds::Vector{Bond{D}}: All available bond definitions in simulation, with vector indices giving the bond ID.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ModelGeometry-Union{Tuple{D}, Tuple{UnitCell{D}, Lattice{D}}} where D","page":"API","title":"SmoQyDQMC.ModelGeometry","text":"ModelGeometry(unit_cell::UnitCell, lattice::Lattice)\n\nInitialize and return a ModelGeometry instance. Defines a \"trivial\" bond defintion for each orbital in the unit cell that connects an orbital to itself.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.add_bond!","page":"API","title":"SmoQyDQMC.add_bond!","text":"addbond!(modelgeometry::ModelGeometry{D,T}, bond::Bond{D}) where {D, T}   \n\nAdd bond definition to model_geometry, returning the bond ID i.e. the index to bond in the vector model_geometry.bonds. This method first checks that bond is not already defined. If it is this method simply returns the corresponding bond ID. If bond is not already defined, then it is appended to the vector model_geometry.bonds.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.get_bond_id","page":"API","title":"SmoQyDQMC.get_bond_id","text":"get_bond_id(model_geometry::ModelGeometry{D,T}, bond::Bond{D}) where {D, T}\n\nReturn the bond ID associated with the bond defintion bond, returning bond_id=0 if the it is not a recorded bond.\n\n\n\n\n\n","category":"function"},{"location":"api/#Fermion-Path-Integral-Type-and-Methods","page":"API","title":"Fermion Path Integral Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FermionPathIntegral\ninitialize_propagators\ncalculate_propagators!\ncalculate_propagator!","category":"page"},{"location":"api/","page":"API","title":"API","text":"FermionPathIntegral\nFermionPathIntegral(;)\ninitialize_propagators\ncalculate_propagators!\ncalculate_propagator!","category":"page"},{"location":"api/#SmoQyDQMC.FermionPathIntegral","page":"API","title":"SmoQyDQMC.FermionPathIntegral","text":"FermionPathIntegral{T<:Number, E<:AbstractFloat}\n\nRepresents a fermion path integral. In particular, contains the information to represent each diagonal on-site energy matrix V_l and hopping matrix K_l for each imaginary time slicel in 1 L_tau such that tau = Deltatau cdot l and beta = Deltatau cdot L_tau\n\nFields\n\nβ::E: Inverse temperature.\nΔτ::E: Discretization in imaginary time.\nLτ::Int: Length of the imaginary time axis.\nN::Int: Number of orbitals in the lattice.\nneighbor_table::Matrix{Int}: Neighbor table for each pair of orbitals in the lattice connected by a hopping.\nt::Matrix{T}: Hopping amplitudes for imaginary time slice l is stored in t[:,l].\nV::Matrix{T}: Diagonal on-site energy matrix V_l for imaginary time slice l is stored in V[:,l].\nK::Matrix{T}: Used to construct hopping matrix to cacluate exponentiated hopping matrix if checkerboard approximation is not being used.\neigen_ws::HermitianEigenWs{T,Matrix{T},E}: For calculating eigenvalues and eigenvectors of K while avoiding dynamic memory allocations.\nu::Vector{T}: Temporary vector to avoid dynamic allocation when performing local updates.\nv::Vector{T}: Temporary vector to avoid dynamic allocation when performing local updates.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.FermionPathIntegral-Tuple{}","page":"API","title":"SmoQyDQMC.FermionPathIntegral","text":"FermionPathIntegral(; tight_binding_parameters::TightBindingParameters{T,E},\n                    β::E, Δτ::E) where {T,E}\n\nInitialize an instance of FermionPathIntegral an instance of TightBindingParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize_propagators","page":"API","title":"SmoQyDQMC.initialize_propagators","text":"initialize_propagators(fpi::FermionPathIntegral{T,E}; symmetric::Bool, checkerboard::Bool) where {T,E}\n\nInitialize a propagator for each imaginary time slice, returning a vector of type Vector{<:AbstractPropagators{T,E}}.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.calculate_propagators!","page":"API","title":"SmoQyDQMC.calculate_propagators!","text":"calculate_propagators!(B::Vector{P}, fpi::FermionPathIntegral{T,E};\n                       calculate_exp_V::Bool, calculate_exp_K::Bool) where {T, E, P<:AbstractPropagator{T,E}}\n\nCalculate the propagator matrices B_l, given by B[l], for all imaginary time slice tau = Deltatau cdot l If calculate_exp_V = true, then calculate the diagonal exponentiated on-site energy matrices. If calculate_exp_K = true, then calculate the exponentiated hopping matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.calculate_propagator!","page":"API","title":"SmoQyDQMC.calculate_propagator!","text":"calculate_propagator!(B::AbstractPropagator{T,E}, fpi::FermionPathIntegral{T,E}, l::Int;\n                      calculate_exp_V::Bool, calculate_exp_K::Bool) where {T,E}\n\nCalculate the propagator matrix B_l for imaginary time slice tau = Deltatau cdot l If calculate_exp_V = true, then calculate the diagonal exponentiated on-site energy matrix. If calculate_exp_K = true, then calculate the exponentiated hopping matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#Update-Numerical-Stabilization-Frequency","page":"API","title":"Update Numerical Stabilization Frequency","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"update_stabalization_frequency!","category":"page"},{"location":"api/","page":"API","title":"API","text":"update_stabalization_frequency!","category":"page"},{"location":"api/#SmoQyDQMC.update_stabalization_frequency!","page":"API","title":"SmoQyDQMC.update_stabalization_frequency!","text":"update_stabalization_frequency!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n                                Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T;\n                                fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                                fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                                Bup::Vector{P}, Bdn::Vector{P}, δG::E, δθ::E, n_stab::Int,\n                                δG_max::E) where {E<:AbstractFloat, T<:Number, P<:AbstractPropagator{T,E}}\n\nIf the corrected error in the Green's funciton matrix is too large, δG > δG_max, then increase the frequency of numerical stablization by decrementing n_stab such that it is updated to n_stab = max(n_stab - 1, 1), and update the equal-time Green's function matrices and all related variables and types. If the frequency of stabilization is udpated, then δG and δθ are reset to zero. This method returns a tuple of the following variables:\n\n(logdetGup, sgndetGdn, logdetGup, sgndetGdn, δG, δθ),\n\nwhere updated = true if n_stab was decremented.\n\n\n\n\n\nupdate_stabalization_frequency!(G::Matrix{T}, logdetG::E, sgndetG::T;\n                                fermion_greens_calculator::FermionGreensCalculator{T,E},\n                                B::Vector{P}, δG::E, δθ::E, n_stab::Int,\n                                δG_max::E) where {E<:AbstractFloat, T<:Number, P<:AbstractPropagator{T,E}}\n\nIf the corrected error in the Green's funciton matrix is too large, δG > δG_max, then increase the frequency of numerical stablization by decrementing n_stab such that it is updated to n_stab = max(n_stab - 1, 1), and update the equal-time Green's function matrices and all related variables and types. If the frequency of stabilization is udpated, then δG and δθ are reset to zero. This method returns a tuple of the following variables:\n\n(updated, logdetG, sgndetG, δG, δθ),\n\nwhere updated = true if n_stab was decremented.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tight-Binding-Model","page":"API","title":"Tight-Binding Model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TightBindingModel\nTightBindingParameters\nmeasure_onsite_energy\nmeasure_hopping_energy","category":"page"},{"location":"api/","page":"API","title":"API","text":"TightBindingModel\nTightBindingModel(;)\nTightBindingParameters\nTightBindingParameters(;)\nmeasure_onsite_energy\nmeasure_hopping_energy","category":"page"},{"location":"api/#SmoQyDQMC.TightBindingModel","page":"API","title":"SmoQyDQMC.TightBindingModel","text":"TightBindingModel{T<:Number, E<:AbstractFloat, D}\n\nDefines a tight binding model in D dimensions.\n\nFields\n\nμ::E: Chemical potential.\nϵ_mean::Vector{E}: Mean on-site energy for each orbital in the unit cell. \nϵ_std::Vector{E}: Standard deviation of on-site energy for each orbital in the unit cell.\nt_bond_ids::Vector{Int}: The bond ID for each bond/hopping definition.\nt_bonds::Vector{Bond{D}}: Bond definition for each type of hopping in the tight binding model.\nt_mean::Vector{T}: Mean hopping energy for each type of hopping.\nt_std::Vector{E}: Standard deviation of hopping energy for each type of hopping.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.TightBindingModel-Tuple{}","page":"API","title":"SmoQyDQMC.TightBindingModel","text":"TightBindingModel(; model_geometry::ModelGeometry{D,E,N},\n                  μ::E,\n                  ϵ_mean::Vector{E},\n                  ϵ_std::Vector{E} = zeros(eltype(ϵ_mean), length(ϵ_mean)),\n                  t_bonds::Vector{Bond{D}} = Bond{ndims(model_geometry.unit_cell)}[],\n                  t_mean::Vector{T} = eltype(ϵ_mean)[],\n                  t_std::Vector{E} = zeros(eltype(ϵ_mean), length(t_mean))) where {T<:Number, E<:AbstractFloat, D, N}\n\nInitialize and return an instance of TightBindingModel, also adding/recording the bond defintions t_bonds to the ModelGeometry instance model_geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.TightBindingParameters","page":"API","title":"SmoQyDQMC.TightBindingParameters","text":"TightBindingParameters{T<:Number, E<:AbstractFloat}\n\nA mutable struct containing all the parameters needed to characterize a finite tight-binding Hamiltonian for a single spin species sigma on a finite lattice with periodic boundary conditions of the form\n\nhatH_0sigma=-sum_langle ijrangle(t_ij hatc_sigmai^daggerhatc_sigmaj+textrmhc)+sum_i(epsilon_i-mu)hatn_sigmai\n\nwhere hatc_sigmai^dagger is the fermion creation operator for an electron with spin sigma on orbital i t_ij are the hopping energies, epsilon_i are the on-site energies for each orbital in the lattice, and mu is the chemical potential.\n\nFields\n\nμ::E: The chemical potential mu\nconst ϵ::Vector{E}: A vector containing the on-site energy epsilon_i for each orbital in the lattice.\nconst t::Vector{T}: The hopping energy t_ij associated with each pair of neighboring orbitals connected by a bond in the lattice.\nconst neighbor_table::Matrix{Int}: Neighbor table containing all pairs of orbitals in the lattices connected by a bond, with a non-zero hopping energy between them.\nconst bond_ids::Vector{Int}: The bond ID definitions that define the types of hopping in the lattice.\nconst bond_slices::Vector{UnitRange{Int}}: Slices of neighbor_table corresponding to given bond ID i.e. the neighbors neighbor_table[:,bond_slices[1]] corresponds the bond_ids[1] bond defintion.\nconst norbital::Int: Number of orbitals per unit cell.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.TightBindingParameters-Tuple{}","page":"API","title":"SmoQyDQMC.TightBindingParameters","text":"TightBindingParameters(; tight_binding_model::TightBindingModel{T,E,D},\n                       model_geometry::ModelGeometry{D,E},\n                       rng::AbstractRNG) where {T,E,D}\n\nInitialize and return an instance of TightBindingParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.measure_onsite_energy","page":"API","title":"SmoQyDQMC.measure_onsite_energy","text":"measure_onsite_energy(tight_binding_parameters::TightBindingParameters{T,E},\n                      Gup::Matrix{T}, Gdn::Matrix{T},\n                      orbital_id::Int) where {T<:Number, E<:AbstractFloat, D, N}\n\nMeasure and return the on-site energy epsilon_textrmon-site = (epsilon - mu)langle hatn_uparrow + hatn_downarrow rangle for the orbital_id in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_hopping_energy","page":"API","title":"SmoQyDQMC.measure_hopping_energy","text":"measure_hopping_energy(tight_binding_parameters::TightBindingParameters{T,E},\n                       Gup::Matrix{T}, Gdn::Matrix{T},\n                       bond_id::Int) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average hopping energy epsilon_rm hopping = -sum_sigma langle t_ij hatc^dagger_sigmai hatc_sigmaj + rm hc rangle for the hopping defined by the bond corresponding to bond_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#Hubbard-Model","page":"API","title":"Hubbard Model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HubbardModel\nHubbardParameters\ninitialize","category":"page"},{"location":"api/","page":"API","title":"API","text":"Hubbard Model Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"measure_hubbard_energy","category":"page"},{"location":"api/","page":"API","title":"API","text":"Hubbard Ising Hubbard-Stratonovich Transformation Types and Methods","category":"page"},{"location":"api/","page":"API","title":"API","text":"HubbardIsingHSParameters\ninitialize!\nlocal_updates!\nreflection_update!\nswap_update!","category":"page"},{"location":"api/","page":"API","title":"API","text":"HubbardModel\nHubbardModel(;)\nHubbardParameters\nHubbardParameters(;)\ninitialize!(::FermionPathIntegral{T,E}, ::FermionPathIntegral{T,E}, ::HubbardParameters{E}) where {T,E}","category":"page"},{"location":"api/#SmoQyDQMC.HubbardModel","page":"API","title":"SmoQyDQMC.HubbardModel","text":"HubbardModel{T<:AbstractFloat}\n\nIf shifted = true, then a Hubbard interaction of the form\n\nhatH_U=sum_mathbfinuU_numathbfihatn_uparrownumathbfihatn_downarrownumathbfi\n\nis assumed, where mathbfi specifies the unit cell, and nu denotes the orbital in the unit cell. For a bipartite lattice with only nearest neighbor hopping, the on-site energy corresponding to half-filling and particle-hole symmetry is epsilon_numathbfi = -U_numathbfi2\n\nIf shifted = false, then a Hubbard interaction of the form\n\nhatH_U=sum_mathbfinuU_numathbfi(hatn_uparrownumathbfi-tfrac12)(hatn_downarrownumathbfi-tfrac12)\n\nis assumed. In this case, for a bipartite lattice with only nearest neighbor hopping, the on-site energy corresponding to half-filling and particle-hole symmetry is epsilon_numathbfi = 0\n\nFields\n\nshifted::Bool: Determines which form for Hubbard interaction is used, and whether the on-site energies need to be shifted.\nU_orbital::Vector{Int}: Orbital species in unit cell with finite Hubbard interaction.\nU_mean::Vector{T}: Average Hubbard U_nu for a given orbital species in the lattice.\nU_std::Vector{T}: Standard deviation of Hubbard U_nu for a given orbital species in the lattice.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardModel-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardModel","text":"HubbardModel(; shifted::Bool, U_orbital::AbstractVector{Int}, U_mean::AbstractVector{T},\n             U_std::AbstractVector{T} = zeros(eltype(U_mean), length(U_mean))) where {T<:AbstractFloat}\n\nInitialize and return an instance of the type HubbardModel.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.HubbardParameters","page":"API","title":"SmoQyDQMC.HubbardParameters","text":"HubbardParameters{T<:AbstractFloat}\n\nHubbard parameters for finite lattice.\n\nFields\n\nU::Vector{T}: On-site Hubbard interaction for each site with finite Hubbard interaction.\nsites::Vector{Int}: Site index associated with each finite Hubbard U interaction.\norbitals::Vector{Int}: Orbital species in unit cell with finite Hubbard interaction.\nshifted::Bool: Convention used for Hubbard interaction, refer to HubbardModel for more information.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardParameters-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardParameters","text":"HubbardParameters(; hubbard_model::HubbardModel{T},\n                  model_geometry::ModelGeometry{D,T},\n                  rng::AbstractRNG) where {D,T<:AbstractFloat}\n\nInitialize an instance of HubbardParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, HubbardParameters{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(fermion_path_integral_up::FermionPathIntegral{T,E},\n            fermion_path_integral_dn::FermionPathIntegral{T,E},\n            hubbard_parameters::HubbardParameters{E}) where {T,E}\n\ninitialize!(fermion_path_integral::FermionPathIntegral{T,E},\n            hubbard_parameters::HubbardParameters{E}) where {T,E}\n\nInitialize the contribution from the Hubbard interaction to a FermionPathIntegral instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#Hubbard-Model-Measurements","page":"API","title":"Hubbard Model Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"measure_hubbard_energy","category":"page"},{"location":"api/#SmoQyDQMC.measure_hubbard_energy","page":"API","title":"SmoQyDQMC.measure_hubbard_energy","text":"measure_hubbard_energy(hubbard_parameters::HubbardParameters{E},\n                       Gup::Matrix{T}, Gdn::Matrix{T},\n                       orbital_id::Int) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average Hubbard energy U langle hatn_uparrow hatn_downarrow rangle for the orbital corresponding orbital_id in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#Hubbard-Ising-Hubbard-Stratonovich-Transformation-Types-and-Methods","page":"API","title":"Hubbard Ising Hubbard-Stratonovich Transformation Types and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HubbardIsingHSParameters\nHubbardIsingHSParameters(;)\ninitialize!(::FermionPathIntegral{T,E}, ::FermionPathIntegral{T,E}, ::HubbardIsingHSParameters{E}) where {T,E}\ninitialize!(::FermionPathIntegral{T,E}, ::HubbardIsingHSParameters{E}) where {T,E}\nlocal_updates!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E})  where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nlocal_updates!(::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E})  where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nreflection_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nreflection_update!(::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nswap_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nswap_update!(::Matrix{T}, ::E, ::T, ::HubbardIsingHSParameters{E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}","category":"page"},{"location":"api/#SmoQyDQMC.HubbardIsingHSParameters","page":"API","title":"SmoQyDQMC.HubbardIsingHSParameters","text":"HubbardIsingHSParameters{T<:AbstractFloat}\n\nParameters associated with decoupling the Hubbard interaction using the standard Ising Hubbard-Stratonovich (HS) transformation.\n\nFields\n\nβ::T: Inverse temperature.\nΔτ::T: Discretization in imaginary time.\nLτ::Int: Length of imaginary time axis.\nN::Int: Number of orbitals in the lattice.\nU::Vector{T}: Each hubbard interaction.\nα::Vector{T}: The constant given by cosh(alpha_i) = e^Deltatau vert U_i vert2\nsites::Vector{Int}: Site index associated with each finite Hubbard U interaction.\ns::Matrix{Int}: Ising Hubbard-Stratonovich fields.\nupdate_perm::Vector{Int}: Order in which to iterate over HS fields in time slice when performing local updates.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HubbardIsingHSParameters-Tuple{}","page":"API","title":"SmoQyDQMC.HubbardIsingHSParameters","text":"HubbardIsingHSParameters(; β::E, Δτ::E,\n                         hubbard_parameters::HubbardParameters{E},\n                         rng::AbstractRNG) where {E<:AbstractFloat}\n\nInitialize and return an instance of the HubbardIsingHSParameters type. Note that on-site energies fpi.V are shifted by -U_i2 if hmshifted = true.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, HubbardIsingHSParameters{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(fermion_path_integral_up::FermionPathIntegral{T,E},\n            fermion_path_integral_dn::FermionPathIntegral{T,E},\n            hubbard_ising_parameters::HubbardIsingHSParameters{E}) where {T,E}\n\nInitialize the contribution from the Hubbard interaction to the FermionPathIntegral instance fermion_path_integral_up for spin up and fermion_path_integral_dn spin down.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, HubbardIsingHSParameters{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(fermion_path_integral::FermionPathIntegral{T,E},\n            hubbard_ising_parameters::HubbardIsingHSParameters{E}) where {T,E}\n\nInitialize the contribution from an attractive Hubbard interaction to the FermionPathIntegral instance fermion_path_integral.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.local_updates!","text":"local_updates!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n               Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n               hubbard_ising_parameters::HubbardIsingHSParameters{E};\n               fermion_path_integral_up::FermionPathIntegral{T,E},\n               fermion_path_integral_dn::FermionPathIntegral{T,E},\n               fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n               fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n               Bup::Vector{P}, Bdn::Vector{P},\n               δG_max::E, δG::E, δθ::E,  rng::AbstractRNG,\n               update_stabilization_frequency::Bool=true) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nSweep through every imaginary time slice and orbital in the lattice, peforming local updates to every Ising Hubbard-Stratonovich (HS) field.\n\nThis method returns the a tuple containing (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ).\n\nArguments\n\nGup::Matrix{T}: Spin-up equal-time Green's function matrix.\nlogdetGup::E: The log of the absolute value of the determinant of the spin-up equal-time Green's function matrix, log vert det G_uparrow(tautau) vert\nsgndetGup::T: The sign/phase of the determinant of the spin-up equal-time Green's function matrix, det G_uparrow(tautau)  vert det G_uparrow(tautau) vert\nGdn::Matrix{T}: Spin-down equal-time Green's function matrix.\nlogdetGdn::E: The log of the absolute value of the determinant of the spin-down equal-time Green's function matrix, log vert det G_downarrow(tautau) vert\nsgndetGdn::T: The sign/phase of the determinant of the spin-down equal-time Green's function matrix, det G_downarrow(tautau)  vert det G_downarrow(tautau) vert\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of the FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of the FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: An instance of the FermionGreensCalculator type for the spin-up electrons.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: An instance of the FermionGreensCalculator type for the spin-down electrons.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-dn propagators for each imaginary time slice.\nδG_max::E: Maximum allowed error corrected by numerical stabilization.\nδG::E: Previously recorded maximum error in the Green's function corrected by numerical stabilization.\nδθ::T: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green's function matrix corrected by numerical stabilization.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nupdate_stabilization_frequency::Bool=true: If true, allows the stabilization frequency n_stab to be dynamically adjusted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.local_updates!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.local_updates!","text":"local_updates!(G::Matrix{T}, logdetG::E, sgndetG::T,\n               hubbard_ising_parameters::HubbardIsingHSParameters{E};\n               fermion_path_integral::FermionPathIntegral{T,E},\n               fermion_greens_calculator::FermionGreensCalculator{T,E},\n               B::Vector{P}, δG_max::E, δG::E, δθ::E, rng::AbstractRNG,\n               update_stabilization_frequency::Bool=true) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nSweep through every imaginary time slice and orbital in the lattice, performing local updates to every Ising Hubbard-Stratonovich (HS) field, assuming strictly attractive Hubbard interactions and perfect spin symmetry.\n\nThis method returns the a tuple containing (acceptance_rate, logdetG, sgndetG, δG, δθ).\n\nArguments\n\nG::Matrix{T}: Equal-time Green's function matrix.\nlogdetG::E: The log of the absolute value of the determinant of theequal-time Green's function matrix, log vert det G_uparrow(tautau) vert\nsgndetG::T: The sign/phase of the determinant of the equal-time Green's function matrix, det G_uparrow(tautau)  vert det G_uparrow(tautau) vert\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of the FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: An instance of the FermionGreensCalculator type.\nB::Vector{P}: Propagators for each imaginary time slice.\nδG_max::E: Maximum allowed error corrected by numerical stabilization.\nδG::E: Previously recorded maximum error in the Green's function corrected by numerical stabilization.\nδθ::T: Previously recorded maximum error in the sign/phase of the determinant of the equal-time Green's function matrix corrected by numerical stabilization.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nupdate_stabilization_frequency::Bool=true:  If true, allows the stabilization frequency n_stab to be dynamically adjusted.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n                   Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n                   hubbard_ising_parameters::HubbardIsingHSParameters{E};\n                   fermion_path_integral_up::FermionPathIntegral{T,E},\n                   fermion_path_integral_dn::FermionPathIntegral{T,E},\n                   fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n                   Bup::Vector{P}, Bdn::Vector{P},\n                   rng::AbstractRNG) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform a reflection update where the sign of every Ising Hubbard-Stratonovich field on a randomly chosen orbital in the lattice is changed. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n                   hubbard_ising_parameters::HubbardIsingHSParameters{E};\n                   fermion_path_integral::FermionPathIntegral{T,E},\n                   fermion_greens_calculator::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n                   B::Vector{P},\n                   rng::AbstractRNG) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform a reflection update where the sign of every Ising Hubbard-Stratonovich field on a randomly chosen orbital in the lattice is changed. This function returns (accepted, logdetG, sgndetG). This method assumes strictly attractive Hubbard interactions.\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n             Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n             hubbard_ising_parameters::HubbardIsingHSParameters{E};\n             fermion_path_integral_up::FermionPathIntegral{T,E},\n             fermion_path_integral_dn::FermionPathIntegral{T,E},\n             fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n             Bup::Vector{P}, Bdn::Vector{P},\n             rng::AbstractRNG) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform a swap update where the HS fields associated with two randomly chosen sites in the lattice are exchanged. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, HubbardIsingHSParameters{E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n             hubbard_ising_parameters::HubbardIsingHSParameters{E};\n             fermion_path_integral::FermionPathIntegral{T,E},\n             fermion_greens_calculator::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n             B::Vector{P}, rng::AbstractRNG) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nFor strictly attractive Hubbard interactions, perform a swap update where the HS fields associated with two randomly chosen sites in the lattice are exchanged. This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nhubbard_ising_parameters::HubbardIsingHSParameters{E}: Ising Hubbard-Stratonovich fields and associated parameters to update.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#Electron-Phonon-Model","page":"API","title":"Electron-Phonon Model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Model Types and Method","category":"page"},{"location":"api/","page":"API","title":"API","text":"ElectronPhononModel\nPhononMode\nHolsteinCoupling\nSSHCoupling\nPhononDispersion\nadd_phonon_mode!\nadd_holstein_coupling!\nadd_ssh_coupling!\nadd_phonon_dispersion!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Parameter Types and Methods","category":"page"},{"location":"api/","page":"API","title":"API","text":"ElectronPhononParameters\nSmoQyDQMC.PhononParameters\nSmoQyDQMC.HolsteinParameters\nSmoQyDQMC.SSHParameters\nSmoQyDQMC.DispersionParameters\ninitialize!\nupdate!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"measure_phonon_kinetic_energy\nmeasure_phonon_potential_energy\nmeasure_phonon_position_moment\nmeasure_holstein_energy\nmeasure_ssh_energy\nmeasure_dispersion_energy","category":"page"},{"location":"api/","page":"API","title":"API","text":"Electron-Phonon Updates","category":"page"},{"location":"api/","page":"API","title":"API","text":"HMCUpdater\nhmc_update!\nLMCUpdater\nlmc_update!\nSmoQyDQMC.FourierMassMatrix\nreflection_update!\nswap_update!","category":"page"},{"location":"api/#Electron-Phonon-Model-Types-and-Method","page":"API","title":"Electron-Phonon Model Types and Method","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ElectronPhononModel\nElectronPhononModel(;)\nPhononMode\nPhononMode(;)\nHolsteinCoupling\nHolsteinCoupling(;)\nSSHCoupling\nSSHCoupling(;)\nPhononDispersion\nPhononDispersion(;)\nadd_phonon_mode!\nadd_holstein_coupling!\nadd_ssh_coupling!\nadd_phonon_dispersion!","category":"page"},{"location":"api/#SmoQyDQMC.ElectronPhononModel","page":"API","title":"SmoQyDQMC.ElectronPhononModel","text":"ElectronPhononModel{T<:Number, E<:AbstractFloat, D}\n\nDefines an electron-phonon model.\n\nFields\n\nphonon_modes::Vector{PhononModes{E}}: A vector of PhononMode definitions.\nholstein_couplings::Vector{HolsteinCoupling{E,D}}: A vector of HolsteinCoupling definitions.\nssh_couplings::Vector{SSHCoupling{T,E,D}}: A vector of SSHCoupling defintions.\nphonon_dispersions::Vector{PhononDispersion{E,D}}: A vector of PhononDispersion defintions.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ElectronPhononModel-Tuple{}","page":"API","title":"SmoQyDQMC.ElectronPhononModel","text":"ElectronPhononModel(; model_geometry::ModelGeometry{D,E},\n                    tight_binding_model::TightBindingModel{T,E,D}) where {T<:Number, E<:AbstractFloat, D}\n\nInitialize and return a null (empty) instance of ElectronPhononModel given model_geometry and tight_binding_model.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononMode","page":"API","title":"SmoQyDQMC.PhononMode","text":"PhononMode{E<:AbstractFloat}\n\nDefines a phonon mode on the orbital species orbital in the unit cell. Specifically, it defines the phonon Hamiltonian terms\n\nhatH_rm ph = sum_mathbfi\n  left\n      frac12 M_mathbfinuOmega_mathbfinu^2hatX_mathbfinu^2\n    + frac112M_mathbfinuOmega_4mathbfinu^2hatX_mathbfinu^4\n    + frac12M_mathbfinuhatP_mathbfinu^2\n  right\n\nwhere the sum runs over unit cell mathbfi, nu denotes the orbital species orbital in the unit cell, M_mathbfinu is the phonon mass M, Omega_mathbfinu is the phonon frequency that is distributed according to a normal distribution with mean Ω_mean and standard deviation Ω_std. Lastly, Omega_4mathbfinu is the anhmaronic coefficient, and is distributed according to a normal distribution with mean Ω4_mean and standard deviation Ω4_std.\n\nFields\n\norbital::Int: Orbital species nu in the unit cell.\nM::E:: The phonon mass M_mathbfinu\nΩ_mean::E: Mean of normal distribution the phonon frequency Omega_mathbfinu is sampled from.\nΩ_std::E: Standard deviation of normal distribution the phonon frequency Omega_mathbfinu is sampled from.\nΩ4_mean::E: Mean of normal distribution the anharmonic coefficient Omega_4mathbfinu is sampled from.\nΩ4_std::E: Standard deviation of normal distribution the anharmonic coefficient Omega_4mathbfinu is sampled from.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.PhononMode-Tuple{}","page":"API","title":"SmoQyDQMC.PhononMode","text":"PhononMode(; orbital::Int, Ω_mean::E, Ω_std::E=0., M::E=1., Ω4_mean::E=0., Ω4_std::E=0.) where {E<:AbstractFloat}\n\nInitialize and return a instance of PhononMode.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.HolsteinCoupling","page":"API","title":"SmoQyDQMC.HolsteinCoupling","text":"HolsteinCoupling{E<:AbstractFloat, D}\n\nDefines a Holstein coupling between a specified phonon mode and orbital density. Specifically, it defines the (extended) Holstein Hamiltonian interaction term\n\nhatH_rm hol = sum_sigmamathbfi\n    left sum_n=1^4alpha_nmathbfi(mathbfrkappanu)hatX_mathbfinu^n right\n    left( hatn_sigmamathbfi+mathbfrkappa-tfrac12 right)\n\nwhere sigma specifies the sum, and the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa specify orbital species in the unit cell, and mathbfr is a static displacement in unit cells.\n\nFields\n\nphonon_mode::Int: The phonon mode getting coupled to.\nbond::Bond{D}: Static displacement from hatX_mathbfinu to hatn_sigmamathbfi+mathbfrkappa\nbond_id::Int: Bond ID associtated with bond field.\nα_mean::E: Mean of the linear Holstein coupling coefficient alpha_1mathbfi(mathbfrkappanu)\nα_std::E: Standard deviation of the linear Holstein coupling coefficient alpha_1mathbfi(mathbfrkappanu)\nα2_mean::E: Mean of the squared Holstein coupling coefficient alpha_2mathbfi(mathbfrkappanu)\nα2_std::E: Standard deviation of the squared Holstein coupling coefficient alpha_2mathbfi(mathbfrkappanu)\nα3_mean::E: Mean of the cubic Holstein coupling coefficient alpha_3mathbfi(mathbfrkappanu)\nα3_std::E: Standard deviation of the cubic Holstein coupling coefficient alpha_3mathbfi(mathbfrkappanu)\nα4_mean::E: Mean of the quartic Holstein coupling coefficient alpha_4mathbfi(mathbfrkappanu)\nα4_std::E: Standard deviation of the quartic Holstein coupling coefficient alpha_4mathbfi(mathbfrkappanu)\n\nComment\n\nNote that the initial orbital bond.orbital[1] must match the orbital species associated with phonon mode PhononMode getting coupled to.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HolsteinCoupling-Tuple{}","page":"API","title":"SmoQyDQMC.HolsteinCoupling","text":"HolsteinCoupling(; model_geometry::ModelGeometry{D,E}, phonon_mode::Int,\n                 bond::Bond{D}, α_mean::E, α_std::E=0.,\n                 α2_mean::E=0., α2_std::E=0., α3_mean::E=0., α3_std::E=0.,\n                 α4_mean::E=0., α4_std::E=0.) where {E,D}\n\nInitialize and return a instance of HolsteinCoupling.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.SSHCoupling","page":"API","title":"SmoQyDQMC.SSHCoupling","text":"SSHCoupling{T<:Number, E<:AbstractFloat, D}\n\nDefines a Su-Schrieffer-Heeger (SSH) coupling between a pair of phonon modes. Specifically, it defines the SSH interaction term\n\nhatH_rm ssh = -sum_sigmamathbfi\n    left t_mathbfi(mathbfrkappanu) - left( sum_n=1^4alpha_nmathbfi(mathbfrkappanu)\n    left( hatX_mathbfi+mathbfrkappa - hatX_mathbfinuright)^nright) right\n    left( hatc_sigmamathbfi+mathbfrkappa^daggerhatc_sigmamathbfinu+rm hc right)\n\nwhere sigma specifies the sum, and the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa specify orbital species in the unit cell, and mathbfr is a static displacement in unit cells. In that above expression t_mathbfi(mathbfrkappanu) is the bare hopping amplitude, which is not specified here.\n\nFields\n\nphonon_modes::NTuple{2,Int}: Pair of phonon modes getting coupled together.\nbond::Bond{D}: Static displacement seperating the two phonon modes getting coupled.\nbond_id::Int: Bond ID associated with the bond field.\nα_mean::T: Mean of the linear SSH coupling constant alpha_1mathbfi(mathbfrkappanu)\nα_std::T: Standard deviation of the linear SSH coupling constant alpha_1mathbfi(mathbfrkappanu)\nα2_mean::T: Mean of the quadratic SSH coupling constant alpha_2mathbfi(mathbfrkappanu)\nα2_std::T: Standard deviation of the quadratic SSH coupling constant alpha_2mathbfi(mathbfrkappanu)\nα3_mean::T: Mean of the cubic SSH coupling constant alpha_3mathbfi(mathbfrkappanu)\nα3_std::T: Standard deviation of the cubic SSH coupling constant alpha_3mathbfi(mathbfrkappanu)\nα4_mean::T: Mean of the quartic SSH coupling constant alpha_4mathbfi(mathbfrkappanu)\nα4_std::T: Standard deviation of the quartic SSH coupling constant alpha_4mathbfi(mathbfrkappanu)\n\nComment\n\nThe pair of orbitals appearing in bond.orbitals must correspond to the orbital species associated with the two coupling phonon modes specified by phonon_modes.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SSHCoupling-Tuple{}","page":"API","title":"SmoQyDQMC.SSHCoupling","text":"SSHCoupling(; model_geometry::ModelGeometry{D,E}, tight_binding_model::TightBindingModel{T,E,D},\n            phonon_modes::NTuple{2,Int}, bond::Bond{D},\n            α_mean::T, α_std::E=0., α2_mean::T=0., α2_std::E=0., α3_mean::T=0., α3_std::E=0.,\n            α4_mean::T=0., α4_std::E=0.) where {D, T<:Number, E<:AbstractFloat}\n\nInitialize and return a instance of SSHCoupling.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononDispersion","page":"API","title":"SmoQyDQMC.PhononDispersion","text":"PhononDispersion{E<:AbstractFloat, D}\n\nDefines a dispersive phonon coupling between phonon modes. Specifically, it defines the dispersive phonon term\n\nhatH_rm disp = sum_mathbfi\n    left(\n        fracM_mathbfi+mathbfrkappaM_mathbfinuM_mathbfi+mathbfrkappa+M_mathbfinu\n    right)\n    bigg\n                    Omega_mathbfi(mathbfrkappanu)^2Big(hatX_mathbfi+mathbfrkappa-hatX_mathbfinuBig)^2\n       +frac112Omega_4mathbfi(mathbfrkappanu)^2Big(hatX_mathbfi+mathbfrkappa-hatX_mathbfinuBig)^4\n    bigg\n\nwhere the sum over mathbfi runs over unit cells in the lattice. In the above nu and kappa specify orbital species in the unit cell, and mathbfr is a static displacement in unit cells.\n\nFields\n\nphonon_modes::NTuple{2,Int}: Pair of phonon modes getting coupled together.\nbond::Bond{D}: Static displacement seperating the two phonon modes getting coupled.\nbond_id::Int: Bond ID associated with the bond field.\nΩ_mean::E: Mean dispersive phonon frequency Omega_mathbfi(mathbfrkappanu)\nΩ_std::E: Standard deviation of dispersive phonon frequency Omega_mathbfi(mathbfrkappanu)\nΩ4_mean::E: Mean quartic dispersive phonon coefficient Omega_4mathbfi(mathbfrkappanu)\nΩ4_std::E: Standard deviation of quartic dispersive phonon coefficient Omega_4mathbfi(mathbfrkappanu)\n\nComment\n\nThe pair of orbitals appearing in bond.orbitals must correspond to the orbital species associated with the two coupling phonon modes specified by phonon_modes.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.PhononDispersion-Tuple{}","page":"API","title":"SmoQyDQMC.PhononDispersion","text":"PhononDispersion(; model_geometry::ModelGeometry{D,E}, phonon_modes::NTuple{2,Int}, bond::Bond{D},\n                 Ω_mean::E, Ω_std::E=0., Ω4_mean::E=0., Ω4_std::E=0.) where {E<:AbstractFloat, D}\n\nInitialize and return a instance of PhononDispersion.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.add_phonon_mode!","page":"API","title":"SmoQyDQMC.add_phonon_mode!","text":"add_phonon_mode!(; electron_phonon_model::ElectronPhononModel{T,E,D},\n                 phonon_mode::PhononMode{E}) where {T<:Number, E<:AbstractFloat, D}\n\nAdd a PhononMode to an ElectronPhononModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_holstein_coupling!","page":"API","title":"SmoQyDQMC.add_holstein_coupling!","text":"add_holstein_coupling!(; electron_phonon_model::ElectronPhononModel{T,E,D},\n                       holstein_coupling::HolsteinCoupling{E,D},\n                       model_geometry::ModelGeometry{D,E}) where {T,E,D}\n\nAdd the HolsteinCoupling to an ElectronPhononModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_ssh_coupling!","page":"API","title":"SmoQyDQMC.add_ssh_coupling!","text":"add_ssh_coupling!(; electron_phonon_model::ElectronPhononModel{T,E,D},\n                  ssh_coupling::SSHCoupling{T,E,D},\n                  tight_binding_model::TightBindingModel{T,E,D}) where {T,E,D}\n\nAdd a SSHCoupling to an ElectronPhononModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.add_phonon_dispersion!","page":"API","title":"SmoQyDQMC.add_phonon_dispersion!","text":"add_phonon_dispersion!(; electron_phonon_model::ElectronPhononModel{T,E,D},\n                       phonon_dispersion::PhononDispersion{E,D},\n                       model_geometry::ModelGeometry{D,E}) where {T,E,D}\n\nAdd a PhononDispersion to an ElectronPhononModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#Electron-Phonon-Parameter-Types-and-Methods","page":"API","title":"Electron-Phonon Parameter Types and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ElectronPhononParameters\nElectronPhononParameters(;)\nSmoQyDQMC.PhononParameters\nSmoQyDQMC.HolsteinParameters\nSmoQyDQMC.SSHParameters\nSmoQyDQMC.DispersionParameters\ninitialize!(::FermionPathIntegral{T,E}, ::FermionPathIntegral{T,E}, ::ElectronPhononParameters{T,E}) where {T,E}\nupdate!(::FermionPathIntegral{T,E}, ::FermionPathIntegral{T,E}, ::ElectronPhononParameters{T,E}, ::Matrix{E}, ::Matrix{E}) where {T,E}","category":"page"},{"location":"api/#SmoQyDQMC.ElectronPhononParameters","page":"API","title":"SmoQyDQMC.ElectronPhononParameters","text":"ElectronPhononParameters{T<:Number, E<:AbstractFloat}\n\nDescribes all parameters in the electron-phonon model.\n\nFields\n\nβ::E: Inverse temperature.\nΔτ::E: Discretization in imaginary time.\nLτ::Int: Length of imaginary time axis.\nx::Matrix{E}: Phonon fields, where each column represents the phonon fields for a given imaginary time slice.\nphonon_parameters::PhononParameters{E}: Refer to PhononParameters.\nholstein_parameters::HolsteinParameters{E}: Refer to HolsteinParameters.\nssh_parameters::SSHParameters{T}: Refer to SSHParameters.\ndispersion_parameters::DispersionParameters{E}: Refer to DispersionParameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.ElectronPhononParameters-Tuple{}","page":"API","title":"SmoQyDQMC.ElectronPhononParameters","text":"ElectronPhononParameters(; β::E, Δτ::E,\n                         model_geometry::ModelGeometry{D,E},\n                         tight_binding_parameters::TightBindingParameters{T,E},\n                         electron_phonon_model::ElectronPhononModel{T,E,D},\n                         rng::AbstractRNG) where {T,E,D}\n\nInitialize and return an instance of ElectronPhononParameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.PhononParameters","page":"API","title":"SmoQyDQMC.PhononParameters","text":"PhononParameters{E<:AbstractFloat}\n\nDefines the parameters for each phonon in the lattice, includes the phonon field configuration.\n\nFields\n\nnphonon::Int: Number of type of phonon modes.\nNphonon::Int: Total number of phonon modes in finite lattice.\nM::Int: Mass of each phonon mode.\nΩ::Int: Frequency of each phonon mode.\nΩ4::Int: Quartic phonon coefficient for each phonon mode.\nphonon_to_site::Vector{Int}: Map each phonon to the site it lives on in the lattice.\nsite_to_phonons::Vector{Vector{Int}}: Maps the site to the phonon modes on it, allowing for multiple modes to reside on a single site.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HolsteinParameters","page":"API","title":"SmoQyDQMC.HolsteinParameters","text":"HolsteinParameters{E<:AbstractFloat}\n\nDefines the Holstein coupling parameters in lattice.\n\nFields\n\nnholstein::Int: The number of type of holstein couplings.\nNholstein::Int: Total number of Holstein couplings in lattice.\nα::Vector{T}: Linear Holstein coupling.\nα2::Vector{T}: Quadratic Holstein coupling.\nα3::Vector{T}: Cubic Holstein coupling.\nα4::Vector{T}: Quartic Holstein coupling.\nneighbor_table::Matrix{Int}: Neighbor table where the first row specifies the site where the phonon mode is located, and the second row specifies the site corresponds to the density getting coupled to.\ncoupling_to_phonon::Vector{Int}: Maps each Holstein coupling in the lattice to the corresponding phonon mode.\nphonon_to_coupling::Vector{Vector{Int}}: Maps each phonon model to correspond Holstein couplings.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.SSHParameters","page":"API","title":"SmoQyDQMC.SSHParameters","text":"SSHParameters{T<:Number}\n\nDefines the SSH coupling parameters in lattice.\n\nFields\n\nnssh::Int: Number of types of SSH couplings.\nNssh::Int: Number of SSH couplings in lattice.\nα::Vector{T}: Linear SSH coupling.\nα2::Vector{T}: Quadratic SSH coupling.\nα3::Vector{T}: Cubic SSH coupling.\nα4::Vector{T}: Quartic SSH coupling.`\nneighbor_table::Matrix{Int}: Neighbor table to SSH coupling.\ncoupling_to_phonon::Matrix{Int}: Maps each SSH coupling onto that pair of coupled phonons.\ninit_phonon_to_coupling::Vector{Vector{Int}}: Maps initial phonon mode to corresponding SSH coupling(s).\nfinal_phonon_to_coupling::Vector{Vector{Int}}: Maps final phonon mode to corresponding SSH coupling(s).\nhopping_to_coupling::Vector{Int}: Maps hopping in the tight-binding model onto SSH couplings. If zero, this means there is no SSH coupling for that hopping.\ncoupling_to_hopping::Vector{Int}: Maps each SSH coupling onto the corresponding hopping in the tight-binding model.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.DispersionParameters","page":"API","title":"SmoQyDQMC.DispersionParameters","text":"DispersionParameters{E<:AbstractFloat}\n\nDefines the dispersive phonon coupling parameters in the lattice.\n\nFields\n\nndispersion::Int: Number of types of dispersive couplings.\nNdispersion::Int: Number of dispersive couplings in the lattice.\nΩ::Vector{E}: Frequency of dispersive phonon coupling.\nΩ4::Vector{E}: Quartic coefficient for the phonon dispersion.\ndispersion_to_phonon::Matrix{Int}: Pair of phonon modes in lattice coupled by dispersive coupling.\ninit_phonon_to_coupling::Vector{Vector{Int}}: Maps initial phonon mode to corresponding dispersive phonon coupling.\nfinal_phonon_to_coupling::Vector{Vector{Int}}: Maps final phonon mode to corresponding dispersive phonon coupling.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.initialize!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, ElectronPhononParameters{T, E}}} where {T, E}","page":"API","title":"SmoQyDQMC.initialize!","text":"initialize!(fermion_path_integral_up::FermionPathIntegral{T,E},\n            fermion_path_integral_dn::FermionPathIntegral{T,E},\n            electron_phonon_parameters::ElectronPhononParameters{T,E}) where {T,E}\n\ninitialize!(fermion_path_integral::FermionPathIntegral{T,E},\n            electron_phonon_parameters::ElectronPhononParameters{T,E}) where {T,E}\n\nInitialize the contribution of an ElectronPhononParameters to a FermionPathIntegral.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.update!-Union{Tuple{E}, Tuple{T}, Tuple{FermionPathIntegral{T, E}, FermionPathIntegral{T, E}, ElectronPhononParameters{T, E}, Matrix{E}, Matrix{E}}} where {T, E}","page":"API","title":"SmoQyDQMC.update!","text":"update!(fermion_path_integral_up::FermionPathIntegral{T,E},\n        fermion_path_integral_dn::FermionPathIntegral{T,E},\n        electron_phonon_parameters::ElectronPhononParameters{T,E},\n        x′::Matrix{E}, x::Matrix{E} = electron_phonon_parameters.x) where {T,E}\n\nupdate!(fermion_path_integral::FermionPathIntegral{T,E},\n        electron_phonon_parameters::ElectronPhononParameters{T,E},\n        x′::Matrix{E}, x::Matrix{E} = electron_phonon_parameters.x) where {T,E}\n\nUpdate a FermionPathIntegral to reflect a change in the phonon configuration from x to x′.\n\n\n\n\n\n","category":"method"},{"location":"api/#Electron-Phonon-Measurements","page":"API","title":"Electron-Phonon Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"measure_phonon_kinetic_energy\nmeasure_phonon_potential_energy\nmeasure_phonon_position_moment\nmeasure_holstein_energy\nmeasure_ssh_energy\nmeasure_dispersion_energy","category":"page"},{"location":"api/#SmoQyDQMC.measure_phonon_kinetic_energy","page":"API","title":"SmoQyDQMC.measure_phonon_kinetic_energy","text":"measure_phonon_kinetic_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                              n::Int) where {T<:Number, E<:AbstractFloat}\n\nEvaluate the average phonon kinetic energy for phonon mode n. The measurement is made using the expression\n\nlangle K rangle = frac12Deltatau - fracM2bigglanglefrac(x_l+1-x_l)^2Deltatau^2biggrangle \n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_phonon_potential_energy","page":"API","title":"SmoQyDQMC.measure_phonon_potential_energy","text":"measure_phonon_potential_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                                n::Int) where {T<:Number, E<:AbstractFloat}\n\nCalculate the average phonon potential energy, given by\n\nU = frac12 M Omega^2 langle hatX^2 rangle + frac124 M Omega_4^2 langle hatX^4 rangle\n\nfor phonon mode n in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_phonon_position_moment","page":"API","title":"SmoQyDQMC.measure_phonon_position_moment","text":"measure_phonon_position_moment(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                               n::Int, m::Int) where {T<:Number, E<:AbstractFloat}\n\nMeasure langle X^m rangle for phonon mode n in the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_holstein_energy","page":"API","title":"SmoQyDQMC.measure_holstein_energy","text":"measure_holstein_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                     Gup::Matrix{T}, Gdn::Matrix{T},\n                     holstein_id::Int) where {T<:Number, E<:AbstractFloat}\n\nCalculate and return the Holstein interaction energy\n\nepsilon_rm hol = leftlangle  alpha hatX     + alpha_2 hatX^2\n                                  + alpha_3 hatX^3 + alpha_4 hatX^4\n                                (hatn_uparrow + hatn_downarrow - 1) rightrangle\n\nfor the Holstein coupling definition corresponding to holstein_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_ssh_energy","page":"API","title":"SmoQyDQMC.measure_ssh_energy","text":"measure_ssh_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                Gup::Matrix{T}, Gdn::Matrix{T},\n                ssh_id::Int) where {T<:Number, E<:AbstractFloat}\n\nCalculate the return the SSH interaction energy\n\nepsilon_rm ssh = sum_sigma leftlangle alpha hatX     + alpha_2 hatX^2\n                                               alpha_3 hatX^3 + alpha_4 hatX^4\n                                              (hatc^dagger_sigmai hatc_sigmaj + rm hc) rightrangle\n\nfor coupling definition specified by ssh_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.measure_dispersion_energy","page":"API","title":"SmoQyDQMC.measure_dispersion_energy","text":"measure_dispersion_energy(electron_phonon_parameters::ElectronPhononParameters{T,E},\n                       dispersion_id::Int) where {T<:Number, E<:AbstractFloat}\n\nEvaluate the average dispersion energy\n\nepsilon_rm disp = frac12 M_rm red Omega^2 langle(hatX_i - hatX_j)^2rangle\n                    + frac124 Mrm red Omega_4^2 langle(hatX_i - hatX_j)^4rangle\n\nwhere M_rm red = fracM_i M_jM_i + M_j is the reduced mass, for the dispersive coupling definition specified by dispersion_id.\n\n\n\n\n\n","category":"function"},{"location":"api/#Electron-Phonon-Updates","page":"API","title":"Electron-Phonon Updates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HMCUpdater\nHMCUpdater(;)\nhmc_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}, ::HMCUpdater{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nhmc_update!(::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}, ::HMCUpdater{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nLMCUpdater\nLMCUpdater(;)\nlmc_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}, ::LMCUpdater{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nlmc_update!(::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}, ::LMCUpdater{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nSmoQyDQMC.FourierMassMatrix\nSmoQyDQMC.FourierMassMatrix(::ElectronPhononParameters{T,E}, ::E) where {T,E}\nreflection_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nreflection_update!(::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nswap_update!(::Matrix{T}, ::E, ::T, ::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\nswap_update!(::Matrix{T}, ::E, ::T, ::ElectronPhononParameters{T,E}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}","category":"page"},{"location":"api/#SmoQyDQMC.HMCUpdater","page":"API","title":"SmoQyDQMC.HMCUpdater","text":"HMCUpdater{T<:Number, E<:AbstractFloat, PFFT, PIFFT}\n\nDefines a hybrid/hamiltonian monte carlo (HMC) update for the phonon degrees of freedom. Each HMC update uses a number of timesteps sampled from a geometric distribution with a mean given by Nt.\n\nFields\n\nNt::Int: Mean trajectory length in terms of the number of fermionic time-steps.\nΔt::E: Fermionic time-step size.\nnt::Int: Number of bosonic time-steps per fermionic time-step. The effective bosonic time-step size is Δt′ = Δt/nt.\nM::FourierMassMatrix{E, PFFT, PIFFT}: Fourier mass matrix, refer to FourierMassMatrix for more information.\ndSdx::Matrix{E}: Array to contain derivative of fermionic and bosonic action during HMC trajectory.\ndSfdx0::Matrix{E}: Array to contain the initial derivative of fermionic action associated with the initial phonon configuration.\nGup′::Matrix{T}: Matrix to contain itermediate spin-up Green's function matrices.\nGdn′::Matrix{T}: Matrix to contain itermediate spin-down Green's function matrices.\nx′::Matrix{E}: Array to record intermediate phonon configurations.\nx0::Matrix{E}: Array to record initial phonon configuration.\nv::Matrix{E}: Conjugate momentum to phonon fields in HMC trajectory.\nfirst_update::Bool: A flag indicating whether the next update will be the first update\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.HMCUpdater-Tuple{}","page":"API","title":"SmoQyDQMC.HMCUpdater","text":"HMCUpdater(; electron_phonon_parameters::ElectronPhononParameters{T,E},\n           G::Matrix{T}, Nt::Int, Δt::E, nt::Int, reg::E) where {T,E}\n\nInitialize and return an instance of HMCUpdater.\n\nArguments\n\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Defines electron phonon model.\nG::Matrix{T}: Template Green's function matrix.\nNt::Int: Mean of geometric distribution an HMC trajectory length in the number of fermionic timesteps is sampled from.\nΔt::E: Fermionic time-step.\nnt::Int: Bosonic time-steps per fermionic time-step, with the effective bosonic time-step given by Δt′ = Δt/nt.\nreg::E: Regularization parameter for defining an instance of FourierMassMatrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}, HMCUpdater{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n            Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n            electron_phonon_parameters::ElectronPhononParameters{T,E},\n            hmc_updater::HMCUpdater{T,E};\n            fermion_path_integral_up::FermionPathIntegral{T,E},\n            fermion_path_integral_dn::FermionPathIntegral{T,E},\n            fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n            Bup::Vector{P}, Bdn::Vector{P},\n            δG_max::E, δG::E, δθ::E, rng::AbstractRNG,\n            initialize_force::Bool = true,\n            δG_reject::E = 1e-2) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform HMC update to the phonon degrees of freedom. This method returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ), where accepted is a boolean field indicating whether the proposed HMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.hmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}, HMCUpdater{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.hmc_update!","text":"hmc_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n            electron_phonon_parameters::ElectronPhononParameters{T,E},\n            hmc_updater::HMCUpdater{T,E};\n            fermion_path_integral::FermionPathIntegral{T,E},\n            fermion_greens_calculator::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n            B::Vector{P}, δG_max::E, δG::E, δθ::E, rng::AbstractRNG,\n            initialize_force::Bool = true,\n            δG_reject::E = 1e-2) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform HMC update to the phonon degrees of freedom assuming the spin-up and spin-down sectors are equivalent. This method returns (accepted, logdetG, sgndetG, δG, δθ), where accepted is a boolean field indicating whether the proposed HMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.LMCUpdater","page":"API","title":"SmoQyDQMC.LMCUpdater","text":"LMCUpdater{T<:Number, E<:AbstractFloat, PFFT, PIFFT}\n\nDefines a langevin monte carlo (HMC) update for the phonon degrees of freedom.\n\nFields\n\nΔt::E: Mean fermionic time-step size, which for a given LMC update is sampled from an exponential distribution.\nnt::Int: Number of bosonic time-steps per fermionic time-step. The effective bosonic time-step size is Δt′ = Δt/nt.\nM::FourierMassMatrix{E, PFFT, PIFFT}: Fourier mass matrix, refer to FourierMassMatrix for more information.\ndSdx::Matrix{E}: Array to contain derivative of fermionic and bosonic action during HMC trajectory.\ndSfdx0::Matrix{E}: Array to contain the initial derivative of fermionic action associated with the initial phonon configuration.\nGup′::Matrix{T}: Matrix to contain itermediate spin-up Green's function matrices.\nGdn′::Matrix{T}: Matrix to contain itermediate spin-down Green's function matrices.\nx′::Matrix{E}: Array to record intermediate phonon configurations.\nx0::Matrix{E}: Array to record initial phonon configuration.\nv::Matrix{E}: Conjugate momentum to phonon fields in HMC trajectory.\nfirst_update::Bool: A flag indicating whether the next update will be the first update\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.LMCUpdater-Tuple{}","page":"API","title":"SmoQyDQMC.LMCUpdater","text":"LMCUpdater(; electron_phonon_parameters::ElectronPhononParameters{T,E},\n           G::Matrix{T}, Δt::E, nt::Int, reg::E) where {T,E}\n\nInitialize and return an instance of LMCUpdater.\n\nArguments\n\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Defines electron phonon model.\nG::Matrix{T}: Template Green's function matrix.\nΔt::E: Mean of exponential distribution the fermionic time-step is sampled from.\nnt::Int: Number of bosonic time-steps, with the effective bosonic time-step given by Δt′ = Δt/nt.\nreg::E: Regularization parameter for defining an instance of FourierMassMatrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.lmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}, LMCUpdater{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.lmc_update!","text":"lmc_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n            Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n            electron_phonon_parameters::ElectronPhononParameters{T,E},\n            lmc_updater::LMCUpdater{T,E};\n            fermion_path_integral_up::FermionPathIntegral{T,E},\n            fermion_path_integral_dn::FermionPathIntegral{T,E},\n            fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n            Bup::Vector{P}, Bdn::Vector{P},\n            δG_max::E, δG::E, δθ::E, rng::AbstractRNG,\n            initialize_force::Bool = true,\n            δG_reject::E = sqrt(δG_max)) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform LMC update to the phonon degrees of freedom. This method returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ), where accepted is a boolean field indicating whether the proposed LMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.lmc_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}, LMCUpdater{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.lmc_update!","text":"lmc_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n            electron_phonon_parameters::ElectronPhononParameters{T,E},\n            lmc_updater::LMCUpdater{T,E};\n            fermion_path_integral::FermionPathIntegral{T,E},\n            fermion_greens_calculator::FermionGreensCalculator{T,E},\n            fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n            B::Vector{P}, δG_max::E, δG::E, δθ::E, rng::AbstractRNG,\n            initialize_force::Bool = true,\n            δG_reject::E = sqrt(δG_max)) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nPerform LMC update to the phonon degrees of freedom assuming the spin-up and spin-down sectors are equivalent. This method returns (accepted, logdetG, sgndetG, δG, δθ), where accepted is a boolean field indicating whether the proposed LMC update was accepted or rejected.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.FourierMassMatrix","page":"API","title":"SmoQyDQMC.FourierMassMatrix","text":"FourierMassMatrix{E<:AbstractFloat, PFFT, PIFFT}\n\nDefines the mass matrix that implements fourier acceleration when performing either hybrid/hamiltonian monte carlo or langevin monte carlo updates to the phonon fields.\n\nFields\n\nM̃::Matrix{E}: Matrix elements of fourier mass matrix in frequency space.\nv′::Matrix{Complex{E}}: Temporary storage array to contain velocities as complex numbers to avoid dynamic memory allocations.\nṽ::Matrix{Complex{E}}: Temporary storage to avoid some dynamic memory allocations when performing fourier transforms.\npfft::PFFT: Forward FFT plan to perform transformation from imaginary time to frequency space without allocations.\npifft::PIFFT: Inverse FFT plan to perform transformation from frequency to imaginary time space without allocations.\n\n\n\n\n\n","category":"type"},{"location":"api/#SmoQyDQMC.FourierMassMatrix-Union{Tuple{E}, Tuple{T}, Tuple{ElectronPhononParameters{T, E}, E}} where {T, E}","page":"API","title":"SmoQyDQMC.FourierMassMatrix","text":"FourierMassMatrix(electron_phonon_parameters::ElectronPhononParameters{T,E}, reg::E=1.0) where {T,E}\n\nInitialize and return an instance of FouerierMassMatrix. Given a regularization value of reg, represented by the symbol m_rm reg, the matrix elements of the fouerier mass matrix in frequency space, where it is diagonal, are given by\n\ntildeM_omegaomega = \n    Deltataufrac(1+m_rm reg)MOmega^2+frac4MDeltatau^2sin^2big(fracpiomegaL_taubig)(1+m_rm reg)MOmega^2\n\nwhere omega in 0 L_tau) corresponds to the frequency after fourier transforming from imaginary time to frequency space, and L_tau is the length of the imaginary time axis. Also, Omega and M are the phonon frequency and mass respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n                   Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n                   electron_phonon_parameters::ElectronPhononParameters{T,E};\n                   fermion_path_integral_up::FermionPathIntegral{T,E},\n                   fermion_path_integral_dn::FermionPathIntegral{T,E},\n                   fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n                   Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,\n                   phonon_types = nothing) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a phonon mode in the lattice, and propose an update that reflects all the phonon fields associated with that phonon mode x rightarrow -x This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_types = nothing: Collection of phonon types in the unit cell to randomly sample a phonon mode from. If nothing then all phonon modes in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.reflection_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.reflection_update!","text":"reflection_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n                   electron_phonon_parameters::ElectronPhononParameters{T,E};\n                   fermion_path_integral::FermionPathIntegral{T,E},\n                   fermion_greens_calculator::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n                   B::Vector{P}, rng::AbstractRNG,\n                   phonon_types = nothing) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a phonon mode in the lattice, and propose an update that reflects all the phonon fields associated with that phonon mode x rightarrow -x This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_types = nothing: Collection of phonon types in the unit cell to randomly sample a phonon mode from. If nothing then all phonon modes in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n             Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T,\n             electron_phonon_parameters::ElectronPhononParameters{T,E};\n             fermion_path_integral_up::FermionPathIntegral{T,E},\n             fermion_path_integral_dn::FermionPathIntegral{T,E},\n             fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_up_alt::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E},\n             Bup::Vector{P}, Bdn::Vector{P}, rng::AbstractRNG,\n             phonon_type_pairs = nothing) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a pairs of phonon modes and exchange the phonon fields associated with the pair of phonon modes. This function returns (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn).\n\nArguments\n\nGup::Matrix{T}: Spin-up eqaul-time Greens function matrix.\nlogdetGup::E: Log of the determinant of the spin-up eqaul-time Greens function matrix.\nsgndetGup::T: Sign/phase of the determinant of the spin-up eqaul-time Greens function matrix.\nGdn::Matrix{T}: Spin-down eqaul-time Greens function matrix.\nlogdetGdn::E: Log of the determinant of the spin-down eqaul-time Greens function matrix.\nsgndetGdn::T: Sign/phase of the determinant of the spin-down eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral_up::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-up electrons.\nfermion_path_integral_dn::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type for spin-down electrons.\nfermion_greens_calculator_up::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-up sector state.\nfermion_greens_calculator_dn::FermionGreensCalculator{T,E}: Contains matrix factorization information for current spin-down sector state.\nfermion_greens_calculator_up_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nfermion_greens_calculator_dn_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed spin-up sector state.\nBup::Vector{P}: Spin-up propagators for each imaginary time slice.\nBdn::Vector{P}: Spin-down propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_type_pairs = nothing: Collection of phonon type pairs in the unit cell to randomly sample a phonon modes from. If nothing then all phonon mode pairs in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#SmoQyDQMC.swap_update!-Union{Tuple{P}, Tuple{E}, Tuple{T}, Tuple{Matrix{T}, E, T, ElectronPhononParameters{T, E}}} where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T, E}}","page":"API","title":"SmoQyDQMC.swap_update!","text":"swap_update!(G::Matrix{T}, logdetG::E, sgndetG::T,\n             electron_phonon_parameters::ElectronPhononParameters{T,E};\n             fermion_path_integral::FermionPathIntegral{T,E},\n             fermion_greens_calculator::FermionGreensCalculator{T,E},\n             fermion_greens_calculator_alt::FermionGreensCalculator{T,E},\n             B::Vector{P}, rng::AbstractRNG,\n             phonon_type_pairs = nothing) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nRandomly sample a pairs of phonon modes and exchange the phonon fields associated with the pair of phonon modes. This function returns (accepted, logdetG, sgndetG).\n\nArguments\n\nG::Matrix{T}: Eqaul-time Greens function matrix.\nlogdetG::E: Log of the determinant of the eqaul-time Greens function matrix.\nsgndetG::T: Sign/phase of the determinant of the eqaul-time Greens function matrix.\nelectron_phonon_parameters::ElectronPhononParameters{T,E}: Electron-phonon parameters, including the current phonon configuration.\n\nKeyword Arguments\n\nfermion_path_integral::FermionPathIntegral{T,E}: An instance of FermionPathIntegral type.\nfermion_greens_calculator::FermionGreensCalculator{T,E}: Contains matrix factorization information for current state.\nfermion_greens_calculator_alt::FermionGreensCalculator{T,E}: Used to calculate matrix factorizations for proposed state.\nB::Vector{P}: Propagators for each imaginary time slice.\nrng::AbstractRNG: Random number generator used in method instead of global random number generator, important for reproducibility.\nphonon_type_pairs = nothing: Collection of phonon type pairs in the unit cell to randomly sample a phonon modes from. If nothing then all phonon mode pairs in the unit cell are considered.\n\n\n\n\n\n","category":"method"},{"location":"api/#Density-and-Chemical-Potential-Tuning","page":"API","title":"Density and Chemical Potential Tuning","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"update_chemical_potential!\nsave_density_tuning_profile","category":"page"},{"location":"api/","page":"API","title":"API","text":"update_chemical_potential!\nsave_density_tuning_profile","category":"page"},{"location":"api/#SmoQyDQMC.update_chemical_potential!","page":"API","title":"SmoQyDQMC.update_chemical_potential!","text":"update_chemical_potential!(Gup::Matrix{T}, logdetGup::E, sgndetGup::T,\n                           Gdn::Matrix{T}, logdetGdn::E, sgndetGdn::T;\n                           chemical_potential_tuner::MuTunerLogger{E,T},\n                           tight_binding_parameters::TightBindingParameters{T,E},\n                           fermion_path_integral_up::FermionPathIntegral{T,E},\n                           fermion_path_integral_dn::FermionPathIntegral{T,E},\n                           fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                           fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                           Bup::Vector{P}, Bdn::Vector{P}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nUpdate the chemical potential mu in the simulation to approach the target density/filling. This method returns the new values for (logdetGup, sgndetGup, logdetGup, sgndetGup).\n\n\n\n\n\nupdate_chemical_potential!(G::Matrix{T}, logdetG::E, sgndetG::T;\n                           chemical_potential_tuner::MuTunerLogger{E,T},\n                           tight_binding_parameters::TightBindingParameters{T,E},\n                           fermion_path_integral::FermionPathIntegral{T,E},\n                           fermion_greens_calculator::FermionGreensCalculator{T,E},\n                           B::Vector{P}) where {T<:Number, E<:AbstractFloat, P<:AbstractPropagator{T,E}}\n\nUpdate the chemical potential mu in the simulation to approach the target density/filling. This method returns the new values for (logdetG, sgndetG).\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.save_density_tuning_profile","page":"API","title":"SmoQyDQMC.save_density_tuning_profile","text":"save_density_tuning_profile(simulation_info::SimulationInfo,\n                            chemical_potential_tuner::MuTunerLogger{E,T}) where {E,T}\n\nWrite the full density tuning history to a CSV file, typically done at the end of a simulation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Measurement-Methods","page":"API","title":"Measurement Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LOCAL_MEASUREMENTS\nCORRELATION_FUNCTIONS","category":"page"},{"location":"api/","page":"API","title":"API","text":"Initialize Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"initialize_measurement_container\ninitialize_measurements!\ninitialize_correlation_measurements!\ninitialize_measurement_directories","category":"page"},{"location":"api/","page":"API","title":"API","text":"Make Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"make_measurements!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Write Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"write_measurements!","category":"page"},{"location":"api/","page":"API","title":"API","text":"Process Measurements","category":"page"},{"location":"api/","page":"API","title":"API","text":"process_measurements\nprocess_correlation_measurement\ncomposite_correlation_stats\nglobal_measurement_bins_to_csv\nlocal_measurement_bins_to_csv\ncorrelation_bins_to_csv","category":"page"},{"location":"api/","page":"API","title":"API","text":"CORRELATION_FUNCTIONS","category":"page"},{"location":"api/#SmoQyDQMC.CORRELATION_FUNCTIONS","page":"API","title":"SmoQyDQMC.CORRELATION_FUNCTIONS","text":"const CORRELATION_FUNCTIONS = Dict(\n    \"greens\"           => \"ORBITAL_ID\",\n    \"greens_up\"        => \"ORBITAL_ID\",\n    \"greens_dn\"        => \"ORBITAL_ID\",\n    \"greens_tautau\"    => \"ORBITAL_ID\",\n    \"greens_tautau_up\" => \"ORBITAL_ID\",\n    \"greens_tautau_dn\" => \"ORBITAL_ID\",\n    \"density\"          => \"ORBITAL_ID\",\n    \"spin_x\"           => \"ORBITAL_ID\",\n    \"spin_z\"           => \"ORBITAL_ID\",\n    \"pair\"             => \"BOND_ID\",\n    \"bond\"             => \"BOND_ID\",\n    \"phonon_greens\"    => \"PHONON_ID\",\n    \"current\"          => \"HOPPING_ID\"\n)\n\nList of all the correlation functions that can be measured, along with the corresponding type of ID the correlation measurement is reported in terms of. Correlation functions are well defined in both position and momentum space.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Initialize-Measurements","page":"API","title":"Initialize Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"initialize_measurement_container\ninitialize_measurements!\ninitialize_correlation_measurements!\ninitialize_measurement_directories","category":"page"},{"location":"api/#SmoQyDQMC.initialize_measurement_container","page":"API","title":"SmoQyDQMC.initialize_measurement_container","text":"initialize_measurement_container(model_geometry::ModelGeometry{D,T,N}, β::T, Δτ::T) where {T<:AbstractFloat, D, N}\n\nInitialize and return a measurement container of type NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_measurements!","page":"API","title":"SmoQyDQMC.initialize_measurements!","text":"initialize_measurements!(measurement_container::NamedTuple,\n                         tight_binding_model::TightBindingModel{T,E}) where {T<:Number, E<:AbstractFloat}\n\nInitialize tight-binding model related measurements.\n\nInitialized Measurements\n\nonsite_energy: Refer to measure_onsite_energy.\nhopping_energy: Refer to measure_hopping_energy.\n\n\n\n\n\ninitialize_measurements!(measurement_container::NamedTuple,\n                         hubbard_model::HubbardModel{T}) where {T<:AbstractFloat}\n\nInitialize Hubbard model related measurements.\n\nInitialized Measurements:\n\nhubbard_energy: Refer to measure_hopping_energy.\n\n\n\n\n\ninitialize_measurements!(measurement_container::NamedTuple,\n                         electron_phonon_model::ElectronPhononModel{T, E, D}) where {T<:Number, E<:AbstractFloat, D}\n\nInitialize electron-phonon model related measurements.\n\nInitialized Measurements:\n\nphonon_kinetic_energy: Refer to measure_phonon_kinetic_energy.\nphonon_potential_energy: Refer to measure_phonon_potential_energy.\nX: Measure langle hatX rangle, refer to measure_phonon_position_moment.\nX2: Measure langle hatX^2 rangle, refer to measure_phonon_position_moment.\nX3: Measure langle hatX^3 rangle, refer to measure_phonon_position_moment.\nX4: Measure langle hatX^4 rangle, refer to measure_phonon_position_moment.\nholstein_energy: Refer to measure_holstein_energy.\nssh_energy: Refer to measure_ssh_energy.\nssh_sgn_switch: Refer to measure_ssh_sgn_switch.\ndispersion_energy: Refer to measure_dispersion_energy.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_correlation_measurements!","page":"API","title":"SmoQyDQMC.initialize_correlation_measurements!","text":"initialize_correlation_measurements!(; measurement_container::NamedTuple,\n                                     model_geometry::ModelGeometry{D,T,N},\n                                     correlation::String, pairs::AbstractVector{NTuple{2,Int}},\n                                     time_displaced::Bool,\n                                     integrated::Bool = false)  where {T<:AbstractFloat, D, N}\n\nInitialize measurements of correlation for all pairs of bond ID's in pairs. The name correlation must appear in CORRELATION_FUNCTIONS. If time_displaced = true then time-displaced and integrated correlation measurements are made. If time_displaced = false and integrated = false, then just equal-time correlation measurements are made. If time_displaced = false and integrated = true, then both equal-time and integrated correlation measurements are made.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.initialize_measurement_directories","page":"API","title":"SmoQyDQMC.initialize_measurement_directories","text":"initialize_measurement_directories(; simulation_info::SimulationInfo,\n                                   measurement_container::NamedTuple)\n\nInitialize the measurement directories for simulation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Make-Measreuments","page":"API","title":"Make Measreuments","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"make_measurements!","category":"page"},{"location":"api/#SmoQyDQMC.make_measurements!","page":"API","title":"SmoQyDQMC.make_measurements!","text":"make_measurements!(measurement_container::NamedTuple,\n                   logdetGup::E, sgndetGup::T, Gup::AbstractMatrix{T}, Gup_ττ::AbstractMatrix{T}, Gup_τ0::AbstractMatrix{T}, Gup_0τ::AbstractMatrix{T},\n                   logdetGdn::E, sgndetGdn::T, Gdn::AbstractMatrix{T}, Gdn_ττ::AbstractMatrix{T}, Gdn_τ0::AbstractMatrix{T}, Gdn_0τ::AbstractMatrix{T};\n                   fermion_path_integral_up::FermionPathIntegral{T,E},\n                   fermion_path_integral_dn::FermionPathIntegral{T,E},\n                   fermion_greens_calculator_up::FermionGreensCalculator{T,E},\n                   fermion_greens_calculator_dn::FermionGreensCalculator{T,E},\n                   Bup::Vector{P}, Bdn::Vector{P}, δG_max::E, δG::E, δθ::E,\n                   model_geometry::ModelGeometry{D,E,N},\n                   tight_binding_parameters::TightBindingParameters{T,E},\n                   coupling_parameters::Tuple) where {T<:Number, E<:AbstractFloat, D, N, P<:AbstractPropagator{T,E}}\n\nMake measurements, including time-displaced correlation and zero Matsubara frequency measurements. This method also returns (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ).\n\n\n\n\n\nmake_measurements!(measurement_container::NamedTuple,\n                   logdetG::E, sgndetG::T, G::AbstractMatrix{T},\n                   G_ττ::AbstractMatrix{T}, G_τ0::AbstractMatrix{T}, G_0τ::AbstractMatrix{T};\n                   fermion_path_integral::FermionPathIntegral{T,E},\n                   fermion_greens_calculator::FermionGreensCalculator{T,E},\n                   B::Vector{P}, δG_max::E, δG::E, δθ::E,\n                   model_geometry::ModelGeometry{D,E,N},\n                   tight_binding_parameters::TightBindingParameters{T,E},\n                   coupling_parameters::Tuple) where {T<:Number, E<:AbstractFloat, D, N, P<:AbstractPropagator{T,E}}\n\nMake measurements, including time-displaced correlation and zero Matsubara frequency measurements. This method also returns (logdetG, sgndetG, δG, δθ).\n\n\n\n\n\n","category":"function"},{"location":"api/#Write-Measreuments","page":"API","title":"Write Measreuments","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"write_measurements!","category":"page"},{"location":"api/#SmoQyDQMC.write_measurements!","page":"API","title":"SmoQyDQMC.write_measurements!","text":"write_measurements!(; measurement_container::NamedTuple,\n                    simulation_info::SimulationInfo,\n                    model_geometry::ModelGeometry{D, E, N},\n                    bin::Int, bin_size::Int) where {E<:AbstractFloat, D, N}\n\nWrite the measurements contained in measurement_container to file. Measurements are written to file in a binary format using the JLD2.jl package.\n\nThis funciton also does a few other things:\n\nNormalizes all the measurements by the bin_size i.e. the number of measurements that were accumlated into the measurement container.\nTake position space correlation function measurements and fourier transform them to momentum space.\nIntegrate relevant time-displaced correlation function measurements over imaginary time to get the corresponding zero matsubara frequency correlation function.\nReset all the measurements in measurement_container to zero after the measurements are written to file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Process-Measurements","page":"API","title":"Process Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"process_measurements\nprocess_correlation_measurement\ncomposite_correlation_stats\nglobal_measurement_bins_to_csv\nlocal_measurement_bins_to_csv\ncorrelation_bins_to_csv","category":"page"},{"location":"api/#SmoQyDQMC.process_measurements","page":"API","title":"SmoQyDQMC.process_measurements","text":"process_measurements(folder::String, N_bin::Int; time_displaced::Bool = false)\n\nProcess the measurements recorded in the simulation directory folder, where N_bin is the number of bins the data is grouped into for calculating error bars. Note that this method will over-write an existing correlation stats file if there already is one. The boolean flag time_displaced determines whether or not to calculate error bars for time-displaced correlation measurements, as this can take a non-negligible amount of time for large system, especially when many simulations were run in parallel.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.process_correlation_measurement","page":"API","title":"SmoQyDQMC.process_correlation_measurement","text":"process_correlation_measurement(; folder::String, correlation::String, type::String, space::String, N_bin::Int)\n\nProcess a single correlation measurement using N_bin number of bins to calculate the error bars. The argument type must be set to either \"equal-time\", \"time-displaced\" or \"integrated\", and the argument space must be set to either \"position\" or \"momentum\".\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.composite_correlation_stats","page":"API","title":"SmoQyDQMC.composite_correlation_stats","text":"composite_correlation_stats(;\n    folder::String,\n    correlation::String,\n    space::String,\n    type::String,\n    ids::Vector{NTuple{2,Int}},\n    locs::Vector{NTuple{D,Int}},\n    num_bins::Int,\n    l::Int = 0,\n    f::Function = identity\n) where {D}\n\nCalaculate the mean and error for a composite correlation measurement based on the function Note that D indicates the spatial dimension of the system.\n\nKeyword Arguments\n\nfolder::String: The directory all simulations results were written to.\ncorrelation::String: Name of the correlation in question that will be processed.\nspace::String: The space of the measurement, either \"position\" or \"momentum\".\ntype::String: The type of correlation measurement \"eqaul-time\", \"time-displaced\" or \"integrated\".\nids::Vector{NTuple{2,Int}}: A vector or ID pairs to read.\nlocs::Vector{NTuple{D,Int}}: A vector specifying either a displacement if type = \"position\", or k-point if type = \"momentum\".\nnum_bins::Int: The number of bins that should be used to calculate the mean and standard deviation with using the jackknife method.\nl::Int = 0: Specifies the imaginary time slice, only used if type = \"time-displaced\".\nf::Function = identity: The function used to construct the composite correlation function based on each correlation specified by ids and locs.\n\nComments\n\nFor the locs argument, for a given location, i.e. loc = locs[1], the loc[d] value corresponds to either a displacement in the direction of the d lattice vector, or corresponds to a k-point index relative to the d reciprocal lattice vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.global_measurement_bins_to_csv","page":"API","title":"SmoQyDQMC.global_measurement_bins_to_csv","text":"global_measurement_bins_to_csv(folder::String)\n\nWrite the binned global measurements to file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.local_measurement_bins_to_csv","page":"API","title":"SmoQyDQMC.local_measurement_bins_to_csv","text":"local_measurement_bins_to_csv(folder::String, measurement::String)\n\nWrite the binned values for the local measurement measurement to a CSV file.\n\n\n\n\n\n","category":"function"},{"location":"api/#SmoQyDQMC.correlation_bins_to_csv","page":"API","title":"SmoQyDQMC.correlation_bins_to_csv","text":"correlation_bins_to_csv(; folder::String, correlation::String, type::String, space::String, write_index_key::Bool = true)\n\nWrite binned correlation data for correlation to a CSV file. The field type must be set equal to \"equal-time\", \"time-displaced\" or \"integrated\", and the field space but bet set to either \"position\" or \"momentum\".\n\n\n\n\n\n","category":"function"},{"location":"examples/hubbard_chain/","page":"Example 1(a): Hubbard Chain","title":"Example 1(a): Hubbard Chain","text":"EditURL = \"https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/main/literate_scripts/hubbard_chain.jl\"","category":"page"},{"location":"examples/hubbard_chain/#Example-1(a):-Hubbard-Chain","page":"Example 1(a): Hubbard Chain","title":"Example 1(a): Hubbard Chain","text":"","category":"section"},{"location":"examples/hubbard_chain/","page":"Example 1(a): Hubbard Chain","title":"Example 1(a): Hubbard Chain","text":"In this first example we will work through simulating the repulsive Hubbard model on a 1D chain at half-filling. The Hubbard Hamiltonian for a 1D chain is given by","category":"page"},{"location":"examples/hubbard_chain/","page":"Example 1(a): Hubbard Chain","title":"Example 1(a): Hubbard Chain","text":"hatH = -t sum_sigmai (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n+ U sum_i (hatn_uparrowi-tfrac12)(hatn_downarrowi-tfrac12)\n- mu sum_sigmai hatn_sigmai","category":"page"},{"location":"examples/hubbard_chain/","page":"Example 1(a): Hubbard Chain","title":"Example 1(a): Hubbard Chain","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. In the above Hamiltonian t is the nearest neighbor hopping integral and U  0 controls the strength of the on-site Hubbard repulsion. Lastly, we consider the case that the system is half-filled and particle-hole symmetric, which occurs when when the chemical potential is zero, mu = 00.","category":"page"},{"location":"examples/hubbard_chain/","page":"Example 1(a): Hubbard Chain","title":"Example 1(a): Hubbard Chain","text":"The script scripts/hubbard_chain.jl found in the repository simulates this Hamiltonian. Suppose we want to simulate a half-filled Hubbard chain (mu = 00) of length L=16 with U=80 at an inverse temperature of beta = 80. This is accomplished with the command","category":"page"},{"location":"examples/hubbard_chain/","page":"Example 1(a): Hubbard Chain","title":"Example 1(a): Hubbard Chain","text":"> julia hubbard_chain.jl 1 6.0 0.0 8.0 16 2000 10000 50","category":"page"},{"location":"examples/hubbard_chain/","page":"Example 1(a): Hubbard Chain","title":"Example 1(a): Hubbard Chain","text":"with the resulting data being written to a local directory hubbard_chain_U6.00_mu0.00_L16_b8.00-1 that will be created. The first command line argument is the simulation ID (sID = 1), and reuslts in the directory name ending in -1. The second, third, fourth and fifth command line arguments correspond to U, mu, beta and L respectively. The sixth command line argument specifies the number thermalization/burnin sweeps (N_burnin = 2000) that are performed, where an update to each Hubbard-Stratonovich field is attempted. The seventh command line argument specifies the subsequent number of sweeps through the lattice (N_udpates = 10000), after each of which measurements are performed. Finally, the eighth command line argument specifies the number of times during the simulation data is written to file (N_bins = 50). Note that this example only runs for a few minutes on most systems and can be easily run on most personal computers.","category":"page"},{"location":"examples/hubbard_chain/","page":"Example 1(a): Hubbard Chain","title":"Example 1(a): Hubbard Chain","text":"However, it should be stressed that this structure for the simulation is not enforced by the SmoQyDQMC package itself, but rather is simply a function of how the example_scripts/hubbard_chain.jl script is structured.","category":"page"},{"location":"examples/hubbard_chain/","page":"Example 1(a): Hubbard Chain","title":"Example 1(a): Hubbard Chain","text":"Below you will find a more heavily commented version of the example_scripts/hubbard_chain.jl script that includes additional exposition on what each part of the code is doing.","category":"page"},{"location":"examples/hubbard_chain/","page":"Example 1(a): Hubbard Chain","title":"Example 1(a): Hubbard Chain","text":"# First we import the required packages, including all of the required SmoQyDQMC submodules.\n\nusing LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# To start, we define a top-level function for running the DQMC simulation.\n# Note that the arguments to this function correspond to the command line arguments\n# used to run this script.\nfunction run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    # Note that the simulation ID `sID`` will be appended to this foldername as `*-sID`\n    datafolder_prefix = @sprintf \"hubbard_chain_U%.2f_mu%.2f_L%d_b%.2f\" U μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    # This type helps keep track of where data will be written to, and also what versions of\n    # SmoQyDQMC and Julia were used to run the script.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    # For convenience, we seed this function with a randomly sampled number for the\n    # global random number generator.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    # The function  dqmcf.eval_length_imaginary_axis() simply ensures\n    # that Lτ can be appropriately defined as an integer.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    # The bin size is the number of measurements that are averaged over each time data is written\n    # to file during the simulation.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    # Thinks of this as a simulation notebook where you can store any parameters you would like to record\n    # about how the DQMC simulation was run. For instance, it may be good to record the seed\n    # used to initialize the random number generator for reproducibility reasons. This dictionary\n    # will be appended as a table to the simulation information TOML file generated at the end of\n    # the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    # This struct defines the UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    # The struct describes the size of the finite periodic lattice to be simulated.\n    # Note that curretly periodic boundary condition must be used.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    # This type helps keep track of all the relevant features of the lattice\n    # geometry being simulated, including the defintion of the unit cell,\n    # the size of the finite periodic lattice, and all the relevant\n    # bond defintions that may arise in the model.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted = false, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n        U_orbital = [1],\n        U_mean = [U],\n    )\n\n    # Write the model summary to file.\n    # The model summary file, \"model_summary.toml\", is a very important file.\n    # It fully describes the model and system being simulated. It also defines all the\n    # various tID definitions (ORBITAL_ID, BOND_ID, HOPPING_ID, PHONON_ID)\n    # that measurements are reported in terms of. Therefore, this file is useful\n    # for understanding out the interpret and process the output data files.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n    # Above we defined the both the model and lattice size. Next, we initialize\n    # the actual system parameters. This is different because in general any\n    # parameter appearing in the model can support disorder. For instance, you\n    # can in simulate a system with random disorder in the on-site energy.\n    # Therefore, we need to initialize the parameters for the model on the lattice\n    # size we actually want to simulate.\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Here we initialize/define all the measurements we plan on making during the simulation.\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    # Because `time_displaced = true`, the time-displaced Greens function will be measured.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize density correlation function measurement.\n    # Because `time_displaced = false` and `integrated = true` the equal-time\n    # density correlation function, and the charge susceptibility will\n    # be measured. Note that the charge susceptibilty can be understood as the\n    # integral of the time-displaced density correlation function over\n    # the imaginary-time axis from τ=0 to τ=β.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    # Measure the local s-wave equal-time pair correlation function (`time-displaced = false`),\n    # and the corresponding pair susceptibility (`integrated = true`).\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # The code appearing in this section of the code is relatively boiler plate.\n    # While it may change in some small ways from system to system, the overall\n    # structure should remain relatively static.\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters,)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    # This simulation summary file records the version number of SmoQyDQMC and Julia\n    # used to perform the simulation. The dictionary `additional_info` is appended\n    # as a table to the end of the simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n   # Note that everyting appearing in this section of the code is considered post-processing,\n   # and can be re-run so long as the data folder generated by the DQMC simulation persists\n   # and none of the binned data has been deleted from it.\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    μ = parse(Float64, ARGS[3])\n    β = parse(Float64, ARGS[4])\n    L = parse(Int, ARGS[5])\n    N_burnin = parse(Int, ARGS[6])\n    N_updates = parse(Int, ARGS[7])\n    N_bins = parse(Int, ARGS[8])\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/hubbard_chain/","page":"Example 1(a): Hubbard Chain","title":"Example 1(a): Hubbard Chain","text":"","category":"page"},{"location":"examples/hubbard_chain/","page":"Example 1(a): Hubbard Chain","title":"Example 1(a): Hubbard Chain","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Example 8: Honeycomb Hubbard model","title":"Example 8: Honeycomb Hubbard model","text":"EditURL = \"https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/main/literate_scripts/hubbard_honeycomb.jl\"","category":"page"},{"location":"examples/hubbard_honeycomb/#Example-8:-Honeycomb-Hubbard-model","page":"Example 8: Honeycomb Hubbard model","title":"Example 8: Honeycomb Hubbard model","text":"","category":"section"},{"location":"examples/hubbard_honeycomb/","page":"Example 8: Honeycomb Hubbard model","title":"Example 8: Honeycomb Hubbard model","text":"In this script we simulate the Hubbard model on a Honeycomb lattice, with a Hamiltonian given by","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Example 8: Honeycomb Hubbard model","title":"Example 8: Honeycomb Hubbard model","text":"beginalign*\nhatH =  -t sum_sigmalangle i j rangle (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n            -mu sum_sigmaihatn_sigmai\n           + U sum_i (hatn_uparrowi-tfrac12)(hatn_downarrowi-tfrac12)\nendalign*","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Example 8: Honeycomb Hubbard model","title":"Example 8: Honeycomb Hubbard model","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. The nearest-neighbor hopping amplitude is t and mu is the chemical potential. The strength of the repulsive Hubbard interaction is controlled by U0.","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Example 8: Honeycomb Hubbard model","title":"Example 8: Honeycomb Hubbard model","text":"The example script to simulate this sytem is scripts/hubbard_honeycomb.jl. A short test simulation using this script that only takes a few minutes on most personal computers is","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Example 8: Honeycomb Hubbard model","title":"Example 8: Honeycomb Hubbard model","text":"> julia hubbard_honeycomb.jl 0 6.0 0.0 4.0 3 2000 10000 50","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Example 8: Honeycomb Hubbard model","title":"Example 8: Honeycomb Hubbard model","text":"This simulates a half-filled (mu = 00) Hubabrd model on a 3 times 3 unit cell honeycomb lattice, with a Hubbard interaction of U = 60, at inverse temperature beta = 40.","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Example 8: Honeycomb Hubbard model","title":"Example 8: Honeycomb Hubbard model","text":"Below you will find a more heavily commented version of the example_scripts/hubbard_honeycomb.jl script that includes additional exposition on what each part of the code is doing.","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Example 8: Honeycomb Hubbard model","title":"Example 8: Honeycomb Hubbard model","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running DQMC simulation.\nfunction run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_honeycomb_U%.2f_mu%.2f_L%d_b%.2f\" U μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[3/2,√3/2],\n                        [3/2,-√3/2]],\n        basis_vecs   = [[0.,0.],\n                        [1.,0.]]\n    )\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the first nearest-neighbor bond in a honeycomb lattice.\n    bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n    # Add the first nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_1_id = add_bond!(model_geometry, bond_1)\n\n    # Define the second nearest-neighbor bond in a honeycomb lattice.\n    bond_2 = lu.Bond(orbitals = (1,2), displacement = [-1,0])\n\n    # Add the second nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_2_id = add_bond!(model_geometry, bond_2)\n\n    # Define the third nearest-neighbor bond in a honeycomb lattice.\n    bond_3 = lu.Bond(orbitals = (1,2), displacement = [0,-1])\n\n    # Add the third nearest-neighbor bond in a honeycomb lattice to the model.\n    bond_3_id = add_bond!(model_geometry, bond_3)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds        = [bond_1, bond_2, bond_3], # defines hopping\n        t_mean         = [t, t, t], # defines corresponding hopping amplitude\n        μ              = μ, # set chemical potential\n        ϵ_mean         = [0.0, 0.0] # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted   = false, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n        U_orbital = [1, 2],\n        U_mean    = [U, U],\n    )\n\n    # Write the model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model,)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1), (2, 2), (1, 2)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (1, 2)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (1, 2)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (1, 2)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters,)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    μ = parse(Float64, ARGS[3])\n    β = parse(Float64, ARGS[4])\n    L = parse(Int, ARGS[5])\n    N_burnin = parse(Int, ARGS[6])\n    N_updates = parse(Int, ARGS[7])\n    N_bins = parse(Int, ARGS[8])\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Example 8: Honeycomb Hubbard model","title":"Example 8: Honeycomb Hubbard model","text":"","category":"page"},{"location":"examples/hubbard_honeycomb/","page":"Example 8: Honeycomb Hubbard model","title":"Example 8: Honeycomb Hubbard model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Example 1(c): Hubbard Chain with Checkpointing","title":"Example 1(c): Hubbard Chain with Checkpointing","text":"EditURL = \"https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/main/literate_scripts/hubbard_chain_checkpoint.jl\"","category":"page"},{"location":"examples/hubbard_chain_checkpoint/#Example-1(c):-Hubbard-Chain-with-Checkpointing","page":"Example 1(c): Hubbard Chain with Checkpointing","title":"Example 1(c): Hubbard Chain with Checkpointing","text":"","category":"section"},{"location":"examples/hubbard_chain_checkpoint/","page":"Example 1(c): Hubbard Chain with Checkpointing","title":"Example 1(c): Hubbard Chain with Checkpointing","text":"In this script we take the script from the previous example and introduce checkpointing, so that if the simulation is killed at some point it can resumed from the previous checkpoint. It is important to note that how checkpointing is introduced in this script is not unique, and other checkpointing schemes could be implemented in a script. For instance, in this script the checkpointing is implemented such that the number of checkpoints written to file during the simulation is a fixed number at the start of the simulation. It is possible, though slightly more involved, to implement a checkpointing scheme that instead writes checkpoints to file based on the wall clock and the amount of time that has passed since the previous checkpoint was written to file.","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Example 1(c): Hubbard Chain with Checkpointing","title":"Example 1(c): Hubbard Chain with Checkpointing","text":"To write the checkpoints we use the package JLD2, which allows the checkpoint files to be written to file as binary files that are HDF5 compatible. In this script, following the thermalziation/burnin updates, a checkpoint is written to file whenever measurements are written to file, so a total of N_bins checkpoints are written following the initial thermalization/burnin period of the simulation. During the thermalization/burnin updates, checkpoints are written with the same frequency as they are going to be once measurements start getting made.","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Example 1(c): Hubbard Chain with Checkpointing","title":"Example 1(c): Hubbard Chain with Checkpointing","text":"Below you can find the contents of the script example_scripts/hubbard_chain_checkpoint.jl with some expanded discussion of how checkpoints were added to the script.","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Example 1(c): Hubbard Chain with Checkpointing","title":"Example 1(c): Hubbard Chain with Checkpointing","text":"using LinearAlgebra\nusing Random\nusing Printf\nusing MPI\n\n# Import JLD2 package for write checkpoints during the simulation\n# to file as a binary file.\nusing JLD2\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# initialize MPI\nMPI.Init()\n\n# Define top-level function for running DQMC simulation\nfunction run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_chain_U%.2f_mu%.2f_L%d_b%.2f\" U μ L β\n\n    # Get the MPI comm rank, which fixes the process ID (pID).\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID,\n        pID = pID\n    )\n\n    # Define checkpoint filename.\n    # We implement three checkpoint files, an old, current and new one,\n    # that get cycled through to ensure a checkpoint file always exists in the off\n    # chance that the simulation is killed while a checkpoint is getting written to file.\n    # Additionally, each simulation that is running in parallel with MPI will have their own\n    # checkpoints written to file.\n    datafolder = simulation_info.datafolder\n    sID        = simulation_info.sID\n    pID        = simulation_info.pID\n    checkpoint_name_old          = @sprintf \"checkpoint_sID%d_pID%d_old.jld2\" sID pID\n    checkpoint_filename_old      = joinpath(datafolder, checkpoint_name_old)\n    checkpoint_name_current      = @sprintf \"checkpoint_sID%d_pID%d_current.jld2\" sID pID\n    checkpoint_filename_current  = joinpath(datafolder, checkpoint_name_current)\n    checkpoint_name_new          = @sprintf \"checkpoint_sID%d_pID%d_new.jld2\" sID pID\n    checkpoint_filename_new      = joinpath(datafolder, checkpoint_name_new)\n\n    ######################################################\n    ### DEFINE SOME RELEVANT DQMC SIMULATION PARAMETERS ##\n    ######################################################\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = 0.0\n    δθ = 0.0\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted = false, # If true, Hubbard interaction instead parameterized as U⋅nup⋅ndn\n        U_orbital = [1],\n        U_mean = [U],\n    )\n\n    #######################################################\n    ### BRANCHING BEHAVIOR BASED ON WHETHER STARTING NEW ##\n    ### SIMULAIOTN OR RESUMING PREVIOUS SIMULATION.      ##\n    #######################################################\n\n    # Synchronize all the MPI processes.\n    MPI.Barrier(comm)\n\n    # If starting a new simulation.\n    if !simulation_info.resuming\n\n        # Initialize a random number generator that will be used throughout the simulation.\n        seed = abs(rand(Int))\n        rng = Xoshiro(seed)\n\n        # Initialize the directory the data will be written to.\n        initialize_datafolder(simulation_info)\n\n        # Write the model summary to file.\n        model_summary(\n            simulation_info = simulation_info,\n            β = β, Δτ = Δτ,\n            model_geometry = model_geometry,\n            tight_binding_model = tight_binding_model,\n            interactions = (hubbard_model,)\n        )\n\n        # Calculate the bins size.\n        bin_size = div(N_updates, N_bins)\n\n        # Initialize a dictionary to store additional information about the simulation.\n        additional_info = Dict(\n            \"dG_max\" => δG_max,\n            \"N_burnin\" => N_burnin,\n            \"N_updates\" => N_updates,\n            \"N_bins\" => N_bins,\n            \"bin_size\" => bin_size,\n            \"local_acceptance_rate\" => 0.0,\n            \"reflection_acceptance_rate\" => 0.0,\n            \"n_stab_init\" => n_stab,\n            \"symmetric\" => symmetric,\n            \"checkerboard\" => checkerboard,\n            \"seed\" => seed,\n        )\n\n        #########################################\n        ### INITIALIZE FINITE MODEL PARAMETERS ##\n        #########################################\n\n\n        # Initialize tight-binding parameters.\n        tight_binding_parameters = TightBindingParameters(\n            tight_binding_model = tight_binding_model,\n            model_geometry = model_geometry,\n            rng = rng\n        )\n\n        # Initialize Hubbard interaction parameters.\n        hubbard_parameters = HubbardParameters(\n            model_geometry = model_geometry,\n            hubbard_model = hubbard_model,\n            rng = rng\n        )\n\n        # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n        # corresponding HS fields that will be sampled in DQMC simulation.\n        hubbard_ising_parameters = HubbardIsingHSParameters(\n            β = β, Δτ = Δτ,\n            hubbard_parameters = hubbard_parameters,\n            rng = rng\n        )\n\n        ##############################\n        ### INITIALIZE MEASUREMENTS ##\n        ##############################\n\n        # Initialize the container that measurements will be accumulated into.\n        measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n        # Initialize the tight-binding model related measurements, like the hopping energy.\n        initialize_measurements!(measurement_container, tight_binding_model)\n\n        # Initialize the Hubbard interaction related measurements.\n        initialize_measurements!(measurement_container, hubbard_model)\n\n        # Initialize the single-particle electron Green's function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"greens\",\n            time_displaced = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize density correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"density\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the pair correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"pair\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the spin-z correlation function measurement.\n        initialize_correlation_measurements!(\n            measurement_container = measurement_container,\n            model_geometry = model_geometry,\n            correlation = \"spin_z\",\n            time_displaced = false,\n            integrated = true,\n            pairs = [(1, 1)]\n        )\n\n        # Initialize the sub-directories to which the various measurements will be written.\n        initialize_measurement_directories(\n            simulation_info = simulation_info,\n            measurement_container = measurement_container\n        )\n\n        #############################\n        ### WRITE FIRST CHECKPOINT ##\n        #############################\n\n        # Calculate the bin size.\n        bin_size = div(N_updates, N_bins)\n\n        # Calculate the number of thermalization/burnin bins.\n        # This determines the number times the simulations checkpoints\n        # during the initial thermalziation/burnin period.\n        N_bins_burnin = div(N_burnin, bin_size)\n\n        # Initialize variable to keep track of the current burnin bin.\n        n_bin_burnin = 1\n\n        # Initialize variable to keep track of the current bin.\n        n_bin = 1\n\n        # Write an initial checkpoint to file.\n        JLD2.jldsave(\n            checkpoint_filename_current;\n            rng, additional_info,\n            N_burnin, N_updates, N_bins,\n            bin_size, N_bins_burnin, n_bin_burnin, n_bin,\n            measurement_container,\n            model_geometry,\n            tight_binding_parameters,\n            hubbard_parameters,\n            dG = δG, dtheta = δθ, n_stab = n_stab\n        )\n\n    # If resuming simulation from previous checkpoint.\n    else\n\n        # Initialize checkpoint to nothing before it is loaded.\n        checkpoint = nothing\n\n        # Try loading in the new checkpoint.\n        if isfile(checkpoint_filename_new)\n            try\n                # Load the new checkpoint.\n                checkpoint = JLD2.load(checkpoint_filename_new)\n            catch\n                nothing\n            end\n        end\n\n        # Try loading in the current checkpoint.\n        if isfile(checkpoint_filename_current) && isnothing(checkpoint)\n            try\n                # Load the current checkpoint.\n                checkpoint = JLD2.load(checkpoint_filename_current)\n            catch\n                nothing\n            end\n        end\n\n        # Try loading in the current checkpoint.\n        if isfile(checkpoint_filename_old) && isnothing(checkpoint)\n            try\n                # Load the old checkpoint.\n                checkpoint = JLD2.load(checkpoint_filename_old)\n            catch\n                nothing\n            end\n        end\n\n        # Throw an error if no checkpoint was succesfully loaded.\n        if isnothing(checkpoint)\n            error(\"Failed to load checkpoint successfully!\")\n        end\n\n        # Unpack the contents of the checkpoint.\n        rng                      = checkpoint[\"rng\"]\n        additional_info          = checkpoint[\"additional_info\"]\n        N_burnin                 = checkpoint[\"N_burnin\"]\n        N_updates                = checkpoint[\"N_updates\"]\n        N_bins                   = checkpoint[\"N_bins\"]\n        bin_size                 = checkpoint[\"bin_size\"]\n        N_bins_burnin            = checkpoint[\"N_bins_burnin\"]\n        n_bin_burnin             = checkpoint[\"n_bin_burnin\"]\n        n_bin                    = checkpoint[\"n_bin\"]\n        model_geometry           = checkpoint[\"model_geometry\"]\n        measurement_container    = checkpoint[\"measurement_container\"]\n        tight_binding_parameters = checkpoint[\"tight_binding_parameters\"]\n        hubbard_parameters       = checkpoint[\"hubbard_parameters\"]\n        hubbard_ising_parameters = checkpoint[\"hubbard_ising_parameters\"]\n        δG                       = checkpoint[\"dG\"]\n        δθ                       = checkpoint[\"dtheta\"]\n        n_stab                   = checkpoint[\"n_stab\"]\n    end\n\n    # Synchronize all the MPI processes.\n    MPI.Barrier(comm)\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization bins.\n    for bin in n_bin_burnin:N_bins_burnin\n\n        # Iterate over updates in current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n        end\n\n        # Write the new checkpoint to file.\n        JLD2.jldsave(\n            checkpoint_filename_new;\n            rng, additional_info,\n            N_burnin, N_updates, N_bins,\n            bin_size, N_bins_burnin,\n            n_bin_burnin = bin + 1,\n            n_bin = 1,\n            measurement_container,\n            model_geometry,\n            tight_binding_parameters,\n            hubbard_parameters,\n            hubbard_ising_parameters,\n            dG = δG, dtheta = δθ, n_stab = n_stab\n        )\n        # Make the current checkpoint the old checkpoint.\n        mv(checkpoint_filename_current, checkpoint_filename_old, force = true)\n        # Make the new checkpoint the current checkpoint.\n        mv(checkpoint_filename_new, checkpoint_filename_current, force = true)\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in n_bin:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters,)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n\n        # Write the new checkpoint to file.\n        JLD2.jldsave(\n            checkpoint_filename_new;\n            rng, additional_info,\n            N_burnin, N_updates, N_bins,\n            bin_size, N_bins_burnin,\n            n_bin_burnin = N_bins_burnin+1,\n            n_bin = bin + 1,\n            measurement_container,\n            model_geometry,\n            tight_binding_parameters,\n            hubbard_parameters,\n            hubbard_ising_parameters,\n            dG = δG, dtheta = δθ, n_stab = n_stab\n        )\n        # Make the current checkpoint the old checkpoint.\n        mv(checkpoint_filename_current, checkpoint_filename_old, force = true)\n        # Make the new checkpoint the current checkpoint.\n        mv(checkpoint_filename_new, checkpoint_filename_current, force = true)\n    end\n\n    # Calculate acceptance rate for local updates.\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Synchronize all the MPI processes.\n    MPI.Barrier(comm)\n\n    # Have the primary MPI process calculate the final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    if iszero(simulation_info.pID)\n        process_measurements(simulation_info.datafolder, N_bins)\n    end\n\n    return nothing\nend\n\n\n# Only excute if script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    μ = parse(Float64, ARGS[3])\n    β = parse(Float64, ARGS[4])\n    L = parse(Int, ARGS[5])\n    N_burnin = parse(Int, ARGS[6])\n    N_updates = parse(Int, ARGS[7])\n    N_bins = parse(Int, ARGS[8])\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(sID, U, μ, β, L, N_burnin, N_updates, N_bins)\n\n    # Finalize MPI (not strictly required).\n    MPI.Finalize()\nend","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Example 1(c): Hubbard Chain with Checkpointing","title":"Example 1(c): Hubbard Chain with Checkpointing","text":"","category":"page"},{"location":"examples/hubbard_chain_checkpoint/","page":"Example 1(c): Hubbard Chain with Checkpointing","title":"Example 1(c): Hubbard Chain with Checkpointing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/ossh_chain/","page":"Example 3: Optical Su-Schrieffer-Heeger Chain","title":"Example 3: Optical Su-Schrieffer-Heeger Chain","text":"EditURL = \"https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/main/literate_scripts/ossh_chain.jl\"","category":"page"},{"location":"examples/ossh_chain/#Example-3:-Optical-Su-Schrieffer-Heeger-Chain","page":"Example 3: Optical Su-Schrieffer-Heeger Chain","title":"Example 3: Optical Su-Schrieffer-Heeger Chain","text":"","category":"section"},{"location":"examples/ossh_chain/","page":"Example 3: Optical Su-Schrieffer-Heeger Chain","title":"Example 3: Optical Su-Schrieffer-Heeger Chain","text":"In this example we simulate the optical Su-Schrieffer-Heeger (OSSH) model on a 1D chain, with a Hamiltonian given by","category":"page"},{"location":"examples/ossh_chain/","page":"Example 3: Optical Su-Schrieffer-Heeger Chain","title":"Example 3: Optical Su-Schrieffer-Heeger Chain","text":"beginalign*\nhatH = sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)\n          - sum_sigmai t-alpha(hatX_i+1-hatX_i) (hatc^dagger_sigmai+1 hatc^phantom dagger_sigmai + rm hc)\n          - mu sum_sigmai hatn_sigmai\nendalign*","category":"page"},{"location":"examples/ossh_chain/","page":"Example 3: Optical Su-Schrieffer-Heeger Chain","title":"Example 3: Optical Su-Schrieffer-Heeger Chain","text":"in which the fluctuations in the position of dispersionless phonon modes placed on each site in the lattice modulate the hopping amplitude between neighboring sites. In the above expression hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creation (annihilation) operator a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is corresponding electron number operator. The phonon position (momentum) operator for the dispersionless phonon mode on site i is given by hatX_i  (hatP_i), where Omega and M are the phonon frequency and associated ion mass respectively. Lastly, the strength of the electron-phonon coupling is controlled by the parameter alpha.","category":"page"},{"location":"examples/ossh_chain/","page":"Example 3: Optical Su-Schrieffer-Heeger Chain","title":"Example 3: Optical Su-Schrieffer-Heeger Chain","text":"The example script to simulate this sytem is scripts/ossh_chain.jl. A short test simulation using this script that only takes a few minutes on most personal computers is","category":"page"},{"location":"examples/ossh_chain/","page":"Example 3: Optical Su-Schrieffer-Heeger Chain","title":"Example 3: Optical Su-Schrieffer-Heeger Chain","text":"> julia ossh_chain.jl 0 1.0 0.5 0.0 4.0 16 1000 5000 20","category":"page"},{"location":"examples/ossh_chain/","page":"Example 3: Optical Su-Schrieffer-Heeger Chain","title":"Example 3: Optical Su-Schrieffer-Heeger Chain","text":"which simulates an L=16 chain with Omega = 10, alpha = 05 at half-filling (mu = 00) and an inverse temperature of beta = 40. In this example N_burnin = 1000 HMC thermalization updates are performed, followed an additional N_updates = 5000 HMC updates, after each of which measurements are made. Bin averaged measurements are then written to file N_bins = 20 during the simulation.","category":"page"},{"location":"examples/ossh_chain/","page":"Example 3: Optical Su-Schrieffer-Heeger Chain","title":"Example 3: Optical Su-Schrieffer-Heeger Chain","text":"Below you will find the source code in the script scripts/ossh_chain.jl, with additional comments giving more detailed explanations for what certain parts of the code are doing.","category":"page"},{"location":"examples/ossh_chain/","page":"Example 3: Optical Su-Schrieffer-Heeger Chain","title":"Example 3: Optical Su-Schrieffer-Heeger Chain","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running the DQMC simulation.\nfunction run_ossh_chain_simulation(sID, Ω, α, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"ossh_chain_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" Ω α μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.05\n\n    # For performance reasons it is important that we represent the exponentiated hopping\n    # matrix with the checkerboard approximation when simulating an SSH model, where the\n    # phonons modulate the hopping amplitudes. Without the checkerboard approximation,\n    # each time a phonon field is updated the kinetic energy matrix would need to be diagonalized\n    # to calculate its exponential, which is very computationally expensive.\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = true\n\n    # As we are using the checkboard approximation, using a symmetric definition for the propagator\n    # matrices is important as it significantly improves the accuracy of approximation.\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = true\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bin size.\n    bin_size = div(N_updates, N_bins)\n\n    # Fermionic time-step used in HMC update.\n    Δt = 1/(10*Ω)\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 10\n\n    # Number of bosonic time-steps per fermionic time-step in HMC udpate.\n    nt = 10\n\n    # Regularizaton parameter for fourier acceleration mass matrix used in HMC dyanmics.\n    reg = 1.0\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"swap_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"Nt\" => Nt,\n        \"nt\" => nt,\n        \"reg\" => reg,\n        \"seed\" => seed,\n    )\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0]],\n                            basis_vecs   = [[0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L],\n        periodic = [true]\n    )\n\n    # Get the number of sites in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond for a 1D chain.\n    bond = lu.Bond(orbitals = (1,1), displacement = [1])\n\n    # Add this bond to the model, by adding it to the ModelGeometry type.\n    bond_id = add_bond!(model_geometry, bond)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond], # defines hopping\n        t_mean = [t],     # defines corresponding hopping amplitude\n        μ = μ,            # set chemical potential\n        ϵ_mean = [0.]     # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add optical ssh phonon to electron-phonon model.\n    phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon\n    )\n\n    # Define optical SSH coupling.\n    # Defines total effective hopping amplitude given by t_eff = t-α⋅(Xᵢ₊₁-Xᵢ).\n    ossh_coupling = SSHCoupling(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        phonon_modes = (phonon_id, phonon_id),\n        bond = bond,\n        α_mean = α\n    )\n\n    # Add optical SSH coupling to the electron-phonon model.\n    ossh_coupling_id = add_ssh_coupling!(\n        electron_phonon_model = electron_phonon_model,\n        ssh_coupling = ossh_coupling,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Write a model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )\n\n    #################################################\n    ### INITIALIZE FINITE LATTICE MODEL PARAMETERS ##\n    #################################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the measurement container.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the measurements associated with the tight-binding model.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the measurements associated with the electron-phonon model.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize time-displaced Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize time-displaced phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(phonon_id, phonon_id)]\n    )\n\n    # Initialize the density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the pair correlation function measurements.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (bond_id, bond_id)]\n    )\n\n    # Initialize the bond correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"bond\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(bond_id, bond_id)]\n    )\n\n    # Initialize current-current correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"current\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)] # Hopping ID pair.\n    )\n\n    # Initialize the sub-directories the various measurements will be written to.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Allocate and initialize propagators for each imaginary time slice.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize fermion greens calculator.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize equal-time Green's function matrix\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = HMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt, nt = nt, reg = reg\n    )\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a swap update.\n        # In a swap update, to phonon modes are randomly selected in the lattice\n        # and their phonon fields are exchanged for all imaginary time slices.\n        (accepted, logdetG, sgndetG) = swap_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng, phonon_type_pairs = ((phonon_id, phonon_id),)\n        )\n\n        # Record whether the swap update was accepted or rejected.\n        additional_info[\"swap_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng, initialize_force = true\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a swap update..\n            (accepted, logdetG, sgndetG) = swap_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, rng = rng, phonon_type_pairs = ((phonon_id, phonon_id),)\n            )\n\n            # Record whether the swap update was accepted or rejected.\n            additional_info[\"swap_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng, initialize_force = true\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Make measurements.\n            (logdetG, sgndetG, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (electron_phonon_parameters,)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate HMC acceptance rate.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Calculate swap update acceptance rate.\n    additional_info[\"swap_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ω = parse(Float64, ARGS[2])\n    α = parse(Float64, ARGS[3])\n    μ = parse(Float64, ARGS[4])\n    β = parse(Float64, ARGS[5])\n    L = parse(Int, ARGS[6])\n    N_burnin = parse(Int, ARGS[7])\n    N_updates = parse(Int, ARGS[8])\n    N_bins = parse(Int, ARGS[9])\n\n    # Run the simulation.\n    run_ossh_chain_simulation(sID, Ω, α, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/ossh_chain/","page":"Example 3: Optical Su-Schrieffer-Heeger Chain","title":"Example 3: Optical Su-Schrieffer-Heeger Chain","text":"","category":"page"},{"location":"examples/ossh_chain/","page":"Example 3: Optical Su-Schrieffer-Heeger Chain","title":"Example 3: Optical Su-Schrieffer-Heeger Chain","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Example 5: Hubbard-Holstein Square Lattice Model","title":"Example 5: Hubbard-Holstein Square Lattice Model","text":"EditURL = \"https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/main/literate_scripts/hubbard_holstein_square.jl\"","category":"page"},{"location":"examples/hubbard_holstein_square/#Example-5:-Hubbard-Holstein-Square-Lattice-Model","page":"Example 5: Hubbard-Holstein Square Lattice Model","title":"Example 5: Hubbard-Holstein Square Lattice Model","text":"","category":"section"},{"location":"examples/hubbard_holstein_square/","page":"Example 5: Hubbard-Holstein Square Lattice Model","title":"Example 5: Hubbard-Holstein Square Lattice Model","text":"In this example we write a script to simulate the Hubbard-Holstein model on a square lattice, with a Hamiltonian given by","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Example 5: Hubbard-Holstein Square Lattice Model","title":"Example 5: Hubbard-Holstein Square Lattice Model","text":"beginalign*\nhatH =  -t sum_sigmalangle i j rangle (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n            -mu sum_sigmaihatn_sigmai\n           + U sum_i (hatn_uparrowi-tfrac12)(hatn_downarrowi-tfrac12)\n            + alpha sum_sigmai hatX_i (hatn_sigmai - tfrac12) \n           + sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)\nendalign*","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Example 5: Hubbard-Holstein Square Lattice Model","title":"Example 5: Hubbard-Holstein Square Lattice Model","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. The nearest-neighbor hopping amplitude is t and mu is the chemical potential. The strength of the repulsive Hubbard interaction is controlled by U0. hatX_i  (hatP_i) is the phonon position (momentum) operator for a dispersionless mode placed on site i with phonon frequency Omega and corresponding ion mass M. The stength of the Holstein electron-phonon is controlled by the parameter alpha.","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Example 5: Hubbard-Holstein Square Lattice Model","title":"Example 5: Hubbard-Holstein Square Lattice Model","text":"The example script to simulate this sytem is scripts/hubbard_holstein_square.jl. A short test simulation using this script that only takes a few minutes on most personal computers is","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Example 5: Hubbard-Holstein Square Lattice Model","title":"Example 5: Hubbard-Holstein Square Lattice Model","text":"> julia hubbard_holstein_square.jl 0 6.0 0.1 0.1 0.0 4.0 4 1000 5000 50","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Example 5: Hubbard-Holstein Square Lattice Model","title":"Example 5: Hubbard-Holstein Square Lattice Model","text":"which simulates the Hubbard-Holstein model on a L = 4 square lattice, with U = 60, Omega = 01, alpha = 01 and mu = 00 at an inverse temperature of beta = 40. In this simulation the Hubbard-Stranonovich and phonon fields are thermalized with N_burnin = 1000 rounds of updates, followed by N_udpates = 5000 rounds of updates with measurements being made. Bin averaged measurements are written to file N_bins = 50 during the simulation.","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Example 5: Hubbard-Holstein Square Lattice Model","title":"Example 5: Hubbard-Holstein Square Lattice Model","text":"Below you will find a more heavily commented version of the example_scripts/hubbard_holstein_square.jl script that includes additional exposition on what each part of the code is doing. Additionally, this script demonstrates how to calculate the extended s-wave and d-wave pair susceptibilities.","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Example 5: Hubbard-Holstein Square Lattice Model","title":"Example 5: Hubbard-Holstein Square Lattice Model","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n\n# Define top-level function for running DQMC simulation\nfunction run_hubbard_holstein_square_simulation(sID, U, Ω, α, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"hubbard_chain_U%.2f_w%.2f_a%.2f_mu%.2f_L%d_b%.2f\" U Ω α μ L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.10\n\n    # Calculate the length of the imaginary time axis, Lτ = β/Δτ.\n    Lτ = dqmcf.eval_length_imaginary_axis(β, Δτ)\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bins size.\n    bin_size = div(N_updates, N_bins)\n\n    # Fermionic time-step used in HMC update.\n    Δt = 1/(10*Ω)\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 10\n\n    # Number of bosonic time-steps per fermionic time-step in HMC udpate.\n    nt = 10\n\n    # Regularizaton parameter for fourier acceleration mass matrix used in HMC dyanmics.\n    reg = 1.0\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"local_acceptance_rate\" => 0.0,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"reflection_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"seed\" => seed,\n        \"dt\" => Δt,\n        \"Nt\" => Nt,\n        \"nt\" => nt,\n        \"reg\" => reg\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(lattice_vecs = [[1.0, 0.0],\n                                            [0.0, 1.0]],\n                            basis_vecs   = [[0.0, 0.0]])\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond in the +x direction.\n    bond_x = lu.Bond(orbitals = (1,1), displacement = [1,0])\n\n    # Add nearest-neighbor bond in the +x direction.\n    bond_x_id = add_bond!(model_geometry, bond_x)\n\n    # Define the nearest-neighbor bond in the +y direction.\n    bond_y = lu.Bond(orbitals = (1,1), displacement = [0,1])\n\n    # Add the nearest-neighbor bond in the +y direction.\n    bond_y_id = add_bond!(model_geometry, bond_y)\n\n    # Here we define bonds to points in the negative x and y directions respectively.\n    # We do this in order to be able to measure all the pairing channels we need\n    # in order to reconstruct the extended s-wave and d-wave pair susceptibilities.\n\n    # Define the nearest-neighbor bond in the +x direction.\n    bond_nx = lu.Bond(orbitals = (1,1), displacement = [-1,0])\n\n    # Add nearest-neighbor bond in the +x direction.\n    bond_nx_id = add_bond!(model_geometry, bond_nx)\n\n    # Define the nearest-neighbor bond in the +y direction.\n    bond_ny = lu.Bond(orbitals = (1,1), displacement = [0,-1])\n\n    # Add the nearest-neighbor bond in the +y direction.\n    bond_ny_id = add_bond!(model_geometry, bond_ny)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_x, bond_y], # defines hopping\n        t_mean = [t, t],            # defines corresponding hopping amplitude\n        μ = μ,                      # set chemical potential\n        ϵ_mean = [0.]               # set the (mean) on-site energy\n    )\n\n    # Initialize the Hubbard interaction in the model.\n    hubbard_model = HubbardModel(\n        shifted = false,\n        U_orbital = [1],\n        U_mean = [U],\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live on each site in the lattice.\n    phonon = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon\n    )\n\n    # Define a on-site Holstein coupling between the electron and the local dispersionless phonon mode.\n    holstein_coupling = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_id,\n    \tbond = lu.Bond(orbitals = (1,1), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model.\n    holstein_coupling_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Write the model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (hubbard_model, electron_phonon_model)\n    )\n\n    #########################################\n    ### INITIALIZE FINITE MODEL PARAMETERS ##\n    #########################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize Hubbard interaction parameters.\n    hubbard_parameters = HubbardParameters(\n        model_geometry = model_geometry,\n        hubbard_model = hubbard_model,\n        rng = rng\n    )\n\n    # Apply Ising Hubbard-Stranonvich (HS) transformation, and initialize\n    # corresponding HS fields that will be sampled in DQMC simulation.\n    hubbard_ising_parameters = HubbardIsingHSParameters(\n        β = β, Δτ = Δτ,\n        hubbard_parameters = hubbard_parameters,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the Hubbard interaction related measurements.\n    initialize_measurements!(measurement_container, hubbard_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1)]\n    )\n\n    # Measure all possible combinations of bond pairing channels\n    # for the bonds we have defined. We will need each of these\n    # pairs channels measured in order to reconstruct the extended\n    # s-wave and d-wave pair susceptibilities.\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1),\n                 (bond_x_id, bond_x_id),  (bond_x_id, bond_nx_id),\n                 (bond_nx_id, bond_x_id), (bond_nx_id, bond_nx_id),\n                 (bond_y_id, bond_y_id),  (bond_y_id, bond_ny_id),\n                 (bond_ny_id, bond_y_id), (bond_ny_id, bond_ny_id),\n                 (bond_x_id, bond_y_id),  (bond_x_id, bond_ny_id),\n                 (bond_nx_id, bond_y_id), (bond_nx_id, bond_ny_id),\n                 (bond_y_id, bond_x_id),  (bond_y_id, bond_nx_id),\n                 (bond_ny_id, bond_x_id), (bond_ny_id, bond_nx_id)]\n    )\n\n    # Initialize the current correlation function measurement\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"current\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), # hopping ID pair for x-direction hopping\n                 (2, 2)] # hopping ID pair for y-direction hopping\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Allocate FermionPathIntegral type for both the spin-up and spin-down electrons.\n    fermion_path_integral_up = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n    fermion_path_integral_dn = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the FermionPathIntegral type for both the spin-up and spin-down electrons.\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_parameters)\n    initialize!(fermion_path_integral_up, fermion_path_integral_dn, hubbard_ising_parameters)\n\n    # Initialize the imaginary-time propagators for each imaginary-time slice for both the\n    # spin-up and spin-down electrons.\n    Bup = initialize_propagators(fermion_path_integral_up, symmetric=symmetric, checkerboard=checkerboard)\n    Bdn = initialize_propagators(fermion_path_integral_dn, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize FermionGreensCalculator for the spin-up and spin-down electrons.\n    fermion_greens_calculator_up = dqmcf.FermionGreensCalculator(Bup, β, Δτ, n_stab)\n    fermion_greens_calculator_dn = dqmcf.FermionGreensCalculator(Bdn, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_up_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_up)\n    fermion_greens_calculator_dn_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator_dn)\n\n    # Allcoate matrices for spin-up and spin-down electron Green's function matrices.\n    Gup = zeros(eltype(Bup[1]), size(Bup[1]))\n    Gdn = zeros(eltype(Bdn[1]), size(Bdn[1]))\n\n    # Initialize the spin-up and spin-down electron Green's function matrices, also\n    # calculating their respective determinants as the same time.\n    logdetGup, sgndetGup = dqmcf.calculate_equaltime_greens!(Gup, fermion_greens_calculator_up)\n    logdetGdn, sgndetGdn = dqmcf.calculate_equaltime_greens!(Gdn, fermion_greens_calculator_dn)\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = HMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = Gup, Nt = Nt, Δt = Δt, nt = nt, reg = reg\n    )\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    Gup_ττ = similar(Gup) # G↑(τ,τ)\n    Gup_τ0 = similar(Gup) # G↑(τ,0)\n    Gup_0τ = similar(Gup) # G↑(0,τ)\n    Gdn_ττ = similar(Gdn) # G↓(τ,τ)\n    Gdn_τ0 = similar(Gdn) # G↓(τ,0)\n    Gdn_0τ = similar(Gdn) # G↓(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a reflection update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn, rng = rng, phonon_types = (phonon_id,)\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = hmc_update!(\n            Gup, logdetGup, sgndetGup,\n            Gdn, logdetGdn, sgndetGdn,\n            electron_phonon_parameters,\n            hmc_updater,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n            fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n            Bup = Bup, Bdn = Bdn,\n            δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n            initialize_force = true\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n\n        # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n        (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n            Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n            hubbard_ising_parameters,\n            fermion_path_integral_up = fermion_path_integral_up,\n            fermion_path_integral_dn = fermion_path_integral_dn,\n            fermion_greens_calculator_up = fermion_greens_calculator_up,\n            fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n            Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n        )\n\n        # Record the acceptance rate for the attempted local updates to the HS fields.\n        additional_info[\"local_acceptance_rate\"] += acceptance_rate\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetGup))\n    δθ = zero(typeof(sgndetGup))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a reflection update.\n            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn) = reflection_update!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn,\n                electron_phonon_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n                Bup = Bup, Bdn = Bdn, rng = rng, phonon_types = (phonon_id,)\n            )\n\n            # Record whether the reflection update was accepted or rejected.\n            additional_info[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = hmc_update!(\n                Gup, logdetGup, sgndetGup,\n                Gdn, logdetGdn, sgndetGdn,\n                electron_phonon_parameters,\n                hmc_updater,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                fermion_greens_calculator_up_alt = fermion_greens_calculator_up_alt,\n                fermion_greens_calculator_dn_alt = fermion_greens_calculator_dn_alt,\n                Bup = Bup, Bdn = Bdn,\n                δG_max = δG_max, δG = δG, δθ = δθ, rng = rng,\n                initialize_force = true\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Perform a sweep through the lattice, attemping an update to each Ising HS field.\n            (acceptance_rate, logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = local_updates!(\n                Gup, logdetGup, sgndetGup, Gdn, logdetGdn, sgndetGdn,\n                hubbard_ising_parameters,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng\n            )\n\n            # Record the acceptance rate for the attempted local updates to the HS fields.\n            additional_info[\"local_acceptance_rate\"] += acceptance_rate\n\n            # Make measurements, with the results being added to the measurement container.\n            (logdetGup, sgndetGup, logdetGdn, sgndetGdn, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetGup, sgndetGup, Gup, Gup_ττ, Gup_τ0, Gup_0τ,\n                logdetGdn, sgndetGdn, Gdn, Gdn_ττ, Gdn_τ0, Gdn_0τ,\n                fermion_path_integral_up = fermion_path_integral_up,\n                fermion_path_integral_dn = fermion_path_integral_dn,\n                fermion_greens_calculator_up = fermion_greens_calculator_up,\n                fermion_greens_calculator_dn = fermion_greens_calculator_dn,\n                Bup = Bup, Bdn = Bdn, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (hubbard_parameters, electron_phonon_parameters)\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate acceptance rates.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n    additional_info[\"reflection_acceptance_rate\"] /= (N_updates + N_burnin)\n    additional_info[\"local_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator_up.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    # Here we use the `composite_correlation_stats` to reconstruct the extended\n    # s-wave and d-wave pair susceptibilities. Behind the scenes, uses the binning\n    # method to calculate the error bars by calculating both susceptibilities for\n    # each bin of data that was written to file.\n\n    # Measure the extended s-wave pair suspcetibility.\n    P_ext_s, ΔP_ext_s = composite_correlation_stats(\n        folder = simulation_info.datafolder,\n        correlation = \"pair\",\n        space = \"momentum\",\n        type = \"integrated\",\n        ids = [(bond_x_id, bond_x_id), (bond_nx_id, bond_nx_id), (bond_x_id, bond_nx_id), (bond_nx_id, bond_x_id),\n               (bond_y_id, bond_y_id), (bond_ny_id, bond_ny_id), (bond_y_id, bond_ny_id), (bond_ny_id, bond_y_id),\n               (bond_x_id, bond_y_id), (bond_nx_id, bond_ny_id), (bond_x_id, bond_ny_id), (bond_nx_id, bond_y_id),\n               (bond_y_id, bond_x_id), (bond_ny_id, bond_nx_id), (bond_y_id, bond_nx_id), (bond_ny_id, bond_x_id)],\n        locs = [(0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0)],\n        num_bins = N_bins,\n        f = (P_x_x, P_nx_nx, P_x_nx, P_nx_x,\n             P_y_y, P_ny_ny, P_y_ny, P_ny_y,\n             P_x_y, P_nx_ny, P_x_ny, P_nx_y,\n             P_y_x, P_ny_nx, P_y_nx, P_ny_x) -> (P_x_x + P_nx_nx + P_x_nx + P_nx_x +\n                                                 P_y_y + P_ny_ny + P_y_ny + P_ny_y +\n                                                 P_x_y + P_nx_ny + P_x_ny + P_nx_y +\n                                                 P_y_x + P_ny_nx + P_y_nx + P_ny_x)/4\n    )\n\n    # Record the extended s-wave pair suspcetibility.\n    additional_info[\"P_ext_s_mean\"] = real(P_ext_s)\n    additional_info[\"P_ext_s_std\"]  = ΔP_ext_s\n\n    # Measure the d-wave pair suspcetibility.\n    P_d, ΔP_d = composite_correlation_stats(\n        folder = simulation_info.datafolder,\n        correlation = \"pair\",\n        space = \"momentum\",\n        type = \"integrated\",\n        ids = [(bond_x_id, bond_x_id), (bond_nx_id, bond_nx_id), (bond_x_id, bond_nx_id), (bond_nx_id, bond_x_id),\n               (bond_y_id, bond_y_id), (bond_ny_id, bond_ny_id), (bond_y_id, bond_ny_id), (bond_ny_id, bond_y_id),\n               (bond_x_id, bond_y_id), (bond_nx_id, bond_ny_id), (bond_x_id, bond_ny_id), (bond_nx_id, bond_y_id),\n               (bond_y_id, bond_x_id), (bond_ny_id, bond_nx_id), (bond_y_id, bond_nx_id), (bond_ny_id, bond_x_id)],\n        locs = [(0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0),\n                (0,0), (0,0), (0,0), (0,0)],\n        num_bins = N_bins,\n        f = (P_x_x, P_nx_nx, P_x_nx, P_nx_x,\n             P_y_y, P_ny_ny, P_y_ny, P_ny_y,\n             P_x_y, P_nx_ny, P_x_ny, P_nx_y,\n             P_y_x, P_ny_nx, P_y_nx, P_ny_x) -> (P_x_x + P_nx_nx + P_x_nx + P_nx_x +\n                                                 P_y_y + P_ny_ny + P_y_ny + P_ny_y -\n                                                 P_x_y - P_nx_ny - P_x_ny - P_nx_y -\n                                                 P_y_x - P_ny_nx - P_y_nx - P_ny_x)/4\n    )\n\n    # Record the d-wave pair suspcetibility.\n    additional_info[\"P_d_mean\"] = real(P_d)\n    additional_info[\"P_d_std\"]  = ΔP_d\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    return nothing\nend\n\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    U = parse(Float64, ARGS[2])\n    Ω = parse(Float64, ARGS[3])\n    α = parse(Float64, ARGS[4])\n    μ = parse(Float64, ARGS[5])\n    β = parse(Float64, ARGS[6])\n    L = parse(Int, ARGS[7])\n    N_burnin = parse(Int, ARGS[8])\n    N_updates = parse(Int, ARGS[9])\n    N_bins = parse(Int, ARGS[10])\n\n    # Run the simulation.\n    run_hubbard_holstein_square_simulation(sID, U, Ω, α, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Example 5: Hubbard-Holstein Square Lattice Model","title":"Example 5: Hubbard-Holstein Square Lattice Model","text":"","category":"page"},{"location":"examples/hubbard_holstein_square/","page":"Example 5: Hubbard-Holstein Square Lattice Model","title":"Example 5: Hubbard-Holstein Square Lattice Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/holstein_kagome/","page":"Example 7: Kagome Holstein Model with Density Tuning","title":"Example 7: Kagome Holstein Model with Density Tuning","text":"EditURL = \"https://github.com/SmoQySuite/SmoQyDQMC.jl/blob/main/literate_scripts/holstein_kagome.jl\"","category":"page"},{"location":"examples/holstein_kagome/#Example-7:-Kagome-Holstein-Model-with-Density-Tuning","page":"Example 7: Kagome Holstein Model with Density Tuning","title":"Example 7: Kagome Holstein Model with Density Tuning","text":"","category":"section"},{"location":"examples/holstein_kagome/","page":"Example 7: Kagome Holstein Model with Density Tuning","title":"Example 7: Kagome Holstein Model with Density Tuning","text":"In this script we simulate the Holstein model on the Kagome lattice, with a Hamiltonian given by","category":"page"},{"location":"examples/holstein_kagome/","page":"Example 7: Kagome Holstein Model with Density Tuning","title":"Example 7: Kagome Holstein Model with Density Tuning","text":"beginalign*\nhatH =  -t sum_sigmalangle i j rangle (hatc^dagger_sigmai hatc^phantom dagger_sigmaj + rm hc)\n            -mu sum_sigmaihatn_sigmai + alpha sum_sigmai hatX_i (hatn_sigmai - tfrac12)\n           + sum_i left( frac12MhatP_i^2 + frac12MOmega^2hatX_i^2 right)\nendalign*","category":"page"},{"location":"examples/holstein_kagome/","page":"Example 7: Kagome Holstein Model with Density Tuning","title":"Example 7: Kagome Holstein Model with Density Tuning","text":"where hatc^dagger_sigmai  (hatc^phantom dagger_sigmai) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_sigmai = hatc^dagger_sigmai hatc^phantom dagger_sigmai is the spin-sigma electron number operator for site i. The nearest-neighbor hopping amplitude is t and mu is the chemical potential. The phonon position (momentum) operators hatX_i  (hatP_i) describe a dispersionless mode placed on site i with phonon frequency Omega and corresponding ion mass M. The stength of the Holstein electron-phonon is controlled by the parameter alpha.","category":"page"},{"location":"examples/holstein_kagome/","page":"Example 7: Kagome Holstein Model with Density Tuning","title":"Example 7: Kagome Holstein Model with Density Tuning","text":"The example script to simulate this sytem is scripts/holstein_kagome.jl. To run a short test simulation using this script that only takes a few minutes on most personal computers, run the following command:","category":"page"},{"location":"examples/holstein_kagome/","page":"Example 7: Kagome Holstein Model with Density Tuning","title":"Example 7: Kagome Holstein Model with Density Tuning","text":"> julia holstein_chain.jl 0 0.1 0.1 0.667 0.0 4.0 3 2000 10000 50","category":"page"},{"location":"examples/holstein_kagome/","page":"Example 7: Kagome Holstein Model with Density Tuning","title":"Example 7: Kagome Holstein Model with Density Tuning","text":"Here the Holstein model on a 3 times 3 unit cell Kagome lattice is simulated with Omega = 01, alpha = 01 and inverse temperature beta = 40. The chemical potential is initialized to mu = 00, and then tuned to achieve are target electron density of langle n rangle = 0667. In this example N_burnin = 2000 thermalizatoin HMC and refleciton updates are performed, followed by an additional N_updates = 10000 such updates, during which time an equivalent number of measurements are made. Bin averaged measurements are written to file N_bins = 50 during the simulation.","category":"page"},{"location":"examples/holstein_kagome/","page":"Example 7: Kagome Holstein Model with Density Tuning","title":"Example 7: Kagome Holstein Model with Density Tuning","text":"Below you can find the contents of the script example_scripts/holstein_kagome.jl with additional comments that discuss in more detail what certain parts of the code are doing.","category":"page"},{"location":"examples/holstein_kagome/","page":"Example 7: Kagome Holstein Model with Density Tuning","title":"Example 7: Kagome Holstein Model with Density Tuning","text":"using LinearAlgebra\nusing Random\nusing Printf\n\nusing SmoQyDQMC\nimport SmoQyDQMC.LatticeUtilities  as lu\nimport SmoQyDQMC.JDQMCFramework    as dqmcf\nimport SmoQyDQMC.JDQMCMeasurements as dqmcm\n# Import the MuTuner module that implements the chemical potential tuning algorithm.\nimport SmoQyDQMC.MuTuner           as mt\n\n# Define top-level function for running the DQMC simulation.\nfunction run_holstein_chain_simulation(sID, Ω, α, n, μ, β, L, N_burnin, N_updates, N_bins; filepath = \".\")\n\n    # Construct the foldername the data will be written to.\n    datafolder_prefix = @sprintf \"holstein_kagome_w%.2f_a%.2f_n%.2f_L%d_b%.2f\" Ω α n L β\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath,\n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written to.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the discretization in imaginary time for the DQMC simulation.\n    Δτ = 0.05\n\n    # This flag indicates whether or not to use the checkboard approximation to\n    # represent the exponentiated hopping matrix exp(-Δτ⋅K)\n    checkerboard = false\n\n    # Whether the propagator matrices should be represented using the\n    # symmetric form B = exp(-Δτ⋅K/2)⋅exp(-Δτ⋅V)⋅exp(-Δτ⋅K/2)\n    # or the asymetric form B = exp(-Δτ⋅V)⋅exp(-Δτ⋅K)\n    symmetric = false\n\n    # Set the initial period in imaginary time slices with which the Green's function matrices\n    # will be recomputed using a numerically stable procedure.\n    n_stab = 10\n\n    # Specify the maximum allowed error in any element of the Green's function matrix that is\n    # corrected by performing numerical stabiliziation.\n    δG_max = 1e-6\n\n    # Calculate the bin size.\n    bin_size = div(N_updates, N_bins)\n\n    # To update the phonon degrees of freedom in this code we primarily perform\n    # hybrid/hamiltonian Monte Carlo (HMC) updates. Below we specify some of the\n    # parameters associated with these HMC updates.\n\n    # Fermionic time-step used in HMC update.\n    Δt = 1/(10*Ω)\n\n    # Number of fermionic time-steps in HMC update.\n    Nt = 10\n\n    # Number of bosonic time-steps per fermionic time-step in HMC udpate.\n    nt = 10\n\n    # Regularizaton parameter for fourier acceleration mass matrix used in HMC dyanmics.\n    reg = 1.0\n\n    # Initialize a dictionary to store additional information about the simulation.\n    additional_info = Dict(\n        \"dG_max\" => δG_max,\n        \"N_burnin\" => N_burnin,\n        \"N_updates\" => N_updates,\n        \"N_bins\" => N_bins,\n        \"bin_size\" => bin_size,\n        \"hmc_acceptance_rate\" => 0.0,\n        \"reflection_acceptance_rate\" => 0.0,\n        \"n_stab_init\" => n_stab,\n        \"symmetric\" => symmetric,\n        \"checkerboard\" => checkerboard,\n        \"dt\" => Δt,\n        \"Nt\" => Nt,\n        \"nt\" => nt,\n        \"reg\" => reg,\n        \"seed\" => seed,\n    )\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the type UnitCell.\n    unit_cell = lu.UnitCell(\n        lattice_vecs = [[1.0,0.0],\n                        [1/2,√3/2]],\n        basis_vecs   = [[0.0,0.0],\n                        [1/2,0.0],\n                        [1/4,√3/4]]\n    )\n\n    # Initialize an instance of the type Lattice.\n    lattice = lu.Lattice(\n        L = [L, L],\n        periodic = [true, true]\n    )\n\n    # Get the number of sites in the lattice.\n    N = lu.nsites(unit_cell, lattice)\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(unit_cell, lattice)\n\n    # Define the nearest-neighbor bond.\n    bond_1 = lu.Bond(orbitals = (1,2), displacement = [0,0])\n\n    # Add nearest neighbor bond to the model.\n    bond_1_id = add_bond!(model_geometry, bond_1)\n\n    # Define the nearest-neighbor bond.\n    bond_2 = lu.Bond(orbitals = (1,3), displacement = [0,0])\n\n    # Add nearest neighbor bond to the model.\n    bond_2_id = add_bond!(model_geometry, bond_2)\n\n    # Define the nearest-neighbor bond.\n    bond_3 = lu.Bond(orbitals = (2,3), displacement = [0,0])\n\n    # Add nearest neighbor bond to the model.\n    bond_3_id = add_bond!(model_geometry, bond_3)\n\n    # Define the nearest-neighbor bond.\n    bond_4 = lu.Bond(orbitals = (2,1), displacement = [1,0])\n\n    # Add nearest neighbor bond to the model.\n    bond_4_id = add_bond!(model_geometry, bond_4)\n\n    # Define the nearest-neighbor bond.\n    bond_5 = lu.Bond(orbitals = (3,1), displacement = [0,1])\n\n    # Add nearest neighbor bond to the model.\n    bond_5_id = add_bond!(model_geometry, bond_5)\n\n    # Define the nearest-neighbor bond.\n    bond_6 = lu.Bond(orbitals = (3,2), displacement = [-1,1])\n\n    # Add nearest neighbor bond to the model.\n    bond_6_id = add_bond!(model_geometry, bond_6)\n\n    # Define nearest-neighbor hopping amplitude, setting the energy scale for the system.\n    t = 1.0\n\n    # Define the tight-binding model\n    tight_binding_model = TightBindingModel(\n        model_geometry = model_geometry,\n        t_bonds = [bond_1, bond_2, bond_3, bond_4, bond_5, bond_6], # defines hopping\n        t_mean  = [t, t, t, t, t, t],     # defines corresponding hopping amplitude\n        μ       = μ,            # set chemical potential\n        ϵ_mean  = [0.0, 0.0, 0.0]     # set the (mean) on-site energy\n    )\n\n    # Initialize a null electron-phonon model.\n    electron_phonon_model = ElectronPhononModel(\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model\n    )\n\n    # Define a dispersionless electron-phonon mode to live the first sub-lattice.\n    phonon_1 = PhononMode(orbital = 1, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_1_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_1\n    )\n\n    # Define a dispersionless electron-phonon mode to live the second sub-lattice.\n    phonon_2 = PhononMode(orbital = 2, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_2_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_2\n    )\n\n    # Define a dispersionless electron-phonon mode to live the third sub-lattice.\n    phonon_3 = PhononMode(orbital = 3, Ω_mean = Ω)\n\n    # Add the phonon mode definition to the electron-phonon model.\n    phonon_3_id = add_phonon_mode!(\n        electron_phonon_model = electron_phonon_model,\n        phonon_mode = phonon_3\n    )\n\n    # Define a on-site Holstein coupling for first sub-lattice.\n    holstein_coupling_1 = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_1_id,\n    \tbond = lu.Bond(orbitals = (1,1), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model for first sub-lattice.\n    holstein_coupling_1_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling_1,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Define a on-site Holstein coupling for second sub-lattice.\n    holstein_coupling_2 = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_2_id,\n    \tbond = lu.Bond(orbitals = (2,2), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model for first sub-lattice.\n    holstein_coupling_2_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling_2,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Define a on-site Holstein coupling for first sub-lattice.\n    holstein_coupling_3 = HolsteinCoupling(\n    \tmodel_geometry = model_geometry,\n    \tphonon_mode = phonon_3_id,\n    \tbond = lu.Bond(orbitals = (3,3), displacement = [0,0]),\n    \tα_mean = α\n    )\n\n    # Add the Holstein coupling definition to the model for first sub-lattice.\n    holstein_coupling_3_id = add_holstein_coupling!(\n    \telectron_phonon_model = electron_phonon_model,\n    \tholstein_coupling = holstein_coupling_3,\n    \tmodel_geometry = model_geometry\n    )\n\n    # Write a model summary to file.\n    model_summary(\n        simulation_info = simulation_info,\n        β = β, Δτ = Δτ,\n        model_geometry = model_geometry,\n        tight_binding_model = tight_binding_model,\n        interactions = (electron_phonon_model,)\n    )\n\n    #################################################\n    ### INITIALIZE FINITE LATTICE MODEL PARAMETERS ##\n    #################################################\n\n    # Initialize tight-binding parameters.\n    tight_binding_parameters = TightBindingParameters(\n        tight_binding_model = tight_binding_model,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    # Initialize electron-phonon parameters.\n    electron_phonon_parameters = ElectronPhononParameters(\n        β = β, Δτ = Δτ,\n        electron_phonon_model = electron_phonon_model,\n        tight_binding_parameters = tight_binding_parameters,\n        model_geometry = model_geometry,\n        rng = rng\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(model_geometry, β, Δτ)\n\n    # Initialize the tight-binding model related measurements, like the hopping energy.\n    initialize_measurements!(measurement_container, tight_binding_model)\n\n    # Initialize the electron-phonon interaction related measurements.\n    initialize_measurements!(measurement_container, electron_phonon_model)\n\n    # Initialize the single-particle electron Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"greens\",\n        time_displaced = true,\n        pairs = [(1, 1), (2, 2), (3, 3),\n                 (1, 2), (1, 3), (2, 3)]\n    )\n\n    # Initialize time-displaced phonon Green's function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"phonon_greens\",\n        time_displaced = true,\n        pairs = [(1, 1), (2, 2), (3, 3),\n                 (1, 2), (1, 3), (2, 3)]\n    )\n\n    # Initialize density correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"density\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (3, 3),\n                 (1, 2), (1, 3), (2, 3)]\n    )\n\n    # Initialize the pair correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"pair\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (3, 3)]\n    )\n\n    # Initialize the spin-z correlation function measurement.\n    initialize_correlation_measurements!(\n        measurement_container = measurement_container,\n        model_geometry = model_geometry,\n        correlation = \"spin_z\",\n        time_displaced = false,\n        integrated = true,\n        pairs = [(1, 1), (2, 2), (3, 3),\n                 (1, 2), (1, 3), (2, 3)]\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info = simulation_info,\n        measurement_container = measurement_container\n    )\n\n    #############################\n    ### SET-UP DQMC SIMULATION ##\n    #############################\n\n    # Note that the spin-up and spin-down electron sectors are equivalent in the Holstein model\n    # without Hubbard interaction. Therefore, there is only a single Fermion determinant\n    # that needs to be calculated. This fact is reflected in the code below.\n\n    # Allocate fermion path integral type.\n    fermion_path_integral = FermionPathIntegral(tight_binding_parameters = tight_binding_parameters, β = β, Δτ = Δτ)\n\n    # Initialize the fermion path integral type with respect to electron-phonon interaction.\n    initialize!(fermion_path_integral, electron_phonon_parameters)\n\n    # Allocate and initialize propagators for each imaginary time slice.\n    B = initialize_propagators(fermion_path_integral, symmetric=symmetric, checkerboard=checkerboard)\n\n    # Initialize fermion greens calculator.\n    fermion_greens_calculator = dqmcf.FermionGreensCalculator(B, β, Δτ, n_stab)\n\n    # Initialize alternate fermion greens calculator required for performing various global updates.\n    fermion_greens_calculator_alt = dqmcf.FermionGreensCalculator(fermion_greens_calculator)\n\n    # Allocate equal-time Green's function matrix.\n    G = zeros(eltype(B[1]), size(B[1]))\n\n    # Initialize equal-time Green's function matrix\n    logdetG, sgndetG = dqmcf.calculate_equaltime_greens!(G, fermion_greens_calculator)\n\n    # Allocate matrices for various time-displaced Green's function matrices.\n    G_ττ = similar(G) # G(τ,τ)\n    G_τ0 = similar(G) # G(τ,0)\n    G_0τ = similar(G) # G(0,τ)\n\n    # Initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Initialize Hamitlonian/Hybrid monte carlo (HMC) updater.\n    hmc_updater = HMCUpdater(\n        electron_phonon_parameters = electron_phonon_parameters,\n        G = G, Nt = Nt, Δt = Δt, nt = nt, reg = reg\n    )\n\n    # Initialize the density/chemical potential tuner.\n    # This type facilitates the tuning of the chemical potential to achieve\n    # at target electron density.\n    chemical_potential_tuner = mt.MuTunerLogger(n₀ = n, β = β, V = N, u₀ = 1.0, μ₀ = μ, c = 0.5)\n\n    ####################################\n    ### BURNIN/THERMALIZATION UPDATES ##\n    ####################################\n\n    # Iterate over burnin/thermalization updates.\n    for n in 1:N_burnin\n\n        # Perform a reflection update.\n        # This update randomly selects a phonon mode in the lattice and reflects\n        # all the associated phonon about the origin, (xᵢ → -xᵢ).\n        # This updates all the phonon fields to cross the on-site energy barrier\n        # associated with bipolaron formation, helping reduce autocorrelation times.\n        (accepted, logdetG, sgndetG) = reflection_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, rng = rng, phonon_types = (phonon_1_id, phonon_2_id, phonon_3_id)\n        )\n\n        # Record whether the reflection update was accepted or rejected.\n        additional_info[\"reflection_acceptance_rate\"] += accepted\n\n        # Perform an HMC update.\n        (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n            G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n            B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng, initialize_force = true\n        )\n\n        # Record whether the HMC update was accepted or rejected.\n        additional_info[\"hmc_acceptance_rate\"] += accepted\n\n        # Update the chemical potential.\n        logdetG, sgndetG = update_chemical_potential!(\n            G, logdetG, sgndetG,\n            chemical_potential_tuner = chemical_potential_tuner,\n            tight_binding_parameters = tight_binding_parameters,\n            fermion_path_integral = fermion_path_integral,\n            fermion_greens_calculator = fermion_greens_calculator,\n            B = B\n        )\n    end\n\n    ################################\n    ### START MAKING MEAUSREMENTS ##\n    ################################\n\n    # Re-initialize variables to keep track of the largest numerical error in the\n    # Green's function matrices corrected by numerical stabalization.\n    δG = zero(typeof(logdetG))\n    δθ = zero(typeof(sgndetG))\n\n    # Iterate over the number of bin, i.e. the number of time measurements will be dumped to file.\n    for bin in 1:N_bins\n\n        # Iterate over the number of updates and measurements performed in the current bin.\n        for n in 1:bin_size\n\n            # Perform a reflection update.\n            (accepted, logdetG, sgndetG) = reflection_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, rng = rng, phonon_types = (phonon_1_id, phonon_2_id, phonon_3_id)\n            )\n\n            # Record whether the reflection update was accepted or rejected.\n            additional_info[\"reflection_acceptance_rate\"] += accepted\n\n            # Perform an HMC update.\n            (accepted, logdetG, sgndetG, δG, δθ) = hmc_update!(\n                G, logdetG, sgndetG, electron_phonon_parameters, hmc_updater,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                fermion_greens_calculator_alt = fermion_greens_calculator_alt,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ, rng = rng, initialize_force = true\n            )\n\n            # Record whether the HMC update was accepted or rejected.\n            additional_info[\"hmc_acceptance_rate\"] += accepted\n\n            # Make measurements.\n            (logdetG, sgndetG, δG, δθ) = make_measurements!(\n                measurement_container,\n                logdetG, sgndetG, G, G_ττ, G_τ0, G_0τ,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B, δG_max = δG_max, δG = δG, δθ = δθ,\n                model_geometry = model_geometry, tight_binding_parameters = tight_binding_parameters,\n                coupling_parameters = (electron_phonon_parameters,)\n            )\n\n            # Update the chemical potential.\n            logdetG, sgndetG = update_chemical_potential!(\n                G, logdetG, sgndetG,\n                chemical_potential_tuner = chemical_potential_tuner,\n                tight_binding_parameters = tight_binding_parameters,\n                fermion_path_integral = fermion_path_integral,\n                fermion_greens_calculator = fermion_greens_calculator,\n                B = B\n            )\n        end\n\n        # Write the average measurements for the current bin to file.\n        write_measurements!(\n            measurement_container = measurement_container,\n            simulation_info = simulation_info,\n            model_geometry = model_geometry,\n            bin = bin,\n            bin_size = bin_size,\n            Δτ = Δτ\n        )\n    end\n\n    # Calculate HMC acceptance rate.\n    additional_info[\"hmc_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Calculate reflection update acceptance rate.\n    additional_info[\"reflection_acceptance_rate\"] /= (N_updates + N_burnin)\n\n    # Record the final numerical stabilization period that the simulation settled on.\n    additional_info[\"n_stab_final\"] = fermion_greens_calculator.n_stab\n\n    # Record the maximum numerical error corrected by numerical stablization.\n    additional_info[\"dG\"] = δG\n\n    # Save the density tuning profile.\n    save_density_tuning_profile(simulation_info, chemical_potential_tuner)\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, additional_info)\n\n    #################################\n    ### PROCESS SIMULATION RESULTS ##\n    #################################\n\n    # Process the simulation results, calculating final error bars for all measurements,\n    # writing final statisitics to CSV files.\n    process_measurements(simulation_info.datafolder, N_bins)\n\n    return nothing\nend\n\n# Only excute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    Ω = parse(Float64, ARGS[2])\n    α = parse(Float64, ARGS[3])\n    n = parse(Float64, ARGS[4]) # target electorn density\n    μ = parse(Float64, ARGS[5]) # intial chemical potential\n    β = parse(Float64, ARGS[6])\n    L = parse(Int, ARGS[7])\n    N_burnin = parse(Int, ARGS[8])\n    N_updates = parse(Int, ARGS[9])\n    N_bins = parse(Int, ARGS[10])\n\n    # Run the simulation.\n    run_holstein_chain_simulation(sID, Ω, α, n, μ, β, L, N_burnin, N_updates, N_bins)\nend","category":"page"},{"location":"examples/holstein_kagome/","page":"Example 7: Kagome Holstein Model with Density Tuning","title":"Example 7: Kagome Holstein Model with Density Tuning","text":"","category":"page"},{"location":"examples/holstein_kagome/","page":"Example 7: Kagome Holstein Model with Density Tuning","title":"Example 7: Kagome Holstein Model with Density Tuning","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SmoQyDQMC","category":"page"},{"location":"#SmoQyDQMC","page":"Home","title":"SmoQyDQMC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SmoQyDQMC.jl. This package implements the determinant quantum Monte Carlo (DQMC) method for Hubbard, and electron-phonon interactions, including both Holstein and Su-Schrieffer-Heeger (SSH) style electron-phonon coupling.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This code is currently in the experimental phase of development.","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The development of this code was supported by the U.S. Department of Energy, Office of Science, Basic Energy Sciences, under Award Number DE-SC0022311.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the SmoQyDQMC.jl, simply open the Julia REPL and run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add SmoQyDQMC","category":"page"},{"location":"#Supported-Hamiltonians","page":"Home","title":"Supported Hamiltonians","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This section describes the class of Hamiltonians SmoQyDQMC.jl currently supports, and how the various terms appearing in the Hamiltonian are parameterized within the code. We start by partitioning the full Hamiltonian as ","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\n    hatH = hatU + hatK + hatV\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"where hatU is the bare lattice energy, hatK the total electron kinetic energy, and hatV the total electron potential energy. In the discussion that follows we apply the normalization hbar = 1 throughout.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The bare lattice term is further decomposed into","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\n    hatU = hatU_rm ph + hatU_rm disp\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\n    hatU_rm ph = sum_mathbfinusum_n_mathbfinu\n        left\n            frac12M_n_mathbfinuhatP_n_mathbfinu\n            + frac12M_n_mathbfinuOmega_0n_mathbfinu^2hatX_n_mathbfinu^2\n            + frac124M_n_mathbfinuOmega_an_mathbfinu^2hatX_n_mathbfinu^4\n        right\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"describes the placement of local dispersionless phonon (LDP) modes in the lattice, i.e. an Einstein solid, and","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\n    hatU_rm disp = sum_substackmathbfinu  mathbfjgammasum_substackn_mathbfinu  n_mathbfjgamma\n        fracM_n_mathbfialphaM_n_mathbfjgammaM_n_mathbfialpha+M_n_mathbfjgammaleft\n            tildeOmega^2_0n_mathbfialphan_mathbfjgamma(hatX_n_mathbfinu-hatX_n_mathbfjgamma)^2\n            + frac112tildeOmega^2_an_mathbfialphan_mathbfjgamma(hatX_n_mathbfinu-hatX_n_mathbfjgamma)^4\n        right\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"introduces dispersion between the LDP modes. The sums over mathbfi  (mathbfj) and nu  (gamma) run over unit cells in the lattice and orbitals within each unit cell respectively. A sum over n_mathbfinu  (n_mathbfjgamma) then runs over the LDP modes placed on a given orbital in the lattice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The position and momentum operators for each LPD mode are given by hatX_n_mathbfinu and hatP_n_mathbfinu respectively, with corresponding phonon mass M_n_mathbfinu. The spring constant is K_n_mathbfinu = M_n_mathbfinu Omega_0n_n_mathbfinu^2, with Omega_0n_n_mathbfinu specifying the phonon frequency. The U_rm ph also supports an anharmonic hatX_n_mathbfinu^4 contribution to the LDP potential energy that is controlled by the parameter Omega_an_n_mathbfinu. Similary, tildeOmega_0n_mathbfialphan_mathbfjgamma  (tildeOmega_an_mathbfialphan_mathbfjgamma) is the coefficient controlling harmonic (anhmaronic) dispersion between LDP modes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next we trace out the phonon degrees of freedom ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The electron kinetic energy is decomposed as","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\n    hatK = hatK_0 + hatK_rm ssh\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\n    hatK_0 = -sum_sigmasum_substackmathbfinu  mathbfjgamma\n        left\n            t_(mathbfinu)(mathbfjgamma) hatc^dagger_sigmamathbfinuhatc_sigmamathbfjgamma + rm hc\n        right\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"is the non-interacting electron kinetic energy, and","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\n    hatK_rm ssh = sum_sigmasum_substackmathbfinu  mathbfjgammasum_substackn_mathbfinu  n_mathbfjgammasum_m=1^4\n        (hatX_n_mathbfinu-hatX_n_mathbfjgamma)^mleft\n            alpha_mn_mathbfinun_mathbfjgamma hatc^dagger_sigmamathbfinuhatc_sigmamathbfjgamma + rm hc\n        right\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"is describes the interaction between the lattice degrees of freedom and the electron kinetic energy via a Su-Schrieffer-Heeger (SSH)-like coupling mechanism. The hopping integral between from orbital gamma in unit cell mathbfj to orbital nu in unit cell mathbfi is given by t_(mathbfinu)(mathbfjgamma), and may in general be complex. The modulations to this hopping integral are controlled by the parameters alpha_m(mathbfinu)(mathbfjgamma), where min 14 specifies the order of the difference in the phonon positions that modulates the hopping integral.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lastly, the electron potential energy is broken down into the three terms","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\n    hatV = hatV_0 + hatV_rm hol + hatV_rm hub\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\n    hatV_0 = sum_sigmasum_mathbfinu\n        left\n            (epsilon_mathbfinu - mu) hatn_sigmamathbfinu\n        right\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"is the non-interacting electron potential energy,","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\n    hatV_rm hol = sum_sigmasum_substackmathbfinu  mathbfjgammasum_n_mathbfinusum_m=1^4\n        hatX^m_n_mathbfinu left\n            tildealpha_mn_mathbfinu(mathbfjgamma) (hatn_sigmamathbfjgamma-tfrac12)\n        right\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"is the contribution to the electron potential energy that results from a Holstein-like coupling to the lattice degrees of freedom, and","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginalign*\n    hatV_rm hub=\n    begincases\n        sum_mathbfinuU_mathbfinubig(hatn_uparrowmathbfinu-tfrac12big)big(hatn_downarrowmathbfinu-tfrac12big)\n        sum_mathbfinuU_mathbfinuhatn_uparrowmathbfinuhatn_downarrowmathbfinu\n    endcases\nendalign*","category":"page"},{"location":"","page":"Home","title":"Home","text":"is the on-site Hubbard interaction contribution to the electron potential energy. In hatV_0 the chemical potential is given by mu, and epsilon_mathbfinu is the on-site energy, the parameter tildealpha_mn_mathbfinu(mathbfjgamma) controls the strength of the Holstein-like coupling in hatV_rm ph, and U_mathbfinu is the on-site Hubbard interaction strength in hatV_rm hub. Note that either functional form for V_rm hub can used in the code.","category":"page"},{"location":"#Notable-Package-Dependencies","page":"Home","title":"Notable Package Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This section reviews some notable package dependencies.","category":"page"},{"location":"#Re-exported-Packages","page":"Home","title":"Re-exported Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SmoQyDQMC.jl re-exports certain packages using the Reexport.jl package in order to simplify the installation process.","category":"page"},{"location":"","page":"Home","title":"Home","text":"LatticeUtilties.jl: Used to represent arbitrary lattice geometries.\nJDQMCFramework.jl: Implements and exports the basic framework for running a DQMC simulation.\nJDQMCMeasurements.jl: Implements various global, local and correlation measurements for a DQMC simulation.\nMuTuner.jl: Impelments and exports an algorithm for tuning the chemical potential to achieve a target density in grand canonical Monte Carlo simulations.","category":"page"},{"location":"#External-Dependencies","page":"Home","title":"External Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"StableLinearAlgebra.jl: Implements optimized numerical stabilizaiton methods required by DQMC simulations.\nCheckerboard.jl: Implements and exports the checkerboard method for approximating exponentiated hopping matrices by a sparse matrix.\nJLD2.jl: Package used to write data to binary files in an HDF5 compatible format. It is also recommended this package be used at the scripting level to implement checkpointing in a simulation.\nBinningAnalysis.jl: Export method impelementing the jackknife algorithm for calculating error bars.","category":"page"},{"location":"#Contact-Us","page":"Home","title":"Contact Us","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For question and comments regarding this package, please email either Dr. Benjamin Cohen-Stead at bcohenst@utk.edu or Professor Steven Johnston at sjohn145@utk.edu.","category":"page"}]
}
